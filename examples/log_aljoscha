{
  "previous": null,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1,
  "timestamp": 1490467093028,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
    "name": "Aljoscha"
  },
  "signature": "O/AqV+EoGpa6AZhPT8Fe+ngMlrJJEnGR6K8m4py2gBMJBkoUYvjbRxWgPvZIozxusR9na3YqPhoRCtIgXLYpBQ==.sig.ed25519"
}

{
  "previous": "%MwjdLV95P7VqHfrgS49nScXsyIwJfL229e5OSKc+0rc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 2,
  "timestamp": 1490467239118,
  "hash": "sha256",
  "content": {
    "type": "pub",
    "address": {
      "host": "pub.mixmix.io",
      "port": 8008,
      "key": "@uRECWB4KIeKoNMis2UYWyB2aQPvWmS3OePQvBj2zClg=.ed25519"
    }
  },
  "signature": "RTHdL6ASHbrS1VkppxKMRR4BNUOQDV75cqPw2DfvDxhF+hoO5tNYO+Hcn0u9yAJZcdBVJ2AlNr13UK86MIFxAA==.sig.ed25519"
}

{
  "previous": "%kHiGGFWS2D/WnOMy+gFgwlLwcPYDOYMy1NZaXZRHB8M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 3,
  "timestamp": 1490467239334,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@uRECWB4KIeKoNMis2UYWyB2aQPvWmS3OePQvBj2zClg=.ed25519",
    "following": true
  },
  "signature": "qLOSEW+0Uo9E5//XCsvoXVzZUltHXQFaRdNlDHtSN/GM6nCpZXDNuLM7mqWStToLKCVVczqWLpafi+qpkPmhDg==.sig.ed25519"
}

{
  "previous": "%23akzMzTHBQWtx3IrKntwSN3On4RfYFtI/Pi8oq8jds=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 4,
  "timestamp": 1490467549520,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "new-people",
    "subscribed": true
  },
  "signature": "pm4k37GFJD0rr5Dbct71+/Vc10MQ9KKpDOQFxXksywqLTctYBo7DURm/g9EjiY/66clk6JxfV2QUzhkzKWGWAg==.sig.ed25519"
}

{
  "previous": "%KIXi5PXtNQ4++5B3typWwjm4SSSIekTyLEt3SU/qrBE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 5,
  "timestamp": 1490468072000,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "new-people",
    "subscribed": false
  },
  "signature": "A0Nql9TirjFMSL1H1QGv+plrMYHXnjnFsuIwglhggL6UKWHxlKKOLRh0tGWvqNoXl1OJRHENxwmpLOZrB3PjBQ==.sig.ed25519"
}

{
  "previous": "%G+a+oqMaXLwsVlTQacee3qR195DXd4ikd/+x5R/WW2U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 6,
  "timestamp": 1490468756369,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "anarchitecture",
    "subscribed": true
  },
  "signature": "7oe77/zA6X77tyvZKMZCzj94yn16FZyhvDMJhiZBLzbjtQMN/2goiX8FuClumpibtL/yGEhuUB1O39YGwtrsCQ==.sig.ed25519"
}

{
  "previous": "%ijx2YehJ2LMY5tm3QejwmP5+us4cEyO/GdCE3mLXXaQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 7,
  "timestamp": 1490476812088,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "scuttleverse",
    "subscribed": true
  },
  "signature": "XLZCB7aEoekTn52BsfDGdzP4EzBzkRkE9b61WF6GG7ll5OFsV4wusXN29Wsht0wjk/JGX2rtfx48ZAipu8rECA==.sig.ed25519"
}

{
  "previous": "%6YEJkjY+js2NOYHfBZRm7gMaBxrRWI/BDM/uEg6zIOg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 8,
  "timestamp": 1490476836600,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "haskell",
    "subscribed": true
  },
  "signature": "3u0BW4XRSrRbHXtqra5StjeP2VizqJGENcQ9Smpy5zrEDZc3iuHeghw5MRVuFFkxRmmJkxhp+V3azM3JlIDoCw==.sig.ed25519"
}

{
  "previous": "%+uwd6D8SDcxqKdOhklcHcad3FzoY+2YkIlqoTh0pyFM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 9,
  "timestamp": 1490476876828,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "patchwork",
    "subscribed": true
  },
  "signature": "SNppb0VG51cjQZIzqgns/JZPdSuL5Ot4Aq9RicDK7uE+r+PuuFC3i/9Qa3BaZwIw6IUym+RvNLrNp5rPo/fVCw==.sig.ed25519"
}

{
  "previous": "%ECTHhiUgusfzovzZitijP95kqPOBiIJZQc1DfgoGoPk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 10,
  "timestamp": 1490476968596,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "berlin",
    "subscribed": true
  },
  "signature": "w0L4ZL4WvC7mMHJrbzcX0iwtDAhBElsfS7UGSHxjH90G9E1cerELhyUj91S2tbNNiFcr8zFxP0X7tiNGbphMBw==.sig.ed25519"
}

{
  "previous": "%KY5NIDPijY5pIgcrIfA8O08z9CKUTb9SAeF/YasBJaU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 11,
  "timestamp": 1490520030515,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@L+nPFTMUHWXuchOwuzT6Z8Ea8wD/Rtd7leVRxGaknVk=.ed25519",
    "following": true
  },
  "signature": "E95on4oMVdqo4fYRbPP/sQmOAsXxskFzcu+sgHbT4qjKqiXLCkSefc2of6FB5Y+qW76OkectauiGximjQY+zBQ==.sig.ed25519"
}

{
  "previous": "%Zm1yLIfVoMTwBqNsCgSScni2sTz+2u0lkWhK53gfkd4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 12,
  "timestamp": 1490520109970,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "scheme",
    "subscribed": true
  },
  "signature": "A+Fytx09GVauV3pusHilhz68IIPY0Pst9ytvUDxHnuCOtwxZWGZzuXtZHOpbEHUIA9/TM0UNKMZ9o0K3ELlxCw==.sig.ed25519"
}

{
  "previous": "%fIzTX/O7X5YFG1+E1uH20pSUUiCsp9M2jjecC1+qWwo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 13,
  "timestamp": 1490520467192,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "programming",
    "subscribed": true
  },
  "signature": "zP86jOwb369kMWQwatR9YVmwvb6Qfzy0tEMBE3D1AUaerKR/sRs1DcGz1tk1qBpN8bmoVNSwionnG6I4Uy+CDg==.sig.ed25519"
}

{
  "previous": "%dywl+1H2fipG8GKIZShHTDdvQ8ml8Gu7V5mpYzu4Fdw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 14,
  "timestamp": 1490525558694,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "patchbay",
    "subscribed": true
  },
  "signature": "1bPY173tNXCM9a/wshzrYX5RkDnn4dMTVw7R7suo5mrvuhk2zfAt3KzCXV7s5jk/P4ZC9wbiAGGI8UK9HpMICA==.sig.ed25519"
}

{
  "previous": "%zX8p1HB0cInWHNLD1BQTWWaaHuJHXSdEGTtrQuoC6dw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 15,
  "timestamp": 1490526669489,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "patchbay-dev",
    "subscribed": true
  },
  "signature": "POMjLnt3tqXjumfNbwTHbQc+z6EI/xXQWE2/ZMhX8clTz/cbeIFW+Rz/5qjH1BZxbktcmrOtRLCx1k8KN8DMBA==.sig.ed25519"
}

{
  "previous": "%RRF+EgpC/OVRyfuWCTVgn7yZaQNJLATNaSYOM72tgX4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 16,
  "timestamp": 1490528750224,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "scuttlebutt",
    "subscribed": true
  },
  "signature": "E6n5t0HpMNy+aqBLgl91r8c3LS7zRPIVXwOEyN0YcSfOHldjHGiSKnmozZTs7yhIAQ0t/eHTTgrwVlFyaVghBw==.sig.ed25519"
}

{
  "previous": "%A2oS2rbMX84I7wDPnjc7M1e2PDuMhBQJnF9cJ7yq0cI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 17,
  "timestamp": 1490528954740,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "scuttlebot",
    "subscribed": true
  },
  "signature": "R2xmdB9pauSPDBVhiLGud4uD6jPsG7apwWM5XWRGdz4q8X8sTxEQqNSK7PhtTeQt3n3+srlZC4wJY8HV7VPMCQ==.sig.ed25519"
}

{
  "previous": "%0/GcUivL34PR6Wy43sue2+tu7RhiKKEVTKNSEN/+liA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 18,
  "timestamp": 1490532586946,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%yMH4cssbTHFgb0IIChSmvuTAGBBkzgjDoujZYCihquA=.sha256",
    "branch": "%NZ6WM/yjD00bE03bNsnSa1GnQNvd8qCWW0tQxGc5fuA=.sha256",
    "channel": "anarchitecture",
    "recps": null,
    "text": "I thought about self-organizing messages as well, although the ideas I'm presenting here use a more explicit approach. I am new to the scuttleverse and its concepts, so there might be some obvious flaws in my thoughts. Anyways, here we go:\n\nNearly everything in the scuttleverse is identified by a unique hash. Message types however use strings as a type. Some quotes from the [scuttlebot documentation](http://scuttlebot.io/docs/message-types/custom-types.html):\n\n> There is no official mechanism for making sure message-types interoperate, except for the documentation which you're reading here. As it becomes clear that new types are coming into common use, we'll add them to this site.\n\nManually posting information about the intended use to a central place seems primitive compared to the scuttlebot architecture.\n\n> To avoid accidental collisions with other applications, it's a good idea to add your org or application name (or both!) to the message type.\n\nWe are using a system where everything is uniquely identified by a hash, but the fundamental building block of all communication relies on namespacing?\n\nThis seems to be such a fundamental decision, that I'll just assume you had good reasons to chose the current system instead of hash message types. But even with string identifiers, it would be nice to come up with a self-organizing system. The meaning of messages should not be dictated up-front, but rather through their usage. One way of achieving this, would be to represent message types and message consumers (e.g. frontends like patchwork, or maybe patchbay plugins/modules) in the scuttleverse. Just like smalltalk uses objects to represent language concepts themselves (classes, control-flow, etc.) at runtime, the scuttleverse could use messages to represent message types and consumers.\n\nFor example, somebody might add a message-entity to the scuttleverse, which represents a move in a tic-tac-toe game. This entity consists of nothing but its identifier. Next, I might write a GUI frontend for playing tic-tac-toe via scuttlebut. I'd add a consumer-entity to the scuttleverse, which represents the frontend. This entity can refer to the tac-tac-toe message-entity, and claim that it uses the following fields of such a message: `game`, `àctivePlayer` and `position`. Additionally, the consumer-entity could provide human-readable information about how it interprets these fields. Of course, nobody forces me to set up the message-entity, or to be truthful in which fields it claims to use.\n\nOther consumers might expect different fields in a tic-tac-toe message, or they might only consume a subset of fields. Every tool can still interpret messages as it sees fit. But by querying which tools accept which messages, and what they expect of these messages, we get a self-description of the system.\n\nAnother interesting dimension to this is that users could publish statements such as `I use these consumers to handle this message-entity`. This gives credibility to the message-consumer's claims on how it deals with messages. At this point, we could build some pretty interesting (and useful) features for scuttleverse clients. If a friend sends me a message, but my client does not know how to handle it, it could look up which consumer the friend would use to handle the message. Then, it could recommend me to install this consumer. This would be especially powerful for plugin-based clients (i.e. patchbay).\n\nFinally, the message types for describing message-entities and message-consumers would be message-entities themselves. There is no need to add any of this on the protocol level, you would just add some messages. Which happen to be interpreted as a meta-description.\n\nNobody would be forced to use this, you could simply ignore the whole thing. I just believe that having a self-aware, reflective ecosystem of message-entities and message-consumers would make for a healthy, robust and extensible system. For example, if you want to write an alternative frontend with overlapping functionality with other frontends, you can query the system itself on how existing messages should be handled, rather than looking up disparate sources of documentation.\n",
    "mentions": []
  },
  "signature": "cVc7xcxSEweTqLU/aZjgvc5VbahViLOZV9Tynbke6Bvh15zj82WKEPjHiNKkq6JsJQ9hLckq2Lqr1sM10EhSBQ==.sig.ed25519"
}

{
  "previous": "%AND+detlntlSVEkBJQwelrVYY9VPVWitYC4DFv1KJbw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 19,
  "timestamp": 1490532703233,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%yMH4cssbTHFgb0IIChSmvuTAGBBkzgjDoujZYCihquA=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "8PKo5VSP0YqAB/K/MqaRxhReGB1FPkHo3ebWExpII7XA1O4veglK+/jh+p368ZPEEXyCLxF4n4Fxs8aJrsEFCQ==.sig.ed25519"
}

{
  "previous": "%6XnVO+/C8oaPH2SOSEmYRARrHQXLuS5dMB5TdASWBkY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 20,
  "timestamp": 1490534404258,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@L+nPFTMUHWXuchOwuzT6Z8Ea8wD/Rtd7leVRxGaknVk=.ed25519",
    "following": false
  },
  "signature": "XKuYYFATrvwnN8+0JTTMMiJrNioXsGAY15sO24Zlq2k9yA1/6IGl0dxhU7LPmv2jWsk4H4CTQKC69qgeHeBCCg==.sig.ed25519"
}

{
  "previous": "%+JKxrZbcTUnL4oItfSrtKZady9yx+73nUVk6j15Ii34=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 21,
  "timestamp": 1490534557681,
  "hash": "sha256",
  "content": {
    "type": "pub",
    "address": {
      "host": "198.211.122.115",
      "port": 8008,
      "key": "@7snGJQdhw12HrUTzeaWMfxuBO8c2U75sG7sNkeEfYOw=.ed25519"
    }
  },
  "signature": "DVHXCKlfRHhNH7QgfNe46etJtZrYUvPwGYVIsA1y92bQZahk1gAjxiW3yGOVM4aCnbdE+CefNNoapaLNLvKZBA==.sig.ed25519"
}

{
  "previous": "%M59ka4keDaPF/qAUGa5v8qs3gTIWn0RMRzcWZSl32cI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 22,
  "timestamp": 1490534558007,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@7snGJQdhw12HrUTzeaWMfxuBO8c2U75sG7sNkeEfYOw=.ed25519",
    "following": true
  },
  "signature": "k5lHlTky7GaY5JVROs8rwBvBw95K0pxadI/RVu6ioLxlcvpLfrZG3k2z87BdimJcSN5zy2UBHLHPQQrYBPhEAA==.sig.ed25519"
}

{
  "previous": "%T+rMs+sBHM2En+DOyt2VfN/lOk88Ggf5sfvD0kj4h7A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 23,
  "timestamp": 1490534639515,
  "hash": "sha256",
  "content": {
    "type": "pub",
    "address": {
      "host": "ssb.rootsystems.nz",
      "port": 8008,
      "key": "@L+nPFTMUHWXuchOwuzT6Z8Ea8wD/Rtd7leVRxGaknVk=.ed25519"
    }
  },
  "signature": "6OM9lsjEjmwdyy9BWZg9TbXazw/+l29eUTRLdtFCPImrgMO/yvws4fW59vUKPUVEREHLlz/BEZzGEE4Nbl77AQ==.sig.ed25519"
}

{
  "previous": "%pOOP0KqzOtL94cZGfxGOGkoXMGOMS+e0E1hBkpt5P/U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 24,
  "timestamp": 1490534639790,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@L+nPFTMUHWXuchOwuzT6Z8Ea8wD/Rtd7leVRxGaknVk=.ed25519",
    "following": true
  },
  "signature": "OQambehP6Yngw55Rs/QgjoCoQ+shw66ic1Ai5seoUfA+BRjCQ+TQr6jBpYy3Bf093uG4IB5pq7GLOEtHnZp/Bw==.sig.ed25519"
}

{
  "previous": "%W0LNoBGzZkt60ShIEOUlj9h3OGr7k7TF9H9CpdEcwSE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 25,
  "timestamp": 1490534730070,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
    "description": "http://aljoscha-meyer.de/"
  },
  "signature": "wqtEKIs8tHybWzHr4bEU0z2MFWePgk6l/raXvFeyezRrbSpImMGpGCU98oprWoPhcQOvv0e1l6v1Dq7D9J6RCQ==.sig.ed25519"
}

{
  "previous": "%qtIrFnK4ra+ZL/SE0U0ZhFU0lP1J+E/wOCaeHSwA4wA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 26,
  "timestamp": 1490595930926,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "javascript",
    "subscribed": true
  },
  "signature": "6k2chd8Lvm8JHPEdTukN0CtwYYDXP3G1XTcN4QYSMikesvZd4KymsVtKzLu+4yNG/RHTh5uQOodBSr4kaOiJCw==.sig.ed25519"
}

{
  "previous": "%h2sDfJ/mkL5y53yGaACZENc/PXUAt2HfEYTSHDukZb0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 27,
  "timestamp": 1490630098662,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
    "following": true
  },
  "signature": "6xjchkbfqC0EzUl1gB1uQUW9bLtHfe2xb1Nc7lqVOCeXKhIKQ/GbQJY8Rl/9H9YjF/sFxQVwNptzOBCmkGyFDg==.sig.ed25519"
}

{
  "previous": "%Y8OFg2BkRuMcX1NJrAnxD5FnGkiws2cTIEdfi14a2Y8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 28,
  "timestamp": 1490630138892,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
    "following": true
  },
  "signature": "p1fHS8F6BAwyXWzJMLPFEWQRXr+PmstzYb46QJ6gxlH2TFgUVe5B9wF4fAEe6OYJEsBFAZjnumMzfGZivkGZBw==.sig.ed25519"
}

{
  "previous": "%xp/t/DiyfEp8eDq6rSi7BI4OkUriXRsubCr/XxnMlCk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 29,
  "timestamp": 1490630146283,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
    "following": true
  },
  "signature": "uQhQA3nFTyFVAkCIiYniMn1PctY1mJNs9KRWJ4i6XChkzQ/boTPZZ8Mfoxydob3sTeFWYwmBaRARLZdd8dgzDg==.sig.ed25519"
}

{
  "previous": "%tnXJmWv0txzO+QKiGrwnCGtFPdbRN/0pAKs8bzrA5SU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 30,
  "timestamp": 1490630200106,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519",
    "following": true
  },
  "signature": "Bd+zQopo9Qe5onbwW4FvqTdjNpgAvK1LyqCabbr36gabE8sdM4blvbkn1cbqYUe+wRu/v5PaIFKxZ8AWVTB6BQ==.sig.ed25519"
}

{
  "previous": "%mIoMMhAit7TBFMvQxEULw5lwmne5bdr83xLmgLjOdkQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 31,
  "timestamp": 1490631179404,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
    "following": true
  },
  "signature": "wPZn1MwfLXeNHyMRRKO/nTqHqKzMHRyC+sf6/w6N4/pYMQcp6HmjE4yKstV2zb5fOTxPeDS0twKtW+gMT3obDA==.sig.ed25519"
}

{
  "previous": "%azbRylrhG+RqQbT1LRkp2FLH4GPqbkb1GIO3q9MCnX8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 32,
  "timestamp": 1490636903781,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%b6nlgiAu3ZWkLqKnvkU1T/9PZCfiqSU/Ujg1xRmD/64=.sha256",
    "branch": "%ytJ4susH5xo43GLqS+MHaRjgnQkxJeTeOVe7Xp+/urw=.sha256",
    "channel": "ssbc",
    "recps": null,
    "text": "If a portability rewrite in Java ever becomes a serious possibility, we (you? everyone?) should also consider C. Everything either runs C or has an FFI to it. It might come with a lot of ugliness, but it for portability it is probably still the best choice.\n\nI'm not saying whether a rewrite is a good idea at all though, just wanted to put this here...",
    "mentions": []
  },
  "signature": "yi4j9PhH5MeU+APvuPxM/VHRVd4IfMCqNh2iP3/PP3rPK7g5NoIAEncHiYZ5+/zKduKtKwIvRwwVNPBXdY3OBA==.sig.ed25519"
}

{
  "previous": "%KU++TvaOHt/c0NceU5iHJagbyI25ifYZWT42eaqJCb4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 33,
  "timestamp": 1490642809805,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ssbc",
    "subscribed": true
  },
  "signature": "G7u3F6dknupuCY+waMacXFORDLjoeC0VTLkx4OVZfuER58HZJBWR/yavPKHY6Ntr9+sxFClnLR13yeRflr4NDw==.sig.ed25519"
}

{
  "previous": "%vQcDAPO38+FSh5vyPpjG2yaUSw7lFj7X/VAXegOGtlA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 34,
  "timestamp": 1490650248218,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
    "following": true
  },
  "signature": "E5LbW9H2RNHNoPXotv3saHnES6JP6CImrQauNzWCjuZ1PyM3AoYthWU5g3D2DyWrb1/pLG+hustw4Bm7JDDNCw==.sig.ed25519"
}

{
  "previous": "%Y0k+BNFrurltvj+mc2DIr4NZLK/dhGT62JJEzffDvhA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 35,
  "timestamp": 1490692070582,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
    "following": true
  },
  "signature": "kNvCNWtSYYsmWdAkMQNdOGYoXzGlvacXCq7GPDYV6VPjvfsjs4ySWAN37H37vg4nzzU3iYxyxDinKIoEl+2jAw==.sig.ed25519"
}

{
  "previous": "%pwyYXc7G9PNUjgIEy1PjLIcmmHyqbcbshywOX/gDtK0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 36,
  "timestamp": 1490697419553,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@9nTgtYmvW4HID6ayt6Icwc8WZxdifx5SlSKKIX/X/1g=.ed25519",
    "following": true
  },
  "signature": "6K0+E3LchWVXDT8ijEFE8Nj7IoZYSnMzj8YHmPTOSpVe6ABag+t3vGnC4EBdSclpNgZ39TagNJk0TnvO5WdXCA==.sig.ed25519"
}

{
  "previous": "%222S0cZSSxmVOj9998i5JL/KBlsnDWkWotW3dwI7Tdk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 37,
  "timestamp": 1490715747620,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%yMH4cssbTHFgb0IIChSmvuTAGBBkzgjDoujZYCihquA=.sha256",
    "branch": "%uBidwSeMC3hU/JkmrL6jfC096wE/gulj2lphS85pTUQ=.sha256",
    "channel": "anarchitecture",
    "recps": null,
    "text": "Suppose I define a meta-message type, and its type is the hash `%123...321=.sha256`. Now I can create a message `{type: \"%123...321=.sha256\", displayName: \"vote\"}` to represent the message type `vote`. So far so good. But I also need to create the representation of the message type `%123...321=.sha256` (the type of meta message descriptions). The type field of this message would need to refer to its own hash. Which is - as far as I understand the protocols - impossible, right?\n\nIt would be a shame if it was impossible for the message metamodel to describe itself, so let's hope that there can be a workaround via a stringly-typed message.",
    "mentions": []
  },
  "signature": "kQB+UWlhyhYlZJAl6jPnK7xzh3U64pQdwc+wu43uNiWXYz0GgtqrmQHhZHs1B4/NvNVEMv8MFq9SQRUELpNVBg==.sig.ed25519"
}

{
  "previous": "%DME83LuScaU1xiEnq7YtG4Jwt/kSFnxZY6knxatPX0U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 38,
  "timestamp": 1490733138841,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "new-people",
    "subscribed": true
  },
  "signature": "AChFIHypaIjIWwAJz++PG+okWNKehD3sLteUPRD/W7Km5E525EiEdvYfS0qx6uZGgzYzsTKQ5IvbccLx1aDsBA==.sig.ed25519"
}

{
  "previous": "%P3FIxIvBkcl6p20gV4Rk2MkTWyANAnemLP+tbn+FMo4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 39,
  "timestamp": 1490733246495,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@hxGxqPrplLjRG2vtjQL87abX4QKqeLgCwQpS730nNwE=.ed25519",
    "following": true
  },
  "signature": "/olpKRG7t8grVVz23qxPT4JtIUBXGmHFifciU2r7XjpiqM6DeAfnOWgqNcXEayPtUzOwKcmT/1TGxN1tcy5dDw==.sig.ed25519"
}

{
  "previous": "%iT14tVJPA8nvXB+SHIvWeYsDmZejyv/lPQt0d/+hzM0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 40,
  "timestamp": 1490780579575,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%yMH4cssbTHFgb0IIChSmvuTAGBBkzgjDoujZYCihquA=.sha256",
    "branch": "%c/88hXWPAAjgp3w7QbCeTIS/XEerAIkwtTHWR9AqySw=.sha256",
    "channel": "anarchitecture",
    "recps": null,
    "text": "Yep, a special case for the meta-message type itself seems to be the easiest solution. Clients who consume/produce these meta messages need to be aware of the special message anyways. So expecting them to be aware of the special case would be inelegant, but probably not be a problem.\n\nSome more questions on messages: Are there any messages that get special treatment from the protocol? The [message types docs](http://scuttlebot.io/docs/message-types/post.html) single out `Post`, `About`, `Contact`, `Vote` and `Pub`. Is that because they form the basis of the social graph, or are they relevant at the protocol level? The docs for these message types don't mention any special behaviour, except for `Pub` messages.\n\nAlso a question on [links](http://scuttlebot.io/docs/advanced/links.html): Does SSB build a search index for any field in any message that contains a link, or only for some messages it knows about? What about arrays of links? Links in nested objects/arrays?",
    "mentions": []
  },
  "signature": "TbVcJ5V/QWANTpp7PH32J6otYAw+l+R6AwoY6sIZsuw5GYBLPil1CswXUtvR1R7DagD8Q6sZNFe4LXKa2grSBw==.sig.ed25519"
}

{
  "previous": "%7Dmejie0KkpF4028+gKaiAN8+vqVjzyBUgzG3JgSuRQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 41,
  "timestamp": 1490788802223,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%yMH4cssbTHFgb0IIChSmvuTAGBBkzgjDoujZYCihquA=.sha256",
    "branch": "%2lI7rcYa18ZYf1fhfboApRKHRkRDAFYWMwN6jjtzVFY=.sha256",
    "channel": "anarchitecture",
    "recps": null,
    "text": "[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) Thanks for digging those up.\n\nI wouldn't focus on things like absolute specifications and types at first. I'd rather try to find a minimal model to describe relationships between message types and their interpretation by clients. Once these relationships can be expressed, one could add some more metadata, like types, links, documentation, git-ssb repositories, and so on. This can develop organically - basically you build a client which uses some type of metadata and then encourage everyone to add this specific sort of metadata.\n\nAs for type schemata, I'd be interested in exploring the possibilities there. I spent  a lot of time in the past year or so thinking about programming languages, which included exploring a bunch of type systems. But I believe finding a minimal vocabulary for self-description of message usage needs to be the first step. Any specific usage of this vocabulary should not determine the details of the design.\n\nI think I'll spend the coming weekend exploring the meta-description rabbit hole and to write a summary - both of designs, and of use-cases. Then, I'll start writing a patchbay plugin to actually get something working. ",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "xQEmRDdFRIfPPQzlEm35oWEB78wVKoxKyI7P5jfLrCrhYanDnXeTqwVwunRQPvC7A2wMmrNtUOGzNCWBFKzLDQ==.sig.ed25519"
}

{
  "previous": "%1i+KHU93VT2DXgE+qvEbdTA74ERYpkZGpCkP4wWQ2V0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 42,
  "timestamp": 1490791976159,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "new-people",
    "subscribed": false
  },
  "signature": "njqnEEBX9HvfHHwFmmw0egjIp1VXNTJrsOJ0p/D79zQZSs75O2CXN7Zb2NkChXvqQ25VC/ajMqY84dORIfyFAw==.sig.ed25519"
}

{
  "previous": "%tezIVJtMADG1suiRVBd3xspRvWArbvkesvOFNJJRCvM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 43,
  "timestamp": 1490796254530,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%1lEv6AdiSaTsydGvUi65KaKLN64ykRvc3g7lTRRKsHg=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "EQLFjZ+kh5Lniz2ibWep3fnmJv7ZdNjSaMsSvQTIQ91eJgrY2dp9563cNpudF3YFt+ccZMHDd3lr2q845yisDQ==.sig.ed25519"
}

{
  "previous": "%NUP8stk1BDhOwvdm/oe7yVyQXv27a+xXnLZBGZl/ebg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 44,
  "timestamp": 1490821412929,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%kDrsaJXkDiRwit9mCCmqoWBqI3WWxBxp+82fjZELluU=.sha256",
    "branch": "%1OtZ9eSMa0YHH7om/aAlizZokTwZcwGMpk4qg+a5M/4=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "I know some of these words!\n\nAre all of these backwards-compatible (either implementation detail changes or additional features), or are you willing to break things built on ssb/scuttlebot?",
    "mentions": []
  },
  "signature": "2W9x6ftmdJVXJg3D2cBOCcgOv9RNm7OIK4l+Lk1VG14vb+Hl6zXgU9WqYplKMLGtY9n2eSUePGFuFsx6B+B0Dw==.sig.ed25519"
}

{
  "previous": "%kvwk2IaPpgqTt2W3eC4XqsbzC6RdTnNzzVEuZ0OU6Tg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 45,
  "timestamp": 1490872467148,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "freesoftware",
    "subscribed": true
  },
  "signature": "U+i6YQ6oq3oGumRsPWiROd6ceE6VVqEWIhS+z0vn8NlA7CDGH2gHyl/9sZNgSCQrD//Rzsrg71Vc9AUflez2Ag==.sig.ed25519"
}

{
  "previous": "%+Z6Hzec1hmCkiEBlQx5HPF28xGbIBPQnQHr1WxuITiU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 46,
  "timestamp": 1490901508528,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "patchwork-dev",
    "subscribed": true
  },
  "signature": "Rw95ZZaNx3Uz2M6XRfv+co2PjAqFadUuq/v46eo3Pdbe5RLcZ/YEll5KMMzARASUliqPtXF/YIFwNM2lZOfABQ==.sig.ed25519"
}

{
  "previous": "%nj398AtiJ8yWCjHUJ5rbRPmU2jC4ltgUqUqwl87S1E4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 47,
  "timestamp": 1490994674132,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%s1GPDFZpXMbqSYK6XWiutf/YgW6l2PwdQJe4x8ayGR4=.sha256",
    "branch": "%s1GPDFZpXMbqSYK6XWiutf/YgW6l2PwdQJe4x8ayGR4=.sha256",
    "channel": null,
    "recps": null,
    "text": "The [servo](https://github.com/servo/servo) team actually does [some](https://github.com/servo/servo/blob/master/CONTRIBUTING.md) [interesting](https://github.com/servo/highfive) [stuff](https://starters.servo.org/) to enable contributions from non-mozillians.\n\nThe code base itself is [fairly modular](https://github.com/servo) as well.",
    "mentions": []
  },
  "signature": "BMfgWRAOil3ScMZCLvl49cjmB6SFWJizxeXQKxT4T2KkWRUsH1xVegW/bgutB4+8EwgeBsB3prCU2Qm0ujbABA==.sig.ed25519"
}

{
  "previous": "%6CkzU3F+OT1PCiGQxfY0xtw6d3rdEye1jGcFSdZEwH4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 48,
  "timestamp": 1491117465174,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "git-ssb",
    "subscribed": true
  },
  "signature": "MFdqeWL0eFCp5YvMngcHdAz79ogYVA4R2EHYWoeYHB4ekbORyy/C/VySxJrSiNwVTvIagqW2dq8s7k37VIQXCQ==.sig.ed25519"
}

{
  "previous": "%rMZEugH7osuq/oOL2JErMFLMpKKKckIZAI60PrUripM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 49,
  "timestamp": 1491132855074,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "softwarequality",
    "subscribed": true
  },
  "signature": "FxWgyP389cbVefN6MJnvbDUImTZzEy/QSzN8oGhk54FbH/poHM2VWOvOQZlq8ESKEiwsce4RIAqdlqZtaIREBA==.sig.ed25519"
}

{
  "previous": "%ytSyElM36d7+jXuMEOXPysIkMiM/soiuAA95Xl4IYKk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 50,
  "timestamp": 1491153237706,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "modules",
    "subscribed": true
  },
  "signature": "h+hZZ/h4IYICQjfJotwihQN9jIq6cGs7k/Fj1Rv4rZaNiqjTkm9MCT7C/MYtz0DR6Sk+dsotxGgYeVAqarzSAw==.sig.ed25519"
}

{
  "previous": "%W3pCf3dkvF/Zx6A9F5gQrkkXeyLuFrWR/S41muv2YIM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 51,
  "timestamp": 1491294836533,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%i50GtoTa8Dt+64AXHE5/iDapss6KK7DgLNXyAjMCFM8=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "osBRubiHu0KYC1hr1TYwLfoE9crH8FSNkKbcy+t/U5hoRJV2fSn8XfuTYqGyGwPQ/CTJcuFZtre28Ryaj8zjBg==.sig.ed25519"
}

{
  "previous": "%8uzyF813oDPJBuW2lBH871m12GLYEpTdYSiGpDJmHeo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 52,
  "timestamp": 1491295105418,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "webgl",
    "subscribed": true
  },
  "signature": "JNwFuxq4qM0F4i1b6S6smyX3Sfqo9JRJ4QmS36YbMDmYfEP+RduaijqCxPpVuthczphWFDK6+7X8P4N10L1HBg==.sig.ed25519"
}

{
  "previous": "%KjwIPNyjyZjV9qaJRJgF92ttej/14HwAOBRdJ4s3H7g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 53,
  "timestamp": 1491308842099,
  "hash": "sha256",
  "content": {
    "type": "%%%",
    "name": "meta-message"
  },
  "signature": "YBFGiPpZJlnoziQgjvu7nmkUseg0DNbsbO4+SSVRqqzYy5k84VGqA9efWC0pRHgAdnrinukyJq6IfinyCamtDw==.sig.ed25519"
}

{
  "previous": "%et1Dc8iT5ZPXZsU0kFQ8ZhOyH4GnytYCGOUVfZ1PD2k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 54,
  "timestamp": 1491315033741,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebot",
    "text": "Is it possible to tell `sbot server` to use a specific data directory? I want it to use a database in `~/.test-ssb` rather than `~/.ssb`.",
    "mentions": []
  },
  "signature": "UM1NCfBsIwkc1KiTLyjlRb3aWt5sXLjDKW46HQDEV9v2CDmi74DHmeKzz+gxEKi9cc2LNmw3n6BjutMFJfI8CQ==.sig.ed25519"
}

{
  "previous": "%khUU3xWYYP3IspHLBXdD8Y697MTrKL7ONaD5U9mnS14=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 55,
  "timestamp": 1491319318072,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%khUU3xWYYP3IspHLBXdD8Y697MTrKL7ONaD5U9mnS14=.sha256",
    "branch": "%4Mjnub5YFpUiFa1RLeyINFCEerwKUSKSmdE+Jff/qoU=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "And how do I set this config? It does not seem to be an environment variable: `env SSB_APPNAME=/home/aljoscha/.test-ssb sbot server` does not work.",
    "mentions": []
  },
  "signature": "vOqO5SqsETCu1ILar0AiBeWoMrlWOwO1IWodTxZf9DLISYz7k6O1C/7v0XhelWfqkkn9kumuQpn57Mic8p5jBQ==.sig.ed25519"
}

{
  "previous": "%ee8imWbHwcQRPRlLlUBhQ+GR6lR0/30zidsSuNk6E78=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 56,
  "timestamp": 1491321544644,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%khUU3xWYYP3IspHLBXdD8Y697MTrKL7ONaD5U9mnS14=.sha256",
    "branch": "%G0Euz+WtzrMx0BNznXXxiX7HVtJLuSxWp3u9GFcYvDk=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "Ok, this works: `env ssb_appname=test-ssb sbot server`\n\n`ssb_appname` needs to be lowercase, and sbot automatically adds a `.` to the name.\n\nThanks for the help!",
    "mentions": []
  },
  "signature": "W8oi52tfOwyfjto7kvoCWPGPxaEMR/DLWygCgzdi9kQ1hbJirNp5j4ITD62c4dnc4lE+hnABS2rEU1xsUlnzDg==.sig.ed25519"
}

{
  "previous": "%bA//C3GJf0dSTCwYblG+69EGpF50377W4LoZOQX1c2Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 57,
  "timestamp": 1491384575745,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%m8fNpY1Ch29zDRRlRVLF0Xh9P0wTboG/d6a2yWPQcsA=.sha256",
    "branch": "%6674ZhT7dif+BoC+Iq2xq8K6yYQ4yAuGuJ3b5erVf+g=.sha256",
    "channel": "ssbc",
    "recps": null,
    "text": "Some spontaneous remarks:\n\nThe article (rightfully) focuses on the peer-to-peer capabilities and not having to rely on an internet connection. This might make it sound like a very peculiar platform of no interest for people with stable internet access. Why would I care about an obscure system solving problems I don't have? Maybe you could put something in to signal that everything *just works* for the average first-world techie, list some of the benefits over alternatives that are directly visible to the user, and... gah, I'm bad at articulating this stuff. Basically: Even if you are not directly affected by censorship/network problems, it's still a pretty cool and uniquely useful thing.\n\nAlso, one of the most appealing things (to me) about the scuttleverse is the dogfooding going on. Perhaps the last paragraph where you list the existing applications could bring that up.",
    "mentions": []
  },
  "signature": "QkO4zTdahjv6FEHcHDnKv6TTNWMyffVvVfNg3oNHxUV9+QsmHRSH6mU7KmFxgdvp1gw6nYNrkFFEtHK8XbakCw==.sig.ed25519"
}

{
  "previous": "%1wI6+FMdM4YkaUHgx5jnjkt0wDj4kzDY1GjEbxNAD2M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 58,
  "timestamp": 1491404576625,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%yMH4cssbTHFgb0IIChSmvuTAGBBkzgjDoujZYCihquA=.sha256",
    "branch": "%1i+KHU93VT2DXgE+qvEbdTA74ERYpkZGpCkP4wWQ2V0=.sha256",
    "channel": "anarchitecture",
    "recps": null,
    "text": "Turns out writing is hard and takes time. For anyone willing to read it, here's a somewhat structured brain-dump:\n\n# Self-Describing Message Schemas for Scuttlebot\n\nThis post explores a way of building self-describing message schemas in the scuttleverse.\n\n## Background\n[Scuttlebot](http://scuttlebot.io/) is a protocol for building up an eventually consistent peer-to-peer database. Unlike related projects (e.g. the [IPFS](https://ipfs.io/)), each entry in the data store is tied to a user identity. Data is added to the store in the form of messages. Each message contains some metadata, a type string, and arbitrary data. The data may contain links to other messages. The database automatically creates indices based on these links, the resulting message graph is bidirectional.\n\nFor a developer, the primary interface to the database thus consists of the following operations:\n\n- add a message to the database, signed by the current user\n- retrieve messages of a certain type\n- retrieve messages by a certain user\n- look up messages referenced by a certain message\n- look up messages referencing a certain message\n- the expected mechanisms to filter data and to be notified of new data\n\nThe resulting ecosystem of applications has some interesting, unique properties. All data in the scuttleverse inhabits the same graph and is tied together by persistent user identities. This way, any application can use data produced by any other application. For example, an application might combine status updates à la twitter and commits to git repositories into a single newsfeed.\n\nAs a consequence of this, any application is free to interpret messages [as it sees fit](https://www.scuttlebutt.nz/concepts/consensus.html). There is no authority on what messages to produce, or how to consume them or present them to the user. Interoperability happens because several people interpret messages in similiar ways, not because a grand authority decides on how things are supposed to work.\n\n## Going Meta: Messages Describing Messages\n- need for some structure (why?)\n  - given a message without context, do something with it\n  - [type field](http://scuttlebot.io/docs/message-types/custom-types.html)\n  - problems\n    - conflicts\n    - names as resource\n    - difficult to find information on given message type\n    - primitive\n  - opportunities:\n    - tooling, linkability\n    - documentation\n    - gather information about ecosystem\n    - client-recommendations\n    - type information\n    - serialization\n    - automatic API negotiation\n    - plan interoperability\n- requirements (what?)\n  - powerful (should allow everything listed above, and anything one might come up with later)\n  - subjective\n  - flexible/evolutionary\n  - future-proof\n- how?\n  - [as simple as possible](http://joearms.github.io/2014/06/25/minimal-viable-program.html)\n  - minimal setup to allow self-description\n  - type can be a hash\n  - add meta-messages, and use their hashes as the types of normal message\n  - one special meta-message that is its own instance: %et1Dc8iT5ZPXZsU0kFQ8ZhOyH4GnytYCGOUVfZ1PD2k=.sha256\n  - no assumptions about what self-description should look like\n    - meta-messages don't need any fields\n    - but we can add a human-readable name just for good measure\n      - optional and no predescribed functionality\n      - certainly useful for building interfaces\n      - it might turn out to be useful to add more information on meta-messages, who knows\n  - doing something useful: post descriptive messages which link to a meta-message\n    - what to post?\n      - I don't care. Anything useful\n      - free to experiment: everything is nothing but messages (which may be ignored by everyone)\n    - who posts?\n      - one approach: represent message consumers and producers (clients) as messages themselves\n        - a usage description could link to a meta-message, a client-message, and contain some other information, e.g:\n\t     - a human-readable description of how the client deals with the message\n\t     - or which library it uses for dealing with the message\n\t     - or a structured representation of the fields and the types in the message\n\t     - and so on\n\t- trust in these claims?\n\t  - votes on these messages?\n\t  - trust the author of the message?\n\t- different versions of clients might do different stuff\n\t- tie client identity to git-ssb repositories?\n\n## Implementation\n- not protocol-level, can be organically adopted (or left to die)\n- create meta-messages for the currently used message types\n- ideally, apps would start using the corresponding hashes for their produced messages\n- apps should consume both the old, stringly-typed messages and the new hashly-typed ones\n- what about protocol-relevant messages?\n  - pub\n  - contact\n\n- implement a simple cli for querying meta-messages\n- start adding some information, e.g. human-readable documentation\n  - no need to enforce this tough, it's enough if people turn to this once they have genuine need for some message metadata\n",
    "mentions": [
      {
        "link": "%et1Dc8iT5ZPXZsU0kFQ8ZhOyH4GnytYCGOUVfZ1PD2k=.sha256"
      }
    ]
  },
  "signature": "8l9wKI5KH8njEP7+LIyj9H6Y1ZTG8zjSgrsbZwgcap94s9BNqyYivVQQDkZ/v9Mq7/4wytGm0BvLGhb34nlFBQ==.sig.ed25519"
}

{
  "previous": "%NR/ESRtxiPouBbhYt28/tsaHY5CuztMqLW46t2HIWBs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 59,
  "timestamp": 1491469517231,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%QNHzBJViCbWZOl3dURlfbXiQGfpixKqM2zLVj2tEbkM=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "oaXDqrK6IC1KeQOnaTgwZwPPduDKAjtu6/TTkW1bKq6Fp7K4bxKvhHqxRiZqnPd22rtMNTSyUNL75F4stKr0Dg==.sig.ed25519"
}

{
  "previous": "%dtMKDHluXfuUVzOVgsOsIstI6NVVXvn+GJHz5vIrSlo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 60,
  "timestamp": 1491477683538,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%s1GPDFZpXMbqSYK6XWiutf/YgW6l2PwdQJe4x8ayGR4=.sha256",
    "branch": "%nnExSOnb6D//Amq52PS2TDrgJ0C7a50e486p/f2Xfps=.sha256",
    "channel": null,
    "recps": null,
    "text": "> thinking more on this (I consider it an important, key principle), I wonder if designing the protocols/interfaces correctly means it becomes difficult for any one person to then \"enclose\" (in the broadest possible sense) the software (the browser) - mostly because the browser doesn't exist in any predefined way, only the interfaces do.\n\nFunnily enough, this precisely describes web technologies at a higher level. The W3C recommendations are the interfaces, and no one browser vendor can \"enclose\" the web.\n\n> writing in python or lisp or whatever doesn't limit anyone\n\nIn a fractal model, a \"module\" does not even need to be written in a single language, since it can be decomposed into independent submodules. At this point, we basically reached Alan Kay's original vision of object-orientation: An object provides an interface in the form of messages, but the internals of the computational process are hidden. Any two objects which offer the same interface are interchangeable. Object-oriented languages (and by that I don't mean \"we call our structs 'classes', now we are object-oriented\") provide a framework for implementing:\n- independend computational processes (aka objects) with an interface to the outside world\n- composition of these objects to form new objects\n\nIf you squint a bit, Lisps basically follow the same principles (or more accurately: object-orientation heavily borrows from Lisp): The function is a computational process with a well-defined interface but hidden implementation, and new functions are constructed by composing other functions.\n\nYet another facet of this is the actor model, the major difference being asynchronicity. The major programming language to look at here is erlang. In Lisp and Smalltalk, it's turtles all the way down - S-Expressions and objects respectively. Erlang however provides a \"normal\" programming language (which happens to be functional). So while larger programs are composed of actors, subprograms are eventually implemented in some other primitives.\n\nAll these programming language provide mechanisms to compose building blocks while hiding their implementation details. However, each language confines the user to its constructs. Which has some obvious benefits, e.g. performance gains, a unified development experience, static analysis, everyone can understand everyone else's implementation details if necessary, and so on. But support for choosing implementation details outside of the languages capabilities is usually second-class. Foreign function interfaces exist, but you can't really implement a lisp function in prolog, or a smalltalk object as an erlang process.\n\nTo get this degree of freedom, we need to turn to the operating systems and its inter-process communication mechanisms. The obvious price is performance. A less obvious price is that interoperability needs to be ensured. While we stay in one language, we can use its interface-description mechanism, and the compiler/runtime takes care of the rest. Current mainstream operating systems lack these possibilities. Unix-likes explicitly favors files (i.e. streams of characters) instead of stricter interfaces. The best we can get is probably windows powershell...\n\nThese drawbacks are the reason why complex software systems are usually written in one language, instead of composing subprograms through IPC. From an abstract viewpoint, there should not even be a difference between a program and a function. But as long as composing a language's functions (or objects or actors) is way more efficient and convenient than IPC, large (desktop) software projects stay monolithic.\n\nI should probably mention microservice architectures as well. Since communication across microservices needs to cross the network anyways, they can embrace the paradigm of small composable programs more freely.\n\nI rambled long enough without a coherent direction, so to end this here are some of the different choices inherent to different frameworks of composition:\n- strongly typed vs dynamically typed\n- self-descriptive (aka reflective aka in-band schema) vs just the data\n- stateful vs stateless\n- synchronous vs asynchronous\n- sequential vs concurrent vs parallel\n- fully recursive vs special implementation primitives\n\nSome resources:\n- [the original lisp paper](http://www-formal.stanford.edu/jmc/recursive.pdf): very readable, very impressive\n- [alan kay on object-orientation](https://youtu.be/oKg1hTOQXoY?t=30m26s): the first 35 minutes build up to this, the link starts about 5 minutes before reaching the part directly relevant to what I wrote in this post. If you have the time though, just watch the whole talk from the beginning.\n- [rhich hickey on languages vs systems](https://www.youtube.com/watch?v=ROor6_NGIWU)",
    "mentions": []
  },
  "signature": "P1aHxxxvSNDR/QVt+zrZQXEFrc2lZ/JjSqQM35CNpI1GJ2vuNxc3JuskKt5t35MhCG7+Ue5sMRQd2qS02LbTCg==.sig.ed25519"
}

{
  "previous": "%a2Wn/Q5rAlPH+HatVTrQPkh8jmQj7Bwwn4IOVP4W/JE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 61,
  "timestamp": 1491489686816,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%hDPzILSa5lDh56comjkPYvWEQFU22VHZAKzY/24+nHk=.sha256",
    "branch": "%LjQLNpWqYeZLy+RVVq+2SRWF8hOB7pDb30X1cWtfg4Y=.sha256",
    "channel": "new-people",
    "recps": null,
    "text": "The soundcloud alternative is [ferment](https://github.com/mmckegg/ferment)",
    "mentions": []
  },
  "signature": "vWNy4HA/g2TxztSiSHD6u+gyyEpkIDU7EUatzbPpPItICTBjUklGGr7Le1uwYe3RSrmmaU13YI5LV4Y93rVSCQ==.sig.ed25519"
}

{
  "previous": "%u8ko52zgtUzmz0GUz8/eNZ7AKB84ShCShKz+6t69WeA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 62,
  "timestamp": 1491490495997,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ipfs",
    "subscribed": true
  },
  "signature": "Db7sMLz3NwK39aluofZeMSI2w2YkpocTMkBGCC7AxTC+ydBtl7OWnFmdZfy8B88P+HYOYEl1WKikitFGrV8MDg==.sig.ed25519"
}

{
  "previous": "%BERcei8Ah6pvBmWKfmhfMEZa7LUD1eoOYCdF9UnQqXw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 63,
  "timestamp": 1491492634207,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "opensource",
    "subscribed": true
  },
  "signature": "PjoOJAs4Wg9KB/Vf2DyBPP+rvaY/gqvJ6kyn855x6OJ3WtFwEde7j9UE8hUrC78fvm+wIpjENp8u6KG1Yb9oDg==.sig.ed25519"
}

{
  "previous": "%L52ToODE9CDfBnth2Vr89WxkaHmkg6FkkfKxuxRl8QI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 64,
  "timestamp": 1491492722161,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "socialsoftware",
    "subscribed": true
  },
  "signature": "J/hMy0/jSlTaZK96b5NlTTKaLCHsUnvFye98+dGW+fmlS18zgmYltxZ8lQkF9ljT4IEhFPhoWOxmc4xh/RiYCA==.sig.ed25519"
}

{
  "previous": "%18KjBykZQ4U5+vY8kbCd+3iugZekNwCgAi4y2XUz/zo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 65,
  "timestamp": 1491497323496,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%tpH4PPCpW3bYvYpODYGIBAE6R18Yf8cZk3tv57q1Ypw=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "nzvZ/ixVjNWCrX8N6qHvD/cZaFAM1aRSayF2Xr6W9OWIcywIZchtbX0Jfaz4XewgJzJwMGzdHk0qj7yVKw9YDQ==.sig.ed25519"
}

{
  "previous": "%itKUgab6g/vGkCxZrStPjpuv6c8cC5o0lZP4UuBGQS4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 66,
  "timestamp": 1491498256303,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%UiW+OlejvOEBUV+dWWiG4AnV1/BXAIhxxkEd12/8nLY=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "YKDJjMULNX0kX3HtYaWr5btKQLdzr4qcyfFeVwSYGLMwHzX8zVdS0v/wwXZsXahELEsiOzkhL52Gj4z4gddNAw==.sig.ed25519"
}

{
  "previous": "%9TjEJ1CtM+LGYhfHLTtOwNJr6Ib2GqSD1MQT7YI3EnA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 67,
  "timestamp": 1491511416624,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "faq",
    "subscribed": true
  },
  "signature": "f6XIopk+hbkQNT0IGpXAYjOx4eGORU+vFLPNapSw7I0CUyfVp+RvNbg1UG2hNaqXbXoTV/4sRIo1W73oSEGPCQ==.sig.ed25519"
}

{
  "previous": "%raTliCOoak2OM5H/CiSAsCJIsUWmZKwtgcHOqpLPX0g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 68,
  "timestamp": 1491552024225,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%UYmlPZtzAcw6BppHs2MNdsunz/MnGgmcEH0XhsVk+w8=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "vIAEA4uxWxHtAVq8lEtZqBckJfJc2pXTxajqbOS4JGq220vuVaA3naU5iUfDLB6j+txBbTKaqhlm+8n8yJx7DA==.sig.ed25519"
}

{
  "previous": "%r13vIczpFUE8wUIGQGHSsUg88gZN5rR3x8kKEbjDOfo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 69,
  "timestamp": 1491552448480,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%QKmhvUUfVgQ2o8yOyem7q3IlSYxkEsDjaw+gnP5hzuE=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "B+/8hcvkdiT2uZSqulLjE1jqMgYOviFmQqDAhNAG3Q5iiBI9/B1ELf8gVBc1+qMwXmsgjk2xFv6N40H3kO3eDA==.sig.ed25519"
}

{
  "previous": "%sKKHtTyF6ld0x71UgIjALsS34r2uuHLArHGPJ75Iee4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 70,
  "timestamp": 1491552679668,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QKmhvUUfVgQ2o8yOyem7q3IlSYxkEsDjaw+gnP5hzuE=.sha256",
    "branch": "%QKmhvUUfVgQ2o8yOyem7q3IlSYxkEsDjaw+gnP5hzuE=.sha256",
    "channel": "programming",
    "recps": null,
    "text": "What confuses me here: The language is supposed to be dynamic, but everything is an object conforming to an immutable class definition. So what is the dynamic part? Cynically speaking, if the language combines the rigidness of predefined types with the error-proneness of values that could be anything, I'm somewhat skeptical.",
    "mentions": []
  },
  "signature": "JbNl6ULe+EpEJdEJ4ule+CxdaWt967Dwe2ONJeWopb7mzEskWhQqrzlUGnQ+wsOpNLyd03ITqWTYfqJC2hGFCA==.sig.ed25519"
}

{
  "previous": "%qYEh+ZMgoKRgRHUBda7j0sS1+l6XhnZCzALW6QWixN8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 71,
  "timestamp": 1491561641218,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@7snGJQdhw12HrUTzeaWMfxuBO8c2U75sG7sNkeEfYOw=.ed25519",
    "name": "digitalocean.staltz"
  },
  "signature": "uRPH4R9mZgf2oSPRu0hvGisZoClRB97jc5jbUaOYNZv2J5IMU5Rrogexs5H0S9oSUdsG1h/7+9h/vGXUEziKDg==.sig.ed25519"
}

{
  "previous": "%A7/223C+L8D5ojq5q/OY1g7b9WuJ/Vbrkl8NrOZsGCg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 72,
  "timestamp": 1491561922010,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
    "following": true
  },
  "signature": "JZiy/W+tblS+K0CL0eT7m7kUoeb0r8W+8egalFJ8R3hTeVAQF9+JogVR+jq8boprTDIeK5Q3Jkp7c7pFyUbTCg==.sig.ed25519"
}

{
  "previous": "%bUDwlienD46DFx2TWNfqr3MSthb02RSxPU2hF8VtLms=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 73,
  "timestamp": 1491562055246,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "linux",
    "subscribed": true
  },
  "signature": "1g309YuFNoU93Foo5D9jdcjN5Yw5Xw7pcIAblfJI1l18eqQzAm4owdWKcOspz7X0r4wFArDr8UwjdhE4I/FJAg==.sig.ed25519"
}

{
  "previous": "%Dx6+COeIBgio9ZEUXjgO789ilxiTRa+Akbx2Mxg+hh0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 74,
  "timestamp": 1491564647229,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%+vfG/X9gvWn4vC04zm+yHtSdRQHk9wgjtCdxLYLdEhE=.sha256",
    "branch": "%2DplhCmLMkRjFTuhK9o0VVYrcw1W7mi2ocFY9cILurQ=.sha256",
    "channel": null,
    "recps": null,
    "text": "Clicking on the `%patch-gathering` link in patchwork 3.3.0 give the following error and results in a UI that hangs in the loading indicators:\n\n> TypeError: Param 0 must by of type msgId\n    at Error.ZE (/home/aljoscha/projects/patchwork/node_modules/zerr/index.js:11:42)\n    at Object.ZError [as Type] (/home/aljoscha/projects/patchwork/node_modules/zerr/index.js:13:14)\n    at validate (/home/aljoscha/projects/patchwork/node_modules/muxrpc-validation/index.js:138:22)\n    at Object.<anonymous> (/home/aljoscha/projects/patchwork/node_modules/muxrpc-validation/index.js:78:17)\n    at Object.hooked (/home/aljoscha/projects/patchwork/node_modules/hoox/index.js:10:15)\n    at Object.localCall (/home/aljoscha/projects/patchwork/node_modules/muxrpc/local-api.js:31:31)\n    at Object.<anonymous> (/home/aljoscha/projects/patchwork/node_modules/muxrpc/local-api.js:37:22)\n    at Object.request (/home/aljoscha/projects/patchwork/node_modules/muxrpc/stream.js:46:17)\n    at PacketStream._onrequest (/home/aljoscha/projects/patchwork/node_modules/packet-stream/index.js:159:17)\n    at PacketStream.write (/home/aljoscha/projects/patchwork/node_modules/packet-stream/index.js:132:41)",
    "mentions": []
  },
  "signature": "Xh5o/P0lpGziFmxcUaTUFHt0MHhWFI/7HhOGZYZNmhCKK36wNQmdPyUgAkN7ZdBLIYScHKZ9qckpVFxPQ4Y+DA==.sig.ed25519"
}

{
  "previous": "%0+uYgO01cjINBc797bUr2NJBdTjmc/hW7LiHoxqMt5A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 75,
  "timestamp": 1491566348137,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%+vfG/X9gvWn4vC04zm+yHtSdRQHk9wgjtCdxLYLdEhE=.sha256",
    "branch": "%ZHL+jWeso5K5VRvdi4FgqAoUnkF7yLeXI0wDsKryXm4=.sha256",
    "channel": null,
    "recps": null,
    "text": "I'd guess (without knowing any of the involved code) that the connection does not drop, but the rendering code simply errors out or hangs.",
    "mentions": []
  },
  "signature": "tqrQxTEYXZe/KVZSmbg3I/V4j13WjAvB298qgdKubjJXTdlD2ClJJs09kzmffJmoBBLPYT9CoXwbpEXqlK0GCg==.sig.ed25519"
}

{
  "previous": "%tj+Xo2+mgHfiiO/3yhmNOXz16OjW9ZnlTKrwiv1Nxo0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 76,
  "timestamp": 1491566441346,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%gMdzumHGAiGRtZKaQywy81FRdbYSLKQOMIj983xgkG0=.sha256",
    "branch": "%oj+2YQiD2DqJ3kgPzHBpvSyqLbUaOhcyHwmQwxBihIo=.sha256",
    "channel": "germany",
    "recps": null,
    "text": "Moin zusammen.\n\nAlso [#berlin](#berlin) is a (pretty much inactive) channel that exists.",
    "mentions": []
  },
  "signature": "LUxAGDHpU9LEsLrCHrTNQej7OtbHaH9/q8Xi4Zfqanwj4VyF7mn1PE6wUeBSoLccq/7tobZjbqel3+Cxd3wfDg==.sig.ed25519"
}

{
  "previous": "%JNS8lN+7+v4xpX8Ejuc7HbxJ6AFIPsIwimrFH6301Ko=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 77,
  "timestamp": 1491566492229,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%bvaYJVxXy88eVVEqlOlG05aj5Vs6zdAHmGNHW10cT10=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "Zx/T3qVZpmog+BX5/3iVhjAI3BbCzf64VGMqr+LoiyF8Ji/U5E5O2sRJEXpHZLpnezXOMjRjebKxvFdpdNKVCQ==.sig.ed25519"
}

{
  "previous": "%t0Ex4A342N4GDhs9gshih3WXCZRoyiP0UknH5/vwP3M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 78,
  "timestamp": 1491566710066,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "germany",
    "subscribed": true
  },
  "signature": "tbrmkxf3VZomVnE2jBBsvkF86uLTRVOxIr6V/MvbwcBAXQok+YZn8olui4m1g25eYMb/6vD0y0udedlan8/iAQ==.sig.ed25519"
}

{
  "previous": "%2c4sApwe9yh76qxou32yUtKlsUnx/V2QeoJUPPizIwM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 79,
  "timestamp": 1491570259967,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebot",
    "text": "Is there are module that does the following?\n\n- try to connect to a scuttlebot server\n  - if no server is running, start a new server\n    - if successful, connect to it\n    - if unsuccessful, error out\n\nThat seems like a basic starting block for pretty much any scuttlebot-based application. Patchcore has [sbot.js](https://github.com/ssbc/patchcore/blob/master/sbot.js), which might do that? Or maybe not? Without any comments or documentation it is quite difficult to untangle the depject needs/gives.",
    "mentions": []
  },
  "signature": "RNAjxCq7ZgxJh2cguof+QH8LkfdnUy1D3zdGgR2jIYVnQLSrBXH7Fl38UMRODb143vEnGYzioytCyV8nl9UZAg==.sig.ed25519"
}

{
  "previous": "%cJ1GJMhW1Npgj4FmdnrucUr4X/69lQ5iTjhUCyLHg4I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 80,
  "timestamp": 1491570354045,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%7D1/p+QYyTnNhS90yJWBlmWn8YHajY78uIO7Qgli35c=.sha256",
    "branch": "%6A14TJa8pyWbDpkKv/K6a/2oItFxHKr69UxDl04j6Xc=.sha256",
    "channel": "faq",
    "recps": null,
    "text": "The key is in `~/.ssb/secret`.",
    "mentions": []
  },
  "signature": "gFMd0GrX0nmtQ3KgRKBhNq3l67HH2hJK46TacoAzGUGbPZRkfoqZqZIO4NPvkcqBZSOPLu6ArFLINCqik/DnCA==.sig.ed25519"
}

{
  "previous": "%ZKF2LP40FoxigPZx+10fxCgDqsH5mzHIqUyWW5OJGqM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 81,
  "timestamp": 1491570769511,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%cJ1GJMhW1Npgj4FmdnrucUr4X/69lQ5iTjhUCyLHg4I=.sha256",
    "branch": "%cJ1GJMhW1Npgj4FmdnrucUr4X/69lQ5iTjhUCyLHg4I=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "Also, while I'm being frustrated (not really) with patchcore's documentation: The readme contains this section about plugins:\n\n> ## plugins\n>\n> here's a list of plugins that build on top of `patchcore`:\n>\n> - [`patch-gatherings`](https://github.com/pietgeursen/patch-gatherings)\n> - [(add yours here)](https://github.com/ssbc/patchcore/edit/master/README.md)\n\nWhat is a plugin? How can it be used with patchcore? Is \"plugin\" just a name for a library that provides similiar functionality for custom message types? Or is there some integration mechanism?",
    "mentions": []
  },
  "signature": "nbUutJhML55Ma4wrNl3yffh2K+FBDv57NuwusE3zJVZYRkHB8XsIi7osyx73dk1VZkVR+bhJQfnkcEX0uMOfCA==.sig.ed25519"
}

{
  "previous": "%iT0oz/S+dG5bl2WHwxjq8+o/qONo9yEY1ypJlzJP730=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 82,
  "timestamp": 1491571934408,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "golang",
    "subscribed": true
  },
  "signature": "zeI/PeUly6N8Fajo6osweXj5XYE8jIQ/4MTFER+w6yzFeYLSJkP2N7OXt6LBUoYmNKVIsLLHctiTfHy3EyOHCA==.sig.ed25519"
}

{
  "previous": "%q0mOxy7FUIWaYaWubkbqKqWDmxt5lMXmvyafhA8Pz7M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 83,
  "timestamp": 1491576880624,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%o5HdaPZpA6sCrq+QnkhgCC5/wbjg6FlKGqg4P7VD6ss=.sha256",
    "branch": "%yl9V0Y6i7O+/JTIx7dlaWwLD/Got8FO92Kd76u499MQ=.sha256",
    "channel": "faq",
    "recps": null,
    "text": "To leave a pub, you can simply \"unfriend\" it. In patchwork, click on the pub's name to get to its profile, then toggle the \"friends\" button.",
    "mentions": []
  },
  "signature": "H8CAYQYACEB2XwRAy8jpJLlYSmtBuvyDWe09t7fQal+XraeZPBklPWx41wZL86eC4d0TyAWUzC0VwE57QV0RDQ==.sig.ed25519"
}

{
  "previous": "%LZyhjnhi3CgT8GUPxd0bYrBntXeDiPTCJxpbA+65eWw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 84,
  "timestamp": 1491587069695,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebot",
    "text": "Is there a URI scheme for referring to scuttlebot messages? I'd think I remember seeing `ssb://hash`, but could not find this anywhere.\n\nIn related news, after reading [this discussion](https://github.com/ipfs/go-ipfs/issues/1678) on IPFS URIs, I now understand why the scuttleverse seems to move so much faster than the ipfs.",
    "mentions": []
  },
  "signature": "cDUDHDLsSKC2nb5vQqh/OBONY4hGFqzlNgCexsau0XLLeQcMjI4lNwYOHR/dCA6rNWMaCtKqsbXv1gK3r0F0DQ==.sig.ed25519"
}

{
  "previous": "%Ar7gwhhG6k5VDKE25LEtILMu3Gpnj+dX3oH/jvwl6GU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 85,
  "timestamp": 1491592718252,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebot",
    "text": "# Semantic Versioning in a Decentralized Package Manager\nI spent some time today thinking about package managers built on scuttlebot and/or ipfs. A package manager should be able to deterministically resolve (transitive) dependencies. As long as dependencies are directly specified as hashes, there are no problems. But I could not figure out a way to make dependencies based on semver ranges work. I.e. being able to specify \"I depend on any version of package <hash> which is at least as new as version 1.2.3, but not a major release\".\n\nAn obvious approach to enable this is to create a message which represents a package, and then create new messages for each release, which include their version, links to their dependencies, the actual payload (e.g. as a link to a blob), and a link to the package of which they are a version:\n\n```\n{\n  \"type\": \"package\",\n  \"name\": \"someLib\"\n}\n\n{\n  \"type\": \"packageVersion\",\n  \"version\": \"1.0.0\",\n  \"package:\" \"%hash-of-the-above-package\",\n  \"dependencies\": [],\n  \"payload\": \"&hash-of-some-tar-archive\"\n}\n```\n\nThe package manager would only accept `packageVersion` messages which were signed with the same key as the corresponding `package` message. However, I could not find a way to enforce that there are no `packageVersion` messages for the same `package` with the same version. A malicious/mischievous user could simply post multiple `packageVersion` messages from different machines without synchronizing. The package manager can not prohibit same-version releases based on local information. But if this can not be enforced, a dependency declaration based on a version might resolve to different payloads on different machines. Do you think I'm missing something, or is enforcing this actually impossible in a decentralized system?\n\nAssuming this is indeed impossible, there are two options:\n\n- accept the risks while keeping the benefits of semver\n- specify all dependencies directly\n\nThere are some [inherent](https://www.kb.cert.org/CERT_WEB/services/vul-notes.nsf/6eacfaeab94596f5852569290066a50b/018dbb99def6980185257f820013f175/$FILE/npmwormdisclosure.pdf) [problems](https://www.youtube.com/watch?v=oyLBGkS5ICk) with semver anyways. Also, a `package` version in a non-semver package manager could include a link to the superseded `package`. The package manager could notify the user of newer available versions by checking the links to all dependencies. Basically a decentralized [greenkeeper](https://greenkeeper.io/) with scuttlebot doing all the work.\n\nAs potential users, would you be willing to give up semver ranges in dependency specifications?",
    "mentions": []
  },
  "signature": "+wjPv1oiiBeYAhiSMy7yGqkA+UsBhSClzAl4AZXTJIc6dUfV7Vv4dXUqOLmc25iUV2JeekCxMECd0AReT9m5Ag==.sig.ed25519"
}

{
  "previous": "%c5gQnKyNfQ98trih9Zi9BZTfpLKRWL+sLm03hyn0k7E=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 86,
  "timestamp": 1491592888474,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%WIH/TeP2Wc4VeDTsxIDBFNmQE46CAiXaoNYdbrnOYQs=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "tDhKuFt7IJp7gmgX6qSUFBiowXskzgmWWqHEELqK2AGGeWY3iJlGYf8AwNdP08mH3FVw2Lm56TlC901LH4fXDw==.sig.ed25519"
}

{
  "previous": "%rcGuOhpgX58s8NuKhADOm6XphJ3wsufk7RV3q2a43lM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 87,
  "timestamp": 1491592950282,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "licensing",
    "subscribed": true
  },
  "signature": "mIRRa3BuhWu+DJS0HEeFTw99QUuzz+ZenBA+euNZZGDrYhRNZHvwRR1Ty01SoHkmmITHk+vBO7KCjOc52Jd0Aw==.sig.ed25519"
}

{
  "previous": "%7ypxBdkpmxhA70dDfD2HlBEezwTHbZG3gy9OixRpwCM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 88,
  "timestamp": 1491593014741,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%5qzkkeywLQqMC+8lsmYzAOIy2cBzlQh3b5vhx1T1mz8=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "UdTATza6rUS+iUhcqgXRGQspU30LDMEcExm8siN2yK3Uwl7qN0n1y9P7djgqBf6RzGxkPB8KI9U7FWNCx4IVBA==.sig.ed25519"
}

{
  "previous": "%KEzaDMo+4QIMOz+S0gTh0TJ3mh0sRxI1JIX87oYbnf4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 89,
  "timestamp": 1491593991455,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%cJ1GJMhW1Npgj4FmdnrucUr4X/69lQ5iTjhUCyLHg4I=.sha256",
    "branch": "%lrkGBipm6r14DuXtY6KlKHsmvGSN2dvkJZTgfxGxYB4=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "Seems like I managed to dodge my calling there. Thanks. I'll open a pull request to add this to the [module docs](http://scuttlebot.io/apis/modules/ssb-client.html) if you don't mind.",
    "mentions": []
  },
  "signature": "YcZSeI6+c5vC65zWDmqwW/VjQpwS7P4EH8ExjEIBYUUvPvj3o0BM+e7JVEANwOhVYZCBmKEfGVnVmkIMXV+oBw==.sig.ed25519"
}

{
  "previous": "%/Lde/F29nk4FFzCgwwePNudX15TXT9JshxAEtWU4vKE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 90,
  "timestamp": 1491596755067,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "unix",
    "subscribed": true
  },
  "signature": "78k0cyGsVgvFUdb6iyTJOh5Fz6xfYMPu/f/wvRxWX61jIABa2iuiGAwWZ6P4XENuWfZESEHG7Zt0jOSvmVuhCA==.sig.ed25519"
}

{
  "previous": "%UQ/iM84d7m8ptoAyurTjqJen4nAoJpkdXPJlAahHZG8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 91,
  "timestamp": 1491597620717,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%90FCiefu7ieNkCbanCIR/Gz2l2bYqIUeOEAcAg9xiaI=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "FnCNiGOQosW3uIpbAZ3LcinhIaLWzRPRzTf8cEGB8b7YzqJ1tIkUFh+qtd0Mp7fJ/QybXQTYB6N3fRwnyzwiAQ==.sig.ed25519"
}

{
  "previous": "%ud9B3R5zK3FlUd5VnGakfJHJ83yG5vxG7h+8iKib9G4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 92,
  "timestamp": 1491598310228,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%c5gQnKyNfQ98trih9Zi9BZTfpLKRWL+sLm03hyn0k7E=.sha256",
    "branch": "%9F0IsdMKKlYp1PJf0YmNXDzzEwF1iC0BlsRgaCBVV8s=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "I agree that with heuristics one could build something that works reliable enough. Another example of a safety-measure would be a lockfile à la [yarn](https://yarnpkg.com/en/docs/yarn-lock#search), but recording the hash of all dependencies of the last install, not just their version.\n\nBut still I'm slightly uneasy with designing a system where even `packageHash version 1.0.0` could result in ambiguity. With unique addressing and cryptographic integrity verification at our disposal, non-deterministic dependency resolution just seems underwhelming to me.\n\nOf course, the package manager could support both hash-based dependency declarations and semver-based declarations. But just the possibility of any dependency introducing non-determinism by using a semver declaration defeats the purpose of hash-based addressing in the first place.",
    "mentions": []
  },
  "signature": "yu+eNd+foVxJ0VtcStQg7Y49mBbzYgn5bUZqd83JNzDsMkitofU1NNDErVSYuIbPajyISHrlTC7OHn3YmX5+Cw==.sig.ed25519"
}

{
  "previous": "%lM9ZRYuMNZ+ARBX/2d4IGEo64e7GtRGBTP2OrUiAOFU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 93,
  "timestamp": 1491598555499,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%MIG2pbAXTXRjWJujITXwLz2r97sscEXWBe0AS6Yc/lc=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "8NH5fa2oUPQyS7NpIXEnq15XEsy5d+8CE5wbI3fopwkXrG26xg168Sc8/dJVw+EwuKa92cdXsjVdJG1Gn8PyDA==.sig.ed25519"
}

{
  "previous": "%TY4QtSeB3sJp7/lg+2ZpLVcNbpoLptAq4r4/QAZ0p+g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 94,
  "timestamp": 1491600659721,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%c5gQnKyNfQ98trih9Zi9BZTfpLKRWL+sLm03hyn0k7E=.sha256",
    "branch": "%nWFUG3sVz46JmTnUlWRgczTGf6ignGKIamSTEHliz6Y=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "I just got [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)'s response with a delay of 25 minutes. Do I need to follow more pubs, or were you offline? This time-travelling eventual consistency thing sure is confusing.\n\nJust to be clear: I don't have any problems with a semver range allowing resolution to multiple specific versions. The problem is only about not being able enforce that each specific version is resolved to exactly one corresponding message in the global database.\n\n- - -\n\nUsing a link-structure instead of stringly-typed versions also allows attaching metadata:\n\n```\n{\n  \"type\": \"package-manager.release\",\n  \"previous\": {\n    \"hash\": \"%xyz\",\n    \"release\": \"minor\",\n    \"summary\": \"Add support for cabbages\",\n    \"changelog\" : \"%abc\" // the possibilities are enless...\n  },\n  \"dependencies\": [{\n      \"base\": \"&def\",\n      \"releases\": \"minor\"\n    }],\n  \"payload\": \"&ghi\"\n}\n```\nThe package manager could simply discard any metadata it does not care about, but other tools could use it.\n\nSemver ranges with an upper bound should also still be possible with this.\n\nSuch a setup is still not deterministic, but it does look very appealing...",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "7wXXO/ejv/vq/V5ATUDqwlV6ZUm8H5CZ60TBzxAhkdILcR2Rr3t3jKx9xBA/zpy2xvkgdrRO7rDp1VYrvYFxBA==.sig.ed25519"
}

{
  "previous": "%ECpOzaUpJaveCC/zNidfk5ezeg1RnbTkdClzB4XuqaE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 95,
  "timestamp": 1491602128812,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%QKaKTAc+Vo+tqDP02QQ+XFAKAPURVcQetsO6rzf7qzo=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "E8RMjM+znUtgPALfOKw1aqaO+VBwsm6c/6Tv1HFzAYAXNNnjsNjuuCi+OYWWlwqaaDCN8s4zDOwh7M84LzQYCA==.sig.ed25519"
}

{
  "previous": "%bgwcZXqxsXstIeU9HRff+w/R+qDMslO69YqHCWdpW+4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 96,
  "timestamp": 1491604098376,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%c5gQnKyNfQ98trih9Zi9BZTfpLKRWL+sLm03hyn0k7E=.sha256",
    "branch": "%ECpOzaUpJaveCC/zNidfk5ezeg1RnbTkdClzB4XuqaE=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "One last thought before getting some sleep: We could invert the role of the dependency specifications and the lockfile. The user still writes a dependency specification using semvers, and generates a lockfile by running the install command. But when publishing, the dependency data that is put into the message is actually taken from the lockfile, not form the user's specification.\n\nThis way, the user gets all the convenience, but the `package.release` messages specify dependencies through hashes and are thus fully deterministic. The only drawback is that updates to dependencies are only propagated by users running the install command. That does not sound too bad however:\n\n- having to confirm updates instead of blindly propagating them seems like a reasonable approach\n- if each package release message links to the superseded release, notifying the user on available updates is fairly trivial\n- if absolutely desired, regularly running the update command can be automated easily",
    "mentions": []
  },
  "signature": "k5qmZ2BjvbeJg+Hizc4Z4/Tj2K+f9NeyF4WKDukmgO+5Jiklhl9JhY5FgSmIViXRfwrNprygAK+VNXOpui6gCQ==.sig.ed25519"
}

{
  "previous": "%tBMcD9POmRXPju6wQKV0cKxWScD78792S/6F+GQf1fs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 97,
  "timestamp": 1491605067625,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%c5gQnKyNfQ98trih9Zi9BZTfpLKRWL+sLm03hyn0k7E=.sha256",
    "branch": "%tBMcD9POmRXPju6wQKV0cKxWScD78792S/6F+GQf1fs=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "> if you want to resolve a specific version string unambiguously, you could include a feed id in it, and then use the first message in the feed that set a value for that version. i might rather just use ssb refs though\n\nThe problematic scenario I thought about was this:\n\n- user `foo` creates a package `p`\n- user `foo` publishes `{pkg: p, version: 1.0.0, payload: \"&abc\"} from device `a`\n- user `foo` now publishes `{pkg: p, version: 1.0.0, payload: \"&def\"} from device `b`\n- user `bar` only synchs with device `a`, installing the package yields payload `&abc`\n- user `baz` only synchs with device `b`, installing the package yields payload `&def`\n\nSo there's a flaw in that logic because `baz` will not accept the synchronization, since each message needs to point to its predecessor, right? If so, I wish that more problems would go away by simply realizing they never existed in the first place =D\n\n- - -\n\nThe feed id would not even have to be included, it would be enough to only accept version messages from the same feed that posted the package message.",
    "mentions": []
  },
  "signature": "yUI6Ao6D2Ym6/cD5kRRasDMc592e2rZGMSMaKKF8oMV55mxsNewpLfopSVotKm8a72rCTLysCA+3JuzWmKrLCw==.sig.ed25519"
}

{
  "previous": "%vZW2lf6anYWgbIQRnYCBX3h3Et2ig5RpA6yb2KCHrN8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 98,
  "timestamp": 1491638257619,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "### (Semantic) Versioning\n\nContinuing from %8OlKw/3hdbYuaGbGPRTwPd6CVEKSVW1dOpQsGjbzpno=.sha256\n\n[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) I highly recommend to watch [Rhich Hickey's talk on dependencies](https://www.youtube.com/watch?v=oyLBGkS5ICk) if you haven't already. Hickey does suffer from Java's way of managing namespaces, so he gets a bit dramatic. But there's a lot of ideas in this talk you might identify with (and some you might not, else it would be boring...).\n\n> Basically I recommend we do a simpler version of semver where there's only major / minor. Major is for incompatible changes, minor is for compatible changes.\n\n> Only if its a \"major\"/incompatible change do we produce a new hash.\n\nSo there are three options:\n\n- major, minor and patch: minor and patch both (redundantly) indicate backwards compatibility, but nicely indicate to a human whether the changes are only internal or whether new functionality was added\n- major and minor: only indicate whether a new version is backwards compatible\n- minor only: A minor release is one that is backwards compatible. Anything else is not \"a new version of something old\", but \"a completely different thing that humans happen to associate with something old\". This corresponds to only using new hashes for major versions.\n\nI really like the last option, as it accurately reflects compatibility. But it might be hard to sell to people who are used to semver. And let's face it, not every user of a package manager has spent some time thinking about the nature of backwards-compatible releases and dependency chains/dags. So the second option could be a good compromise. Or maybe the user interface could make it look like the second option whereas the actual data structures reflect the third one. Although there are always problems when UI does not reflect the actual data, especially in a tool targeted at developers.",
    "mentions": [
      {
        "link": "%8OlKw/3hdbYuaGbGPRTwPd6CVEKSVW1dOpQsGjbzpno=.sha256"
      },
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "WPx7AZ26SiM+QN6bSTQUE1UtvWt+oAn1Cs9ybrUYaX2x50flSAfRRTasHmx0Q6siC1M3vTV3IvqCiiIcqaNoBA==.sig.ed25519"
}

{
  "previous": "%ZeGwOzv7dt37wdA1+5iLtyCnQqEps7J9jpyrO6jgJPM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 99,
  "timestamp": 1491638304673,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "Original thread: %c5gQnKyNfQ98trih9Zi9BZTfpLKRWL+sLm03hyn0k7E=.sha256",
    "mentions": [
      {
        "link": "%c5gQnKyNfQ98trih9Zi9BZTfpLKRWL+sLm03hyn0k7E=.sha256"
      }
    ]
  },
  "signature": "UzBXBYRaro1vFZuQj5W3sdATqej3SwrQiwOKamRFL19JsE5bBxKm1mrChNbF8aAa48Z8uycwROeXMk7y9xIsBw==.sig.ed25519"
}

{
  "previous": "%hBD0F4mIZWNYnSYsS0+TbfNc0fh9eaLoTsw0eK+D9rE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 100,
  "timestamp": 1491638359168,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%c5gQnKyNfQ98trih9Zi9BZTfpLKRWL+sLm03hyn0k7E=.sha256",
    "branch": "%I7MYGeZj7yal/7dzmssstQkCKYZUQbEBhaMJRlOoroA=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "Mind if we move these discussions to their own channel to keep things organized? I'll post some replies at #ssbpm",
    "mentions": []
  },
  "signature": "NjtH8q9WpD5IKRBtXiV34kiRnFWbrVch/jyc15QncZm2cllIcQbVgu+IfAjNx+O5qBkfsoo6ESHwRXfysfy9Aw==.sig.ed25519"
}

{
  "previous": "%1vN2jkIWk7qXsZpin06AfDaB9jqmiSGZLqZPqQnyGeM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 101,
  "timestamp": 1491638656917,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%8OlKw/3hdbYuaGbGPRTwPd6CVEKSVW1dOpQsGjbzpno=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "BxwEvISTuR3zEjUefX5N/zEwcaCpmepqiyaR5CEJ9tl3/Ba4Q9H70CzGuVjsGGEYIBplvTOBkXMh87GsdysEDA==.sig.ed25519"
}

{
  "previous": "%13wCjP2bM05dTeeT3foFLjugJ6geWOk+s8SuUfhCRto=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 102,
  "timestamp": 1491640415452,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ssbpm",
    "subscribed": true
  },
  "signature": "i4n/8AVBcJE2NA/RjLtHTApCleNhVDFC+1uUH/Kjm54/hQCljENo0oRa4vZ2iRw7T4W9rSdnMhwcOO4gul44BA==.sig.ed25519"
}

{
  "previous": "%8njeIHke4GokGXr5CBw1EaAF8c03CXFFlN+sTbX8dMg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 103,
  "timestamp": 1491640625923,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "### Dependency Resolution\n\nA little summary on rependency resolution, followed by the open questions.\n\nThe simplest possible package manager has no notion of versioning, all messages refer to their dependencies by hash:\n\n```js\n{\n  \"type\": \"simplePackage\",\n  \"payload\": \"&blobhash\",\n  \"dependencies\": [\"%someSimplePackageHash\", \"%anotherSimplePackageHash\"]\n}\n```\n\nWhen a package gets updated, the new version might still be backwards-compatible with the old version. a package manager can provide a mechanism to specify dependencies as \"anything that is compatible with this thing\". This reduces conflicts between packages, and improvements/fixes are automatically used by other packages.\n\nAn example of some messages that could represent this:\n\n```js\n{\n  \"type\": \"package\",\n  \"name\": \"pull-stream\" // only useful for humans, not used by the package manager (except for UI)\n}\n\n{\n  // pull-stream 1.0\n  \"type\": \"version\",\n  \"package\": \"%hashOfPullStream\",\n  \"payload\": \"&blobHash1\",\n  \"dependencies\": []\n}\n\n{\n  // pull-stream 1.1\n  \"type\": \"version\",\n  \"package\": \"%hashOfPullStream\",\n  \"supersedes\": \"%hashOfPullStream1.0\"\n  \"payload\": \"&blobHash2\",\n  \"dependencies\": []\n}\n\n{\n  \"type\": \"package\",\n  \"name\": \"my-lib\"\n}\n\n{\n  // my-lib 1.0\n  \"type\": \"version\",\n  \"package\": \"%hashOfMyLib\",\n  \"payload\": \"&blobHash3\",\n  \"dependencies\": [{\n    \"minimumVersion\": \"%hashOfPullStream1.0\",\n    \"exactMatch\": false\n  }]\n}\n```\n\nWhen installing `my-lib 1.0` and the package manager knows about both `pull-stream 1.0` and `pull-stream 1.1`, it will use the newer version.\n\nThe UI could either expose this directly, or hide it under a layer of semver (or semver without patches).\n\n- - -\n\nA problem with this: Versions can form a DAG:\n\n```js\n// both messages are pull-stream 1.0\n{\"type\": \"version\", \"package\": \"%hashOfPullStream\", \"payload\": \"&abc\"}\n{\"type\": \"version\", \"package\": \"%hashOfPullStream\", \"payload\": \"&def\"}\n\n// both messages are pull-stream 1.1 (\"%aaa\" is hash of one of the above messages)\n{\"type\": \"version\", \"package\": \"%hashOfPullStream\", \"supersedes\": \"%aaa\", \"payload\": \"&ghi\"}\n{\"type\": \"version\", \"package\": \"%hashOfPullStream\", \"supersedes\": \"%aaa\", \"payload\": \"&jkl\"}\n```\n\nIn different clusters of the network, the same dependency declaration might result in different payloads. Not good.\n\nSolutions:\n- Abandon indirect addressing via versioning, only use the `simplePackage` messages from above.\n  - very explicit, direct control\n  - but loses benefit of automatically receiving (hopefully) improved versions\n- Only accept `version` messages by the feed that published the corresponding `package` message.\n  - can enforce to only use the oldest published `version` when multiple of them are in conflict.\n  - also solves the problem of who may publish new versions\n  - currently my preferred solution\n- embrace subjectivity?\n  - simply allow these conflicts\n  - might make for an interesting experiment, but might also end up more or less useless\n  - could use heuristics and lockfiles to become somewhat reliable (see %9F0IsdMKKlYp1PJf0YmNXDzzEwF1iC0BlsRgaCBVV8s=.sha256)\n- other options I missed?",
    "mentions": [
      {
        "link": "%9F0IsdMKKlYp1PJf0YmNXDzzEwF1iC0BlsRgaCBVV8s=.sha256"
      }
    ]
  },
  "signature": "zffEo3jkBI7TVgSce8MxLfQnBwmL/mv9nD2saPFFfzV48D0zTN8r/72l57uf5LyPqfcOmoca3KG0YLM5nZv8Bg==.sig.ed25519"
}

{
  "previous": "%YvyE9ApNqpzf+e5xXLg+Oa67C17tWWiVNOdsUH5YMyU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 104,
  "timestamp": 1491641901434,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "### Scope of a Package Manager\nOr: Keeping it simple. Or: A tiny rant. Or: Everyone except me gets everything wrong. Obviously.\n\nA package manager has two fundamental operations: publish and install. Publish makes some files available to all users of the package manager. Install retrieves some files, a process that may or may not involve transitive dependency resolution.\n\nA package manager is unopiniated regarding the files it manages. It does not care whether it's an npm module, the linux kernel source, or photos by the hubble telescope. Files are files.\n\nCorollary of the above: A package manager is not a build system. Build systems are build systems.\n\nNpm is an opiniated package manager with a rudamentary build system. This makes npm convenient, not better. The same convenience can be achieved by scripts. For example, nodejs programmers could use a script that installs packages via ssbpm and then runs npm's build scripts. The convenient shell scripts can be published on ssbpm, for convenient access. A simple package manager does not preclude convenient usage.",
    "mentions": []
  },
  "signature": "Njqet7AZeMfL1Xe5eij9f5pUzs+h/Wv3eCHuIe4UySflrS9RKG0GShMUzpS4XydXU44wUAbsmVbnXp5uFfymCQ==.sig.ed25519"
}

{
  "previous": "%MUOcezmXX8n+zz3z7NEjAbXmZfOHldaTJP1IyC+PHOY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 105,
  "timestamp": 1491643585680,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "### Scuttlebot is Awesome\n\nThings a package manager built on scuttlebot gets for free:\n\n- no single point of failure\n- works offline\n- only installs from the network if not cached locally\n- integrity verification of all files\n- bidirectional dependency information, retrieving all packages depending on a package is a one-liner\n- version updates can be intuitively expressed as links to the superseded version, dependency resolution can follow the link in the other direction\n\nThe ipfs would provide the the first four points as well, while being arguably more efficient and not sharing the drawbacks listed below. But it lacks bidirectional links, which seem to be crucial to indirect addressing by versions. Solutions to that would probably involve the ipns. Ipns names however are not durable, so the same dependency metadata might resolve to different payloads at different times when relying on ipns. So scuttlebot it is for now.\n\n- - -\n\nThere are some drawbacks though. None of them unsolvable, but keeping track of them seems like a good idea.\n\n- developers store a lot of packages they don't actually need\n- people who only want a twitter-clone end up hosting packages\n- package availability depends on the user's social network. Installs might fail because you don't have enough \"friends\"...\n  - related to %75TLIcLvePsXjgy+ZFrkmVg/0RIwQSJqCl8Cc6Q6Uso=.sha256",
    "mentions": [
      {
        "link": "%75TLIcLvePsXjgy+ZFrkmVg/0RIwQSJqCl8Cc6Q6Uso=.sha256"
      }
    ]
  },
  "signature": "0AkYdkN19et3zkFcGAzmefmu6xx8XPpEtRzANw35Ml39qteNDLZh7T+KNu8sblTE8lwqoDJkiPwxqUfDKxy/BA==.sig.ed25519"
}

{
  "previous": "%lihyEM/pb+/kNuuCvqeTAaIiNajMpY53lf2JY3K3ows=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 106,
  "timestamp": 1491643744812,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@PNRgWW7JSRryPFhhWiRPQ8edpRytABQtzrv9yF5EHRM=.ed25519",
    "following": true
  },
  "signature": "+vWq2ZKPgwy2Ue6vy/ABNYB5/q4YP9ZCoM5X3s4Iki8LDL/Na42KRYsO1oI6V5DsERZIiY7u+vri8Q0he3JUBQ==.sig.ed25519"
}

{
  "previous": "%AmBt3QAJ8wDfenQIpjAtT4W5Va/TiF6rFH8zhwaO8IQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 107,
  "timestamp": 1491652550955,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZeGwOzv7dt37wdA1+5iLtyCnQqEps7J9jpyrO6jgJPM=.sha256",
    "branch": "%JoB7L1F93zxZDrdMCFRe6t7cS/q+791wSwWY/R57cDM=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "It's worth noting that in statically typed languages, you can strictly define `major.minor.patch` in terms of the type system. `Major` whenever a type signature is made more strict, `minor` when type signatures are added, `patch` if all public signatures remain unchanged. The Elm package manager enforces this programmatically. Note that this still does not prevent changes in functionality.\n\nA package manager probably only needs to care about the binary decision \"is it compatible or not\", and needs no reason for why it is compatible. Providing such a reason is exactly what minor vs patch is about. And in practice, patch changes often get lumped together with feature additions into a single minor release anyways.",
    "mentions": []
  },
  "signature": "8S6h1Sk0MNy81ATLOvTC4PEiwOzZUuKCGAXpZx0+PLPOQlZWvrlH7Pa1jWGQE6AODJNmYmzKrKJDC340BqjPAQ==.sig.ed25519"
}

{
  "previous": "%kUlP25hgRdxlmii6UDTyN/4RNj9zYVa2plyCH9Yjku4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 108,
  "timestamp": 1491652688335,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%QwXkzIXQeWXhT8Zo5L53ycErYBmA8G3Lj/kIR1e+qJg=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "mzlpLvRciR3cSXnCueANxmFhT2111I82qij4ZG+s5s9x/QchYzy/05dCV9D07fuefEURyuKkqCDgBD3+FjpBCw==.sig.ed25519"
}

{
  "previous": "%VZvs7pi/WbdKGiPxSXlU2cxLxbPbM9kDi02K//Q1ozs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 109,
  "timestamp": 1491657201537,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "Is `ssbpm` a good name? It's certainly annoying to type. What about simply `spm`? Or `dpm` (decentralized package manager? Maybe `spam` (**s**cuttlebot **pa**ckage **m**anager)... Let the bikeshedding begin.",
    "mentions": []
  },
  "signature": "19EoveEbK1pDUM983kTIV4I9UgDuES86jrQ6xLuptURnb+dPu0YU1VRBTrUQ0+Bl4NXdcAmV+UlAQUAY4z0OCg==.sig.ed25519"
}

{
  "previous": "%DCLtB1bC73I3HGXNshrGpfUrzQ4n7Q0+BmtlZUcBf/k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 110,
  "timestamp": 1491659188940,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "Description of a minimal ssbpm implementation. Am I missing anything obvious? I'll start implementing this now, so please point out any errors or oversights.\n\n- `ssbpm publish`: publish the current directory as a package\n- `ssbpm install`: install all dependencies of the current directory\n- `ssbpm install hash`: install the package of the given hash in the current directory\n\n- installs are put into the directory `./.ssbpm`\n- all package information is stored in `ssbpm.json`:\n  - hash of a previous release that is superseded by this one (optional, if missing it is assumed to be a major release)\n  - dependencies of the module\n    - hash of the depended-upon release\n    - whether to lock to this specific release or to install the newest compatible release of the same package\n  - ignores: array of globs that will not be published (defaults to `.ssbpm`)\n\nThree example `ssbpm.json` files:\n```js\n{}\n\n// same as:\n{\n  // no \"previous\" field, so this is  major release\n  \"dependencies\": [],\n  \"ignore\": [\".ssbpm\"]\n}\n\n// a minor release with dependencies and the default ignores\n{\n  \"previous\": \"%abc\",\n  \"dependencies\": [\n    \"%uvw\", // the newest release compatible with \"%uvw\"\n    \"=%xyz\" // `=` fixes the dependency to exactly the hash \"%xyz\"\n  ]\n}\n```\n\n`ssbpm publish` creates a tar archive of the current directory (minus the ignored globs), gzips the archive and publishes the result as a blob. It then publishes a message like this:\n\n```json\n{\n  \"type\": \"ssbpm.release\",\n  \"payload\": \"&hashOfTheArchive\",\n  \"previous\": \"%abc\",\n  \"dependencies\": [\n    {\n      \"link\": \"%uvw\",\n      \"fixed\": false\n    },\n    {\n      \"link\": \"%xyz\",\n      \"fixed\": true\n    }\n  ]\n}\n```\n\n`ssbpm install someHash [--fixed]` looks up the hash and verifies that the message is of type `ssbpm.release`. If `fixed` was specified, it simply starts downloading the payload and recursively invokes `ssbpm install dependencyHash [--fixed]` for each dependency. If `fixed` is not specified, the program does not start downloads immediately. Instead it transitively looks for `previous` links to the message that were published by the same feed. Only when there is no `previous` link to the message does it start downloading and recursing.\n\n`ssbpm install` does the same thing but only for all dependencies in the current directory's `ssbpm.json` file (i.e. analogous to `npm install`).\n\n- - -\n\nWith such a minimal implementation, we can get a feel for what is needed, a more usable ssbpm.json file, and so on. Some features that might be added on top of this:\n\n- allow a `data` object in ssbpm.json, whose entries are merged into the `ssbpm.release` message, for use by other tooling\n  - examples of entries that might be useful:\n    - authors\n    - repository\n    - license\n    - name\n    - description\n    - tags\n- `previous` in ssbpm.json could allow arbitrary additional data\n  - examples of entries that might be useful:\n    - short summary of changes\n    - link to a changelog\n- a way to specify a name with a dependency declaration. That name would be helpful for humans to keep track of things, and could be used in the UI as well\n- a [lockfile](https://yarnpkg.com/en/docs/yarn-lock#search) for deterministic package resolution in development\n- additional command line options:\n  - `--ignore [blob...]` specify ignore globs via the command line\n  - `--verbose`\n  - `--dry` (only print hashes but don't download blobs)\n  - `--out <dir>` where to place downloads, useful to e.g. put everything in a directory named `node_modules`\n  - `--host <hostname>` the host to connect to sbot\n  - `--port <port>` the port to connect to sbot\n- a way to specify default command line arguments in the ssbpm.json file\n- a way to specify payloads other than `.tar.gz`\n\nSome other features that might actually not be good ideas:\n\n- version-number sugar\n- resolve dependencies from the filesystem, git, ipfs, etc.\n- some notion of dev-dependencies\n- helper commands to modify the `ssbpm.json` file, for example\n  - `ssbpm init`\n  - `ssbpm add [hash]`\n  - `ssbpm remove [hash]`\n- breaking change: use a non-json format for the metadata file. Comments would be nice... Could simply allow comments in the json, than the change wouldn't even be breaking",
    "mentions": []
  },
  "signature": "RDOTJh8QMzcFDpF3Cb5Uxf1ZzbMPO3QNF65CZmOKXMV3uIcjqk1xoHKm6S0pLwt8caNj3PjxLptOwCmA1LxHAA==.sig.ed25519"
}

{
  "previous": "%CaTUvSVOxlGYm8JlzRc7XmMdLM5NUXSbEhzySkNpc8U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 111,
  "timestamp": 1491662775433,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%nqMyQBDgyZXTTkbdnkRGgJPpqwmQn67kS2w+9lkfFnE=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "hWV4Wl67EO8xJe5uMTiKSGeHZUD6kn1Q1C3Oyr9iF8iVGOAnGFgWD5uwQjQgqYPt0J6/fGLAQsIk69sK8y/nBA==.sig.ed25519"
}

{
  "previous": "%xfx3a491tSFMoAsr90/J2FeT1+X4v4CaGpNNv/orDek=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 112,
  "timestamp": 1491673107934,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%7/4TK5bih4cpFTb0TkPHshU82jUM2dLCElITLYS8Zc8=.sha256",
    "branch": "%7/4TK5bih4cpFTb0TkPHshU82jUM2dLCElITLYS8Zc8=.sha256",
    "channel": "n00bquestions",
    "recps": null,
    "text": "It's the giant hungry cabbage, swallowing a small person wearing long gumboots. But the logo could use some work, you are one of the very few people who correctly recognized it. Most people see it as a hermit crab, so that has become the canonical interpretation.",
    "mentions": []
  },
  "signature": "ZvuuAsXbYxxj0GIXvFdyJUdi/bjGGiXhj+HET4+PQiJoPkjnLa1pKQyLKGX4w6y1+WHFeuYM/in9DKgXCASZCw==.sig.ed25519"
}

{
  "previous": "%y4dCxCLe23tPFHnZXYO15usFYlVWeg6+E/j9P39hgus=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 113,
  "timestamp": 1491673208804,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%7/4TK5bih4cpFTb0TkPHshU82jUM2dLCElITLYS8Zc8=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "U3QSeLEvoLY72teI2sHAG3R2nI5A8ka7TVlHvBaUA47+rnq/faSUBnLXjxupnoWq9Ub1JN66cYjZLooQles8Cg==.sig.ed25519"
}

{
  "previous": "%togC4m7hU+sI2+vcZA8QvLporWqLKioirKx5ccGY/6k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 114,
  "timestamp": 1491685561046,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%7/4TK5bih4cpFTb0TkPHshU82jUM2dLCElITLYS8Zc8=.sha256",
    "branch": "%HT8nOH8q1BxU7J6WeB1EjQORUE8uCFnEFGhMfCCSb68=.sha256",
    "channel": "n00bquestions",
    "recps": null,
    "text": ":heart:",
    "mentions": []
  },
  "signature": "T7Q5TULiIRJF9RwzCwkdeLqWXEBhPsCwXspOTFe5q9w4lOpAD3ZAdXgIq6mkI7NRPg+xBeLdA27KmXT/XUZgBw==.sig.ed25519"
}

{
  "previous": "%RX7Gz+vSoNGDr6R5sCdeQrYp4yshF9UIBnBQqZEU0pc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 115,
  "timestamp": 1491685814092,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@UhORGzAhEE3gqy/pH5vK+EgbpZfnyYvdI46TVBJH6Mw=.ed25519",
    "following": true
  },
  "signature": "TRppGcbmrXgY6g8d4mEbcnyTLSqjGm3I0Tzv7QO8uBDZyf+Qdw28Rzn4Ix4Gbi0v6Qy9IAefk+imrhAdfD0rBg==.sig.ed25519"
}

{
  "previous": "%7FmXck2zJkGVOw3kDGqYOLJbOVyNjSG31dfVpWxD9rA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 116,
  "timestamp": 1491688235504,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lihyEM/pb+/kNuuCvqeTAaIiNajMpY53lf2JY3K3ows=.sha256",
    "branch": "%lihyEM/pb+/kNuuCvqeTAaIiNajMpY53lf2JY3K3ows=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "Another benefits of building on scuttlebot: Releases are identified by hashes, which are not very human friendly. But we can simply reuse [about](http://scuttlebot.io/docs/message-types/about.html) messages to provide names. Also [votes](http://scuttlebot.io/docs/message-types/vote.html) could be used to implement an explicit feedback mechanism.",
    "mentions": []
  },
  "signature": "JUzE291KngFICQDB18se1CFbeSwLKzXPPVZtEjZZhAGYy4tTD4PnpYiDvwZ47eOcWFbQKPLnxiwKfl7gc8XIAQ==.sig.ed25519"
}

{
  "previous": "%sBXTG/GWUA1YDUYmhpJn9PGl5GL2YsvEEHJTOD4cvy8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 117,
  "timestamp": 1491688785838,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "ssbpm"
  },
  "signature": "y4BZcLaFWs0y4dqoPk/x0cBn+2ZSIIAlJnasSKahCKafhviDbHTYA2h6oqGLefhGbpuHKZYHWbyRLVGua5lwCA==.sig.ed25519"
}

{
  "previous": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 118,
  "timestamp": 1491689164950,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
    "refsBranch": [
      "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256"
    ],
    "packs": [
      {
        "link": "&5BPaJ79kbiZnCWBzE6kIE8KWTheK9drsAETMmuaYtQc=.sha256",
        "size": 31856
      }
    ],
    "indexes": [
      {
        "link": "&v53J4J1UgJXn484T+DeOLuq7cWJDb7PwLqHjmL1qpbk=.sha256",
        "size": 1464
      }
    ],
    "refs": {
      "refs/heads/master": "c714ce884183388f266f31b8d9404aca3e0bfd45"
    },
    "commits": [
      {
        "parents": [],
        "title": "Initial commit",
        "body": "Application skeleton wich parses arguments, connects to a scuttlebot\nserver, and then delegates to unimplemented command handlers.\n",
        "sha1": "c714ce884183388f266f31b8d9404aca3e0bfd45"
      }
    ],
    "num_objects": 14,
    "object_ids": [
      "5a73f1c5e3b68992f2be8c886f23a1d4fea1f1db",
      "3c3629e647f5ddf82548912e337bea9826b434af",
      "3b101591a6075753c899f6ad3222643d26ba449a",
      "da82f2e4cf94dcacc0b77b30da4de4f2254f2a35",
      "ee07b937e0c4c563137e89bb475bc8e0aa151263",
      "2a4fc9746fd012037b1f3a30001e517faa4e865d",
      "3c91e5f44ff88c225be30b2408c0c0e2de694dca",
      "969d9d17d3bb16fbedc3cf49f266263b640aab71",
      "23aab938e67b40785e570a18b844825e99fbc180",
      "68d72c36e0df0becf744d37f658f12ea3c48c8ff",
      "d58903b02592a97f6c5115d9ea7c853ebb9ca248",
      "8bb8e28a1b168883ce8581496785488401e16be9",
      "283eddb15308c390eba65651a11bf84e30e48d64"
    ]
  },
  "signature": "8Gc9DgBMOWuR973uz1kQOve+gJok31VXxqwes9kuzHytUn4X4fb8swKjzu7ITm026l0WsZSClpGmNcXtBB7dAg==.sig.ed25519"
}

{
  "previous": "%j9oC7erhTZV9kFP0oO5WDktIxTxgbeoa+Qt+aoplEKQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 119,
  "timestamp": 1491689943737,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%CaTUvSVOxlGYm8JlzRc7XmMdLM5NUXSbEhzySkNpc8U=.sha256",
    "branch": "%q3NkmgyDPt9AvfhrYwJ3toNvZmt5/jzrD2YKOy06w5U=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "Yes, but I don't want to simply emulate the interface of an existing package manager. Rather I'd like to embrace the structure of the underlying database (scuttlebot) and see how a package manager can benefit from it. Also I disagree with some design decisions inherent to npm (and language-specific package managers in general):  %MUOcezmXX8n+zz3z7NEjAbXmZfOHldaTJP1IyC+PHOY=.sha256",
    "mentions": [
      {
        "link": "%MUOcezmXX8n+zz3z7NEjAbXmZfOHldaTJP1IyC+PHOY=.sha256"
      }
    ]
  },
  "signature": "KeXf6OhiW/EGGPZnYaeIaUuvj7LqZ8QRsyUS0x0CzqPf+OIgGD1qtqz+EYtM7x+GxZNVtvVQWc3HPLmKqHAmCg==.sig.ed25519"
}

{
  "previous": "%qmqPyRbwSvIDKpbglEjFokzQxF3xCHQBnuIQdX/XC14=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 120,
  "timestamp": 1491690430367,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%j9oC7erhTZV9kFP0oO5WDktIxTxgbeoa+Qt+aoplEKQ=.sha256"
    ],
    "packs": [
      {
        "link": "&9d+FnrYLXdMcA3dqBzlYpUR8JipWeZfXwtLJMwuP3Oo=.sha256",
        "size": 3369
      }
    ],
    "indexes": [
      {
        "link": "&rwpk8zHEnmDYBjaWK2+22SMYk36HUF2uymBfwg3g9+0=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "6f95abfa06c268ec43dd3e1fdce87afe3ad09bd9"
    },
    "commits": [
      {
        "parents": [
          "c714ce884183388f266f31b8d9404aca3e0bfd45"
        ],
        "title": "Add --ignore option",
        "sha1": "6f95abfa06c268ec43dd3e1fdce87afe3ad09bd9"
      }
    ],
    "num_objects": 6,
    "object_ids": [
      "f0333fd7db0a50efcafd29d0143346d999008fc6",
      "9687a1ac99d044425923fe079c14bcea4c12a67e",
      "3c3df416385bdbc625936223b749bbf72e5d8762",
      "125c692b1aa2a0c1753addd3f8373333ac7f3838",
      "4de2f9747a13d80afb61c4fc7507f7c6b502c7d8"
    ]
  },
  "signature": "Y7BO5vlmpa65OyivW27I3ALJQElnsXCeiPI6mQL7LB1Pq6Fc94QFC5edvNBnXoGx9ZSNZ31GOsVGlA3VxgbADQ==.sig.ed25519"
}

{
  "previous": "%FTirchax92fOofL5QCaT0Qw15GDpj3P0TGlmP4fP28c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 121,
  "timestamp": 1491722905299,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%cx4sDkZEor3BJWlF6GfwXCStXSul3fPbxlLG+MDv2yQ=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "TnzKXdCTXV+tPyH+lsEtfBh0zdM3bwHnmLJqNmguaDTn14z0g5ZNmMsh20BAXumhH+pJam1c93TqC6CaNcaODQ==.sig.ed25519"
}

{
  "previous": "%rJeJsTfS8WXQWONWfTq0e06zpOB10JUDw4g4t61GEtQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 122,
  "timestamp": 1491723825049,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%DCLtB1bC73I3HGXNshrGpfUrzQ4n7Q0+BmtlZUcBf/k=.sha256",
    "branch": "%mku3EcOR8WyOQcgqNPZcTwma/2ZTGu12Tg1dR/VF23s=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "> see also https://github.com/clehner/ssbpm - an abandoned attempt from a while ago - dunno if there is anything worth salvaging from it\n\nI like how we both use a lot of the same terminology, command names etc. And yes, reading through the code was helpful. I might steal the idea of a `defaultignore` file, and I'll definitely refer to the tests once I reach that point.",
    "mentions": []
  },
  "signature": "KOrHBF5INEGYkwbkLZ3LEkLzmerg5OdeMT7Cz9R+I39K+V8WHV04z3WaT2gZaAR/j8FjNySFV8UXE8xA1kmXAw==.sig.ed25519"
}

{
  "previous": "%Auqz0YOtf+Oo6cuoCyCsDlKVZulyx9UrGx9/Pl1y2BQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 123,
  "timestamp": 1491724004400,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%DCLtB1bC73I3HGXNshrGpfUrzQ4n7Q0+BmtlZUcBf/k=.sha256",
    "branch": "%gNAfFv/VvWYq0y8yebfc6egD5q1WA5Kyf+zdWFtxovc=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) I like `dpm` as well, but it feels somewhat audacious to claim that name. Especially since in theory, it would be possible to build a more general package manager which delegates to any supported decentralized backend. What I'm trying to do here does not have that ambition, so I'd like to keep a reference to scuttlebot in the name, even if only `spm`. ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "gCFZ3jr1rpNoytA7JRMuC6dFYBkqBZbzBsuPTymIyVyXY15l0/1t9/H72mR6mkwMu8YUXxFkhVeF3b/24DwkAQ==.sig.ed25519"
}

{
  "previous": "%QDlKyukAQefwE89BK53gRqT6NelgxUviXSjjzSTZ7io=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 124,
  "timestamp": 1491724032821,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%tXCiAsBC8ITGIgAGRlBl8/nbAK/Ae5hiTDJzXA2YDbY=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "IJQLHv+5uZAeriYfRHpKxdLDEqjgAE0pruvOecoJbvvlzDkbt0sHAszsBzoTviZZA+dRVuWn/RZ8Ts4yNf4NDg==.sig.ed25519"
}

{
  "previous": "%t9B449fBl1TdUR3hIn6ar9NjWuCM8ySe8ivD3pUhHeo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 125,
  "timestamp": 1491726930844,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%CaTUvSVOxlGYm8JlzRc7XmMdLM5NUXSbEhzySkNpc8U=.sha256",
    "branch": "%tXCiAsBC8ITGIgAGRlBl8/nbAK/Ae5hiTDJzXA2YDbY=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "gx looks interesting. Some interesting parts of its readme:\n\n> The language-agnostic, universal package manager\n\nLanguage-agnostic, yay! \"**The** [...] package manager\": Very ambitious for a decentralized general-purpose tool to be *the* tool for the job...\n\n> Be language/ecosystem agnostic by providing [git-like hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) for adding [new ecosystems](https://github.com/whyrusleeping/gx-go).\n\nThat is a very good way of providing convenience without forcing the tool into commiting to a single ecosystem. Will absolutely steal that idea.\n\n> Imagine having a helper function in one package, simply because its convenient to have it there, that depends on a bunch of other imports from elsewhere in the tree. Sure its nice, and doesn't actually increase the 'total' number of packages you depend on. But now you've created an extra batch of work for you to do any time any of these are updated, [...]\n\nIt apparently does not allow version ranges. So this channel unfortunately still has a reason to exist.\n\n> Gx by default will not let you publish a package twice if you haven't updated\nits version. To get around this, you can pass the `-f` flag. Though this is not\nrecommended, its still perfectly possible to do.\n\nThis is something I very much disagree with, package-name and version number should uniquely identify something. If ssbpm chooses the version-less architecture (with compatible releases being represented as links), the corresponding scenario would be to publish multiple releases which supersede the same release. I think when installing, the package manager should always use the first one and discard all others. When publishing, it can also check whether the superseded release has already been superseded, and if so, fail to publish. This is not strictly necessary, but signaling such a mistake seems like a good idea.\n\n> You can use a `.gxignore` file to make gx ignore certain files during a publish.\nThis has the same behaviour as a `.gitignore`.\n\nI was wondering about this: Why does every package manager have metadata file (e.g. `package.json`), but still stores ignores in an additional file? Anyone here have a good reason?\n\n> Gx also respects a `.gitignore` file if present, and will not publish any file\nexcluded by it.\n\nThat violates the concept of being language/ecosystem/tooling agnostic. Also it's very, very convenient. I'm somewhat torn on this, but I'm currently leaning towards simplicity (i.e. no special treatment for .gitignore).\n\n> gx supports named packages via user configured repositories. A repository is simply an ipfs object whose links name package hashes. You can add a repository as either an ipns or ipfs path.\n\nThis we can do by using `about` messages. And we can do it more elegantly. The publisher of a release can set its name, so there is no need to give local names per user. But if conflicts arise or someone dislikes a name, they can just use their own about message. Note that names, versions, authors etc. would only be used for a convenient UI, but always be resolved to hashes in the background. All application logic should only depend on message hashes.\n\n> Gx by default will install packages 'globally' in the global install location for your given project type. Global gx packages are shared across all packages that depend on them\n\nThat seems reasonable, although it's not what npm users are used to. In some sense, the scuttlebot database already serves as the global installation location though. Will need to ponder this a bit. Side-note: Couldn't npm install everything globally and populate the local `node_modules` directory with symlinks to the global installation directory?\n\n> Why is it called gx? No reason. \"gx\" stands for nothing.\n\nThat's a naming possibility I didn't even consider. A whole new world of opportunities opens up. Let's spend the next few days discussing naming.\n\nSample dependency entry from a gx `package.json` file:\n\n```json\n{\n  \"author\": \"whyrusleeping\",\n  \"hash\": \"QmWUswjn261LSyVxWAEpMVtPdy8zmKBJJfBpG3Qdpa8ZsE\",\n  \"name\": \"go-libp2p-peer\",\n  \"version\": \"2.1.3\"\n}\n```\nBy using `about` messages from the local scuttlebot database, ssbpm could reduce this to only the hash. The hash is the only piece of information that is really needed (as well as a flag whether the dependency is fixed or open). Having to store anything else in the metadata file only opens up problem. So one more advantage of rolling our own, scuttlebot-based solution.",
    "mentions": []
  },
  "signature": "V0syCSM7RUbuDk+Of0d8olUg19r23uBb7md/QRD3YRLrj0ZkHvoSVjr0ZwgRu/Y+mV0+gtBQ1We0QFjn9NYNBA==.sig.ed25519"
}

{
  "previous": "%CldbyOglBe1bRe3GJ77Ptu2V9ZrZL17+fPG6PwdTDqQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 126,
  "timestamp": 1491727325318,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lihyEM/pb+/kNuuCvqeTAaIiNajMpY53lf2JY3K3ows=.sha256",
    "branch": "%c5q9go0NxVp6VMv6GeL4ooaqNvoZF2SNH8moLqbUvIw=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "Another drawback compared to the ipfs: Ipfs automatically provides global deduplication of files. To get to a working version of ssbpm quickly I wanted to simply upload payloads as tarballs, but that provides no deduplication at all. But even if ssbpm switches to  more file-system-ish approach of payloads as messages which link to individually blobbed files, deduplication can not happen across users, right?\n\nMore generally: Is there a way to store content (most usefully blobs) so that their hash only depends on their content, not their publisher? That is the property that enables full deduplication in the ipfs.",
    "mentions": []
  },
  "signature": "/FVj8IZexLjEUyM6r2XMr6EnRVI+5YI5tVkq13DuujrV/SMggPE+eA4GGr4WKZA7mXb7SEj818tN9u2mi/G0Bg==.sig.ed25519"
}

{
  "previous": "%j6bQNhfw7lQaNr7354r0xZ2/SRh+cCqtlmNjR7lsiU4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 127,
  "timestamp": 1491727396882,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "lifewithoutnpm",
    "subscribed": true
  },
  "signature": "EP80C5bYBhHrkVR60jkbCqaUC0JIuLHdmV3q3/FWStIaqU1cprr77bxrpn8VmXApyctaVUDh0LmoH18FcUQ8BA==.sig.ed25519"
}

{
  "previous": "%QSJpr2ZRIyxo/KrNQlhdQm1rkJFQiOBchQklapoLSbM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 128,
  "timestamp": 1491728280691,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%DNc/ZF8d+ICL9YU4iJ4bTyFEjyDRbEixuS69dg+7Kmw=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "XuEGyMs5WScRg2cHGkN1XDDU3xemON3W7GCX9ANpvV6v5cAaXew/4W7t1WwuCbe06pnIWngomcv9Ud2KcpPTCw==.sig.ed25519"
}

{
  "previous": "%6aczbNy0gjWeT5WWOwC2FI0NcVRjY9EvB64C+brc7QY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 129,
  "timestamp": 1491728955559,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%YvyE9ApNqpzf+e5xXLg+Oa67C17tWWiVNOdsUH5YMyU=.sha256",
    "branch": "%YvyE9ApNqpzf+e5xXLg+Oa67C17tWWiVNOdsUH5YMyU=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "%GulyWWv2sQiNGG7iJOVi6kFKXub5NglKMiqTyj4STM4=.sha256 means that relying on feed-ids does not guarantee deterministic resolution, right? So the general question becomes: Should things built on scuttlebot assume non-forking feeds anyways (and hope that the protocol evolves to handle them), or should they try to work around it? In the case of a package manager, I fear that \"working around it\" means reverting to direct addressing without the possibility of automatically using newer versions.",
    "mentions": [
      {
        "link": "%GulyWWv2sQiNGG7iJOVi6kFKXub5NglKMiqTyj4STM4=.sha256"
      }
    ]
  },
  "signature": "vHcoMXVwbAg6SBda2IAYZ1uTx/3xo3cdze9zt+8YGW8IUo4cBKXJ29W06PxzilCQBoNVhifcTkJH7Ps+GNWCDw==.sig.ed25519"
}

{
  "previous": "%lXOFl0kH8v/bLt7JglRyuemY/5ji/4Fwo8loo4XJA6s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 130,
  "timestamp": 1491730370535,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%89zO/F6Z04MAY/ZsYxKGtd1NDrCoWWwlVLNoGayBmZY=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "lqkycciGjZZmvtXtZc1uMyfHVVZ2k0K7D3AB6vOjWprZBglIZSEECQLExwlYLokxTiAL1n+3xfLqoqkHm7TUAQ==.sig.ed25519"
}

{
  "previous": "%3LqeSjgyJAE8XjKYgSDOY3ZlB5GMZHmfnl3/rKnmbUA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 131,
  "timestamp": 1491730995004,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%CaTUvSVOxlGYm8JlzRc7XmMdLM5NUXSbEhzySkNpc8U=.sha256",
    "branch": "%CldbyOglBe1bRe3GJ77Ptu2V9ZrZL17+fPG6PwdTDqQ=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "More possible features:\n\n- multiple authors, see %SQ1iFZb+rTLul3ZCVoLuPopS+Dbwuv+H+gaxBGYKy8Q=.sha256\n  - might conflict with using a unique feed to prevent duplicate versions\n- control over whether to collapse compatible versions or not, e.g:\n  - transitive dependencies on `foo =1.0` and `foo ^1.0`\n  - `foo 1.1` exists\n  - download only `foo 1.0`, or both `foo 1.0` and `foo 1.1`?\n  - should be configurable",
    "mentions": [
      {
        "link": "%SQ1iFZb+rTLul3ZCVoLuPopS+Dbwuv+H+gaxBGYKy8Q=.sha256"
      }
    ]
  },
  "signature": "YF7zLjXaPr9QyTo/K0nF8+cRszfW/aBnvMy9BMkdNvEkVEJp2yXPMU8rMIbiH2I1UOupr71wk7qfU4lMGb/mCA==.sig.ed25519"
}

{
  "previous": "%zON09pNbf5cba+Hrz+vWpd6G0+OflK/iAQpOQnRsHUk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 132,
  "timestamp": 1491734172650,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%pHrJGddvUV10z5Sipejdk1/T+RwX8RyBnfrksuNm+N0=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "3LzXR199mGbHQcHozrMLil+9W0Xtie/hPWTV5axNgbg8kNhFQRpucIFKyys2TMp7gFKuaMy4tx05LvLqEfqhBg==.sig.ed25519"
}

{
  "previous": "%oREAKszv6BUXIeeVq+obA0YXm4TdQt+LyUNi7oXSOyI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 133,
  "timestamp": 1491734459506,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%FTirchax92fOofL5QCaT0Qw15GDpj3P0TGlmP4fP28c=.sha256"
    ],
    "packs": [
      {
        "link": "&jrktnwIq3du8+SnX5ZWLBODBGe52pnB8H64tvUu9hEg=.sha256",
        "size": 1783
      }
    ],
    "indexes": [
      {
        "link": "&c88cs42wUskJMlscubcELgf2q1jAT5Y5ZMQp9wCsCJM=.sha256",
        "size": 1324
      }
    ],
    "refs": {
      "refs/heads/master": "a67271bdedb7edd41203dd39aee79989e9aa8f08"
    },
    "commits": [
      {
        "parents": [
          "6f95abfa06c268ec43dd3e1fdce87afe3ad09bd9"
        ],
        "title": "Use error callbacks instead of process.exit()",
        "sha1": "a67271bdedb7edd41203dd39aee79989e9aa8f08"
      }
    ],
    "num_objects": 9,
    "object_ids": [
      "6e0c004662d086091313b3a152e32ef7d1cd3d7d",
      "572a4760d7003ce213fa3548a7e54d921068d926",
      "7d1c695d048275a3a4315ea7901d764acab6f0ac",
      "622c112d36328c32294794e7e0bbf82763ddc28c",
      "d7b3c18c9c8afe01b4d4891a745c3efbdb69032a",
      "b34d6271247531d81aee6f686c8f2ae22a4f42a6",
      "e47daa808c5e5246933bac14a35fb435d942ee90",
      "fbb10328beb2fd7d34e50f473b3d7fbc49922806"
    ]
  },
  "signature": "2G/cGLcg71YAk2a2BDuXXBC6JhoAO7X++ejKPlHz6EYfMzVd1L/wIkwjMarzXtla9MTzSouXdHxvPFIbd053Cw==.sig.ed25519"
}

{
  "previous": "%l5qbdUlYzsNHz4T+nBVGvIBBPn8arT2LRamtfgzNJUo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 134,
  "timestamp": 1491740187117,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lihyEM/pb+/kNuuCvqeTAaIiNajMpY53lf2JY3K3ows=.sha256",
    "branch": "%jr+D6Gtyss159jybCSckJ5v7Z+UEk4BrZ9jj5So67QM=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "> Maybe what you want is metadata on ssb, and files in ipfs?\n\nBurn the heretic! Well ok, I basically came to the same conclusion. From a purely technical perspective, this makes perfect sense.\n\nBut here are some counterarguments:\n\n- requires users to install both ipfs and scuttlebot\n- requires users to both run sbot server and an ipfs node all the time\n- scuttlebot users might only spin up an ipfs node to install and publish, but the whole system only works well if nodes are left running in the background. Patchwork et al encourage running a scuttlebot server all the time, but there is no such incentive for ipfs - especially for less technical users.\n- successfully resolving and downloading dependencies requires the user to be connected to two separate network clusters which both need to contain the right data\n\nThe file system layer of ipfs consists of only four very simple object models (which corresspond to scuttlebot messages), see [section 3.6 of the whitepaper](https://github.com/ipfs/papers/blob/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf). Basically there are `blocks` (corresponding to scuttlebot blobs), and some data structures that link to blocks, to model file systems (just like unix directories are just files that link to other files). Could this be replicated with scuttlebot messages? As far as I understand it, the address of every non-blob message is determined by the author an the content, right? Does that mean there is no way of having content-addressable \"directory messages\"?",
    "mentions": []
  },
  "signature": "OXKQ5OMoC1+E1N2pMne9wpeAsuS5U0NL+PpOwD0gQSpj2IWI7R9iZphesxQpMHfS9Lt5LG1bW/WBkr4h73fqCQ==.sig.ed25519"
}

{
  "previous": "%RKCnLyCRNy74/SNy2hyOdMYPNUNAEQ2gRRjLF8jeCC0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 135,
  "timestamp": 1491740230608,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbpm",
    "vote": {
      "link": "%jr+D6Gtyss159jybCSckJ5v7Z+UEk4BrZ9jj5So67QM=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "Cxl2KMaC3Yz0SMLQBReEds2HXzquMgyTGLKEOQAcaWoIftRXW+J6lXivdNAXu7OeFE65RbgTLVFFuGMgKDbrDw==.sig.ed25519"
}

{
  "previous": "%M59Go5hSuxB2rMw+gi5cWPYC3eUTv6ggu6aCQTZNH2s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 136,
  "timestamp": 1491740565644,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%CaTUvSVOxlGYm8JlzRc7XmMdLM5NUXSbEhzySkNpc8U=.sha256",
    "branch": "%d32W0k6ebPSTARsuJBWstGl4efI03PbxYpBef/y9y94=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "So much material to read on here. I like how I've been essentially just rehashing and scratching the surface of territory you guys already explored half a year ago.",
    "mentions": []
  },
  "signature": "e66KL2FCe/osshFPMtScb6SbF2l0cCWhNoyhnCjU3XvYjDWEbd/wWwdQzHXpeBaRg1Yr4uyTDoTxGtmXjM14BQ==.sig.ed25519"
}

{
  "previous": "%9QBuBOb/9ZExw72tn1oL7z1r4ipLnZGSWApa/07acZ0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 137,
  "timestamp": 1491741048641,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%DCLtB1bC73I3HGXNshrGpfUrzQ4n7Q0+BmtlZUcBf/k=.sha256",
    "branch": "%9B+aKcYYvdHZD4aBfOX690TNobomlAFXKS6ocGZXFuY=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "Recursive acronyms are great. What about \"üspm\" (üspm scuttlebutt package manager)? Or \"ßspm\"? My German keyboard layout has some fun characters to use.\n\nOkay, I'll take Dominic's advice, the name simply stays `ssbpm`. The npm-install will add executables for both `ssbpm command` and `spm command`, because I'm not going to type ssbpm on the command line the whole time...",
    "mentions": []
  },
  "signature": "+hKAbieDkI/qzTGXLBtAD1+xtFod3oVpkfVdLufAqChyPmx9OIEUKMIg4/fJzMlrRm7j7HY6eQl9cT2jEH+PAw==.sig.ed25519"
}

{
  "previous": "%aLcJkj7XCRTIp3E/ZWGKkMRIZZFyy1l6juRnyuSKPtA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 138,
  "timestamp": 1491742563033,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebutt",
    "text": "Just an idea (which you probably already discussed elsewhere): Compound identities.\n\nIdentities (i.e. feeds) that can be posted to by certain other identities. Identities with write-access to a compound identity can also grant/revoke access rights to other identities.\n\nThis allows for groups/orgs or whatever you want to call it to be added transparently. Ferment gains automatic support for bands. Git-ssb gains automatic support for orgs. Ssbpm gains automatic support for multiple authors. Compound identities gain automatic support for nested compound identities.\n\nMajor drawbacks:\n- no more strict correspondence between identities and network topology\n- might be tricky to implement?",
    "mentions": []
  },
  "signature": "0gY4XSZZWJJQR2WdhamboIqSTnwrtY8HwHEsTVkQcvih8UYsJj/D7G991gAzfeoEqFKvxYaI6REZrttFjxxJCg==.sig.ed25519"
}

{
  "previous": "%4gORFmp/uqRNpy0ZpFEuwzld33V0b6bT9tHHafiojMw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 139,
  "timestamp": 1491742785932,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "n00bquestions",
    "text": "Could anyone clarify the meaning of the following tems and their relation? Also, is this terminology deliberate, or historical cruft?\n\nSecure-scuttlebutt vs scuttlebutt vs scuttlebot vs sbot?",
    "mentions": []
  },
  "signature": "kdUOIZcd+NLTww6ybrhfU3mroMPK//xAaAn/gxKCM6cG/iS/MRn6hT/u3REG44prXixEr9DRbdUuIjJxRajHCw==.sig.ed25519"
}

{
  "previous": "%a99UCsZqgbOoO0UwYHjLFzU2KiGrXco7QQJJ96Kpgtg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 140,
  "timestamp": 1491742816491,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "golang",
    "vote": {
      "link": "%9k7UezNX6QdcYyAN1rsrN3nGRWT/ThLDMfp/RR+wLgY=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "N7mGQqSjDSdf4wyd4ewTqfJXWrNucUPL65MfTAml+gOid/LK/VeOINt0ExT68oFuhUgFF3J9KxFat1xHLvVRCw==.sig.ed25519"
}

{
  "previous": "%pSpVDBvEeK7z9QfKhi06/SfFBpUMgNvC7+RJdRlLcSQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 141,
  "timestamp": 1491745435056,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lihyEM/pb+/kNuuCvqeTAaIiNajMpY53lf2JY3K3ows=.sha256",
    "branch": "%RKCnLyCRNy74/SNy2hyOdMYPNUNAEQ2gRRjLF8jeCC0=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "Somewhat hacky solution: Represent directories as blobs, interpret the blobs as json-objects which contain the hashes of subdirectories and files. Feels pretty hacky (especially since the ipfs guys do the same stuff much more elegantly and efficient), but should get the job done.\n\nI'll definitely start out by namespacing message types like `\"ssbpm.tmp0.foo\"`, so that I'm free to try out different solutions.",
    "mentions": []
  },
  "signature": "2f5mua+aMOqAJQV1lrtkYTPktNKrAktgcK1eohzgVVoqQI68wISRtjqkHq6dOsyvKHJDxuozwVXW+iEtWmhZBQ==.sig.ed25519"
}

{
  "previous": "%xjxQPwd6JwUtN2UzAuRWmiYWYZIOePwvuDsnYXzYYjI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 142,
  "timestamp": 1491745751999,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Ar7gwhhG6k5VDKE25LEtILMu3Gpnj+dX3oH/jvwl6GU=.sha256",
    "branch": "%cx4sDkZEor3BJWlF6GfwXCStXSul3fPbxlLG+MDv2yQ=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "If changing things is an option, you might also want to check out [multiformats](http://multiformats.io/) in general and [multihash](http://multiformats.io/multihash/) specifically. Sharing some standards with the ipfs could be a good idea.",
    "mentions": []
  },
  "signature": "cjrSfWZbsTdxB2BtAEF5R9ExkQiJ9HPfhPmOuQvJNOYqdq0xYVRyOJpuksnhIgUM/x72KLcrd62qv9Cdco3sBg==.sig.ed25519"
}

{
  "previous": "%DQ7cotJpKiPo5r0E3LRUSp/InUBxnrzPTZq97pehtpA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 143,
  "timestamp": 1491754336227,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebot",
    "text": "How do I get the hash a file would receive if I added it as a blob, *without* actually adding it as a blob?",
    "mentions": []
  },
  "signature": "7QKwVez4OgOwddYj2S6l6dJndo7WI8EZy8RFy4dZQOYD7HRWNjnBZUaQc3FdZhzErxgo/XuFB6coeP9Zrx24BQ==.sig.ed25519"
}

{
  "previous": "%2+j2RZ3b+dwxL++LULSlQao2wbEnB52lAu0IBtn5iyw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 144,
  "timestamp": 1491767311401,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%T4dh8wm2yy6BSg4HWaROV2khUe/TPWndxSbg5Fg6sm4=.sha256",
    "branch": "%T4dh8wm2yy6BSg4HWaROV2khUe/TPWndxSbg5Fg6sm4=.sha256",
    "channel": "faq",
    "recps": null,
    "text": "At the top right corner of patchwork is a \"Mentions\" button. Clicking it should show you all direct replies to your posts.",
    "mentions": []
  },
  "signature": "JC6HocDMSiNj9i6rXMii96Kg88ifPiRy+fh0Gh3uKY7M1xEh5ttMX9B0JjxrZVXkcpfzi4ZDuQUTsO9KTAvOCg==.sig.ed25519"
}

{
  "previous": "%AQNq95fOhlmkwYU9Kp6aJNiNFt9UfnmUuGdHqEHVxwI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 145,
  "timestamp": 1491770832813,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%nrMsfKntA3GnzqoRjmD79ikj7oe0oJRt8jpX1iy0JTw=.sha256",
    "branch": "%nrMsfKntA3GnzqoRjmD79ikj7oe0oJRt8jpX1iy0JTw=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) is already working on it [here](%b6nlgiAu3ZWkLqKnvkU1T/9PZCfiqSU/Ujg1xRmD/64=.sha256)",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      },
      {
        "link": "%b6nlgiAu3ZWkLqKnvkU1T/9PZCfiqSU/Ujg1xRmD/64=.sha256",
        "name": "here"
      }
    ]
  },
  "signature": "Mx8DH8CM9mu6+piYmBih51ieNjI8qxkIGyUZBrN91mz1M9N/DM2dGluxKKuEY7Pf0E8ukLglowfC0z9XEWO3AQ==.sig.ed25519"
}

{
  "previous": "%jZ0A7t9hwBkJfZTZJb0czyIBf9Un519AHRPLZp+wEq4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 146,
  "timestamp": 1491775320328,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%a99UCsZqgbOoO0UwYHjLFzU2KiGrXco7QQJJ96Kpgtg=.sha256",
    "branch": "%P9n7QJ3/xqL/8nykfhEgHht987Oaed71e5lw5s1Hw3o=.sha256",
    "channel": "n00bquestions",
    "recps": null,
    "text": "So scuttlebot is an implementation of the ssb protocol?",
    "mentions": []
  },
  "signature": "6/5iYjPCWAq9x9WadM+oBAOCvGxybeRCRS4kJ9H0P+Vvu4sEZ7F7qc6uPnO+793lA0dkDsaaQST7BsgBwZ5eBQ==.sig.ed25519"
}

{
  "previous": "%smuG/OWnbmtlT5IukhfvjOC/5OM8xEjIo8u+reZfq1M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 147,
  "timestamp": 1491809317701,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%2+j2RZ3b+dwxL++LULSlQao2wbEnB52lAu0IBtn5iyw=.sha256",
    "branch": "%4m9Qk6fVDVIKyEqH6Tr/ug9WBqroTmXJvQ3sbd7a5LI=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "Would be nice if `sbot.blob` exposed a function to compute it, in case the default hash needs to change.",
    "mentions": []
  },
  "signature": "837ALZ96jv/SLRfzX0+1o6LoV11thZlsH1NwhBo8UVWgkHROp36hPUPsUxxx00vxhkKjtHL/hqK0HiEWWQ6uAg==.sig.ed25519"
}

{
  "previous": "%Pfih3tugEJiE0J+gymZinrsYeJf1lOkeKInqp4B604E=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 148,
  "timestamp": 1491822937469,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "patchwork",
    "vote": {
      "link": "%xkCHMmO4Cq0977Orxc6mjBdQLcScJ8wH3q59q/5TuCM=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "r6DkkdPVmI8VcdIUbIO+bbTLCqDpaOHrA/8sDzzRPU4jZ2r6KdssqXXaTuJjnPMvf3FSCiE5GPDYzXe4ihV+AA==.sig.ed25519"
}

{
  "previous": "%YIgyIa1XipTeNJDIMaZ+vO9btcJYQ3uiPNZLHn2tbmA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 149,
  "timestamp": 1491837796207,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lihyEM/pb+/kNuuCvqeTAaIiNajMpY53lf2JY3K3ows=.sha256",
    "branch": "%TMbU8pDhJct/QUwouVfQKw6rDgK651NEsowqbqOMpII=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "As an initial message format, I'm going with messages like this: https://gist.github.com/AljoschaMeyer/066b5af9a9b7cf28e360c4ff9966cb41\n\nSo each release contains a link to its package, the release type (major, minor etc., terminology still undecided), a `content` object representing the directory structure, and `mentions` for all file blobs. Each regular (i.e. non-directory) file gets its own blob.\n\n`spm install scuttlebot` is still some weeks or months away though. Classes start next week, so I'll be even more unproductive. Current coarse roadmap:\n\n- implement publishing and installing based on hashes\n- set up a testing environment\n- provide cli commands for installing and for manipulating the `ssbpm.json` via petnames\n- (add human-readable versioning layer)\n- add hooks (at this point, ssbpm becomes a usable alternative to npm)\n- get somebody to write the node hooks so I don't have to\n- gui for module browsing\n- recognize downvotes on releases and prompt when installing a flagged release\n- improve robustness, including:\n  - better error handling\n  - dealing with large files/directories\n  - improve message schemas if necessary",
    "mentions": []
  },
  "signature": "Q/o8IT+duIEv3skXMucao3AxYkuUfhubvKUrMumH6uO6ADDZfTPqOwDvJ+aPQgPqTM15lgAC7khPtT0Aze9SBg==.sig.ed25519"
}

{
  "previous": "%hbJtYaWgYItbPxraAM/XmexQ2EHtbb+52itlFi7zsWE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 150,
  "timestamp": 1491841359296,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lihyEM/pb+/kNuuCvqeTAaIiNajMpY53lf2JY3K3ows=.sha256",
    "branch": "%Ny/Wjn8Lrri7F00mk0O92l2D6CMtZhMbC7riBcFry2o=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "I *knew* I forgot something... Dependencies are a list of `{hash: \"&<release>\", fixed: boolean}` objects. I'll edit some deps into the gist.\n\nThe format is not intended to be permanent, just to get something going. Handling too large messages (or blobs for that matter) can come later.",
    "mentions": []
  },
  "signature": "0ZkvBcQkwXUNnPUn+hunvKy0n+ohu0hoK7Gb6cOKGvU146KsYS8MJLMQwGWhog9Lacyo+w00gGwwPyHPj8hxBA==.sig.ed25519"
}

{
  "previous": "%ajOjdHDnSMoF7WJt/7b3pUt65ogiP4Quq/dxf2CPzpA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 151,
  "timestamp": 1491857202487,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebot",
    "text": "Could someone please take a look at this code consuming the blobs api and tell me what's wrong? Is the [documentation](http://scuttlebot.io/docs/advanced/publish-a-file.html) outdated, or am I missing something completely obvious?\n\n```js\nconst fs = require('fs');\nconst ssbClient = require('ssb-client');\nconst pull = require('pull-stream');\nconst toPull = require('stream-to-pull-stream');\n\nssbClient((err, sbot) => {\n  if (err) {\n    throw err;\n  }\n\n  pull(\n    toPull.source(fs.createReadStream('./foo.js')),\n    sbot.blobs.add((err, hash) => {\n      if (err) {\n        console.log(err);\n      } else {\n        console.log(hash);\n      }\n    })\n  );\n\n  sbot.close();\n});\n```\n\nExpected behaviour: logs a hash and adds foo.j to the blobstore. Actual behaviour: logs `undefined` and adds foo.js to the blobstore.\n\nWhen changing the path from `./foo.js` to `doesnotexist`, it logs an error message as expected. However, it also crashes the server with the following log:\n\n```\n/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/multiblob/index.js:206\n        if(err) throw explain(err, 'no callback provided')\n                ^\nError: no callback provided\n    at cb (/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/multiblob/index.js:206:23)\n    at /home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/multiblob/index.js:231:28\n  Error: could not write to tmpfile\n    at /home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/multiblob/index.js:231:31\n    at next (/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-write-file/index.js:14:26)\n    at /home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-stream/throughs/map.js:19:9\n    at /home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-stream/throughs/through.js:19:9\n    at source (/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/muxrpc/pull-weird.js:47:22)\n    at /home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-stream/throughs/through.js:16:14\n    at /home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-stream/throughs/map.js:11:7\n    at /home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-write-file/index.js:12:7\n    at FSReqWrap.oncomplete (fs.js:114:15)\n  Error: ENOENT: no such file or directory, open 'doesnotexist'\n```\n\nShouldn't the server continue running?",
    "mentions": []
  },
  "signature": "mgP4oA+qr0BZATk5eSjTbjY9MfYyy1IiHsXgOnbRvSk8bpaVqTGAVJPaQWwnI+NibmTNhS4dmiofUyhKGNc6Dw==.sig.ed25519"
}

{
  "previous": "%7Mq2BfKSrL1AiRKjAToGrgXGivjHR++7+jvZCKsvY3A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 152,
  "timestamp": 1491857428469,
  "hash": "sha256",
  "content": {
    "type": "pub",
    "address": {
      "host": "94.237.35.82",
      "port": 8008,
      "key": "@0YTV22Eg35HneBaqZtbebkG5bTyRZxxKvjnsYtI2adY=.ed25519"
    }
  },
  "signature": "TlIvF6tZgzIQ2KA4imGudhyPd2Ov2Ym+gJgV+mZmrBl4j91Ty2lxpmgg9TwNQisMRqlT68SBje/AS1nM31+QCw==.sig.ed25519"
}

{
  "previous": "%2gE2S7pzgQRqUuVfUdTG2ZTZzYr++RnpVY7og5tAp+0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 153,
  "timestamp": 1491857428592,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@0YTV22Eg35HneBaqZtbebkG5bTyRZxxKvjnsYtI2adY=.ed25519",
    "following": true
  },
  "signature": "HM0TbPRmBz6OQbQS9Xkte4zacQrXfR3ifHBMTWk7I8HfijF405bTf002so7KJPFy65Yr4pAAKKGWJKH93L6gDA==.sig.ed25519"
}

{
  "previous": "%vvsm3WWcfpffVSEkqTyJHoKnYw9TVyofJJW/Nq+Yaho=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 154,
  "timestamp": 1491900970635,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%7Mq2BfKSrL1AiRKjAToGrgXGivjHR++7+jvZCKsvY3A=.sha256",
    "branch": "%rlG/bVnZhP5FXzBEVnwdUyGJljE385FT9jmtln3lrmc=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": ">you are closing the connection before the file is uploaded. move `sbot.close()` to inside the callback to `blobs.add`\n\nNice catch, but fixing that does not change the behavior. \n\nI'm slowly starting to grok pull-streams. What is the best way to interact with node-style callbacks? At the moment, I have some code like this:\n\n```js\n// calls cb with (undefined, \"theSha256Hash\"), or error\nconst computeSha256 = (file, cb) => {\n  const hasher = createHash('sha256');\n  pull(\n    pullFile(file),\n    toPull(zlib.createGzip()),\n    hasher,\n    pull.onEnd(() => cb(null, `&${hasher.digest}`))\n  );\n};\n```\nBut that code does not propagate errors through the callback.\n\n`pull.onEnd()` simply rethrows errors, right? How could I write a function that either calls `cb(err)` on error or `cb(null, whatever)` on normal termination, without having to reimplement the whole onEnd-logic?\n\nThe best solution is probably to use pull-streams throughout the codebase, so `computeSha256` should simply be a through-stream. But first I'd first like to understand how to cleanly convert back to node-style callbacks.",
    "mentions": []
  },
  "signature": "Nc1fV6+4xrJezcSZx2CDjXQn27uin/86t782g8Y6MCxNemDsoH6pMPNnOnAVCM+/rESoTgiywB6Dr0/jdpY6Cw==.sig.ed25519"
}

{
  "previous": "%DHSKZXMyBSUtADuyXRmNYaJ2Ukxo1ChxN4jO38Liw5o=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 155,
  "timestamp": 1491910630313,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%7Mq2BfKSrL1AiRKjAToGrgXGivjHR++7+jvZCKsvY3A=.sha256",
    "branch": "%DHSKZXMyBSUtADuyXRmNYaJ2Ukxo1ChxN4jO38Liw5o=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "This seems to work, although it still looks ugly to me...\n\n```js\npull(\n  pullFile(file),\n  toPull(zlib.createGzip()),\n  hasher,\n  read => {\n    try {\n      pull(\n        read,\n        pull.onEnd(() => cb(null, hasher.digest))\n      );\n    } catch (err) {\n      cb(err);\n    }\n  }\n);\n```",
    "mentions": []
  },
  "signature": "wSS/h+454AeDUJVK9uTomeSVW3RgoykTDbpmn8ZNNkw+zqsPOfKh14ESgQrqs/Pq/iD0lG9TbZekZiltRSXuCQ==.sig.ed25519"
}

{
  "previous": "%jpybjcee/35eRdhxjBreyqfqpDS8QJJy1Im/CMXb9ng=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 156,
  "timestamp": 1491910656438,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "parsing",
    "subscribed": true
  },
  "signature": "oSXzdrg77Xr6KJQjJV1PrlwcFeXCIwFb7mRKLOFUuqyTLWGm6+5mIZCCZNqeAAzZUuyalPTq1i15XVtW2FNAAA==.sig.ed25519"
}

{
  "previous": "%gnP+HJNG/FlN4eCQRFAFHJaOQOm1PqN7w0B7kvxSAoE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 157,
  "timestamp": 1491940143873,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%l5qbdUlYzsNHz4T+nBVGvIBBPn8arT2LRamtfgzNJUo=.sha256"
    ],
    "packs": [
      {
        "link": "&Vlddb/cOjEplabkHwciBTyMwDqxWsoqngal/TMJXqHg=.sha256",
        "size": 35875
      }
    ],
    "indexes": [
      {
        "link": "&PEhjNCBRwa2nINBjqEclGj8sYfa5lDjcQd6W1hRj608=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "9682ef4a5299a788889fc05f79eb581594fde5c5"
    },
    "commits": [
      {
        "parents": [
          "a67271bdedb7edd41203dd39aee79989e9aa8f08"
        ],
        "title": "This does not work, and I have no idea why...",
        "sha1": "9682ef4a5299a788889fc05f79eb581594fde5c5"
      }
    ],
    "num_objects": 13,
    "object_ids": [
      "278e3f32d9ae80f54fa3f47c05bb11d41df3ab1f",
      "f1940d0241456c0912cb861d5576ab2b88a0dc8c",
      "43ded2e5e5e9237912f141244b47552bd87add87",
      "3de79d65b59845cf4231ff408f8b6eb795b6b39b",
      "6f5bb599a1b30c52b4ec60ec04ce76cbdd4cf080",
      "f797a04ce54ae53fee08207554292483f63df389",
      "7b97d9f0845c9bda11c2acc0dc087c46f3c39552",
      "a010a7e7bcc0f1715257ebd0aa459eb06075284b",
      "8fe22d846290db5d9c164b971a824f4172ffa3fa",
      "4c8299943b36be14fdd13f0aebfc60bff4ae19c1",
      "c988e277f8953e4d4a88e30bef4893b71de4cf9b",
      "1bbdc281c432d683ac0b448e82ded10c9a8bec7d"
    ]
  },
  "signature": "3Ui2XBSePzYbxTrEZxICTyrzxhzKHjjpZ1yyx9BRkbmrOxhLB2XwK4k6uyMl+eCT4KGDxvRHb4heHHUXpnVaCw==.sig.ed25519"
}

{
  "previous": "%XklvcHDyTEaBQwTyNLs1rhVemyJN6gWQTsfVrSHiUf8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 158,
  "timestamp": 1491941970566,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "I need help with ssb-client. My mental model seems far enough off that I simply can't get things to run. So if anyone wants to take a look at buggy code, here are the things that are stumping me. To reproduce, clone the [repo](http://localhost:7718/%25FjOeAbe0i8XgtleF%2Bh1x31%2FFdHe31kvJmseeFze40BQ%3D.sha256) and run `node ./index.js publish -vv`\n\n- in [this function](http://localhost:7718/%25FjOeAbe0i8XgtleF%2Bh1x31%2FFdHe31kvJmseeFze40BQ%3D.sha256/blob/9682ef4a5299a788889fc05f79eb581594fde5c5/src/commands/publish.js#L152), pull-stream decides to never run `sbot.blobs.add`, so the callback is never called.\n\nThe following minimal programm sets up the exact same stream, and it works:\n\n```js\nconst zlib = require('zlib');\nconst ssbClient = require('ssb-client');\nconst pull = require('pull-stream');\nconst toPull = require('stream-to-pull-stream');\n\nconst pullFile = require('pull-file');\n\nssbClient((err, sbot) => {\n  pull(\n    pullFile('foo.js'),\n    toPull(zlib.createGzip()),\n    sbot.blobs.add(err => {\n      console.log('yay!');\n      sbot.close();\n    })\n  );\n});\n```\n\n- If I replace the stream that never calls `sbot.blobs.add` with a trivial stream that works (e.g. `pull(pullFile(file), pull.log())`), things run well until [here](http://localhost:7718/%25FjOeAbe0i8XgtleF%2Bh1x31%2FFdHe31kvJmseeFze40BQ%3D.sha256/blob/9682ef4a5299a788889fc05f79eb581594fde5c5/src/commands/publish.js#L40). The callback is invoked, but `fullmsg` is `undefined`, and I get the following error in the terminal:\n\n```\n/home/aljoscha/projects/scuttleverse/ssbpm/index.js:20\n      throw err;\n      ^\n\nError: stream is closed\n    at /home/aljoscha/projects/scuttleverse/ssbpm/node_modules/muxrpc/index.js:39:25\n    at remoteCall (/home/aljoscha/projects/scuttleverse/ssbpm/node_modules/muxrpc/api.js:26:19)\n    at EventEmitter.obj.(anonymous function) [as publish] (/home/aljoscha/projects/scuttleverse/ssbpm/node_modules/muxrpc/api.js:40:20)\n    at createBlobs (/home/aljoscha/projects/scuttleverse/ssbpm/src/commands/publish.js:40:14)\n    at async.each.err (/home/aljoscha/projects/scuttleverse/ssbpm/src/commands/publish.js:252:12)\n    at /home/aljoscha/projects/scuttleverse/ssbpm/node_modules/async/dist/async.js:460:16\n    at iteratorCallback (/home/aljoscha/projects/scuttleverse/ssbpm/node_modules/async/dist/async.js:1034:13)\n    at /home/aljoscha/projects/scuttleverse/ssbpm/node_modules/async/dist/async.js:944:16\n    at onFile (/home/aljoscha/projects/scuttleverse/ssbpm/src/commands/publish.js:227:20)\n    at computeSha256 (/home/aljoscha/projects/scuttleverse/ssbpm/src/commands/publish.js:73:13)\n```\n\nBonus:\n\n- [here](http://localhost:7718/%25FjOeAbe0i8XgtleF%2Bh1x31%2FFdHe31kvJmseeFze40BQ%3D.sha256/blob/9682ef4a5299a788889fc05f79eb581594fde5c5/src/commands/publish.js#L136) `toPull(zlib.createGzip())` simply works, whereas [here](http://localhost:7718/%25FjOeAbe0i8XgtleF%2Bh1x31%2FFdHe31kvJmseeFze40BQ%3D.sha256/blob/9682ef4a5299a788889fc05f79eb581594fde5c5/src/commands/publish.js#L155]) the exact same code results in the following warning logged to the console once per invocation:\n```\nwarning, stream-to-pull-stream:\nthe wrapped node-stream does not implement `destroy`,\nthis may cause resource leaks.\n```\n\nBetween unfamiliar APIs, asynchronicity and callback-shenanigans, my poor little brain simply does not manage to keep up...",
    "mentions": []
  },
  "signature": "yx5AexhtWaEQkMtEDJ1rdAAr4lN1dx+nqT5U28EGu7WjKH6uy+8X8N0voWA7nx4coIsvOYeLO6yyN93vTxI3Dg==.sig.ed25519"
}

{
  "previous": "%b2Mb+a6tDilEPvLC9BlwDNz7LNYr9lZFLSBn8rSZYWU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 159,
  "timestamp": 1491948177670,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebot",
    "vote": {
      "link": "%q7WsVkGEwB00frK2moY9HpHJMjEieSWOBPhseRe8hog=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "JwcstH59MSrJFtLN288GHMOoBfzOLgt3CAEsDP75gA8URt73itl8E5wA/USpc34CZswpnUJFGENfQncmq/LABA==.sig.ed25519"
}

{
  "previous": "%1hl6J/vKJ0J3gOlNSaY1vEkEVMTroMizg0ZUFvzQ7cg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 160,
  "timestamp": 1491986575261,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@Zm/yHwozL4mPlHIS54h4wsDZa6Ae9/cnFw2D0ymewCE=.ed25519",
    "following": true
  },
  "signature": "DBvuzBQDBr4JL4V7uW/FmfYhbpLo9ssfmj1Mo4sSDtdWWzH6r9Ru3oy3S0kYC5mrI7jOXnhd+m5Td2Yx9HskAw==.sig.ed25519"
}

{
  "previous": "%GE3NYtrMQ064vsiVf3a10DpPa4vr3SuAJjqwOZpHicg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 161,
  "timestamp": 1491986597964,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "elixir",
    "subscribed": true
  },
  "signature": "8pV5pqgMf75QXeg7T04zOR0wRz2tWA72xBRQ9edoVUn/AZ4NR+z4n2hXtRv0V9E1yrQ5gX/neFLl2qiTMTB8Dg==.sig.ed25519"
}

{
  "previous": "%mHpGh71br+KHDXv0boTjJh7Eb5DZN9MrMlTy4pc4jrA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 162,
  "timestamp": 1491992829664,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@DIoOBMaI1f0mJg+5tUzZ7vgzCeeHh8+zGta4pOjc+k0=.ed25519",
    "following": true
  },
  "signature": "O/rC6afaAieVbodbKuAnb1CAnNjJiuyhy8BYLDRFN43X1F9B3JaNbxQuodcz1GNH7qDjBjcGNl2CXPtGJHt1DQ==.sig.ed25519"
}

{
  "previous": "%Mq/U05hDrvFGTsrnvH0kPmqDdFRh5gQf4Yh94nkO17I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 163,
  "timestamp": 1492001546630,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
    "image": "&1xijAVuzmk4k4pTtYUou/GzCp8HV0uMJh1ItmIZkMFY=.sha256"
  },
  "signature": "4543WhJ+6EH6WemgNcevkia3Oe6rLxffYFdk/qLtaVhj2qAh3qbbqb00/KWE1c9SKe5RAAQ3KHov0uVT9XvYBA==.sig.ed25519"
}

{
  "previous": "%cxWogX9V8Ly8QEzBCazuUXxqFRoK0Mzw4yRIg3rkkAk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 164,
  "timestamp": 1492019025079,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%b2Mb+a6tDilEPvLC9BlwDNz7LNYr9lZFLSBn8rSZYWU=.sha256",
    "branch": "%b2Mb+a6tDilEPvLC9BlwDNz7LNYr9lZFLSBn8rSZYWU=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "Ok, found the problem, a misplaced callback... Debugging this sort of code sure is fun. Anyways, back to implementing stuff. Publishing works, next up is installing.",
    "mentions": []
  },
  "signature": "1KJHDuRDuXNRexzYMG5+4pqYlZd82izF9XY1BRFdWdCi6Rk8X0wc2OSsmv+Od/wFxi8n3aU5PDSzwJlHTlarDg==.sig.ed25519"
}

{
  "previous": "%GalFjR9Pl3mfmQYVQVvbmDJPyX4wD1t45w82GL11tDU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 165,
  "timestamp": 1492023036095,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%XklvcHDyTEaBQwTyNLs1rhVemyJN6gWQTsfVrSHiUf8=.sha256"
    ],
    "packs": [
      {
        "link": "&Y0ArGWLgAsPHomvzQZp3kpQCYxTpD/mypjbjxH9bypk=.sha256",
        "size": 6884
      }
    ],
    "indexes": [
      {
        "link": "&Nb8FUd3dOBFrMWRag/BIzW4fEGfsuzYK+oplqxlyK1w=.sha256",
        "size": 1772
      }
    ],
    "refs": {
      "refs/heads/master": "0c81d48883eb94210c4d95df6315ed181df464c8"
    },
    "commits": [
      {
        "parents": [
          "7a7a7799010c51132512af6fda14b10e0a1dade1"
        ],
        "title": "Tweak release message schema",
        "sha1": "0c81d48883eb94210c4d95df6315ed181df464c8"
      },
      {
        "parents": [
          "874a1768bae26300c41a73d1467e3a9e75c0ca4c"
        ],
        "title": "Change to more convenient dependency specification",
        "sha1": "7a7a7799010c51132512af6fda14b10e0a1dade1"
      },
      {
        "parents": [
          "d168016f623a7a8fa10e214112b58dc7e9be0b3c"
        ],
        "title": "Separate into api and binary",
        "sha1": "874a1768bae26300c41a73d1467e3a9e75c0ca4c"
      },
      {
        "parents": [
          "9682ef4a5299a788889fc05f79eb581594fde5c5"
        ],
        "title": "Fix publish, it now actually works",
        "sha1": "d168016f623a7a8fa10e214112b58dc7e9be0b3c"
      }
    ],
    "num_objects": 25,
    "object_ids": [
      "68040b0b3bb720c687313bc5bcded7ff943474da",
      "8aaa0d06efbd7e6550b2213b1a7a9524efb42da9",
      "6319fa9d6face2cb5da8055cd0291c87e194cbe2",
      "e00479be132b12c0d57e48d0c0804d981b484eaf",
      "1b6d9bd26d68b6b00862d8793cf9d10e8e35a351",
      "5e98fd6673086cbd022388a010e2dd3310d8a143",
      "1539709383cbfded58b29a285f434c468156d0bb",
      "e7d95bb5e8114e0529af91b45d0dc3b39500173e",
      "d818903abbed24260eba8955d8610094a04efb04",
      "c1000614c3735642e681b1c4c61ed2c0848218be",
      "b8956d5351e141efd026010aebb267de4680e280",
      "33179bce95031c823a32342759549d1086a210c1",
      "1174c3b46c3b63a194b0aec8e5c10cc7f0f53786",
      "5998f025795417da58d52ead55eb0c2e40ec39dd",
      "63c8ffd196455b064c8173eb6f8cc80de3d90072",
      "e5fb70d7835b829f4e2954b6c1d4c8e461440546",
      "6e2467517b716bdf0c6058eaa717fc856b23fb77",
      "7e33fa7c4a06b13e240f2b9fac980ef44ed5b89e",
      "62db5a8e7eda2d9e341f123fdb810f9411f70b7b",
      "5c557162be3e83a202c65a25a354bfc6e59d388e",
      "dabf53824dbd41b8d79626a6556c78bc7e038ece"
    ]
  },
  "signature": "GiBAFlVx3ghWShtDIzmY7/ndszVL619a2b2KszSOnUcFVVwLGluMnM409KKIfK8yDe0OiJ94y0hyHKmxku3RCA==.sig.ed25519"
}

{
  "previous": "%3RTpiZ5rnF3NBK3UsV0Pt77OKGspdToZn3HyLdN9qco=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 166,
  "timestamp": 1492025984721,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@rFgDtlYiyymSD4U96Av3pIil8xBj6afLXr87caoqAyo=.ed25519",
    "following": true
  },
  "signature": "k1p0GbG5k1dQkltlFukhEb8N7UDIzdbFq0/ya90dr2nssxc4JAK/NVY8W0f3I3yB5QBDjwBUAJrX8pxi57pLDA==.sig.ed25519"
}

{
  "previous": "%IyeWOnC52JzpODXYxkkwmtWmk5J5sOdT067vrUKnjDk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 167,
  "timestamp": 1492026361764,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ChQsfn/1rm7fJEKS2TgjM/K4VfRbC4iG5RqtCeuodm4=.sha256",
    "branch": "%ChQsfn/1rm7fJEKS2TgjM/K4VfRbC4iG5RqtCeuodm4=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) Are there any general objections to binary message formats, or was json simply a pragmatic decision? Would it be possible to change to a more efficient format at some time in the future?\n\nDoing so in a backward compatible way should not be too difficult, each binary message would simply need to begin with a sequence of bits that can never occur at the beginning of valid json.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "Tk6HM0a3kJeCkCES5jyvp+jHh+WWz+0gd78admkUMW1LQEV/0p1cUuq2iKqX4upCZWTs4IgyCF8/HfjCBOVYAQ==.sig.ed25519"
}

{
  "previous": "%qtojAREs6xMtFhiaaY0P1jgTk0UmhmesM+x+RAKDTes=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 168,
  "timestamp": 1492029597912,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ChQsfn/1rm7fJEKS2TgjM/K4VfRbC4iG5RqtCeuodm4=.sha256",
    "branch": "%wcevjOKNcc1KiWwYqRC3OLy1wSouj7QAvTV/kJwFbgk=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "> hardcoded encoding of common messages\n\nThat goes against the principle of having no global authority. The protocol needs to treat some messages in a special way because they influence replication. But aside from that, it should not favor any kind of messages over others. If a subgroup of users decide to build their own social-network-thing on top of other message types, the protocol should not punish them for doing so.",
    "mentions": []
  },
  "signature": "pFeP1d8+dfcAwO/Mwju7igDUnAF1mWpHyTx5W53aPoC2qqDrM5Evpasc8W1VBL3tzoiqyfsuG9C2ctFkOdDOBw==.sig.ed25519"
}

{
  "previous": "%UAdLsjAQ1ENcJj9PWUL0iHLTERwXlv82Ap0ZmlVLb40=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 169,
  "timestamp": 1492029607868,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebot",
    "vote": {
      "link": "%wcevjOKNcc1KiWwYqRC3OLy1wSouj7QAvTV/kJwFbgk=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "nnLWsrZ2KWLOouJEc6D5/uelvBFky6cQ1H7R+lIHw2a3sA8CNhgiOXJzJpDzoZCz6E5OExZ6rmJt1lxkYWoxCQ==.sig.ed25519"
}

{
  "previous": "%4X/VDlOJkYOjjusYcJVTQezQZA0AL4c8FyUwTBjhj1Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 170,
  "timestamp": 1492029803586,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebot",
    "vote": {
      "link": "%J5RTMBz+Rz/bqyKyMCX29anIDwLcRg5R8NXJP6ep6qs=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "eFlYomIOoile7DXTwEuzTCinfurXP0b/oicY55pBXX0/voyxLm8fwRUkQY4vNlxdg+diYSaVJguJtgQhxuEsDA==.sig.ed25519"
}

{
  "previous": "%oLTL08yXQf0k7I85t9k4fmpY0WyHvBFLfPPpGx1B0ac=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 171,
  "timestamp": 1492106761959,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%3RTpiZ5rnF3NBK3UsV0Pt77OKGspdToZn3HyLdN9qco=.sha256"
    ],
    "packs": [
      {
        "link": "&KKUBZGR9pBpAkXBcTLn+/k76sewXw/gkSUivAHXQaU0=.sha256",
        "size": 36687
      }
    ],
    "indexes": [
      {
        "link": "&Cw/U7rIbZ9aggZm1xN5lrRf5Os5ZHh3WWQEhi4wVePk=.sha256",
        "size": 1492
      }
    ],
    "refs": {
      "refs/heads/master": "f175159b076f184449fc3a26e5070fd8ba26bf06"
    },
    "commits": [
      {
        "parents": [
          "aec611b1c6071e5cb5d6563b23624cf66f0043a5"
        ],
        "title": "Write documentation",
        "sha1": "f175159b076f184449fc3a26e5070fd8ba26bf06"
      },
      {
        "parents": [
          "0c81d48883eb94210c4d95df6315ed181df464c8"
        ],
        "title": "Implement better datafile validation",
        "sha1": "aec611b1c6071e5cb5d6563b23624cf66f0043a5"
      }
    ],
    "num_objects": 15,
    "object_ids": [
      "ede76b87ad0e7cbdd513b7596f5c02a205ed0918",
      "f444c6ae808934ae1e9851cd4002777b01438bcc",
      "50c732adb6fc0ddd8b09f83d5439be1d195a384d",
      "ad26b9495b0d0a84d221d19d9b807862bb89ea11",
      "2b026e5a769a0b6cb6490c4a6e58370224122f5b",
      "c580219b036f87df2aa70aded4cfc39d19626bf9",
      "3f60429b8c84ad5b7723f41c7e87e315ce1d1f10",
      "2539e1174e1d8669d3df53315ea29c4c9317689f",
      "7e98813d2ede62ade0851df8b921caba2185ef42",
      "7e3364bd9e3817656056cd714cbe0d08e2538eea",
      "f6974199ff589798f599bfc8d0537cc00d5a151f",
      "975a8e2a01bada9a0c86fa83340e125842101549",
      "fd0ec2eae7125e91a0b3626b9f1f42201ada9de2"
    ]
  },
  "signature": "UgRY7bFt2gcZFe7fokFi0YVITCcEQuD01ZA83fkFYFrF++6w1WGjkrItsuR5SzCy3/jvUuxn9cOq6Cfohbr5Cg==.sig.ed25519"
}

{
  "previous": "%P4piCz+Sj9YKlZzz+QjG0w0peAL5WznoeS4R3ceaY8Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 172,
  "timestamp": 1492107321822,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%P4piCz+Sj9YKlZzz+QjG0w0peAL5WznoeS4R3ceaY8Y=.sha256"
    ],
    "packs": [
      {
        "link": "&/CojbgHxzLxOpjNtW2LS+vrGm9JyB+RbuXnSE0tg4yk=.sha256",
        "size": 997
      }
    ],
    "indexes": [
      {
        "link": "&hTAQ+3LTE/LKeT9Gu9zBgSDPw86Hfe/EQeO9x20d5VU=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "3bf97178dd5956bba8b171d9b40919e9546c2eea"
    },
    "commits": [
      {
        "parents": [
          "f175159b076f184449fc3a26e5070fd8ba26bf06"
        ],
        "title": "Use --host and --port options",
        "sha1": "3bf97178dd5956bba8b171d9b40919e9546c2eea"
      }
    ],
    "num_objects": 3,
    "object_ids": [
      "3d6163275cddff07b94fe5848050282c80ddabc4",
      "7a1d57350d59d903134edbfe2ad7955b07ede3d7"
    ]
  },
  "signature": "Li8D1zqjSf0eRyxwsQLTDEPYVdFgdl9/PcVtfBR8cFjlqSdNpIsB/5pN/QFFxaVHOXWV1LHaOoxywxNVeJmPCQ==.sig.ed25519"
}

{
  "previous": "%Nr97ryJ15+o0rx5cFoabj9yLrEPWqPVx0Va8vn5Lfgc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 173,
  "timestamp": 1492195466962,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "idris",
    "subscribed": true
  },
  "signature": "rNXHh6nM6Jnin5vHPBB4uxfb9os/Xqx2G+AAkXvBUNPCF/L13GM+/57IC2kXT7ECw9KB7XVswM+eXlVEwQ35BQ==.sig.ed25519"
}

{
  "previous": "%GVym0UykkX6c4rJnuE0+Q0/ZoEnVRKtWZtOG6nOpqVQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 174,
  "timestamp": 1492202024990,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "solarpunk",
    "subscribed": true
  },
  "signature": "j6p4p3+EaxnvI2z4SUY6HVFJ983pFtfuwN2JWNjfAG02GG4bhYz4cXhpTcuzbulWRvHWmNWO1MNA85tJw6dLBw==.sig.ed25519"
}

{
  "previous": "%IO8ljeM4ENADmkm0V2Eh4lGaranb+umQQ7ZkBziLTos=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 175,
  "timestamp": 1492202057853,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@ZqH7Mctu/7DNInxuwl12ECjfrAKUX2tBLq1rOldNhg0=.ed25519",
    "following": true
  },
  "signature": "nHl1+aaNzKI8IIRKunCMSXs4ZK06y3J48mtpI6MYcHdScYUmtCS51xjw0Ch9wT5Bgrgs07d1WtN7ip9HfVz2AQ==.sig.ed25519"
}

{
  "previous": "%Bf9R4cRfvP6pbP0YS78tadjhRuLQTsL4nSBG70dEodg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 176,
  "timestamp": 1492204333107,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebot",
    "text": "`sbot` stopped working for me when starting it with `ssb_appname` set to anything that is not the default `ssb`.\n\nStarting the server works as usual:\n```\n> env ssb_appname=test-ssbpm sbot server\nLoading plugins from /home/aljoscha/.test-ssbpm/node_modules\nLog level: notice\n```\n\nBut when running a command in another tab, it errors:\n\n```\n> sbot whoami\nError: Could not connect to the scuttlebot server.\nUse the \"server\" command to start it.\n```\n\nAnd back in the server tab, it logs the following:\n\n```\nserver error, from net:::ffff:127.0.0.1:39208~shs:\nError: wrong number\n    at abort (/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/secret-handshake/protocol.js:80:45)\n    at Object.cb (/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/secret-handshake/protocol.js:93:20)\n    at drain (/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-reader/index.js:39:14)\n    at more (/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-reader/index.js:51:13)\n    at /home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-reader/index.js:62:9\n    at /home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/pull-reader/index.js:20:7\n    at drain (/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/stream-to-pull-stream/index.js:141:18)\n    at Socket.<anonymous> (/home/aljoscha/.node_modules/lib/node_modules/scuttlebot/node_modules/stream-to-pull-stream/index.js:150:5)\n    at emitOne (events.js:96:13)\n    at Socket.emit (events.js:191:7)\n```\n\nThe server does not crash, it continues running, and writes this error message each time I try to run any command that connects to the server.\n\nIt does not make a difference whether the directory to which I set `ssb_appname` is empty, contains a `secret`, `config` and `manifest.json` files, or does not exist.\n\nScuttlebot version is 9.6.1, had the same problem with 9.5.0 as well.\n\nThe same command worked fine yesterday, and I did not (knowingly) change anything about sbot.\n\nAny ideas what might cause this?",
    "mentions": []
  },
  "signature": "vuuYdzyvo8HHgDNMgCjEpDU3dP0JLG2Eptk58NYWgM8X7fTfmBvu3EjLUFN1SChYF1D0rO8ZAx3tdC2V+M/4AQ==.sig.ed25519"
}

{
  "previous": "%XVtF6EVV7A9pZ1NPjniVpMdb3GyPier8+mNxH0jvpWw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 177,
  "timestamp": 1492204528151,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%NdmDGnQEm9KE7RghgidtgPPFo90YJcdE5etD8Y6U/hs=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "16DeP6COSO2Z9ngCtRaqHQYtN3S9P/LhkDGevZt/M8vUfSQBUuqWAcjPMXjGEfKMKkaQpJfB5vQ5B1cRztMSCA==.sig.ed25519"
}

{
  "previous": "%utW0FqE/YeEvz4xIXFGMpMIbQttU23KrqNW0IA1MrwU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 178,
  "timestamp": 1492206983503,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%XVtF6EVV7A9pZ1NPjniVpMdb3GyPier8+mNxH0jvpWw=.sha256",
    "branch": "%qAUxR44UzRLsvhVqVvQvBTIvhdYRVCBbkFS1JL5RhUk=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "Thanks a lot. Is that also what the first argument to [ssb-client](http://scuttlebot.io/apis/modules/ssb-client.html) is for?",
    "mentions": []
  },
  "signature": "3wDrhLPRKlCeVkbp5v53AybDcAvkLoZYTeJ4YsTA4v/t7ewNP0Tmh8gD0EXgJiMPDMTNBR1dqBf4o+c96206Dw==.sig.ed25519"
}

{
  "previous": "%V2oyx+jN2A1qiRNO8lzYXa1A0sh+yzxQHGTpd02h6Vg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 179,
  "timestamp": 1492336614135,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "song-islands",
    "subscribed": true
  },
  "signature": "bOHcdqCt1+L0/fskmppt45b/oE+DON16UYhbpzyj07EY6omdf7hNq0zfS9jZvi2AeYgpIROQKU1oLwi8wtq1Bw==.sig.ed25519"
}

{
  "previous": "%mWeztcAofkUZoNN7U9hc063AvmQnowEoAgPIigwDp+4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 180,
  "timestamp": 1492343188825,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Nr97ryJ15+o0rx5cFoabj9yLrEPWqPVx0Va8vn5Lfgc=.sha256"
    ],
    "packs": [
      {
        "link": "&LKfOocwZ4ndMTdeKW2eubUHX+o4EQvVjcQvKHUce4KE=.sha256",
        "size": 36107
      }
    ],
    "indexes": [
      {
        "link": "&jZinlGDbuHWZJYlnqJmjbZ1/NA40H0hQG5N9NINPFx8=.sha256",
        "size": 1548
      }
    ],
    "refs": {
      "refs/heads/master": "e1ab102322bd9f285793bb280bd31eed64508851"
    },
    "commits": [
      {
        "parents": [
          "3bf97178dd5956bba8b171d9b40919e9546c2eea"
        ],
        "title": "Set up tests",
        "sha1": "e1ab102322bd9f285793bb280bd31eed64508851"
      }
    ],
    "num_objects": 17,
    "object_ids": [
      "c3e14b7066c6e619293f84f91483658992ddfb17",
      "7c4287ee5b751cf10320593b39677a4f8dcd5e27",
      "469884cae27f2309a42eb1c8507370a35ba76164",
      "58109e7d6ee66a2922a04ec95b164cadb2da429f",
      "c3a5318d6df86ef605681b0b5afa7353e2701273",
      "f98738737354b2d26c80a2a569c9819efbdcd51d",
      "c11a99e273c5cc98707fcb355ead89f2c480dece",
      "738b6e41f6ba83b4ac3eaf15ee0d460c0204f521",
      "ece6f22acce936d250b347909efe68d1ed3edc6a",
      "4d5fcadc293a348e88f777dc0920f11e7d71441c",
      "77e98a59e190ce51ab7ec86deb24492d1434247e",
      "1ff608f9a1979b734c9610019096620f749366b7",
      "208f975c510d420d1f62d7d2c39cc32df2328fc6",
      "d2bf1e8b53beced333f2273272458acfb2851c56",
      "487380104bb768ef01500168baf65bad487beb69",
      "1ca9b72a29363cfc41ed4c1de507f561ed0f17f5"
    ]
  },
  "signature": "aoKri7sCkh3FFK0HBjT7r5UdwSJD1FRn/WUZKxoNyM1tlqYb0WeqgxWRIxIx0rEAhUACTst/FNcKLL0WnRFfAQ==.sig.ed25519"
}

{
  "previous": "%DBj+mainmIsSbR47zL1FDbNFJgBvwLLtpTGtqrChBHQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 181,
  "timestamp": 1492353872329,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%QuFgM+Yua3OgRzHF7GdDtC1XH/iEVWdu/mY0HTthA0E=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "lMdClE2bNKi9H7MG+y8LcBezsqQoCQiYlcHtcFyjL/FLz0zTmq2y9CV7u0MJ9goPsrBbyB3pCAc+mTQur8W3Dg==.sig.ed25519"
}

{
  "previous": "%JZGftqrfjhokwfFP3L1DI04L2/Il5QFq2x2Nc4Qu5Jo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 182,
  "timestamp": 1492353874541,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%qIB0xTyN58PwdtxFNR3OYY30NYCDb+FulALBJL2Pw/s=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "oU5ketmcUFqMRJRDPrq15kOcciRWjR/dDFWAgb0RThceqwLol60kET1yIxXdeDXt52RpWcpGPUprfNZJkRD6Bw==.sig.ed25519"
}

{
  "previous": "%GMy4552ztTzMYVNV3D0d2HbbCZxs5vZ6AKZDMR07Skg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 183,
  "timestamp": 1492353880330,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@JeguwaY77eK8Yc5PWzwycrC/X5bWt5d9TqtZaVGVL4c=.ed25519",
    "following": true
  },
  "signature": "q4xvnNWzyUuel+PLweEkNb3oypcK7h6UBLgqq/YUpYdiLdjNlIgu24GUqlmy4haQLuEG1f7AOfWBf2qNvqylCg==.sig.ed25519"
}

{
  "previous": "%cDH3TVf+N8H7rokMqmEpNXH897cdyONt0Vp/TMjFGSs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 184,
  "timestamp": 1492375148791,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "faq",
    "vote": {
      "link": "%mgmE+0Pf5qxWoPqQb9H6WPK3jhhNmxXWiJnPsC8rxW0=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "6Yyx/ikSGASM5121eGifl7skhkA4bB6ouowU+yicOKYpLADGONPJU/zOaMBZL43WV8d0xrcXEpNz93Fo+N5UBw==.sig.ed25519"
}

{
  "previous": "%0yZoLceGRRAPio8ZfDVsXQ5MMVu7kkZVZ4vyxPW71JY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 185,
  "timestamp": 1492523326473,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%FjOeAbe0i8XgtleF+h1x31/FdHe31kvJmseeFze40BQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%DBj+mainmIsSbR47zL1FDbNFJgBvwLLtpTGtqrChBHQ=.sha256"
    ],
    "packs": [
      {
        "link": "&cVUKDGfyXbvME5n1NedQYiIkmNsRR1Txmk8YMbRzTEY=.sha256",
        "size": 5719
      }
    ],
    "indexes": [
      {
        "link": "&aMRiodW1D2N4DdUc0dvLVFD6wRLECoOypU99WY1Y4/E=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "23897d71731bd8a7d855162b81b0d5f14d7ed4a4"
    },
    "commits": [
      {
        "parents": [
          "e1ab102322bd9f285793bb280bd31eed64508851"
        ],
        "title": "Test the executable instead of the api",
        "sha1": "23897d71731bd8a7d855162b81b0d5f14d7ed4a4"
      }
    ],
    "num_objects": 13,
    "object_ids": [
      "9d6b6f6b8b3cbd958afd5a52ed42ebd8286b964f",
      "5dd891e79b27cd6e1af2922df3396ab576bc0276",
      "df619e7e9938670b6c9420c0ddae2693f2e5df99",
      "8befd637cdb5e030bf290c9a29c00e5951d5dd4d",
      "1b434969f105d4e4257b700b43193f2f2257674a",
      "91f08bfe3e7740244e555aef9b016018907e2c97",
      "6ca33ee1c398188e0dcc0e01e74ea91d20226041",
      "dbd4ef7c4f9f123225be24bf9fd8cfefd1d1693b",
      "6198f18fe643a0f3c5ccbfd1c7373dfb9ff10aa1",
      "1aee9d2cde1cf8cef2fdcad1648e6415dd100792",
      "e1ea8f2fc5813346210510f0fae277fad70f889f",
      "c1a736212bac154ece3586193f408a04fd90491c"
    ]
  },
  "signature": "2BfCtTgNnFQKgZ3PoJ0pIOnYQkI2hcEQfm+IFdFz8Fh+C/qMkTFmLccRQdS9QzhEue6BMg4kiOC9uNl+F1oNBA==.sig.ed25519"
}

{
  "previous": "%3kHS3qA3cySc/P8OXx6XxUuGfpDMRl+e2lgUlvpcxwQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 186,
  "timestamp": 1492682606742,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@wLinNWXMCITML7/3DyVrcQvhVuit7rQehPJdXlsyuVU=.ed25519",
    "following": true
  },
  "signature": "hNrFTHZC+Bu23y9XrzZ7K2sWDfsBAD/qaJ7aYtIcntaqEc/LEMQjn8amQvvVhOnHQOBmpiEJICsuaSnhgqI1AA==.sig.ed25519"
}

{
  "previous": "%6XA/0enwQ3bgaueK35jNYvuDTMzchzVuG+KSlgevszs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 187,
  "timestamp": 1492761179683,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "golang",
    "vote": {
      "link": "%YCMzqeMh3CATNtT1ST/Cpsy3dSdV+5GDXDRiV1c0tIQ=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "HispKX57PcsGY2LUUbjrS0PoyCpXMheDtwKH+I+qtJW6AvSmTtcKEhGLOwY1YIwC1eAA1XIPJVFgl9r7bBvRDA==.sig.ed25519"
}

{
  "previous": "%DCGD8w6dfI0jhfJeRRHE+Zi7i3cLtinSem431jseQYc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 188,
  "timestamp": 1493499865235,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%14f6AKuaCEjuUV+2K161kzuN40TtRXMLWsBMSi/y5LI=.sha256",
    "branch": "%xxKaTmEdIQHlTEnY+lqi6NdqPiGhDIIV6sqN/Y5wPUQ=.sha256",
    "channel": "ssbc",
    "recps": null,
    "text": "I agree with [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519). A schema should only specify which parts are expected, but should never restrict (non-conflicting) additional values. That's the beauty of dealing maps as objects, instead of strong static typing: Adding additional keys never limits interoperability.\n\nThink of it like semantic versioning: Adding new functions to a module's API does not break the old functions. This allows us to specify dependencies as \"anything that is newer than this but does not break it\". Being able to do this is immensely powerful. And message schemas should embrace the same concept. As long as all entries necessary for the message recipient to function are present and have the correct type, it is compatible. Solely adding additional features (i.e. other entries) never breaks compatibility.",
    "mentions": [
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "cwLZK9ePXLu0jS/vMneNbb4Gb9lnF7MgtzyKlHrbi36Yx4C4wgdhiQZ80c00xLpXvcDi+984V2Ah/B+8RfmGAw==.sig.ed25519"
}

{
  "previous": "%H3dVgX6iXWR50/jUvN0IFm413K5WMa+Zgb8sIWzVtDM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 189,
  "timestamp": 1493583285899,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "arch",
    "subscribed": true
  },
  "signature": "47CRCn9uGtwQt5QislH8FCj3aIJSuNbLrYTdHu9qnWIv/a4BdZHhCCKfEWi+GMpIkxHe/0msvb5WleohYRapDg==.sig.ed25519"
}

{
  "previous": "%qs/SXaSa5l/0/FJ4u3NYEzMtOR46I05lEXCFB7VELBo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 190,
  "timestamp": 1493588217247,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "In order to verify integrity of any message, one must download all messages of this feed up until that message, right? This would be a pretty undesirable property for a package manager. Downloading/installing a package could potentially require to download a bunch of random social media messages as well. \n\nA possible workaround could be to create a feed per package. One would still use one's standard ssb identity for installing packages. Publishing however would happen from a package-specific identity. Following such an identity would enable notifications of new releases, but not result in any unrelated message downloads.\n\nThis goes against the idea of having the network topology resemble the feed subscriptions. But feeds are the primitive building block for expressing interest in future updates. That concept in itself is not necessarily  tied to a social graph.\n\n[#git-ssb](#git-ssb) faces this issue as well. Requiring all users to download completely unrelated messages means that it can not really become a decentralized alternative to github. It is of course great for people who fully commit to the scuttleverse. But it prevents adoption from others who simply want git repository hosting, but do not plan on participating in a social network.\n\nHaving easy distributed package management for the scuttleverse would be great, but I'm more interested in having easy distributed package management in general. But choosing the simple ssb-based implementation of storing all metadata as messages published by regular feeds would carry a lot of overhead for non-scuttlers. This would be a definite disadvantage compared to [gx](https://github.com/whyrusleeping/gx). I'd be rather unhappy with such a compromise.\n\n- - -\n\nAlso, my attention has been drifting to other things for now, but I'll certainly come back to building this at some point. I'm working on a programming language, and it will eventually need a package manager... And I'm always up for discussions around this problem space.",
    "mentions": [
      {
        "link": "#git-ssb"
      }
    ]
  },
  "signature": "0EaJEIReJarwohAyepayl8pBBtu+JsRb+5tmM6U/A/RWBDcGYleFMIzoF6JGu0ywx22KFusA5J8p0lTaLoWeCQ==.sig.ed25519"
}

{
  "previous": "%bcYK0JOPzKlgu1DRhxBmpU7O+xrW+RvKSJ7u48n8Zio=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 191,
  "timestamp": 1493642623966,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%bcYK0JOPzKlgu1DRhxBmpU7O+xrW+RvKSJ7u48n8Zio=.sha256",
    "branch": "%3RD5WE8yQ3YrMPKvy7WyYrjWWRkaEJmDRlDhgnZxDL8=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "Having a feed per package simply seems to be the most straightforward way of working around the problem. It does come wiht some challenges on its own though:\n\n- is it possible to have multiple people with release-capabilities without risking forks?\n- how can replication be ensured? Should the package manager ask pubs to follow the feeds behind the scenes?\n\n---\n\nCreating and publishing packages could work like this:\n\n### Terminology\n- package: conceptually the set of all releases for one thing\n- release: a version of a package\n- primary identity: The normal ssb identity of the user (usually located in ~/.ssb)\n\n\n\n### init: create a new package\n  - create package feed\n  - initialize the feed\n    - set up replication with primary identity\n    - ask pubs to replicate this?\n  - create ssbpm.json\n    - add hash of package feed\n\n### publish: upload a release to the global network\n  - create message containing all metadata for the release\n    - release type\n    - link to previous release?\n    - \"link\" to payload\n      - backend indicator\n    - dependencies\n      - link to release or to package or to both?\n      - version range\n  - publish the metadata message from the package feed\n    - find out which feed\n      - check feed hash in ssbpm.json and build local fs path from it\n    - publish from that feed\n    - make sure it gets replicated\n      - by primary identity?\n      - by pubs?\n      - if offline, how to ensure that it is replicated later?\n  - publish the payload\n    - different backends possible, e.g.\n      - ssb blob\n        - publish from package identity or primary identity or both?\n      - ipfs\n      - local filesystem\n      - git repo\n      - url/uri",
    "mentions": []
  },
  "signature": "Oaflu6kP1YGHKczgQGw5nhwRM0oVvoOHjuQ5ncfBsema19DmxVl7iohW6qQmaQVwI/1nAiISLd29As+dFpa6CA==.sig.ed25519"
}

{
  "previous": "%2fGeueE2/N5pJ2XYv/c/CIHjy3e9mwNto0fAwlU5VnY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 192,
  "timestamp": 1493667539973,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "unravel",
    "text": "Just wondered whether any of you know about [unravel](http://unravel.org/). It's yet another attempt at building a better internet. I'm fairly skeptical about some decisions of the author, there's no really coherent summary of the design yet, and it's at a very early stage. But I'm so impressed by the author's [previous](https://www.youtube.com/watch?v=khmFGThc5TI) [projects](https://www.youtube.com/user/eskilsteenberg/videos) that I'm really looking forward to what unravel will turn into.",
    "mentions": []
  },
  "signature": "C/m08SkztPlfSDDqp82uzMmYVq1NXLfcLI8u1+fd5SOmfKyIxSorPSfW7PwtzifJjpLkASFxKWKlyDxyYSYBCQ==.sig.ed25519"
}

{
  "previous": "%BYouFOL2GMfZb4zdNkZoi1jIqLoMDdVupa2p7pItsyk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 193,
  "timestamp": 1493667544385,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "unravel",
    "subscribed": true
  },
  "signature": "uswtvtVpCkZL8zPhWKU5JhWHGMKSrvAqrNp1eKnRch5X6IkI9ba6LPNG6/rPROa1z4WH94cf5hIK98JF5+3JCA==.sig.ed25519"
}

{
  "previous": "%2y+z4fuCxf3mcRHyP0rdZb7kKD537/ITcPhWd+aJnxo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 194,
  "timestamp": 1493667696264,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@D26sJ/Seyc4WBcpZDi4PYcqEg+2nUb7WoTQg9NknDyg=.ed25519",
    "name": "Kodo"
  },
  "signature": "CbvPR0Hk0OmPCpjDThIPc0CgJ9hybloNNrxAwdGHEbxd4hN6cTU6d+iEaE1ILsoPuRHo7HF3d/eginqxZCHgAg==.sig.ed25519"
}

{
  "previous": "%iJsonAFCFKWtelQKvVOAqxLFuNcXlemq/H0UaTE/bKI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 195,
  "timestamp": 1493731735832,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "lisp",
    "subscribed": true
  },
  "signature": "LA72J6BVS1ftS5hQD450LLr3tVhcuEtd/arl8uVTjScXh2L+9W/uGtIh+n6jlSiFPqwDl8ZHgjvoXJT5bHJSDw==.sig.ed25519"
}

{
  "previous": "%FdP0z1h8xk/fnVjyzBQyIeBX/rsm7uQwFw7I9iIGIxI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 196,
  "timestamp": 1493806417111,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%2GUlOLRVd/WwCg3tbWHQf/sTtC2O66cYUyTLxNxstgU=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "1v4r8PPMR8tnMTqahLH0eGdPgiFleNzmCxOAzrbaJp1MjFcBHkOf84dgHO7kvYN81mEXO3Hrb3ymHCPkBErCCA==.sig.ed25519"
}

{
  "previous": "%7caU/sufYLXYcL2dsyQ5pW9XlkqQa/+ZzES6TXNTXYo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 197,
  "timestamp": 1493807617770,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%bcYK0JOPzKlgu1DRhxBmpU7O+xrW+RvKSJ7u48n8Zio=.sha256",
    "branch": "%yrQkdRU/W1XgXS9z8Q64C0eEx5QIa8tiCBqQKqJlBCs=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "At which order of magnitude might too many feed subscriptions become problem? Even with feed per author it might be possible to approach that point if you are (transitively) pulling in lots of modules with different authors.\n\nSpontaneously I'd think that you could use heuristics to help with this. E.g. sorting feed update requests based on most recent update time, or assigning priorities to feeds update requests, etc. But since I have no idea of the protocol layer I might be completely wrong here.\n\nI guess I'll just write a script to actually get some numbers on how many different packages/authors an npm author (transitively) depends on. My estimate would be a few thousands of dependencies for really prolific authors.\n\n---\nMaintaining a dedicated identity for module publishing sounds like a good idea, it also prevents \"polluting\" the social graph. Otherwise you might end up being a \"friend\" of someone just because you happen to use modules written by each other.\n\n---\nOne more interesting point of view on using your normal identities for package publishing: People who use your package need to replicate your whole feed. In that sense, they are giving back to you: They get to use your code, and in return they improve availability of all your scuttleverse content. That's an interesting way of looking at things, and one not found in any other package manager (that I'm aware of).",
    "mentions": []
  },
  "signature": "Od0Ll2Yxx2+GatdDRYQbpFYsW0AK5F3nV5BlDmDqzQ1JsPKUoXp87bQd0BvFUxddQY/+lOabcao+N2fmegqfBA==.sig.ed25519"
}

{
  "previous": "%XSjyE358AyD5V/F7tvVL7D0KQV41aS8O+lrcvjkolbs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 198,
  "timestamp": 1493811631721,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%DdQwkLGmn2Jz5d8pDdYrSxRJhi3jUkvwNuc/wDrghxA=.sha256",
    "branch": "%yQvfg9/D49mU2lRWy+W/wrkqPFa+j8cB+zNurxu6tfo=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": "For reference, the [indieweb](https://indieweb.org/) people do this quite a lot: [federation](https://indieweb.org/federation).",
    "mentions": []
  },
  "signature": "OjPmgcnvU/cTV/V+u3IsXczVDqxabEY77SnXeMTsTrhviGpgF4Be2daeKJfozcnofxb5rjuPBox7QOjEhfv5BA==.sig.ed25519"
}

{
  "previous": "%MHi5KRQFhAN9l7WR3eLA5cN/bAyyZxiIl0ed2GwP9uw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 199,
  "timestamp": 1493824097454,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%DdQwkLGmn2Jz5d8pDdYrSxRJhi3jUkvwNuc/wDrghxA=.sha256",
    "branch": "%MHi5KRQFhAN9l7WR3eLA5cN/bAyyZxiIl0ed2GwP9uw=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Wrong link by the way, I meant syndication, as linked to by [@Sybil](@rFgDtlYiyymSD4U96Av3pIil8xBj6afLXr87caoqAyo=.ed25519) .",
    "mentions": [
      {
        "link": "@rFgDtlYiyymSD4U96Av3pIil8xBj6afLXr87caoqAyo=.ed25519",
        "name": "Sybil"
      }
    ]
  },
  "signature": "l1cqH+ml/Iot9RYe4q7tRRbqsq6heIzDyioz3clmUUwWMraG208k7PfIZI6wiIBEAZDRMzej3jzJ4wLp0arEAw==.sig.ed25519"
}

{
  "previous": "%S+rkxSTUtZHK45NVToI+47GzPe57yZ6rOgBP2N4bNhA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 200,
  "timestamp": 1493826077030,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%bcYK0JOPzKlgu1DRhxBmpU7O+xrW+RvKSJ7u48n8Zio=.sha256",
    "branch": "%BcRALAnsdx1+w9Kh5KTx54aiw84LKjBMhV3TqCPU/mI=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "> Would also be good so you could mark another feed as a requirement for your feed, and thus extend past standard FOAF to grab all the requirements, rather then a package depending on something that's well beyond your FOAF and thus failing to install.\n\nMy plan was to follow all transitively depended-on packages. Having a mechanism where the protocol could automatically fetch transitive dependencies would be more clean though. But for now to get something that works with the current protocol means simply following not only the direct dependencies, but also the transitive ones.\n\n---\nHere's a script that checks the npm registry for all unique transitive dependencies of a given author: [npm-author-deps](https://github.com/AljoschaMeyer/npm-author-deps). Run `node ./bin.js author-name` to print the number of packages this author transitively depends upon. The script uses [npm-remote-ls](https://github.com/npm/npm-remote-ls), which takes forever and prints error messages into the console instead of providing a programmatic way of handling them... But it works... Hopefully.\n\nMy [8 packages](https://www.npmjs.com/~aljoscha-meyer) have a total of 1096 transitive dependencies. I'm currently running the script for [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) and  [@substack](@9nTgtYmvW4HID6ayt6Icwc8WZxdifx5SlSKKIX/X/1g=.ed25519). But as I said, it takes forever, and I hope that the logged error messages don't mean that the script aborts in the end. But anyways, I'm expecting that there might be more than just \"a few thousand\" dependencies for these authors...\n\nUsing feed-per-author instead of feed-per-package to prevent performance problems still seems odd to me. Feed-per-author would result in more payload network traffic than feed-per-package. Does the protocol overhead of requesting updates really outweight this?\n\nIn the end, these are also usability concerns. If I want to install a package, but the install takes a long time because it requires downloading unrelated data, I'd rather use a centralized alternative with better usability. Ok, actually I wouldn't, but many people would.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@9nTgtYmvW4HID6ayt6Icwc8WZxdifx5SlSKKIX/X/1g=.ed25519",
        "name": "substack"
      }
    ]
  },
  "signature": "R+zJjEDP60EPTYJgLJ8tdSpb4kh7q3VAinu/Fbz972E2SFk7VH9RLCT/bRpFuewHkgRIff/71xvPPUOUonfeCA==.sig.ed25519"
}

{
  "previous": "%t6Gp+Oqi5tz5OdiowO2/Sj9/LAUbLw4cLbQWjPg0ats=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 201,
  "timestamp": 1493826445147,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%DdQwkLGmn2Jz5d8pDdYrSxRJhi3jUkvwNuc/wDrghxA=.sha256",
    "branch": "%S+rkxSTUtZHK45NVToI+47GzPe57yZ6rOgBP2N4bNhA=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Wow, I'm really good with links today... [@Vendan-Go](@wLinNWXMCITML7/3DyVrcQvhVuit7rQehPJdXlsyuVU=.ed25519) linked to [POSSE](https://indieweb.org/POSSE), not sybil.",
    "mentions": [
      {
        "link": "@wLinNWXMCITML7/3DyVrcQvhVuit7rQehPJdXlsyuVU=.ed25519",
        "name": "Vendan-Go"
      }
    ]
  },
  "signature": "tNfgXty6zPxpjDp0awChKMykhDn/+upNO+N4ZMWwr/yL1vvXECDB0mffnrH+ZtifyOlBlSSTI3PssSQcHLNsAA==.sig.ed25519"
}

{
  "previous": "%+BLKwCBVXnAua5vrpfDxl8X7uoGzBC8C8hWCuvOATPc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 202,
  "timestamp": 1494230062724,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "music",
    "vote": {
      "link": "%wU3FmiQkSNO+p2xa+6DNjW09lqOJT5I548xY80hneBs=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "HPalYPQkyKxsxzaCzOv528GZ1m/W2gorh/EVMxZq9aeVDhdMeyVpApFbISDy3CVUL/zx+De8iFhvT/2OOz1kCQ==.sig.ed25519"
}

{
  "previous": "%PPl9iWh/vpTPD0QZnFsDGjx/v7vmTY9PXF9+7q+/RHQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 203,
  "timestamp": 1494324251543,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebot",
    "vote": {
      "link": "%l5vtq0GejGvNROiOfXCBnLl05wO5w29RhEbF1ShWPPE=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "YI2dUGKARYQOgP4ht3uj2hrnpAbKj9RRVufGc2kggX+toQh6UvHOqWUcIZ00p3FafLk9YVqFVOIObx5XM6H5Ag==.sig.ed25519"
}

{
  "previous": "%05J2UobVnga++ZQ6Zys1PCI+O7Pg53GyT+doubO3rec=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 204,
  "timestamp": 1494398775038,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc",
    "vote": {
      "link": "%vxjUx7w6/2/WZgqIKUJh5lJhyMCxl/uR14yH3mnhXxw=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "ujN00I2WwmCyz+pW4eN/d7sIceAy7L9oF1gj0Y0LZCv0LunW7njMDtT51bEei54AyU72HC51ojgupBptQThBCw==.sig.ed25519"
}

{
  "previous": "%rT+pP/sYXtsgoeq7yNfJanYeUW/rUg7r5BIOnXgBe7w=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 205,
  "timestamp": 1494523676012,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "rust",
    "subscribed": true
  },
  "signature": "4nQQyrqEPDfFuxX6rXTyr6DdX76S3qHBnAbMgMciuSmRxNJ38lQ+Fm9ivTwncn+TQSWcZJXxMdsA7QHLqIWoCQ==.sig.ed25519"
}

{
  "previous": "%Rl8TUA26tMQ0h7yQV1dxH16ExzbBCyeINvSZjNKHcUQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 206,
  "timestamp": 1494523717111,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@EgnRlBtE37ZBnMQPwW1Z6BsakPUq0oVjn3bpdAqIeic=.ed25519",
    "following": true
  },
  "signature": "3dNqo8l+5TTvYGH4W/7Qr2yva28rOXW+G6SOPyXP7/UiVl6YIBQ52Pb9An295fAorSjfqcwEwBoYsAczDwWVAg==.sig.ed25519"
}

{
  "previous": "%6Jh2IbYf/DbznmBmiTNgKyoEVaLjqAc4T5U7TpRN3Cw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 207,
  "timestamp": 1494659919030,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%WU3gGJ0sUFngNZnutwtiGrnQ/6qyDf5UUBQLDUTMvYA=.sha256",
    "branch": "%9rHl+JHKTg814RZUYLkSQbDO1nSzT7J1vc3NpFtIlfc=.sha256",
    "channel": "patchwork",
    "recps": null,
    "text": "Please keep in mind that not everyone is a native English speaker. If I saw a \"vibe\" button, I'd simply be confused, whereas pretty much everyone with some knowledge of the language knows verbs like \"like\".",
    "mentions": []
  },
  "signature": "8+nzeHTzd0Eo3i0seLzG1yh6mdmVQJb0YSBMKc8lktUgy1sdrNSCowdcOz+P28u0QbeqBLN/F2crd4DDiby6AA==.sig.ed25519"
}

{
  "previous": "%y6zfb/7FYpm0e7531c+S5calLqpntjNsgLwHUS7t7eI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 208,
  "timestamp": 1495289596415,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "Some links for future reference:\n\nPackage managers in general:\n\n- https://www.youtube.com/watch?v=Bwk8mdU6-ZY\n- https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527\n\nVersion resolution:\n\n- https://research.swtch.com/version-sat\n- https://github.com/yarnpkg/yarn/issues/579",
    "mentions": []
  },
  "signature": "BgOAatIEbZPjWemgAQxVrTNnkimA1ek6e8OaEs0e02ebRJG+u0lBvj+WfAmcNEdnWwGcqUEmGjKdkUtA5Ra9BA==.sig.ed25519"
}

{
  "previous": "%Hfhnyhy/bv1+skGcKxjoCE03bwh0HtiW3DMF9DsbkCk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 209,
  "timestamp": 1495308330455,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Hfhnyhy/bv1+skGcKxjoCE03bwh0HtiW3DMF9DsbkCk=.sha256",
    "branch": "%Hfhnyhy/bv1+skGcKxjoCE03bwh0HtiW3DMF9DsbkCk=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "More on dependency resolution:\n\n- https://github.com/sdboyer/gps/wiki/gps-for-Contributors\n- http://0install.net/solver.html\n- http://minisat.se/downloads/MiniSat.pdf",
    "mentions": []
  },
  "signature": "j61fSlJMo6ZgITRVOnX3yPRxf2pEpxsZdMvU5UGvtj21m3y2chAAYo6LFg1Ea7DFtpOjfFtDOcZWUpB0Lrh2AQ==.sig.ed25519"
}

{
  "previous": "%9mykUw2bICPGgeXsoQz5xN2CF5/a1LqoS8gG6ttfa8A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 210,
  "timestamp": 1495484964453,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Hfhnyhy/bv1+skGcKxjoCE03bwh0HtiW3DMF9DsbkCk=.sha256",
    "branch": "%9mykUw2bICPGgeXsoQz5xN2CF5/a1LqoS8gG6ttfa8A=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "I may have spent too much time reading up on SAT solving...\n\n[Finite Domain SAT](http://www.d.umn.edu/~jainx086/Thesis_Report.pdf#page=13) is more suited then boolean SAT as a reduction target for package resolution. In FD SAT, there can be a variable for each package, whose domain consists of all different versions. To represent that *A@v* (package *A* at version *v*) requires either *B@v_0* or *B@v_1* as a dependency, add a clause *(A ≠ v ∨ B = v_0 ∨ B = v_1)*. This way, the clause is ignored if *A@v* is not part of the interpretation, but if *A@v* is part of the interpretation, *B* needs to have either version *v_0* or *v_1*. Since the number of available versions of a package is finite, all version ranges can be represented as disjunctions of versions matching the range.\n\nThis translation into FD SAT only produces clauses of this form, so a specialized implementation for version resolution could do some optimizations that a general FD SAT solver can't do. Whereas a general FD SAT instance is a conjunction of disjunctions of positive and negative literals over finite domains, a Version Resolution instance consists of a bunch of implications (dependencies) between disjunctions of positive literals (version ranges).\n\nIt should be possible to build a backtracking version resolution engine that uses the same key aspects of efficient SAT solvers:\n\n- [unit propagation](https://en.wikipedia.org/wiki/Unit_propagation) (whenever the range of allowed versions consists of only one version, chose it)\n- [watched literals](http://www.academia.edu/9255616/Simple_and_Efficient_SAT_Solving_using_Watched_Literals) for efficient clause checking\n- [conflict driven clause learning](https://en.wikipedia.org/wiki/Conflict-Driven_Clause_Learning) (where the learned \"clauses\" are actually packages, i.e. sets of dependencies)\n- conflict-directed [backjumping](https://en.wikipedia.org/wiki/Backjumping)\n\nThese are all fairly straightforward in boolean SAT solving, and I think they should all map well to exploring a version resolution search space.\n\nThe engineering-heavier part of SAT solvers are the employed heuristics. When trying to find the optimal version resolution, there is no reason for most of these heuristics. Since a package manager should use the newest non-conflicting versions, there is no need for a complicated decision heuristic, and no need for restarts. The only obvious places where heuristics could be used are the selection of which package to branch on, and for garbage collection of learnt clauses/packages.\n\nSo a version resolver that employs the basic concepts listed above should outperform the resolution code in pretty much any package manager, even those reducing to optimized SAT solvers. If necessary, the implementation can then fine-tune a package selection heuristic to perform well on existing package metadata. Also, there's always parallelization...\n\nOh, and I'm well aware that all of this is completely overkill. But it also happens to be quite fun (for a certain definition of \"fun\" at least).",
    "mentions": []
  },
  "signature": "A+2X2Y0q0ku8wN98ScrBR1YnFMMDMSx0VsZcfEYhhfXHdBoETvq6M3eBChQ9G85EQd9raRoSjwA6UBZfN0BlAw==.sig.ed25519"
}

{
  "previous": "%49LEsdv12YTjjQwqP+jSj61e/PXpEfhIz3lOWRo1EjM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 211,
  "timestamp": 1495485051402,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%MeSZyrRunExgMRgrmlAbY+9KEBtOisl2DM7YHgPnbOg=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "KPvhQ4xxpJq3S/mzOCYP5ONrwXH66uWI4Az/x1Ym14iiH2GrST9lLpb1tUfUwobpZ0YW222ceu1W38F+jBtTCQ==.sig.ed25519"
}

{
  "previous": "%Vvq86DxFfcRmub4STM82tzhPHLomjNf4jnkkL8VZjLw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 212,
  "timestamp": 1495553895367,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%KHu8Q4Gz96DpAvQW59YhN2DC8jT6qfMyQf9m0LdypHo=.sha256",
    "branch": "%TbpxFBSGt9mrsnzl57I/e8X34MV4eNJ1fvwQ52CKqdQ=.sha256",
    "channel": "new-people",
    "recps": null,
    "text": "Sign me up for any bikeshedding about programming languages. As long as it stays (mostly) objective.",
    "mentions": []
  },
  "signature": "aK7cTRt6/HaA9YkFyThAPqfBeto60/N1cHU/FW0WUBZfquW8+474eosJrmFsFjHsQXb029VAS29hzp2FslSQAg==.sig.ed25519"
}

{
  "previous": "%+ecD8M8dDoC8kpW+GvMViX1sv4MRCe86H9HvCHKwATw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 213,
  "timestamp": 1495554756685,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Hfhnyhy/bv1+skGcKxjoCE03bwh0HtiW3DMF9DsbkCk=.sha256",
    "branch": "%49LEsdv12YTjjQwqP+jSj61e/PXpEfhIz3lOWRo1EjM=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "The parent post sketches how to approach exhaustive search for a conflict-free solution. The really interesting thing is how to handle conflicts if multiple versions of the same package may coexist. If an instance can not be solved, the next goal should be to find another instance where one version of a package is moved out of the version-set for that package and into a new set. For example, `{A@1, A@2, A@3}` could be changed into `{A@1, A@2, Z@3}, at which point it might be possible to resolve all versions. If still not possible, this can be applied recursively. The interesting part is the choice of which package to duplicate. To keep things efficient, it should be tried to retain as much of the learned knowledge from the previous run as possible.\n\nThis part of the problem can not be easily/efficiently \"outssourced\" to a plain SAT solver, since retaining information across runs is crucial for an efficient solution.\n\nA corresponding boolean satisfiability problem would be: given an unsatisfiable formula, delete as few literals as possible (removing empty clauses in the process) so that the formula becomes satisfiable. Is that a well-studied thing?",
    "mentions": []
  },
  "signature": "LIVfRf5pJmhi5XYFwB9XzyCMi+J0VP97uIPwODBa6cHJHgihFjexuSUkqb368IGvxijH/v9sgy8yqBbkSuv7AQ==.sig.ed25519"
}

{
  "previous": "%gVALMgBeYMnW9Yv0Vv8u2PreyktirXgFtjpkzxzh+JI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 214,
  "timestamp": 1495817676920,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "patchwork",
    "vote": {
      "link": "%lzuuIGI4h/eDExwMfL4engn0SMRQ8/vIcRi8/drl9Y0=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "daHjn1KKlDjr96i324uuzlVdxc9LGvhXufpKg1B9djgfpBamJ7+UltjK/GCYP/82D8EkYhxf6eu6d7YAhPajBQ==.sig.ed25519"
}

{
  "previous": "%HmfXwQP+HST0aKuE/dSEzeX7dzvZBE5PDfwRLht1l5U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 215,
  "timestamp": 1495832595804,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc",
    "vote": {
      "link": "%j6Ym3Gb+/wK41nqZHhTpYPO5WoZY+lL2kv6zngWnzVM=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "sukbnfTAKn/dtH20bioj2y5+RBAeTsNQd1OGDIgBa7pDuFP/qHy0ikGAjOJpWGojRz1kX/tjYrl4V69/tutSCA==.sig.ed25519"
}

{
  "previous": "%JgjcmjK5F4Oz32l/6clL3OrLJq9vmoVACqocugTw2gY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 216,
  "timestamp": 1495956721020,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-show-and-tell",
    "vote": {
      "link": "%WZF68bGaDIdxFjhryCdpOEYW9jt9l25YhUihaWs1LpI=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "TLI+vXTYUOrH/QERDlSqf9mbe2l6XzrpdoAceB0Jq9XcGC7gk5fT61QmoE9pW9wqgb9G1F7TYhiDQ21NfzvECA==.sig.ed25519"
}

{
  "previous": "%LEIbdK1OYPfZy/ejkD3sGq2qWUKnEIBCspPVuLq8ayA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 217,
  "timestamp": 1496064292415,
  "hash": "sha256",
  "content": "8Qh2a5C4bf9IrjvlmhbGbRKaLgKTi9tb6QJosSC0SYqbiLHa1bhy4rpxgp9dyvaS3ZT5I3LJY22hrnTuna9kZ5uD9QCbrXCD3dctExAZc+XPdRQPulxcpMKHxhzSw4QfDTkV5PQCKzKLvYzY/QisAHMcrF9RTvsEq3xbfp7gVKhjm9JuCR6gijUBZkk+gW6G562igdoO8GqxmzWA+dBTlC1+IDRLXuU0M629T3UFFeWVu4Tf4X7ZoqtLB65f+ecWGVyw8oJBTlJI7Nm10OBqIbYqTxns+uverEEeSRuIFGSVfvm7bPD3ecC+KdgzRGatsJW/oCdr5Axbli5EmN3BEP+hWEEVnVgqtS56HkRUjwU54ArtS8nKh8xNZfcG1dhZt9C0nHiJIq2L1Yrz2oUFavJwW/B5nDMs96uEwudk2w96YaNvkXl5Ov0KN5NpU+rkUCREobets3vMxemPQ+cYJ1sn+QTrop00Fif7170+oY5bqKWOLGGP5SmRPV5WfDCmuKOrXkkzOOffcr4IwQ4cRFEv5Yjo9Ur/Zd+xuka8eWYsJbN40AdvHNz+17PVh0hztQtdmxSyV01dEDtiZAxBtIZQf+apCdDbh/uJQgKRqjTwqmD5BDt2ohq0cSBVDF15ChbpATjrG+4GAIe7XsVFNIOBcGYreh1x2xsxGqAFdANrqFy95+Z5q3Rq8HvWufqmtMtRhEFGqAGAFd+2tz+ZlI5KHzj8C/WzndebywaS/DMz+q1Ktefs3a/pfv1c5VvlecaBj1Gi1TrRsMPEwSZC8q044pFZc51RBYhI01diRidCjutaeEZ+H1n31yEXyv1/XcyeDCC75J2pywhJ9egefiJ8smKyGdAofXW+Aan+9VHY1JUUlQC6lfIIwQBKXSmT9R8Jo8a7VvIlZEF/6ekIUNIsFJK95r4WfOkDhhCgI1YxCuSKZXnhNRpOTLoeR5ho5XsHUQ9N0J7rGGUtlwzVlaLu5qssbvDzuibE7zudrwKUKDDGd2nIKG/z6OKOmmcNzNmRlhQf/es5HzkuQvUYaSrcQ2pOqr7Dt1PtS5lusH7/rBAjDNNwp4BUIIma8keFZUnagHGO0Dk9vTiilDosTQIFpzCkbykkMka7yrJSbYnTPQIYwkTYgMYHFoxU7iQSNqmsDlMikbOzNP6QPBH/hkM/7rQk81LGlS8cg/lWrwKaduDlRzOoEM7+zBl0f1aZuiVOwxoNZ2glDddm7+mAkeehaJhuAtLqtGYewOy7FFKqdIn1LJwSJe8KsU1IU0Da/qBDd2Ctos45GJZX5I5r/bCT.box",
  "signature": "lxi1bp8SOeBH8o50B0AxgBjYcx/uY+/grM3BKl+xmwTNfPyWAIJZgfV5F4nJ1xAyf9r7Ij9FHcucDG6DlOCqCw==.sig.ed25519"
}

{
  "previous": "%+rjVn/v4STehjHr8NX9ejuF+dBxFXzjK6hp1miAxb5U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 218,
  "timestamp": 1496139549756,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%RfQ2qb/wqQ/CfiwogMLFfNYJDwOFBe0+pZIP7yh6ANM=.sha256",
    "branch": "%eBd2Q7HhiQsbgCa35FGspUpvx0pAHUf3kYI1uikxqLo=.sha256",
    "channel": "ssbc",
    "recps": null,
    "text": "> Can we embed our own custom svg emoji also?\n\nEveryone please keep in mind that ssb is not tied to web technologies in any way. Rendering markdown in native GUI libraries is pretty simple, and so is embedding raster graphics. Svgs however require a dedicated engine, limiting the usefulness of lightweight clients (and by lightweight I mean something like a gtk application or a tui, not a browser tab).",
    "mentions": []
  },
  "signature": "drphTFDEDC2ST8OrMOutRN81AYd7HY2BivTL8kePneyfQY2n6v4YeN6NKqFxqtAGNZ31CQai4PEBBrSItXjRCA==.sig.ed25519"
}

{
  "previous": "%ORe0CrHvaiQEiy0sIa0bXVvpgvqGfoD0JHktO8aJ4M8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 219,
  "timestamp": 1496383670562,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%fXv6M90EYjIw+FdNMzfmvsJf9yhBCuT2qwYU9IQlULQ=.sha256",
    "branch": "%uX+MolQ45YFxqzLJ1saOFJjZTAMr+/4BKl3J3uCDw4o=.sha256",
    "channel": "ssbc",
    "recps": null,
    "text": "I'd argue against explicit hiding and rather for not showing unknown message types by default. Anybody can post any kind of (free-form) message, having to opt-out on a case-by-case basis seems unreasonable. And while something like `hidden: true` is a nice convention, there is absolutely no guarantee that all messages you might receive will follow that convention. Actually, there might be message types which are fully intended to be displayed - your client just does not know how.\n\nIn a dev-focussed client it might make sense to display unknown messages, ideally with a way to access the raw json. But for something like patchwork, the UI should probably find a better way to deal with unknown message types.",
    "mentions": []
  },
  "signature": "PQsX+t9b+Hk442QY+LJb7dtvP93zUF36OmgOkD68nW+hise10OMZeQngMMGZGbSyqLELq/XXjKi5kXmLCyV4DQ==.sig.ed25519"
}

{
  "previous": "%14Th+zLUFy84DOJ7qNH9a71hHBpuEU8xBx6Bw5P3iT4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 220,
  "timestamp": 1496389909439,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc",
    "vote": {
      "link": "%uP+FJz92rv6uq3Ko99f4/bRRKF/yY6k/YHcSKd1nvK8=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "2gkE3XwsKKy3wKMqDeToUFuEO2H3wWQNdZv78EZlXS2gk6ntsa8o5vy/IRXoizZ9s8ZzOfsl5JIvZM3Az2AeCA==.sig.ed25519"
}

{
  "previous": "%r9u0OHh8D3PUE5Z6I03sQDIeRjxLmzSujsjkBTg0xWo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 221,
  "timestamp": 1496472596607,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%18LXeE4r6WmdI3W6wgWg8gkFmh8YcBx/9PyP4dEIQaE=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "lQ7KtuP2FLQAyE9lSv8bBP3DGDu3Sdx9r9V+/XzsAtLRaakAFpEc3a38mCJmZlEPU9YA/u2AEKwXUgLIYjfKDg==.sig.ed25519"
}

{
  "previous": "%zrLjx5ZooU4l3tfwtUGYJRtHS/UowjQ6b+VrHOKHxCo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 222,
  "timestamp": 1496473590266,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "test",
    "text": "foo",
    "mentions": []
  },
  "signature": "hb01IEDw4g1zIGJD3joq08EdrJk5G79NBYwTCa0DHHQ39ZDA0yXx8MnudJRtlp7bsL9oS1uct6pjdZlAE599CA==.sig.ed25519"
}

{
  "previous": "%LZKFqyVMb/eIAvZ48ZZwx/YUy9PUhV9Fm0AVZkVFdmE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 223,
  "timestamp": 1496473697503,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%18LXeE4r6WmdI3W6wgWg8gkFmh8YcBx/9PyP4dEIQaE=.sha256",
    "branch": "%CJiQvOuEqjocen8J1Ndbs94CaBxycJj5w9W7ZCqKcRI=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": "I have a WIP implementation of secret-handshake in rust [here](https://github.com/AljoschaMeyer/secret_handshake), but it's far from working yet. I'm advancing very slowly since I'm learning the language while writing the thing. I've reached the point where I mostly understand the protocol, but your implementation certainly helps.\n\nProviding better documentation for the protocol layers is also one of my motivations (aside from having an efficient implementation available). I attached some of my notes I made while trying to understand the protocol. They are somewhat stream-of-consciousness and verbose (due to my lack of crypto knowledge), but maybe they can help a future implementer.\n\n[notes.md](&+kFZU3ab/l3Znc0wiTzXlWw/DwRCO+xg1bJPRRqzuGU=.sha256)",
    "mentions": [
      {
        "link": "&+kFZU3ab/l3Znc0wiTzXlWw/DwRCO+xg1bJPRRqzuGU=.sha256",
        "name": "notes.md",
        "type": "text/x-markdown",
        "size": 8335
      }
    ]
  },
  "signature": "esxonXy+a9VCMvFCsTOfNcRD5iUIBSxNxRjR+D+de+5vobaze2T22i+CFn5OtGza0dYvxxwBfFGMeR8rflyuDg==.sig.ed25519"
}

{
  "previous": "%d87jshM157J4wGUcjA2NJ/QjFN03OZHjH7gIl7Ydv2I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 224,
  "timestamp": 1496498141164,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%18LXeE4r6WmdI3W6wgWg8gkFmh8YcBx/9PyP4dEIQaE=.sha256",
    "branch": "%IvP2AOnKC45LKkktnG5m9qK1/5EO2gnhjRiwyhnP+Tw=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Yeah, between that and the binding author omitting functions he doesn't like I'm not really happy with the rust bindings. Also there are distinct types for each kind of key/digest/etc, rather than using type synonyms. That results in a lot of typecasts just to satisfy the compiler.\n\nBut still, the author invested a bunch of time into writing the bindings and I'm profiting from that, so I won't complain too much :smile:.",
    "mentions": []
  },
  "signature": "3Z2jWf0RCDeyqoyCEhZVKmNki+QzRFp4sVXNpzJWKGJkySniwGgkv6QHy7qWABDqVNCyeREP9HTMO7PAYLbDCg==.sig.ed25519"
}

{
  "previous": "%m8GqyFln9E5dVYa7CV6Oq9gm+ACvMiMeN25Z4S3kubg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 225,
  "timestamp": 1496580542553,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%vZCTqraoqKBKNZeATErXEtnoEr+wnT3p8tT+vL+29I4=.sha256",
      "value": 1,
      "expression": "Dig"
    }
  },
  "signature": "dP5y35F9kFv2WB6swN7R/jf/HxsRE+hD4T27RUX5Kx6CnHJ5RtiUjZXCz2TocJlupmuKExbl7qjZTV5IORfVDQ==.sig.ed25519"
}

{
  "previous": "%r3kX9dyMO6jgVUT4DAMiRJmgWJKpHYG73M1VfY7udus=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 226,
  "timestamp": 1496605706459,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "c",
    "subscribed": true
  },
  "signature": "Wv7y9wluJnjMnWRLIUFntJCedKhcunkb9xiPgsx3cq0dWTjkM7B6X+xGzMvKqWGryLulYzBEeIbWWMvbftSBDw==.sig.ed25519"
}

{
  "previous": "%/tVFOxv4ZqRODs7/Wl4Z9o5w14K3uZU6CMu6vpMk3Pg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 227,
  "timestamp": 1496684123961,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ssb-show-and-tell",
    "subscribed": true
  },
  "signature": "/ybSkrw+gDxSipYG8O3uQIHbPorrLjpm0SiiJka6ARLs+TfoapxRlKkNl64vutpEQw6DkgEPb7XW3ZcjF9zzDQ==.sig.ed25519"
}

{
  "previous": "%6zZcxUEckaOVP6Hy8hqOfcgggA3abrEGHoL4pT21i6c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 228,
  "timestamp": 1496687743018,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%3U6ofqJwaVhilGV7PVW329AQLYip1TChrHpI6Y4wed8=.sha256",
    "branch": "%3U6ofqJwaVhilGV7PVW329AQLYip1TChrHpI6Y4wed8=.sha256",
    "channel": null,
    "recps": null,
    "text": "Somewhat related: I wrote an implementation of the shs handshake in C (without the encrypted streaming, that will go into a separate repo): https://github.com/AljoschaMeyer/shs1-c\n\nIt still needs some cleanup (first time I wrote something in C), but it works.\n\nI started a Rust implementation, but realized I didn't write idiomatic Rust, but C with Rust's syntax. So I decided to write the crypto-handling code itself in C and then wrap Rust bindings around it. Anyways, this might be useful for those going down the C route.",
    "mentions": []
  },
  "signature": "+1JR4SX0InWUY/KCP/CpkgXCg+VJCN7RoTpO1gxI21srLKfFSdLKd3ucs4zRL+h3N0TXvdVfyTPnl2uc+7zhBw==.sig.ed25519"
}

{
  "previous": "%DpPCvJ6DkQkwIGIF/HOqfhF9qsPAlct6HHHHruX4T5c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 229,
  "timestamp": 1496688397294,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "c",
    "text": "### Stack-allocated opaque types\n\nSay I define an opaque data type in a header file like this:\n\n```c\ntypedef struct Opaque Opaque;\nint do_stuff(Opaque *foo);\n```\n\nIn the code consuming this API, I can not directly declare variables of this type, `Opaque foo;` does not work. Instead I'd need to add something to the API like `Opaque *create(int some_arg);`. But this means that all instances of `Opaque` need to be heap-allocated.\n\nHow can I create an opaque type that can be stack-allocated? I'm fine with leaking the implementation detail of the type's size, I simply don't want the API consumer to directly access the inner structure.\n\nI could define a macro with the type's size in bytes, let consumers allocate `char[SIZE]` and cast them to pointers to `Opaque`. Is that a reasonable approach?",
    "mentions": []
  },
  "signature": "V0iqneHIdJjfp8T1rokrLLL+Syrun6btlAHL/s/a/st0RQ9zSG/ArcoUomyUpHUxWLmlEUATStzSrts6+vHDAA==.sig.ed25519"
}

{
  "previous": "%JGu4cE7hxBih9O8YMXfvg7p9cpcluYmhUwYGqIl3cmw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 230,
  "timestamp": 1496736672085,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%3UhoVEx9t0sG1LxYq+EawUCQFSs33cWNgGa4dWH20uo=.sha256",
    "branch": "%KkRtjkUy9+Rsrv1TWLtpUoMP4UW7jDFTRlPxOHjopXk=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Not really about async testing, but I want to comment on this anyways.\n\n> This approach has many advantages when it comes to testing. The state is easily serializable, so you can store state in a file (json format) and use this to test other implementations.\n\nAnother point of view: This exposes implementation details that other implementations might not share. When I needed test data for [shs1-c](https://github.com/AljoschaMeyer/shs1-c), I actually wrote [my own script](https://gist.github.com/AljoschaMeyer/d8766ce2ee6bc8e1e20194567863f25c) to generate test data. This data only includes data that is visible to the outside, while hiding implementation details. The resulting data describes a set of inputs (client and server public keypairs, client and server ephemeral keypairs, and appkey), and all data resulting from a successful handshake: Messages (client challenge, server challenge, client auth and server accept), and outcome (encryption and decryption keys and nonces).\n\nFor test data suitable for any implementation, that seems like the better approach to me. And with more and more alternative ssb implementations appearing (or at least the protocol foundations),I think this is the way to go.\n\n> But the problem with ebt specifically that there is that well tested core, and then 2 more layers of glue,\nwhich are not as easy to test, but still contain races and other bugs.\n\nTaking a black-box, implementation-independent approach to testing might help with this. Although saying this is obviously easier then applying it to a complex protocol...\n\n---\n\nSomewhat far-fetched: You could take a look at how people deal with these problems in Haskell. Its type system enforces separation of logic and state (although the state management is usually monadic instead of [@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519)'s frp approach).",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "hzwDCHjPk7d67cjBkNju4aQn6GtXBhO1zVruIPCGkcKEW/l3wRo7eRxaB0omWbCqAKD5bK8L2kfymK7nyhu4CA==.sig.ed25519"
}

{
  "previous": "%lDasd8LpwBkRSjjnlXrdEA9duaUdoXlw/OvpVvGXT/k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 231,
  "timestamp": 1496787911991,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%JGu4cE7hxBih9O8YMXfvg7p9cpcluYmhUwYGqIl3cmw=.sha256",
    "branch": "%3NQXJTYUpV3/tDxGbdgh+clEfMTFcPfNKf9qcaoO8dQ=.sha256",
    "channel": "c",
    "recps": null,
    "text": "Ok, and when the type has no public fields, I could directly do `typedef unsigned char Opaque[42];` (if the implementation happens to take up 42 bytes). That should be sufficient to communicate that the internals of the type are private, yet the API consumer does not need to perform casts. That moves the casts into the implementation code, but that's fine as long as the API becomes cleaner.\n\nSo the implementation defines a struct `OpaqueImpl` and starts all functions by casting `*Opaque` to `*OpaqueImpl`. Is there a way to add compile-time checks that `sizeof(OpaqueImpl) == sizeof(Opaque)`?",
    "mentions": []
  },
  "signature": "6yHgvtpqtCdlbLxc2bmhoHfhPZsXDVBhUpbCvSWRwmVglOmrCqOwSHKvUjtTO4OeV4BPddoUdoZVBWQCjS6jAg==.sig.ed25519"
}

{
  "previous": "%iC3oSi4tKbd4lxBBwfB64mweolTQxcdYvrYREtDPehQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 232,
  "timestamp": 1496788050428,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@1+Iwm79DKvVBqYKFkhT6fWRbAVvNNVH4F2BSxwhYmx8=.ed25519",
    "following": true
  },
  "signature": "q+3hY1+aXNudAAap3x+tVPPCTIKokuDwLxFtbaFngPBish8Uel/jrSOMKFy673EN+RFCVSh3+X7+GsgI0H+mBw==.sig.ed25519"
}

{
  "previous": "%5geMXTR69RAO3OGVck8yyHUSPzP4Wv6drxx76c/uCmQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 233,
  "timestamp": 1496833184030,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "shs1-c"
  },
  "signature": "iPOzOGYYi/s1ALA4MvRnhVoBkr0G3cAQ6Nw8bFwwudtENK+CW5vuK6US+p1Rka111Q2A6L00XDzHSGuVYwcYDg==.sig.ed25519"
}

{
  "previous": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 234,
  "timestamp": 1496833410208,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
    "refsBranch": [
      "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256"
    ],
    "packs": [
      {
        "link": "&g1gGIgQxBa0SOH5L7880hkazmz5aVees13u/GzQbe4A=.sha256",
        "size": 48887
      }
    ],
    "indexes": [
      {
        "link": "&OyD2eR1jjWGf2fCeoAkg25wcHyZvn7ezbFJzdCOOi0s=.sha256",
        "size": 6280
      }
    ],
    "refs": {
      "refs/heads/master": "e9ef72a2960f88d164b8031dfc25ad148db1d115"
    },
    "commits": [],
    "num_objects": 186,
    "commits_more": 38
  },
  "signature": "B+kI5WMAhMICdqpq6DkXVHNrs6hW9d/MakP1vW/TeyVQnQN87UuoTrgzzNbRGtfXsAH9NYv0ShGzjeWVKrB0Ag==.sig.ed25519"
}

{
  "previous": "%5pxju4Y50gaKVYiYrkoaaRa9CJ9Gjh4cmNUqWjCHsRk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 235,
  "timestamp": 1496846716267,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%5pxju4Y50gaKVYiYrkoaaRa9CJ9Gjh4cmNUqWjCHsRk=.sha256"
    ],
    "packs": [
      {
        "link": "&SQswsvHYewcjp+UbAvopAx0JpHhJwxzclV0bRz4uIcM=.sha256",
        "size": 3179
      }
    ],
    "indexes": [
      {
        "link": "&OfDroGU2vgyL1X7kQ75woLgXJAc1oDYKyGoYsLqt0EI=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "faea92a57d3331640b1623d3ddc359301cdb653f"
    },
    "commits": [
      {
        "parents": [
          "e9ef72a2960f88d164b8031dfc25ad148db1d115"
        ],
        "title": "Remove dangling TODO",
        "sha1": "faea92a57d3331640b1623d3ddc359301cdb653f"
      }
    ],
    "num_objects": 4,
    "object_ids": [
      "9567429241361e8249c0ad5d5a4bdb0a61d54650",
      "11d3f5b3467d57f3eb633aaeb087dee371e2d56a",
      "d2b10bb7cdc0c8781a3045a33d3d78e0e701e506"
    ]
  },
  "signature": "dA+JlHsnSyHI4aldYCT+nL3cHTO27w6UquZ6k5kNoHzr5JiMEvgmc2ttHFc1L6UBHlTuTv37uF5zp+HHiEsiBw==.sig.ed25519"
}

{
  "previous": "%S1L2kX1QDrOIS9s36WSgDA5XCdGeVXVlvAcvI+C+Im4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 236,
  "timestamp": 1496855779577,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%S1L2kX1QDrOIS9s36WSgDA5XCdGeVXVlvAcvI+C+Im4=.sha256"
    ],
    "packs": [
      {
        "link": "&buzyPnkclqtyoYjF1VkeuaF7VfWLr3xWuEA880UH+ws=.sha256",
        "size": 7239
      }
    ],
    "indexes": [
      {
        "link": "&FiLT0aoK2pTDrtV8uwhvbZysyb5hOq0zP4lg9ZLHONg=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "b94535d29b494b72bad1537682bfbefb8ee0e80b"
    },
    "commits": [
      {
        "parents": [
          "faea92a57d3331640b1623d3ddc359301cdb653f"
        ],
        "title": "Use uint8_t instead of unsigned char",
        "sha1": "b94535d29b494b72bad1537682bfbefb8ee0e80b"
      }
    ],
    "num_objects": 7,
    "object_ids": [
      "a8951eda9cc0ed60e0848ece4e2b53eaef9b6880",
      "479c6170974d2f348d8c421fb6e39ee217db2707",
      "4261ca67c618bd638debfb5931baec61ff56ab0e",
      "1019f6b06554bd96af7a207452f2ed9cddb1cedd",
      "7f49e14a3e2a049c806f84d35cd209adaaa0d041",
      "00e9681c9966f6aebf1759f3fbc8b88c738bb76c"
    ]
  },
  "signature": "wGN9Z27i+cbbBFbz+KsVRgNa+uhizq/OeMyPP6cna5rQ5I7HJ3dHtKauqm9qT0YjN5XeGIgOMnw/dlU7+Q1/Bw==.sig.ed25519"
}

{
  "previous": "%ITHqbW8cmTf8rNKZEhgwIV/yRc4vJZwtdMde1aAN9Cw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 237,
  "timestamp": 1496858873810,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ITHqbW8cmTf8rNKZEhgwIV/yRc4vJZwtdMde1aAN9Cw=.sha256"
    ],
    "packs": [
      {
        "link": "&XbVF6hj4d5iG6CgRjGNUOFV01k6KHqXyCplqGWcFUCk=.sha256",
        "size": 1691
      }
    ],
    "indexes": [
      {
        "link": "&SI7y2JVplB04ULgsNqXyuc/770CRuCL1XpJJIdyMdU4=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "7c923f08d7ff4151bbb249c725171a8055dee8d1"
    },
    "commits": [
      {
        "parents": [
          "b94535d29b494b72bad1537682bfbefb8ee0e80b"
        ],
        "title": "Use array syntax instead of pointers in header file",
        "sha1": "7c923f08d7ff4151bbb249c725171a8055dee8d1"
      }
    ],
    "num_objects": 4,
    "object_ids": [
      "43332c61454577306b3c508c38d99a97dd38a3d2",
      "0bc63cf83999f9cf898b50daf2964094edcf26d5",
      "140e60bcb699c6d3b466eac04875e99f0834719b"
    ]
  },
  "signature": "uSZj57XtBYpfGDD/oezHnhmwSU1Kl3h6ncLdaLrZOHUg/6NDVGGG9959Y7CQNLgz3lqvnarNXsbB8mIFeW2uCw==.sig.ed25519"
}

{
  "previous": "%C29jPPU6kqKviNHotWXdLtd72T76soS8UCdtxVnWluk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 238,
  "timestamp": 1496872270373,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "box-stream-c"
  },
  "signature": "+ZAogLuB56RBpIF4ssBBjDODqPSdCYbiSpatdQxwDXSQQh/ULMNf3Hvw3iyNp9TMeoSfmv2TbVu1Esjv/SJLCg==.sig.ed25519"
}

{
  "previous": "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 239,
  "timestamp": 1496872276902,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256",
    "refsBranch": [
      "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256"
    ],
    "packs": [
      {
        "link": "&wa6Hjg4Jk5EBX0KlYjkACp57z3zogicmWCzFdrYRnP0=.sha256",
        "size": 15757
      }
    ],
    "indexes": [
      {
        "link": "&niXHNaTiuSizF6DeGYuXRSrFyemH/RrgyfUx3NO54jI=.sha256",
        "size": 1660
      }
    ],
    "refs": {
      "refs/heads/master": "f1f85a88d64d8ba2135fd340993b1246f6b994a0"
    },
    "commits": [
      {
        "parents": [
          "8c64503ef52389193345a87b0991aad4983f630b"
        ],
        "title": "Explore decryption part of the protocol",
        "sha1": "f1f85a88d64d8ba2135fd340993b1246f6b994a0"
      },
      {
        "parents": [
          "941f23df114933893174333e458b3a973d692d94"
        ],
        "title": "Explore encryption part of the protocol",
        "sha1": "8c64503ef52389193345a87b0991aad4983f630b"
      },
      {
        "parents": [
          "cad2658aa5a3eb68c0383d5d37f97e7fb07ef2fa"
        ],
        "title": "Fix oversight",
        "sha1": "941f23df114933893174333e458b3a973d692d94"
      },
      {
        "parents": [],
        "title": "Initialize project structure",
        "sha1": "cad2658aa5a3eb68c0383d5d37f97e7fb07ef2fa"
      }
    ],
    "num_objects": 21,
    "object_ids": [
      "eb41a7f37a251cbfb7b6009d65a510ad8d62b330",
      "110080c1da1a51abfad9111d16b7a6846bee5157",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "d398c0d1b2f3b9058c060a424a37e6d4848bbe06",
      "df96b4dbfcd41a1c1e2be064b3086922e508bae4",
      "77e0c1653b6658937380e91d96ecf9f21552468e",
      "deb19bfa08f94ab7a50c6161eab73caaac05c84d",
      "5f6f1bcc58f9c6260df00d7556042e69e6436593",
      "77e98a59e190ce51ab7ec86deb24492d1434247e",
      "eaea713951ab0a7d2b8b5545f35cd6b0fdd2d247",
      "68bbb8949ac551a6c90ce47a326a187f95dd6942",
      "5f94496fed29fec1e0ee7d477d3c678aeafdc64a",
      "4793c5cb26f0699b8d1c5045f25a3ea1a2121f7f",
      "63cd4773ab8f7c496118ba25a631bb69b22901d7",
      "c1b9e0acf66afb41b576372260ab816d6e7bdefd",
      "f9d689bdf19068fc4ec5bd934e68f7c477ec8991",
      "8265061f2fcb03532aa73b8f709a55f1fa05f297"
    ]
  },
  "signature": "bPnCr07SBaDqiOIFDhTYcpey+47UdOKwXmLL+c175LvUJ7qvsVFl4xqarTZuvRXgvA81QEXWCGmYziOLpxfhAA==.sig.ed25519"
}

{
  "previous": "%XvdXmU8+IEyiTZZfFlu7xaOB6RjQVr/c4sS64mHELrQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 240,
  "timestamp": 1496932007136,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%drdr/xnmBSHPGqMGUJr7heIsMt5dBzPj3HgkQdMUaiY=.sha256",
    "branch": "%drdr/xnmBSHPGqMGUJr7heIsMt5dBzPj3HgkQdMUaiY=.sha256",
    "channel": "anarchitecture",
    "recps": null,
    "text": "As for package management on ssb, there's some more reading in [#ssbpm](#ssbpm).",
    "mentions": [
      {
        "link": "#ssbpm"
      }
    ]
  },
  "signature": "TRYiHfk7LwH+m6Ue/kFvDIyzehjWpkzMI1CVEHaS4yWW1drSV+TwLSenSbBkorVQmEaG72cnzUGbl7vWlwXmAA==.sig.ed25519"
}

{
  "previous": "%z8dus/E5yraaHWK1DY/TgzPW8UzGpuqAYa20mvsVVX4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 241,
  "timestamp": 1496995668513,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256",
    "refsBranch": [
      "%cqNsbp8llSPSqVJQUHKZwX5XFoZWsG4DhGm1pjVwBsI=.sha256"
    ],
    "repoBranch": [
      "%XvdXmU8+IEyiTZZfFlu7xaOB6RjQVr/c4sS64mHELrQ=.sha256"
    ],
    "packs": [
      {
        "link": "&MBhK3oH0VIFcUJmtF0H2kfq94mLpPfpbVRr2NzHzfqk=.sha256",
        "size": 2265
      }
    ],
    "indexes": [
      {
        "link": "&5VeVzqv7iI/9cc+doLiWquZ951WH1vzTC3r2Ovb2pdw=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "8d33f70ec20fc8b0ab71070ebf784e9adcfbcbc1"
    },
    "commits": [
      {
        "parents": [
          "b02e47a269ef44d60034576b41802d4b27d97d84"
        ],
        "title": "Implement API (untested)",
        "sha1": "8d33f70ec20fc8b0ab71070ebf784e9adcfbcbc1"
      },
      {
        "parents": [
          "f1f85a88d64d8ba2135fd340993b1246f6b994a0"
        ],
        "title": "Write API",
        "sha1": "b02e47a269ef44d60034576b41802d4b27d97d84"
      }
    ],
    "num_objects": 8,
    "object_ids": [
      "08e48f3cccdb899a806acb8ea184a2f0528ca6c0",
      "68941b592f6314f8ae2d212e549f8341099f9248",
      "c8123d475811e46b19c779c4f8542dc5da46507f",
      "8903426ccfe4c00c46ea79d86d0842be1b5d06a1",
      "52f9b67f86818aca7a7ea7bfabcffce6e63887e7",
      "d6e65c778d08729e24457c2d65efe4b453bf8080"
    ]
  },
  "signature": "U3dHxvbV68qDQr+XepfQqsYHXxa67hCf8PvaIdiXe22QqZrunw7f0JhqJdg5Ni3NgfiRx4iQW+Qk/O6QHPYIBw==.sig.ed25519"
}

{
  "previous": "%LkbmnTXAS7YqAZAdd3ORXOtEThvAb1O8ZavZqOOLUYc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 242,
  "timestamp": 1496995954831,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%cqNsbp8llSPSqVJQUHKZwX5XFoZWsG4DhGm1pjVwBsI=.sha256",
    "branch": "%7qnSdv0n3YRc95oq4qWKDpdxQrDZuNwSJOOD+ZcUFak=.sha256",
    "channel": null,
    "recps": null,
    "text": "Thanks. I'm not getting the blobs right now so I can't look at it though.\n\nAnyways, I already changed that routine in my local version, as well as adding a nonce_decrement function. That way, one nonce should be sufficient while having the same number of arithmetic operations. I just didn't push to git-ssb yesterday.\n\n[Current code](ssb://%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256) ([github](https://github.com/AljoschaMeyer/box-stream-c/blob/master/src/box-stream.c#L12)) looks like it should work, but I have yet to actually test it.",
    "mentions": []
  },
  "signature": "AUElCtKUEXhpc00qzPzAKkEX0IfEHUbjP3JftZlLZEM21pSzM1uCSV8dodHgwBKbRfo5997Ip8ORtAqu55vOBA==.sig.ed25519"
}

{
  "previous": "%tZnzRRa6ApriMPsoY1eoBt7IA+iEkS/23uiwIecE6qw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 243,
  "timestamp": 1497017840192,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%LkbmnTXAS7YqAZAdd3ORXOtEThvAb1O8ZavZqOOLUYc=.sha256"
    ],
    "packs": [
      {
        "link": "&Fe+QyK449sKRS7g1XEHHI+NV7Wpr1f+MnWj5puAt0bc=.sha256",
        "size": 3620
      }
    ],
    "indexes": [
      {
        "link": "&kEvBVJSKyZ6mKONrOoqnFiZUHeT7VIjdKCpeUwCSjms=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "0c906cfce854ee0e9e3a8765bee2f19b230b202c"
    },
    "commits": [
      {
        "parents": [
          "8d33f70ec20fc8b0ab71070ebf784e9adcfbcbc1"
        ],
        "title": "Add some tests and make them pass",
        "sha1": "0c906cfce854ee0e9e3a8765bee2f19b230b202c"
      }
    ],
    "num_objects": 6,
    "object_ids": [
      "4a67bdabf3ab21bf64961e576fedcfa1959c5ed6",
      "548aef96f7a4875f2e7b9d5d958daba435cfd605",
      "ab09da576c7ea3fbf2ef91247dd5bd7a2373619e",
      "be150fc8c5702362ee16caa9680b7ae7124d3bff",
      "f4c5ca31d4233e413cd512e4deb86ba66fb9f565"
    ]
  },
  "signature": "oKT0RtpSqdgs/IEpIRBb8QnIWEsx5n3ryoiBREBTQh1ZE5mJYxA2S6cFaKFDmxmdhWuWzmJ5m+2ler8nFY9YAg==.sig.ed25519"
}

{
  "previous": "%kTnyhk4g/nWThIgJfKz6UwTMUwRabz79BxuMtMBKN9E=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 244,
  "timestamp": 1497019874743,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%kTnyhk4g/nWThIgJfKz6UwTMUwRabz79BxuMtMBKN9E=.sha256"
    ],
    "packs": [
      {
        "link": "&AwfofJSVZ2hKlhmMydQr58d1s5ENYM0HaP4RbsVdjcM=.sha256",
        "size": 3613
      }
    ],
    "indexes": [
      {
        "link": "&DUC6dnwLn1wI+4x+h6tMOxfIVMZIHrHduNKGvXj2j4M=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "940d65cc93a4a7f92a20ff77b645e83efd4bf3d0"
    },
    "commits": [
      {
        "parents": [
          "0c906cfce854ee0e9e3a8765bee2f19b230b202c"
        ],
        "title": "Add a PLain_Header type to simplify the API",
        "sha1": "940d65cc93a4a7f92a20ff77b645e83efd4bf3d0"
      }
    ],
    "num_objects": 6,
    "object_ids": [
      "6af8a730ad8a8e4c52712a6f3419a42bc878bb59",
      "9ab403efab6139f99633f1d73c0ce21400b3d58e",
      "95d12c2f7fe38d931934b9d64ece49036ca97389",
      "5187a06eb083765767d5c15a79e81aa7b6a1b7a7",
      "dd5b55a3658e1baab488ccdeda00d6b755f668ac"
    ]
  },
  "signature": "/oM5/S6bX3Xb/BePehEnJHiUihlkETHMXRxHp/ICloC3rrNJsit8SJt+eJdT18SgDWH4BFZSORi04cuZRxceCw==.sig.ed25519"
}

{
  "previous": "%9ND2Ya+Dog2GHXvQUpyqv4tVbTVKukic+xdup+MWRCM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 245,
  "timestamp": 1497026229910,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%9ND2Ya+Dog2GHXvQUpyqv4tVbTVKukic+xdup+MWRCM=.sha256"
    ],
    "packs": [
      {
        "link": "&dM3zAWEs49ZkmOvGATbslZ2kQ5vUuKb/xxs7QZ+n8ks=.sha256",
        "size": 5924
      }
    ],
    "indexes": [
      {
        "link": "&BfrqBSVfU9QdCM9j+eGKWsJXtVqr74EpffRGXteo+DY=.sha256",
        "size": 1800
      }
    ],
    "refs": {
      "refs/heads/master": "ecef5f7fd856b9a516a0888b08432d7af13630a2"
    },
    "commits": [
      {
        "parents": [
          "b5675e8fe7a44d2e221325a20c96e69dc55b4c6e"
        ],
        "title": "Add example",
        "sha1": "ecef5f7fd856b9a516a0888b08432d7af13630a2"
      },
      {
        "parents": [
          "0054b96d913278fa11bf21c1230fff980b04ea5b"
        ],
        "title": "Remove print statements/functions",
        "sha1": "b5675e8fe7a44d2e221325a20c96e69dc55b4c6e"
      },
      {
        "parents": [
          "0d4bab17f8fc2efa50419cdf454625543a0702c6"
        ],
        "title": "Add 'bs_' prefix to API functions",
        "sha1": "0054b96d913278fa11bf21c1230fff980b04ea5b"
      },
      {
        "parents": [
          "db4832acf66d7a8f96776b32772ced7745d1aaec"
        ],
        "title": "Add missing tests",
        "sha1": "0d4bab17f8fc2efa50419cdf454625543a0702c6"
      },
      {
        "parents": [
          "940d65cc93a4a7f92a20ff77b645e83efd4bf3d0"
        ],
        "title": "Add inplace decryption functions",
        "sha1": "db4832acf66d7a8f96776b32772ced7745d1aaec"
      }
    ],
    "num_objects": 26,
    "object_ids": [
      "2724bb2bc0a0c8862bdcef8b203eae38782a3928",
      "f74c18fc6302698bfc62b1942bcbd8e7decdfc78",
      "ea4c7e77f72c3a2c8846f7467e5da6043a429376",
      "ee7cc033d3c789e8ad00647e92e100df0738a748",
      "5fe8cf10157cfcb79d8ad3a97c5d0dddcd1c6822",
      "21b0856c2b7f7aa90dd98942d4a8c429c3053a82",
      "c6fd0d913fee341a8cec1b08459fd9aaea31ae71",
      "5f9b6f3028182279824a0f8666107f5e5e510a70",
      "87cee4e9219ddbd778a46482ea3e21fd214433d4",
      "01b4a0fdfa751cb87383d872af900ca107e1c185",
      "c40390db4d4342c8925769d58e2821482d2fbd74",
      "70b786d12ed055a08b57f5cf47f717bf6a266301",
      "aa10e5f604a7485d78b754cab7631a1ed84442ca",
      "b37f5dc95def1f17b757d02f5db2efc272e573f2",
      "6e37c566cde0e34e31d536965602cb3439d17697",
      "8abc33d3fa1c3014fde497eea6bb0a3c27e10064",
      "1ffdf6ff8f9d70916cb7c9411141cb43f93c1635",
      "ade784a000e35b05504987d45407c47671b9c513",
      "bdc7ed5a29233b4f827bbc45317eb444ec5e16da",
      "e7fcc23d959feadfaa936c45642992f464fd4146",
      "658159136272c0783479c503b74ae8756598e9d4"
    ]
  },
  "signature": "tXzAcN74YLO7e+oGd9AKkCOxRT4HdYleecaO9GyhfukVVQmFRzTx46u8H1E4e31Kb5w0dWUm50Mqz5v4blULCw==.sig.ed25519"
}

{
  "previous": "%w34SM3bHvrjWlEzFN4ArYsocylx9BsjgalyAPQkPZyY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 246,
  "timestamp": 1497026468965,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iLUHyxFuX4IC8v1kk6VAdw95//dQexR45B4QjcDvssI=.sha256",
    "branch": "%iLUHyxFuX4IC8v1kk6VAdw95//dQexR45B4QjcDvssI=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "There is [this list](http://scuttlebot.io/apis/modules/ssb-client.html) of js modules. Anyone is free to add their modules to it, but people don't always remember to do so.",
    "mentions": []
  },
  "signature": "8cKVtCS3k5biuH56BdP/5NqmXpoc+9e1ipq+xyenBjhrfdVTOSVoKkZf0ubBqc+OnYNbtBMDxfxkA2Kj3UESBQ==.sig.ed25519"
}

{
  "previous": "%4Mzj69gdb0p4H4jMc0z4jvskerdvprqoSPTK4EiY0jM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 247,
  "timestamp": 1497027177391,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-implementations",
    "text": "There are a few efforts under way to reimplement ssb or parts of it in programming languages other than javascript. This channel is for sharing links, updates, problems, questions, documentation etc.\n\n[@Vendan](@wLinNWXMCITML7/3DyVrcQvhVuit7rQehPJdXlsyuVU=.ed25519), [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), [@ub|k](@1+Iwm79DKvVBqYKFkhT6fWRbAVvNNVH4F2BSxwhYmx8=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519)",
    "mentions": [
      {
        "link": "@wLinNWXMCITML7/3DyVrcQvhVuit7rQehPJdXlsyuVU=.ed25519",
        "name": "Vendan"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@1+Iwm79DKvVBqYKFkhT6fWRbAVvNNVH4F2BSxwhYmx8=.ed25519",
        "name": "ub|k"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      }
    ]
  },
  "signature": "kDXr+ijYjOJWkznUAVom332cuKAQ8G9xGQGbwt0j17xo+V0HAbGD0uKPsHucleV9qQn/D+vko38e3rH088K7CQ==.sig.ed25519"
}

{
  "previous": "%AG9jWdlA4iU+lt91QX3DkbGipWiBpFjOF9LuCGkk9cI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 248,
  "timestamp": 1497027181168,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ssb-implementations",
    "subscribed": true
  },
  "signature": "eB+dkbL9kJLdBf7ap/qAiqKpPALZmCYoB/yWbOUSPayFLdxMgRgXde6gTUO2WN6SvCczGrgDq0lMUwkkqW1RDw==.sig.ed25519"
}

{
  "previous": "%8SvWc6LGmzjHSBbPkJ5rY5RCejkWvQKH63pXLlWGjK0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 249,
  "timestamp": 1497027664947,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-implementations",
    "text": "### Crypto protocols in C\n\nssb is built upon custom crypto protocols: [secret-handshake](https://github.com/auditdrivencrypto/secret-handshake) for setting up connections, and [box-stream](https://github.com/dominictarr/pull-box-stream) for encrypted communication. The reference implementation of secret-handshake does not only perform the handshake, it also includes further encryption using box-stream.\n\nI reimplemented the crypto logic of the two protocols in C: [secret-handshake](https://github.com/AljoschaMeyer/shs1-c) and [box-stream](https://github.com/AljoschaMeyer/box-stream-c). These implementations don't do any networking, they just provide a low-level API for encryption/decryption.\n\nNext, I'm going to write wrappers for these implementations in Rust, together with higher-level interfaces (both synchronous and asynchronous based on [tokio](https://tokio.rs/)). Then I'll do a module combining the handshake and box-stream (just like the secret-handshake js implementation already does). And when that's done, I'll take a closer look at [muxrpc](https://github.com/ssbc/muxrpc), the protocol used by ssb.",
    "mentions": []
  },
  "signature": "U5+Tf5Tu68P8Zvv/KrGHirzlyTqRQuKEn6MVU+xoD8Fli6DK11WduHVYbKiIGz+MqLbCXa+lkjmicpUOixp5Ag==.sig.ed25519"
}

{
  "previous": "%mU6j+dMrigKfjnXzbKiiJE78aeewAoAow20oDJOE8pk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 250,
  "timestamp": 1497027957888,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-implementations",
    "text": "### Implementation References\n\nSome references to information useful for implementers:\n\n- [collection of links](%lzuuIGI4h/eDExwMfL4engn0SMRQ8/vIcRi8/drl9Y0=.sha256)\n- [short summary of the overall architecture](&+kFZU3ab/l3Znc0wiTzXlWw/DwRCO+xg1bJPRRqzuGU=.sha256)\n- [details on muxrpc](%44PFpT8G9dHtI2v4BtBFRYyhiZV3sbpwd2x2ilrguGs=.sha256)",
    "mentions": [
      {
        "link": "%lzuuIGI4h/eDExwMfL4engn0SMRQ8/vIcRi8/drl9Y0=.sha256",
        "name": "collection of links"
      },
      {
        "link": "&+kFZU3ab/l3Znc0wiTzXlWw/DwRCO+xg1bJPRRqzuGU=.sha256",
        "name": "short summary of the overall architecture"
      },
      {
        "link": "%44PFpT8G9dHtI2v4BtBFRYyhiZV3sbpwd2x2ilrguGs=.sha256",
        "name": "details on muxrpc"
      }
    ]
  },
  "signature": "crjf6eKrZT4RLrYqdj5obUgHd6PFv+5BaR8qKyCa6fTSNRJRZspDq17BLIkfvrRdMPkTJE3UnDFEl9Ws+UqQAA==.sig.ed25519"
}

{
  "previous": "%1/l7r2YdL0EOmSTK8k+6ZwrrEHAnhXxa0bIE502JD9I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 251,
  "timestamp": 1497042801756,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%cqNsbp8llSPSqVJQUHKZwX5XFoZWsG4DhGm1pjVwBsI=.sha256",
    "branch": "%tsj9lWJQQPNjmbUClrKSnEFlv0ZAE3VYSSkJI3AH8Tg=.sha256",
    "channel": null,
    "recps": null,
    "text": "Yup, the current code passes the tests. Unlike the other implementations, it only uses one nonce, which is decremented once during packet encryption. Same total number of nonce arithmetic operations as when using two nonces (`inc, dec, inc, inc` vs `inc2, inc1, inc1, inc2`), but less memory.",
    "mentions": []
  },
  "signature": "VwTrqb7U5zaEsTFbdWrjIXFZ0FpcubOVQLTe10Q5c3TLYYPZtXeyOOnk0XwnEi4rsVkTesZUpMMSCQeDJ5goDQ==.sig.ed25519"
}

{
  "previous": "%Ht7K7zavgiURYfZKcPAvBBpserOCTMPkLCMiNoIWTB8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 252,
  "timestamp": 1497083260898,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%YCHmqr71jh+PhlksiXndbDJ3Pqq80lkr+6mjaoMeLzE=.sha256",
    "branch": "%X4a66693vdpqZc9Fc+3g8jGEyb57/uyA7AdlV+3KT+g=.sha256",
    "channel": "ssbc",
    "recps": null,
    "text": "Related work: [ipfs ahdnling of links](https://github.com/ipld/specs/tree/master/ipld)\n\nThe ipfs guys define a general standard for following links from node to node. Something similar could be done for ssb messages. URIs could then simply correspond to such a format, e.g. by url-encoding it.",
    "mentions": []
  },
  "signature": "RPkSvuFk3UXnhdixiyZ/KJuAqM83wZW3KA8e8BFOSyFkALaeo5MiuULvBghI+Dlux1jybkOmjY4YTU1vWh6sCw==.sig.ed25519"
}

{
  "previous": "%VT6++Fimku1mYlHWExE/ncW9QB/hIkiHesbA319IQUQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 253,
  "timestamp": 1497083747544,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%cqNsbp8llSPSqVJQUHKZwX5XFoZWsG4DhGm1pjVwBsI=.sha256",
    "branch": "%Ht7K7zavgiURYfZKcPAvBBpserOCTMPkLCMiNoIWTB8=.sha256",
    "channel": null,
    "recps": null,
    "text": "Just out of curiosity: Why is the header encrypted with `nonce + 1` and the packet with `nonce`, instead of the other way around? [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "wp4LDmGC+P6UsLLzMft5u3Xkss1MmQLWljRDu9/SvMU1mFAtf9VktYdIHvkNX8ByB+eInuq4+AkfzeLuSamaDg==.sig.ed25519"
}

{
  "previous": "%G20evLz4oYhwrBo39CZ2bWkXH9+GqXQxFVVI/Z4l3ec=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 254,
  "timestamp": 1497085576135,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%cqNsbp8llSPSqVJQUHKZwX5XFoZWsG4DhGm1pjVwBsI=.sha256",
    "branch": "%G20evLz4oYhwrBo39CZ2bWkXH9+GqXQxFVVI/Z4l3ec=.sha256",
    "channel": null,
    "recps": null,
    "text": "Never mind, if the encryption order changed, than the same dance would need to happen during decryption.",
    "mentions": []
  },
  "signature": "GbkaC6XABFsh/tVA1Qqz9Kj08Yvb4XXdv1VUKLHXblDakpQlUrtn0NbE9KWEhw26qWtBmJkX2ER7wjniKWXMBQ==.sig.ed25519"
}

{
  "previous": "%OBGVZ2LnK0GirP9J68MbYYPA9SMh3HSlZCGciIgF5xs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 255,
  "timestamp": 1497087083694,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebutt",
    "text": "### Changes to technical details\n\nThe evil twin of [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519)'s [wishlist](%9W+HJ7fPvNF8sxzJAVht/rx7zx/l3QS4e0EEv2wIui8=.sha256): a list of technical/implementation details that I'd like to be improved - and that I'd like to work on. I'm sure [@Sybil](@rFgDtlYiyymSD4U96Av3pIil8xBj6afLXr87caoqAyo=.ed25519) also has a thing or two to add. Collecting these in one place could help to decide how these can be introduced in a backward-compatible way.\n\nAs I work my way through the [ssb stack](%mU6j+dMrigKfjnXzbKiiJE78aeewAoAow20oDJOE8pk=.sha256), I'll probably find more additions to this list.\n\n- secret-handshake: [actually implement the spec](https://github.com/auditdrivencrypto/secret-handshake/issues/7)\n- binary muxrpc\n- messages:\n  - binary encoding\n  - size limit as maximum byte size  \n\nSome more opiniated points, feel free to ignore these:\n\n- use the [ipfs multiformats](https://multiformats.io/) instead of ad-hoc approaches (e.g. for message hashes)\n- increase message type size in case larger hashes become necessary\n- use [hashes](%NR/ESRtxiPouBbhYt28/tsaHY5CuztMqLW46t2HIWBs=.sha256) instead of free-form message names (hashes could be binary-encoded multi-hashes)\n- feeds should have a \"type\", just like messages (again, preferably hashes)\n- content-adressable blobs, or simply no blobs and delegate to ipfs\n\n- in general, steal more of the ipfs formats, whether it's (de)serialization, adressing, hashes etc. They put a lot of thought/effort into both efficiency and nice interfaces. And there are js and go implementations available. Both projects profit if we share code where possible.",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "%9W+HJ7fPvNF8sxzJAVht/rx7zx/l3QS4e0EEv2wIui8=.sha256",
        "name": "wishlist"
      },
      {
        "link": "@rFgDtlYiyymSD4U96Av3pIil8xBj6afLXr87caoqAyo=.ed25519",
        "name": "Sybil"
      },
      {
        "link": "%mU6j+dMrigKfjnXzbKiiJE78aeewAoAow20oDJOE8pk=.sha256",
        "name": "ssb stack"
      },
      {
        "link": "%NR/ESRtxiPouBbhYt28/tsaHY5CuztMqLW46t2HIWBs=.sha256",
        "name": "hashes"
      }
    ]
  },
  "signature": "d5YJdHQeaOmN6o9+kTcJKpOcpPLQ83y3c0gwxKLJ946jpdRer2v/B++3R03LuBYVq7eGRNRG1GYwSqw3FTcGBQ==.sig.ed25519"
}

{
  "previous": "%ewQsrk9Bw0+a3E1IzJP9/wee3jCB4mZWzmCV+Lp0/l8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 256,
  "timestamp": 1497109575618,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256",
    "refsBranch": [
      "%BtizwM5OBbv/3Hf3TWYPiXie+QMayNajreNNbFnW62g=.sha256"
    ],
    "repoBranch": [
      "%w34SM3bHvrjWlEzFN4ArYsocylx9BsjgalyAPQkPZyY=.sha256"
    ],
    "packs": [
      {
        "link": "&Obi6/4rT4LF3SM44/vGkAp/WzR9N/QOj34DR/ehWb3M=.sha256",
        "size": 1325
      }
    ],
    "indexes": [
      {
        "link": "&0TxSXOtU/vRWO/NmryhM6VqFxUgJY67/7ZhUi9tsJj4=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "99a80e63c72818659416ff1bacbdedba43159c50"
    },
    "commits": [
      {
        "parents": [
          "ecef5f7fd856b9a516a0888b08432d7af13630a2"
        ],
        "title": "Fix typo",
        "sha1": "99a80e63c72818659416ff1bacbdedba43159c50"
      }
    ],
    "num_objects": 4,
    "object_ids": [
      "3f30280aa76f057f7746a1268be44831131ecd8c",
      "ac8049f3a6f301c7c6d00880dcabc7a3b1784653",
      "6df7ba0cb7c1587e76ab9d61e6558d62cf15b79d"
    ]
  },
  "signature": "fEJQKnjPy/tcITb2Qc4+OZe/5ffQCph5PI0dddd09vLL2zGjTD3l9WwQlhv4Vu6VWFA5yJLy+IMSkghe/8ynBQ==.sig.ed25519"
}

{
  "previous": "%DzXm/OkMAfDnBIZphdRLiJ4Hr+tbCTy2QNd/p3CLuAc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 257,
  "timestamp": 1497109617329,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "box-stream-rs"
  },
  "signature": "toX0wWAcdHpmdzf1SlqxK4tHHmuxbMxFREwYSaJAlPMAKEXWlts0+dFzBJyvNrlYFY7Kok9+ZJCCvs4hWsOUBQ==.sig.ed25519"
}

{
  "previous": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 258,
  "timestamp": 1497109622815,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [
      "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256"
    ],
    "packs": [
      {
        "link": "&LbzbWSG7LB2YSlB3xN7jG+tkzYlsKpt/UGfgeJKZaV4=.sha256",
        "size": 3618
      }
    ],
    "indexes": [
      {
        "link": "&dluPMuuqa76Gmz0BQOnHEYupyjwPH6SBngWWkKsgFEw=.sha256",
        "size": 1520
      }
    ],
    "refs": {
      "refs/heads/master": "eacb2a94cc54d612edfaaa0c574752cec7b6af60"
    },
    "commits": [
      {
        "parents": [
          "5043043d2805bd4df6619535c3ab72271b4fe29d"
        ],
        "title": "Add raw bindings",
        "sha1": "eacb2a94cc54d612edfaaa0c574752cec7b6af60"
      },
      {
        "parents": [],
        "title": "Find a setup that compiles and calls into the c code",
        "sha1": "5043043d2805bd4df6619535c3ab72271b4fe29d"
      }
    ],
    "num_objects": 16,
    "object_ids": [
      "f2cbdb5cb7cfa38c572cbcc2ae7a7e848b42a437",
      "4308d822046df995d72605f3497d02ae5ae307d8",
      "aa428e448bd88ea118d45b2c6594f939126218d2",
      "9b1a982400a36fd8eceafb7faf07a1186b339e46",
      "f625e3af180aef659717ddbfc85571e479fb5beb",
      "fd9026e4908c4b814201d8aa6e1a316aadd6a77e",
      "42762bd27c248849ca7b2d24a2b4a2edf08392b7",
      "038e22d15d78b159a104863b2f6f10e736a61cbf",
      "79104aedf8c3af687f07331ec6dab567bdb23d91",
      "7988b2e4e2d32de263b527d14ea3645dbbfd16f2",
      "8f4d413a943d31a35c862f46917db7fb72c69c6f",
      "57ab17f6bf38c9d299531aef0526151ee58d4375",
      "3ef94156eba6dc4d6ae088eadc31e401a5b88d0b",
      "02bbc20f6946a65505c0deb29dc3dd604041dfee"
    ]
  },
  "signature": "8BcfWla4gW3dnBItah4tZqi3iUQRch8/D+R1U64zjV0P0l/V72lozwHixqO82wv1AnLAI7SoL5wBND5X6FR0Dw==.sig.ed25519"
}

{
  "previous": "%o1Mc0szN37JfDI8rKG2q1K640jsiK+HLiwwS/bb3XD8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 259,
  "timestamp": 1497110969534,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ewQsrk9Bw0+a3E1IzJP9/wee3jCB4mZWzmCV+Lp0/l8=.sha256",
    "branch": "%MhkDKtPwTLBUPV3KauqngKeAdyI+1ckgAcv8aW0bxQY=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": ">I'm conflicted about mailslots (ie feed types, unless you mean simply format versions). On one hand, mailslot give opportunity to cherry pick feed contents and simplifies database indexes. On the other hand having everything in a single feed promotes availability of content even when whoever gets the feed isn't interested.\n\nI was thinking more along the line of feeds which do not correspond directly to humans/social identities/network topology. Feeds are essentially a general pub/sub mechanism, the current scuttelverse applications just happen to interpret them as corresponding to human identities. But at some point, there will be applications that use them for other things. By adding feed types, we acknowledge this possibility and provide a standard way for UIs to determine what to do with a random feed.\n\n> Compare to CBOR used by IPFS, which is explicitly not hash-safe (see RFC 7049 section 3.9).\n\nHuh, that's disappointing. The [RFC](https://tools.ietf.org/html/rfc7049#section-3.9) indeed only gives some hints on how to accomplish a canonical form, but it does not specify one. But defining an ssb-canonical CBOR form would still be far better than the current whitespace-sensitive JSON.\n\n> As for multihashes, they don't solve issue with compatibility - what happens when one peers knows about some hash, and another doesn't? How do they negotiate \"ciphersuite\"? This is same problem as feed versions. Some ground rules need to be established, such as \"please folks, use lowest common denominator and only when it's a pressing issue, we'll switch all at once\". Again, nontrivial issue, with no easy silver bullet.\n\nTrue, but still both ssb and ipfs use them. And both use their own format, even though both want to accomplish the same thing. And there's just a lot of this duplication across the two projects. Multihash formats, serialization of messages/objects, representing links, multiserver/multiaddr and so on.\n",
    "mentions": []
  },
  "signature": "HolGBi9yxc8VQctw9qX3MYkPtVVq7ymR4G8N90Z7aaCGNmqnfXDVFLqEFF8r05DC3v0bxbzUBe/+9aC059sYAQ==.sig.ed25519"
}

{
  "previous": "%VGwFTlSS3J0AciaZLwh1Fsvs5eSn+KovP3fX++tHfb8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 260,
  "timestamp": 1497120609140,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ewQsrk9Bw0+a3E1IzJP9/wee3jCB4mZWzmCV+Lp0/l8=.sha256",
    "branch": "%RufXTbRMjtiqphDs25Ukv4lIzM0Vuds2wHVBwqmSelA=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": ">>content-adressable blobs, or simply no blobs and delegate to ipfs\n>\n>What do you mean? That is already the case.\n\nLooks like you are correct. Don't know why I thought they were somehow tied to a feed.\n\n>> feeds should have a \"type\", just like messages (again, preferably hashes)\n>\n>What kind of type? \"RSS bot\", \"real person\", \"twitter bot\"?\n\nRather \"repository\", \"piece of software\", \"some-sort-of-sensor\".\n\n>Why not put that into an `about` message?\n\nFor the same reasons that messages have a `type` rather than storing their type indirectly via `about` messages. There's no one single way for a client to handle all messages, different types call for a different UI. By storing the type with the message itself, links to the message become self-describing. Or at least self-interpretation-suggesting. Feeds are a very general concept as well, it's only their current usage that is limited. I just think it would be useful that given a link to a feed, you can know whether to e.g. suggest it as a friend, display it as a subscribable source of news, or ignore it altogether.\n\nAlso there's the use-case of introducing new protocols in a backward-compatible way by having feeds declare via their type which protocol(s) they speak.\n\nI agree with [@Sybil](@rFgDtlYiyymSD4U96Av3pIil8xBj6afLXr87caoqAyo=.ed25519) that \"spammy\" feeds are healthier for the network. But the protocol is flexible enough for special-purpose feeds, and if the protocol allows it, then it will happen eventually.\n\nFor backwards-compatibility, absence of a feed type would indicate a \"normal\" feed anyways.\n\nJust as message metadata could be binary-encoded, so could be feed metadata (or in general, all protocol-level data). But if the binary encoding fixes the set of metadata corresponding to feeds, I'd rather have the additional flexibility of allowing types.",
    "mentions": [
      {
        "link": "@rFgDtlYiyymSD4U96Av3pIil8xBj6afLXr87caoqAyo=.ed25519",
        "name": "Sybil"
      }
    ]
  },
  "signature": "ooZnx4bKfEw+n6ESrr9qtea/gm3doZsTgISE8VBFWCnwaZBx/R0S9iVFF6cHpcBX/glF+tqE9IyLrB807oGSDA==.sig.ed25519"
}

{
  "previous": "%q6BmcyPIBCRopHe3dDIVtjUDwj1iI8KRZq+qhAuZ8uU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 261,
  "timestamp": 1497164900734,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%DzXm/OkMAfDnBIZphdRLiJ4Hr+tbCTy2QNd/p3CLuAc=.sha256"
    ],
    "packs": [
      {
        "link": "&2WG42J8/q79dWGOvYyasywr+v3elWbrmgeCwukrdzww=.sha256",
        "size": 2152
      }
    ],
    "indexes": [
      {
        "link": "&Sia0Y2e3RRThhXbE8DvKs1rKXDmwhN/BKYH2RGWRsDM=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "7f0abe1e0f33ee42b6c3a445d769c4d8f1b54aa8"
    },
    "commits": [
      {
        "parents": [
          "99a80e63c72818659416ff1bacbdedba43159c50"
        ],
        "title": "Make nonce const in final_header",
        "sha1": "7f0abe1e0f33ee42b6c3a445d769c4d8f1b54aa8"
      }
    ],
    "num_objects": 5,
    "object_ids": [
      "bf4dc3917ac939cea7eb235e30190bda76cd6fef",
      "fd3c0e3a70faca489942eba0bcdc999085cf80ff",
      "b0566cafe4d7df83cf906a6d63f346d7fcf25188",
      "84cff5299e1acc7fd3ead7c226194ebd847f77ec"
    ]
  },
  "signature": "SCe/FZGNepVkHcRNAvMApAsi004PVdyvvgq2ob8T5WqLf/tIYAwmTVcrQ4MOVIJam5SEM3yg8wRFXsVcSs92CA==.sig.ed25519"
}

{
  "previous": "%2jwOlTIEFV7q7pjUHFS9TQGJ/a1qsmMu5oE71WrjtAU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 262,
  "timestamp": 1497217070454,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%o1Mc0szN37JfDI8rKG2q1K640jsiK+HLiwwS/bb3XD8=.sha256"
    ],
    "packs": [
      {
        "link": "&Qnn62YZxYenZ6/v6k1pVshX5tl+djLHJ8CnNg+StMnc=.sha256",
        "size": 3534
      }
    ],
    "indexes": [
      {
        "link": "&AIEapgbzl7ogFbnxh/XDg8031nW29c2Z2Y97oehQZl0=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "3852403410d82f94291de78451e518f258f873c5"
    },
    "commits": [
      {
        "parents": [
          "eacb2a94cc54d612edfaaa0c574752cec7b6af60"
        ],
        "title": "Add a writer adapter for encryption",
        "sha1": "3852403410d82f94291de78451e518f258f873c5"
      }
    ],
    "num_objects": 5,
    "object_ids": [
      "b2a8da1643dd584e9acecd9f3ae59736b77755de",
      "c85c5ea7b871718426379981dd5d3e0f35b328ef",
      "c667e84c7b0507ae3fb6619314da81ced074a337",
      "58b0218d9fbb2051e3c92bebcd079c381070d327"
    ]
  },
  "signature": "vv25qLTQl6rBb4NzeBoOAmrcDYJAR4GXVd34nWrfOLnp2JBFUURsdVUla08Rq/TWoS4cQt1gqIAS/0DASFWoAA==.sig.ed25519"
}

{
  "previous": "%LXMFBSjUmWIwfneVMqrIhFmkBT/vFK6G5mo9VWEMOY0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 263,
  "timestamp": 1497559972754,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@dBQlwh9Gtr3i5YMOGtIOKtGNVepeu+nyb6KGl1vtOcM=.ed25519",
    "following": true
  },
  "signature": "S49mjqmIQk7R78+xDlt4F3PH1w7qoRx6Iph7XiaYnD4mlfnwR1CInhHEtUZ8CscbmEy1eZqbA/J5tnfvjaSCBA==.sig.ed25519"
}

{
  "previous": "%jy5Nmp5k/rRl4nE5lohV+80CYd7MFI/4afXGCUA1/Dk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 264,
  "timestamp": 1497710419775,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%LXMFBSjUmWIwfneVMqrIhFmkBT/vFK6G5mo9VWEMOY0=.sha256"
    ],
    "packs": [
      {
        "link": "&MuwkMWoVgKKQSqYNTYn3ntBkvrOaT9SDkzWwSURtqjk=.sha256",
        "size": 12646
      }
    ],
    "indexes": [
      {
        "link": "&jdjuKQoHwDYT+GITFk+Yn8hz42pVyYj0IizyqEvyqvg=.sha256",
        "size": 1548
      }
    ],
    "refs": {
      "refs/heads/master": "d4e74e1b04f1db8e16f8be52b844ff02cfee8fdc"
    },
    "commits": [
      {
        "parents": [
          "aec370d80a728977e4578139bcfadb709f924be5"
        ],
        "title": "Test and implement Boxer",
        "sha1": "d4e74e1b04f1db8e16f8be52b844ff02cfee8fdc"
      },
      {
        "parents": [
          "f3c3ecd8c9fa3a58bd813d5d4a31b7730a7d90b2"
        ],
        "title": "Add (failing) tests",
        "sha1": "aec370d80a728977e4578139bcfadb709f924be5"
      },
      {
        "parents": [
          "3852403410d82f94291de78451e518f258f873c5"
        ],
        "title": "Add some horrible buffering logic",
        "sha1": "f3c3ecd8c9fa3a58bd813d5d4a31b7730a7d90b2"
      }
    ],
    "num_objects": 17,
    "object_ids": [
      "729c136e8459d72e3692a4473f23a82f0ce70126",
      "bd1db1b6b31bf82f08dc475466ac89d850d844fb",
      "c5057f80ab6d6dd70ff40ba1f7bad1ab15017092",
      "e6d40e670cfa7a0f24bb7264c1dab10cc36de567",
      "d71b166532c57b2ee74724c520784787289a2b5f",
      "c51ca1d0d3aa98837df2468d21ec0789b7c776aa",
      "f9b3fc2bd470e84da683dc1c387d0808ae57df0f",
      "edb1ea6f4ad0938dc8f74b418b54f510d7b239d6",
      "46a7b2c3c14638f4049c4efd8f1aefbca3631855",
      "b8bae0911b2deb99fd81450888aa2ca12b662cc8",
      "d7b6274405a834329571eca414f8b0c39536e8a5",
      "b771221e712dcc890b0a3ed7374f4a21e55786cb",
      "97838ad5ce5212b1e995d8ecc1c70d8ec082ccce",
      "c77a4fcc46e091d506c803c5f54dc57339c04644"
    ]
  },
  "signature": "U+UZoZRH/CMA7DSAf7pkrfpOwZBZvDgAj3nC14aH6kNmQ0JrFIXIcwVFKe6n8qip6mBKcfJx5TSQwHAWkk/zAQ==.sig.ed25519"
}

{
  "previous": "%G/XV8vsRahpT2j4VzNvW9TWKIM0SniuEjN0raquBBhU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 265,
  "timestamp": 1497824285900,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "elm",
    "subscribed": true
  },
  "signature": "ezXVmXgXs/f9a1v3Ws/YD69eiKCP21kCQSjC+IcO+ozo5FRjAaCFueC+cQKrxH74IGxESHL6O4rHt8OcDXNTAw==.sig.ed25519"
}

{
  "previous": "%gV6HTJr4Fyl7gyXpCRD3+7jDBc1sMlzYu7ttU49E+js=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 266,
  "timestamp": 1498032251620,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%45Z8g0u9FLMLx8baWdJuVEOG+dmN0D4GQNXU1i3wU5I=.sha256",
    "branch": "%98ES8cP2nj0XSBD2OXwG5DxlLUfTpOCYl4eAHscliJ0=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "Not every pub runs the js sbot, so a version number alone is not sufficient.",
    "mentions": []
  },
  "signature": "bhE+VmAUvs/Su2GkQYYyEEXra2f1vVwxIVBeiaHZw2AbqAo4K9Vj+TtyXtPxRox3cFM3opgiFJbLArkzzwyhAQ==.sig.ed25519"
}

{
  "previous": "%/dIGz1tXWjr1oZKgSgRc3Ek3wyzO0993i5gVc6Z4OTI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 267,
  "timestamp": 1498032412638,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
    "following": true
  },
  "signature": "Shm4FVGzTZu2k+AYw4vjf5WQ985ngwcZNY+O9yYhYvJ3V0LmBZZrTVCHiJlzZZvDwEfpMST1MmX+FB4RyYD3BQ==.sig.ed25519"
}

{
  "previous": "%9jvFbVEBOzV1qJVTxcNCPTtX2hKWKAHosw0l3o2PLSo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 268,
  "timestamp": 1498164089065,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%p7BuF3nwEpikfjxyEsKI7i8T5TDbyoLfFJcq7e3Bm1E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%2jwOlTIEFV7q7pjUHFS9TQGJ/a1qsmMu5oE71WrjtAU=.sha256"
    ],
    "packs": [
      {
        "link": "&S1nMkA+jUZn/FOqi/z7m2oodPqxcuhtBqOP+F0ctRIA=.sha256",
        "size": 2004
      }
    ],
    "indexes": [
      {
        "link": "&IjFo1x8QDY0tdT62P67WRpxIzA0dp4nprs5hLOglYLM=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "d661bab0ddd851519dc03e0e3d549ca0aa85481b"
    },
    "commits": [
      {
        "parents": [
          "7f0abe1e0f33ee42b6c3a445d769c4d8f1b54aa8"
        ],
        "title": "Add assertions for packet lengths in headers",
        "sha1": "d661bab0ddd851519dc03e0e3d549ca0aa85481b"
      }
    ],
    "num_objects": 4,
    "object_ids": [
      "52f880e8fc39e735ab033a18c783e8a02e3f3024",
      "bae233d0bc1e8eabc8dbe8643ea57902cfc7fa96",
      "76796d3cd905cd2bf7010fa40fdfeb38d27ff82b"
    ]
  },
  "signature": "KWYs57xiqs0y7JW0uXu45UVaOYZZ3SEIOA0oCME02vBHnKHLWrtLm4xGtPeArj/a37s3j+grWyJi4pEOz8peBg==.sig.ed25519"
}

{
  "previous": "%4eTzQCBscZgx6Vtz2b+SBZv+CRWhV+GMDErxih4UOHQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 269,
  "timestamp": 1498934252771,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@H4UWjDPVZRlY7BQw546xcowcCHj1VdFRRCpNT9HQJyc=.ed25519",
    "following": true
  },
  "signature": "h4McJfpg0fENA50mqUiCig+B67HS+r1/3Ly0rLz8jGL2dnh3dof90hjXQRSaICdaE+vvakKmqdEzfaFxPYO+Dw==.sig.ed25519"
}

{
  "previous": "%e4CW37sXnx2zdXbKIgXF8J32izfvfJ03O59sfuq1GvI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 270,
  "timestamp": 1499162384257,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "webassembly",
    "subscribed": true
  },
  "signature": "0WgMwBrMueRdO84P41RoaYeGD3VPMwZzYBIgSFQhTbbT6tsyhQ8LPBp3ZmipRdy/KzKyJFDYu4onaZCyLYlADg==.sig.ed25519"
}

{
  "previous": "%LTmvvBPxD9pIWIpj74JdfKnfSWJ1CCh8bDAj015pA4M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 271,
  "timestamp": 1499244084127,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%KKUN0+ZnVMVQ6hsSBVwVOO3jHPluBpNsJlFGRDwDUlU=.sha256",
    "branch": "%Ol4rcPa1HK64i5R2V/HNsO1GkxlUX/+GcMl7cgV7VwY=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> there's a limit on the amount of text you can post in a given message on ssb - like ~8KB\n\nHow about a flag that indicates that a response to a post should be rendered as part of the parent post? When publishing, clients could transparently split up larger posts into as many components as necessary. All UIs aware of the convention would display them as single, larger posts, and the remaining UIs would gracefully degrade to multiple posts which respond to each other in the correct order.\n\nThis seems like a nice way to hide away the implementation detail of the message limit from less technical users who simply want to post anything.",
    "mentions": []
  },
  "signature": "FpvuZIZIE0pV5tFtaUV7EAMHruXMKbgZSN/C7EzakY/m3+uq4kDJ75o2rvuqI7YpnvcWutjXzEgS8ag9u6AkDQ==.sig.ed25519"
}

{
  "previous": "%30FaqeWyzwTs7ntqfd3XghnprDSOIZ/VQb5iO/mx6Oo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 272,
  "timestamp": 1499462916206,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%G/XV8vsRahpT2j4VzNvW9TWKIM0SniuEjN0raquBBhU=.sha256"
    ],
    "packs": [
      {
        "link": "&NT+lqiw0Mx+E8WnTtC1dWbSpo2AFKIuCDUZTSlw+Ifk=.sha256",
        "size": 33139
      }
    ],
    "indexes": [
      {
        "link": "&EgX09tXrz+NR3t4EFqJ18mj1ThNCai+KrfxmL3LxVWM=.sha256",
        "size": 2920
      }
    ],
    "refs": {
      "refs/heads/master": "9e5261db2331e3a862e9c901f89a9abd11f2930a"
    },
    "commits": [
      {
        "parents": [
          "348059100fe1797c81517a8f93ebad24870974c6"
        ],
        "title": "Handle final headers",
        "sha1": "9e5261db2331e3a862e9c901f89a9abd11f2930a"
      },
      {
        "parents": [
          "0c73e8f393a61971fa34ad57ef28219e450b2822"
        ],
        "title": "Rename Boxer/Unboxer to BoxWriter/BoxReader",
        "sha1": "348059100fe1797c81517a8f93ebad24870974c6"
      },
      {
        "parents": [
          "f069c33e2a3505ce377c8a3dd4ccce08f088bab0"
        ],
        "title": "Move state out of unboxer buffer mode",
        "sha1": "0c73e8f393a61971fa34ad57ef28219e450b2822"
      },
      {
        "parents": [
          "9f9cfa43386e1af3b6c06533ce3a6ea10018a35b"
        ],
        "title": "Clean up boxer",
        "sha1": "f069c33e2a3505ce377c8a3dd4ccce08f088bab0"
      },
      {
        "parents": [
          "ec5de6e35748ec2ced80c88bb074207315a221ff"
        ],
        "title": "All tests passs",
        "sha1": "9f9cfa43386e1af3b6c06533ce3a6ea10018a35b"
      },
      {
        "parents": [
          "e261c4ddc6b6604e3ff36d55c33a20a77d33f31d"
        ],
        "title": "Backup",
        "sha1": "ec5de6e35748ec2ced80c88bb074207315a221ff"
      },
      {
        "parents": [
          "1b3aadff69894b99498720e697afcff9120c693e"
        ],
        "title": "Refactor unboxer",
        "sha1": "e261c4ddc6b6604e3ff36d55c33a20a77d33f31d"
      },
      {
        "parents": [
          "ec0d783366b67d0ef61a94e5082f8861fb10afad"
        ],
        "title": "Finally manage to write correct randomized tests",
        "sha1": "1b3aadff69894b99498720e697afcff9120c693e"
      },
      {
        "parents": [
          "490564196e7a0080180bb66284dec0616c9d1cf2"
        ],
        "title": "Fix fast reading",
        "sha1": "ec0d783366b67d0ef61a94e5082f8861fb10afad"
      },
      {
        "parents": [
          "4215f33fa23085eba530aad676b074a0a2a86e80"
        ],
        "title": "Add unboxing test and make it pass",
        "sha1": "490564196e7a0080180bb66284dec0616c9d1cf2"
      },
      {
        "parents": [
          "d4e74e1b04f1db8e16f8be52b844ff02cfee8fdc"
        ],
        "title": "Implement unboxing - not refactored yet",
        "sha1": "4215f33fa23085eba530aad676b074a0a2a86e80"
      }
    ],
    "num_objects": 66,
    "object_ids": [
      "55a740515aad5799d432d2906fd58f0d85f68551",
      "27b091e7dd5dae263586b2144839b432797f289b",
      "ed807bd29b55402e934a7c087e77685f5b38d556",
      "1be790723d22f7e018117186cc646edae1998714",
      "e1ba64eb7239890e912c06ae966b1e0b07a1629c",
      "8b767c5e108fe31a338e2431d70af13b6eb52d7d",
      "ee211073b10b79b57731f57b7848fc1e8d01035c",
      "bad55be6919a9064db2c33627d67e99dbbfc6597",
      "65901fd59780bc35d3e896f768ac1b6f3070df0c",
      "d0c32e01ee5d35b3961278aa1b2b2da6ce5ce54a",
      "c64a0b8a22a5719184cf671f771f53ec45bf1c90",
      "e8ef74516208a202f67ea1f6087478444c1fee0f",
      "b4a455fb9525e64f1d58a70f089adae7dfe02706",
      "19615d05f0e23a015678824b98f9040f6f38c437",
      "e33b1fd847101bc95cd5cd853329653dab6bce8f",
      "4dea28bf86688f48893c5faf59c735b5bf6fcfcc",
      "65ca533986a10b8bf7d58c1e5a166a4cf5d0fa08",
      "6a14feb3cb52e39e9a0d7382ec032b9b9ed56878",
      "8138a15cb03c0a22816508e1860af0e6d9818bb4",
      "e45b383ea249f0cb0046a8e632d32ce2597fe79a",
      "485cc350cbcafdf474babee238e7f9454083d169",
      "2c79eb5edd8f01a69556adbaacd4cc899b115357",
      "1762b0891138592707f03c383bd207753109390f",
      "77cf2d98643223e1c1fcc4f86ca5a66576276910",
      "22859fa4872f963342ed41decde9049bda2b0f13",
      "be3bab62238e58ccdc55133b9b6e1935e0b44ceb",
      "febd1486268a5ca7e8d20f5586595a6817c83acf",
      "d4856436b9f4d05bddfd58a325a56a6a9e002d57",
      "1e3ad0b9f9f3c3605a0d2ce7539eb8d927f1875a",
      "12669ccf8576cb357486bcf811b6343a1da7c219",
      "413defc2fdff350cc778fa758208c10b097e3030",
      "8df4c88113d1d7a35725606c3ec586616986cbcc",
      "71b5890b11fc92e0aa6ecb6a171dda1d59c9aba2",
      "d7a447c3083c25e449fbba6aba4a96deeb74864b",
      "369826dc382908f98438970be80ae117d422b102",
      "055ed784870d765fdf1461fea5c2fabf44f058f9",
      "0d5d3e77459e4378066633ad646b877ab7c0869a",
      "8c11d615bfc751db0140bc1b18262e8752e492f4",
      "cee3d606757258518d2b44d9341b0eb2f6275775",
      "356b0f41425c8d38e6e9436d118536714d1ab698",
      "5c01372216176958be4770b2edbb40713b575844",
      "0a7bd2ad9333087da05177659620a85ce7c2430d",
      "35c14ba11f7d5723920595b05168c5de7fd706d7",
      "1494d2c0850e904923dce7e64dc2da32746d8225",
      "58e8d2d61489f4f2614b4143a5a738e9bda92b8d",
      "8ca767ddc2769d2c1a63887a2c4f2303c26064dc",
      "43561c5f1e91e336528c85fd84b353f609aacaf1",
      "30d0866393e2aaf8fe4c57d338e2ebd29dfd0b80",
      "98ca12941aaed3d069fdd8e58200185ec17e8cf8",
      "8710e75b414d6f1bb9739d19b3ba90dc57ddc7f6",
      "f4051a510f4cfde8a30ce231c0217edc3cb06f4e",
      "c1204e0fcf5979e592c6c96801d3349df8945469",
      "9d709587f2231c78d046c6c624e93a4a85eea73b",
      "43f44828cc4d212b9ef065a3a50ca443bd026fa6",
      "f857b186e2764ee81b0211bf16d9fa74b23c1840"
    ]
  },
  "signature": "O8dFzC9vzuIu3B1nF1wJKaVt5GV8+JTKlG0ue371QKe1A9wietdPDMA2iLvcXufA4InMuwVHL62axSN29eQyBA==.sig.ed25519"
}

{
  "previous": "%z74+hzNupCg3F3yiQ00OqUQq12uqxf7wE+0zkXXOxDE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 273,
  "timestamp": 1499957778481,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GN18zeGUpYCUQ9bd55N2+2aqDyHCnzt+RT5E5L/PVo0=.sha256",
    "branch": "%GN18zeGUpYCUQ9bd55N2+2aqDyHCnzt+RT5E5L/PVo0=.sha256",
    "channel": "npm-ssb",
    "recps": null,
    "text": "The alternative to version ranges is to deliberately update all dependencies as necessary. So as an author creates more and more packages (and consequently accumulates dependencies), he/she needs to keep track of all releases of all those dependencies to determine whether to publish a new release. If everyone did this, most releases would actually be version-bumps because a dependency of a dependency got a significant update. The number of actually meaningful releases would only be a fraction of all releases, but you'd still need to check out each update in case it provides a relevant improvement.\n\nSo either people get frustrated and stop caring, in which case packages would stagnate and not benefit from improvements. Or we would get a culture where releasing new versions is considered a high-cost action that should be performed as infrequently as possible. Neither sounds particularly desirable to me.\n\nThe article highlights some real problems to version ranges, but there are real benefits as well.\n\nI personally think that lockfiles are a sufficient compromise. A good package manager could provide a mechanism to link directly to locksfiles themselves rather than to just packages. So when full determinism is necessary, it would be easy to obtain.\n\n",
    "mentions": []
  },
  "signature": "gEX7VEPYi0Dsy1ic/z07R62JUBh+YEdfdYX2qzifXwmChXoQhclZDllfaLnCsuS5jZO/+4IW6cX6Mvxx+9qnAg==.sig.ed25519"
}

{
  "previous": "%CRs4+tILd4QQJnLXadpjJqmiOFoVWc/tbyanrUsaoXg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 274,
  "timestamp": 1499959202854,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%z74+hzNupCg3F3yiQ00OqUQq12uqxf7wE+0zkXXOxDE=.sha256"
    ],
    "packs": [
      {
        "link": "&TaQ/dl5UJR6a6uzroYQX1XfoLj2K8m+jfpg6ZNepHxQ=.sha256",
        "size": 10790
      }
    ],
    "indexes": [
      {
        "link": "&NIgkRq0CyEhHrR6taqiPRPcCfIoequvH6HFuVJuZz1M=.sha256",
        "size": 1352
      }
    ],
    "refs": {
      "refs/heads/master": "f1598f1e9c10bb033ed21a7f96b654732f8f77fb"
    },
    "commits": [
      {
        "parents": [
          "58d5553b695510f4ee04d020a947fca394e3baf5"
        ],
        "title": "Handle unauthenticated headers",
        "sha1": "f1598f1e9c10bb033ed21a7f96b654732f8f77fb"
      },
      {
        "parents": [
          "9e5261db2331e3a862e9c901f89a9abd11f2930a"
        ],
        "title": "Handle invalid packet lengths",
        "sha1": "58d5553b695510f4ee04d020a947fca394e3baf5"
      }
    ],
    "tags": [],
    "num_objects": 10,
    "object_ids": [
      "f12eff4379a2346dada91070b53810e46be64226",
      "433b185d2b6d3c54b9baa02eaba38053d4382f98",
      "703cef3ece4b614d235302c641ada45a443b90e3",
      "e6d30c3aa7ea9df6c584fde778514c4d2ec8c8c9",
      "780660953b5500730230714ed13fef70e078b9cc",
      "edfc4741649a9f5abe8934178e09e1d0002c3cd8",
      "df216efba03cb8312413f7869b70a9c030a9fd3e",
      "53f9feb4cff5fb9e7155e9da57fcd4aa472c3ab4"
    ]
  },
  "signature": "/W8pcYoy22iNPAztWU5BkWbtcaSB5Yvy6Azik1Y4qAp70+517EWm1//JBPE48BxcNaeHDNAa3GocikiRv0FoCw==.sig.ed25519"
}

{
  "previous": "%hpKPYCJGwwKwRTvDOou7KYN0rJ087zzy9N02Lzx+oGw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 275,
  "timestamp": 1499971326995,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GN18zeGUpYCUQ9bd55N2+2aqDyHCnzt+RT5E5L/PVo0=.sha256",
    "branch": "%9zBZFwKQncBDxpubk90cuMVIE+Jq7o6fhoVbmPmHfPY=.sha256",
    "channel": "npm-ssb",
    "recps": null,
    "text": "Two more reasons for (automatic) updates are performance improvements and security fixes.\n\nI agree with [@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519)'s point that minor version updates have little reason to be automatic. If I depend on `1.1.x`, and the package is updated to `1.2.0`, I won't receive any of the new patch releases after that, even though they might fix or improve functionality that was already present in `1.1.x`. To benefit from automatic patch upgrades, you need to pull in all non-breaking changes. The underlying problem is that packages are simply too coarse-grained. A precise approach would version every public entity (e.g. static variable, function, type, interface, ...) independently. But even if all these updates were automated, specifying on what exactly you depend on would still be too much effort to make such a system realistic - especially in languages with dynamic typing.\n\nThere's also another point of view regarding bugfix-turned-breakage: If my code depends on behavior that is not specified as part of the provider's API, then my code is buggy, even though it might happen to work correctly. If my dependency' patch breaks my code, it does not create a bug. It simply reports a bug that was there all along. This is of course a very idealistic, not real-world compatible view. But for my personal projects, I permit myself to be this idealistic. And I'm glad the tooling supports this choice.\n ",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "D/+MALviZXeCF/8A73NHl0Az84HEAaD0AHYU/bgy+RnPmz5xzpS0J9CUgPtLUaIWO8ujGrqbN+zgqSMCYp0TBg==.sig.ed25519"
}

{
  "previous": "%HeJmbB8kGD2GBSyC80D6Uj451+v1xNX7q6oUSbw8t5Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 276,
  "timestamp": 1500031181565,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%hpKPYCJGwwKwRTvDOou7KYN0rJ087zzy9N02Lzx+oGw=.sha256"
    ],
    "packs": [
      {
        "link": "&8iQhLkoZY7DtxB3gys1AR7O6+kj8XUO2qoUmKpLj/m8=.sha256",
        "size": 16365
      }
    ],
    "indexes": [
      {
        "link": "&nZCgkMbe9BObkGMkxjCYV3grnbpaJRMkJnM155Rfm8c=.sha256",
        "size": 1856
      }
    ],
    "refs": {
      "refs/heads/master": "a6375aa288365b95f4410b96823ec14529f7aeb8"
    },
    "commits": [
      {
        "parents": [
          "0e8ff6b6ac98997f6fb4ce707cbe005dedd7c77e"
        ],
        "title": "Prevent writing multiple final headers",
        "sha1": "a6375aa288365b95f4410b96823ec14529f7aeb8"
      },
      {
        "parents": [
          "6afed351d87a5ae88c90ed7d2c45dfc676d4281a"
        ],
        "title": "Clean up API (docs)",
        "sha1": "0e8ff6b6ac98997f6fb4ce707cbe005dedd7c77e"
      },
      {
        "parents": [
          "09ceeea14cb2bb15125ef3fc9e66effe3f761c05"
        ],
        "title": "Add BoxDuplex to wrap streams",
        "sha1": "6afed351d87a5ae88c90ed7d2c45dfc676d4281a"
      },
      {
        "parents": [
          "e7bf95eb4a648316e93d180c88eb8fde1dc16746"
        ],
        "title": "Cleanup",
        "sha1": "09ceeea14cb2bb15125ef3fc9e66effe3f761c05"
      },
      {
        "parents": [
          "f1598f1e9c10bb033ed21a7f96b654732f8f77fb"
        ],
        "title": "Handle unauthenticated packets",
        "sha1": "e7bf95eb4a648316e93d180c88eb8fde1dc16746"
      }
    ],
    "tags": [],
    "num_objects": 28,
    "object_ids": [
      "66e48c8378b04902d80e9d5bac15fcee16ae5b8c",
      "8be3be6951847e589916e568e4c5022cb42025b7",
      "7185086d726806d4ab2abff51c33b2af09341bb4",
      "14c22d656c19dd43e71fca86411e830ea21afa36",
      "90595458c3dba56971eea87fce7a700aaa2b998d",
      "2618b3ac85cdad35ea702c593528cbef6cc36669",
      "91bc8aa681d1dd7b4340234aa99a1108a0f4c03d",
      "57b9605c5daa222241139597d9072cd216877027",
      "11de403bcd5462dcfa468324cca397e41af20739",
      "64afac250f7dd63e0d15d232c90be24e54c5b3da",
      "e2ae24669ea2c2a9504f8f92600a087ddeca224b",
      "2fab3d3749ccf83f29d07ac2a2908400c63e45a7",
      "a03a365e11daf3eb2d4278bd8cfb9dd0fb3868f5",
      "b04d66f8369c591ccc7d18e67582602c4ff00f42",
      "d80289e14ac004a1da5212c0fe3b63dd187da9cf",
      "2144fa4ad7f39757fba76de6021ecb986e657c58",
      "f686b524c979337ec653229000b7112a629bf5df",
      "1b546983ef5360581d209c89b2efa84d31122bae",
      "5b32307f696bc22fd0fd6675fe09acd2fd7fd348",
      "62a6e9ac73d415bc73761efde35cf88a3c40ef9c",
      "89a853390116d8238fc409ff54e5eb565f35372f",
      "59177f97f3b1fb720413b92d9fdfede881e73b4e",
      "e913f1ab2234362dfbae095ec5393b5f820ad146"
    ]
  },
  "signature": "Ts/W7rv0/MCLpn3zCAS1KAWb3WDGSMwChq3hDDMFQFyjl3Nr0vxy5TVmTfzNu583c/oGMwBb/RxMiY0WxsCqAg==.sig.ed25519"
}

{
  "previous": "%AWNehHpghD6HuSGGx5tYR5YerIqsYpthEYuA8jz/pFk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 277,
  "timestamp": 1500191869059,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%36IiWXtYwEP29cqFWw9IvzeK4+eHf6eduHJU+sIVXCc=.sha256",
    "branch": "%36IiWXtYwEP29cqFWw9IvzeK4+eHf6eduHJU+sIVXCc=.sha256",
    "channel": "git-ssb",
    "recps": null,
    "text": "There's some discussion about feed-per-thing [here](%bcYK0JOPzKlgu1DRhxBmpU7O+xrW+RvKSJ7u48n8Zio=.sha256) in the context of a package manager. There are good reasons against having a single feed per repository. I currently like the compromise of having one feed for all my repositories (but that's not how git-ssb works).",
    "mentions": [
      {
        "link": "%bcYK0JOPzKlgu1DRhxBmpU7O+xrW+RvKSJ7u48n8Zio=.sha256",
        "name": "here"
      }
    ]
  },
  "signature": "csrlDhYxshgb1opoDJplEVJlm4cSGlOS4c60Z2v9OOLBfFnUn78oi1nvbI4Ev7qfcWQocZP8xqaDGVdnFLnRAg==.sig.ed25519"
}

{
  "previous": "%KdrCmHQ4OTdgYt161aVH3QW/40H1foQeY4N59v8MDbA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 278,
  "timestamp": 1500203207767,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%AWNehHpghD6HuSGGx5tYR5YerIqsYpthEYuA8jz/pFk=.sha256"
    ],
    "packs": [
      {
        "link": "&TgSZy3eU4AY3vB0dgTJjACnYg0ROSWiRDpIHHAIaUg0=.sha256",
        "size": 16696
      }
    ],
    "indexes": [
      {
        "link": "&nRLygmzVysrfHHe369atYdddq2O0SpIphTBYdew+SNw=.sha256",
        "size": 1884
      }
    ],
    "refs": {
      "refs/heads/master": "90fb3536f323f56f8eda3ae242c624ec19f6fd6f"
    },
    "commits": [
      {
        "parents": [
          "3bd62a35a37918131632812605443bd11839d5b4"
        ],
        "title": "Add simple examples",
        "sha1": "90fb3536f323f56f8eda3ae242c624ec19f6fd6f"
      },
      {
        "parents": [
          "9d6c97fb3c6f54964d530b460f0a1d2867917452"
        ],
        "title": "Fix partial renaming",
        "sha1": "3bd62a35a37918131632812605443bd11839d5b4"
      },
      {
        "parents": [
          "11ab07c46193537524a6b939bda435e0fb49671b"
        ],
        "title": "Deny missing doc comments",
        "sha1": "9d6c97fb3c6f54964d530b460f0a1d2867917452"
      },
      {
        "parents": [
          "deae0c51020906a981ea782ec41cb436f82b91bc"
        ],
        "title": "Add implementations of AsyncRead and AsyncWrite",
        "sha1": "11ab07c46193537524a6b939bda435e0fb49671b"
      },
      {
        "parents": [
          "a6375aa288365b95f4410b96823ec14529f7aeb8"
        ],
        "title": "Return Err(WouldBlock) instead of Ok(0) when needing more data for decryption during read",
        "sha1": "deae0c51020906a981ea782ec41cb436f82b91bc"
      }
    ],
    "tags": [],
    "num_objects": 29,
    "object_ids": [
      "3d11a26e3f34aec444f93584b3eda57b7931a0cd",
      "eafca7edda341b513b423ddbce6ff212ea89a275",
      "cd153d0d09559540bcc325ed11215af375c4fc81",
      "38019d324cd372e7a96a1714feee6d038cef8cf6",
      "78b5ae479a6d99d9af97fc3155e9dab66757889f",
      "9812c6cc21d42a0e522ac2bd5711bdb7aa19ead0",
      "84666f566a7d40745e49a2939af1441970f421a8",
      "9949980abb4e339141578b53b03680c96a0a367c",
      "f274ce7281773c67bcae6767dd82a3e5dd32a0d4",
      "5c9a3beb98de153e0e2a041dc124644ed6b5368f",
      "7d003b36542dcf0172a1fe8ff421346fc1a123de",
      "449c5d38b780c76532b5c855c080ffecaa1c4e6d",
      "d36aea4c7b6160ecbd4de2cbd96fc394eaadae04",
      "15e0c3059820f92c1ad1069cc338899b51a14349",
      "7ce33eae43f784690118687dfa8587825db42904",
      "1d480e40d6cad2fa61342afa0bebfee047bfa7bd",
      "b5697d972085f78617bf43d2c9dce6fa5c2e7a5c",
      "5b3d6e0298e7d7edcd267f2dae61b27e9c556237",
      "d3d4922c99a7e47ea982457d4ac2c78a92decd03",
      "5774644a32dd65f381c9bd73bdab0f291df38b4b",
      "88ff541dcb15a0400d2395f075f5f6b02e7bd100",
      "5ed6dddfff4bd7465233f2fa1f3bbb3e940f3a5d",
      "5dc466ad198a2a490755edf7daeb957ced4694b1",
      "c7c1e83662319cc694c1f4a7cdfe2107832d89cb"
    ]
  },
  "signature": "Tv+6L6gE1POCJbGQcFaXNV2c3vM72GD69pqcHxvFg2WyW4uxAuItVeRTMu2R/ihL+LxFx44Chfbws6Y5QRwmCA==.sig.ed25519"
}

{
  "previous": "%QPoCWNcRnQxjF0YurTDl/sMgKqStktowb1quajHDR7Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 279,
  "timestamp": 1500203667496,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%QPoCWNcRnQxjF0YurTDl/sMgKqStktowb1quajHDR7Q=.sha256"
    ],
    "packs": [
      {
        "link": "&XwPJ1EAqTAiHev+LjM+y52F9oq+kKtdGgAe+fgtdglE=.sha256",
        "size": 13087
      }
    ],
    "indexes": [
      {
        "link": "&aebsV5Ipb5SPT5STXHWWkbrshR1eYFB8G5iCny+eCBE=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "487547161436d7ebafc441e651d62e785be83b32"
    },
    "commits": [
      {
        "parents": [
          "821e8749e8ba7ca099af25d9f06731698970e0f0"
        ],
        "title": "Add license (GPL)",
        "sha1": "487547161436d7ebafc441e651d62e785be83b32"
      },
      {
        "parents": [
          "90fb3536f323f56f8eda3ae242c624ec19f6fd6f"
        ],
        "title": "Add metadata to Cargo.toml",
        "sha1": "821e8749e8ba7ca099af25d9f06731698970e0f0"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "bcf594b14a302ac9c884f0e06f135860a6216e2a",
      "3b50cfa5e414fecc09c654ea8ce62024a77f10d0",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "249ee026c2c935597a485c2d47953dad399a8a88",
      "07cf38bd8c0153bfafc1b3516b0473691546a334"
    ]
  },
  "signature": "LZ06VhZQrUPechJhpfFVsKTfgdClNwYSl8yQg1M5FJnSvgUXaenIOkY/8OyX8d7etiI+o5dN0OKMTtPw/qvFDg==.sig.ed25519"
}

{
  "previous": "%+zonO7lzcLrKWa+Y3JzllBJZv1c8FrXPqGqhiM4Konc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 280,
  "timestamp": 1500203933139,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%+zonO7lzcLrKWa+Y3JzllBJZv1c8FrXPqGqhiM4Konc=.sha256"
    ],
    "packs": [
      {
        "link": "&rH4AHJZz/CwtXMTelIkU/gtPs5vhextehb7utzr7ZiQ=.sha256",
        "size": 799
      }
    ],
    "indexes": [
      {
        "link": "&SxveVObnFuFfKC2ahjv7yuJzfhNtOeZxANG4VgJo5qI=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "e83ef09eaebf9542b8539e2785347f9196857604"
    },
    "commits": [
      {
        "parents": [
          "487547161436d7ebafc441e651d62e785be83b32"
        ],
        "title": "Fix license identifier",
        "sha1": "e83ef09eaebf9542b8539e2785347f9196857604"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "d171a083065ced1e6b723b421c1f733aa505f838",
      "652147444abb6c2924ff68ebf6c06671fff99f5c"
    ]
  },
  "signature": "7GYneypXqBv4in8PlHhbfo1+ZlsbRoA0XBebmR5dZgNuCCu8hYT3mkZFC+wUnLEeP8P6qo+/Md3KmxDzzHptDg==.sig.ed25519"
}

{
  "previous": "%ihqpzbDIuaCrJyE4tPGmKqTO3bhzO5JXhPkeAfrn9ms=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 281,
  "timestamp": 1500294132748,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "secret-handshake-rs"
  },
  "signature": "etEFNtFOa/XtcZMU5UxVOBBWRfQ+lcsKl5+Lria1uunYS42I5f1VjWWY4ue+ml3ILqdqUwhNFuJ0j6ly5B/BBA==.sig.ed25519"
}

{
  "previous": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 282,
  "timestamp": 1500294144450,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [
      "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256"
    ],
    "packs": [
      {
        "link": "&KOuP0Mj6rFUmbyu+Bphlcp1lpftiDh+KIWlF3Pom3d8=.sha256",
        "size": 30703
      }
    ],
    "indexes": [
      {
        "link": "&sq6Aqm2JxEthrjkZWuJFosZZyaNq3Ip/CUlkAq3C9Qs=.sha256",
        "size": 1996
      }
    ],
    "refs": {
      "refs/heads/master": "1cfe916b53f21619b33facf0a6524580c03e024a"
    },
    "commits": [
      {
        "parents": [
          "0222dddb688689f4ba63e8e7482f614c3878ecac"
        ],
        "title": "Reuse shs1-c instead of implementing logic in rust",
        "sha1": "1cfe916b53f21619b33facf0a6524580c03e024a"
      },
      {
        "parents": [
          "72b539efd9bd9414b6599a3b83e8c60daaafeb69"
        ],
        "title": "Add bindings to key conversion functions",
        "sha1": "0222dddb688689f4ba63e8e7482f614c3878ecac"
      },
      {
        "parents": [
          "1c7d4fdd8f54f34f311c4c4ff507440b9cbbb46c"
        ],
        "title": "Improve code organization and terminology",
        "body": "Split lib.rs into two files, one for the client and the server. Also\nstarts to consistently use the terms \"client\" and \"server\" rather then\n\"acceptor\" and \"connector\".\n\nRemoves the \"legacy\" functions from the api, instead default to the\n(not spec-conforming) behaviour of the reference implementation.\nA spec-conforming implementation will be released as a new version\nwhen the reference implementation is fixed.\n",
        "sha1": "72b539efd9bd9414b6599a3b83e8c60daaafeb69"
      },
      {
        "parents": [],
        "title": "Add API skeleton",
        "sha1": "1c7d4fdd8f54f34f311c4c4ff507440b9cbbb46c"
      }
    ],
    "tags": [],
    "num_objects": 33,
    "object_ids": [
      "98be08288ca2bfc0cf5277bf6b52b3a7d8a79390",
      "a9d37c560c6ab8d4afbf47eda643e8c42e857716",
      "94587cfe95937be4642f47ca74e61e5eb73cb8d6",
      "3ce3cdb33ca7f943245f798c19000b641ac4d817",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "8ba5fe5664c406ac0b5f6edf76e40a022f405d34",
      "d8c45b760d37fff48e8c4b400e4d23294ded61be",
      "04e47fa2acc05bf90e81728cd43088600f7d46e8",
      "3362c257a67a05f1f30e335d88d7e6793b4dac30",
      "0c69478a95a5e8d09d05da3d3f6d7da3af78a9e0",
      "25d64157bf2e3e27d82e55d4d10c5ec031a3bd50",
      "794c0324a23fcee336b4a7cbebad0438eb64ff45",
      "ec09c93b886f7fd0cac554935127f23e8291234a",
      "d446f9738c2ab38da80c828a5bf0e0d2fd3fcb01",
      "66960b5e588c062fc3bdb25608fd2eb9ecb3fb6b",
      "0edc080861cdf7cc542b7b7c23db81cd8ef42cff",
      "447baf5fe7c16cddf613b742de6a2ea54218fe90",
      "f2c8eed5c33d104ad75b885b0f1cfe4dc3b81494",
      "c9a787fb8066d951c7dfaaa193640e8505139bbc",
      "2b222d7b98d246f31284d7f00ab95614e76b0cd6",
      "841dc8b0292820aa0291e4e4b236f1c8dad93fee",
      "c689a2a291e5ead13fbc41a0bfca63ab5da8d099",
      "03d75487e78f1ea395a97d05c195d39832683f84",
      "a492074891dff3366df25eac4f6fb7c161fa0b76",
      "6e0c2b2d79c1d499765f5eed7eff6e840e25cfb1",
      "f58e1392f650b98ef782b47362224f571052984d",
      "9b1e25878beaa7437b1b0a5a5ca5fb95b3a0bc5b",
      "a92f8c2a551084213c7fe97bc76edf5cb9a726c8",
      "2b2f4045a5fa40354380e8f1f8c5b197e216be40"
    ]
  },
  "signature": "jSomhUmf3rYn0mQEBhuc/Wf8Xblw3At0K9FSLInjdm5TnXfAWcP70KkqrGD8INUNbA3zy3Lz2d/1VL2X9hU1Bw==.sig.ed25519"
}

{
  "previous": "%7pwMYv/TTtlT68X4ihlwL+ENFoh55hTSqwbx9+Vixh0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 283,
  "timestamp": 1500461017462,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%C29jPPU6kqKviNHotWXdLtd72T76soS8UCdtxVnWluk=.sha256"
    ],
    "packs": [
      {
        "link": "&7KiMbkhxyGYVRyqjGQGtL72M62pB5woR7csBRkSJNDI=.sha256",
        "size": 7231
      }
    ],
    "indexes": [
      {
        "link": "&6VZzSBk6p11yEfqvHNz3Zr7aRNSqx98vZnECn8rtnEw=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "1e67248255ad8826c1194616fe02735b84864892"
    },
    "commits": [
      {
        "parents": [
          "7c923f08d7ff4151bbb249c725171a8055dee8d1"
        ],
        "title": "Fix spelling of 'acc' to 'ack'",
        "sha1": "1e67248255ad8826c1194616fe02735b84864892"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "22cd88f98589fe80686a0d694433e7fb2e2f9f8a",
      "88ab543a28c840e9a1a2e269d5e9fb62977501ae",
      "b843b49d75800ef44823b1fcf5721e74016b130a",
      "3c70fc0ee9d029340d01da7df2053eac4aead4ec",
      "4f4bd5af7dd8b11566fdffc2d7621fe47717cc00",
      "d4a12684cba742d172ea8d382e7d92671a6d8a92"
    ]
  },
  "signature": "UiWnq7Qz40PHYozW4QpS3aqMzeW3D9iGCdxokNNWV85LI+arVs7L/nBqWzZ7YdRgKvwIqyXE/XlmBgtahLGCBg==.sig.ed25519"
}

{
  "previous": "%1jYUld49RT8PLzYES9qqhS5Yd1gb9uUb03NvOMkDZ6M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 284,
  "timestamp": 1500561507604,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%2eAPrW+e/YOp2MeglHsw5XtMI86zHVmhhJWtVIos77Y=.sha256",
    "branch": "%hBJ045aMb513zaIHFy7JqmFs1bdspbcxDwzRki68VNg=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "Could you create a minimal working repo, including the package.json, an index.html and a readme explaining which scripts to run to build it? That would be a super handy starting point for prototyping UIs without needing electron.",
    "mentions": []
  },
  "signature": "D7JTr9jwCSYNJz2wkoKVMQBjWJA4WNwdC87RkmqWLMn/Wevpo5CJnCTjZ5NfR9/E+o/ZtLKazh8O9Bx2BGgkCQ==.sig.ed25519"
}

{
  "previous": "%tEzJFDMpwxqISWk90vT5/KKwnLkta6qtE0yRvSYyktA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 285,
  "timestamp": 1500632459738,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebot",
    "vote": {
      "link": "%q7uJ1tT+kdInKuBHJPvywh5MeiAQJX75kgm8MVMqwQo=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "W0J56YKkiMRBqhlS6wWRpuaOTrq71stuWrrWdLLSnH+WBzrKheBtRWmlA2Tc3HLI8rBj5O0JbNxWMSOyi2kuAQ==.sig.ed25519"
}

{
  "previous": "%0cMSpQQDyX3/KBVsFePPaWxTnka6zWEW71Laomtm8a8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 286,
  "timestamp": 1500632519334,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%2eAPrW+e/YOp2MeglHsw5XtMI86zHVmhhJWtVIos77Y=.sha256",
    "branch": "%q7uJ1tT+kdInKuBHJPvywh5MeiAQJX75kgm8MVMqwQo=.sha256",
    "channel": "scuttlebot",
    "recps": null,
    "text": "> @Aljoscha Okay! Here it is: ssb://%Jlj4UHbLrIQBAokyzrEllQ3DnK1p1huBa0NjTPhKKGQ=.sha256\n>\n> and also on npm: [ssb-browser-client](https://www.npmjs.com/package/ssb-browser-client)\n\nThanks a lot! :heart: ",
    "mentions": []
  },
  "signature": "pqeMp9BuPvknOYFxQL2obTB6I7gduhk24y9Anx+PO9bMWUR0gr/WOwFTkiu7eM/A4WwLFhpymPHx+EZTdPIzAQ==.sig.ed25519"
}

{
  "previous": "%uS8KpVYjAiUmaYPR+oV0Uwt0PIgn89nce9oWba6C18A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 287,
  "timestamp": 1501059653229,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@5ovtEaQsrXYU13+02SIq7ny2milWoKusk5+CFI+twfs=.ed25519",
    "following": true
  },
  "signature": "nbz8uwUqs0TjhqV2AKDBz0N3SQUGOb7/FM+B3u5gMZyx+3b2Jh7zQP9as8R7mstyNA6gtFu0dA2/uzrlC0KDDA==.sig.ed25519"
}

{
  "previous": "%0F9ax9kD0lqBDgYh7q0IvOejGpljCQtYSdbiWJXq0+8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 288,
  "timestamp": 1501073902084,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ihqpzbDIuaCrJyE4tPGmKqTO3bhzO5JXhPkeAfrn9ms=.sha256"
    ],
    "packs": [
      {
        "link": "&iVAHsw6pm8p6SdA8QTRmYnJgJuK0QfDX4+8z1ZKgV4E=.sha256",
        "size": 799
      }
    ],
    "indexes": [
      {
        "link": "&Ae/s/1iEatdDpmUEjr/5+Rc4J8eoUWo3UlcnuiEOt38=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "55cc87eab54a4c191b63a1f123ff7ac7e9bab02c"
    },
    "commits": [
      {
        "parents": [
          "e83ef09eaebf9542b8539e2785347f9196857604"
        ],
        "title": "Remove unnecessary license-file metadata",
        "sha1": "55cc87eab54a4c191b63a1f123ff7ac7e9bab02c"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "7b501c19f84497e9f72e9a52658171205254e2fd",
      "b733b228531ba2810fd0fc9696e380d2b1b2dce3"
    ]
  },
  "signature": "nE5oYl1KztnQeiYHV1IXTYSm62wlBOrv2tcie3taDcSFFKjf62XwL8DoUjRcOpGTLSTEFwbKNkNaxLZA0n74Dg==.sig.ed25519"
}

{
  "previous": "%3xTJxgHyisIFXbepqEKoMU+oCRmprIfiMvA/U/ChFYs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 289,
  "timestamp": 1501074070589,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%7pwMYv/TTtlT68X4ihlwL+ENFoh55hTSqwbx9+Vixh0=.sha256"
    ],
    "packs": [
      {
        "link": "&Mp2ONwsJv2FIC0avm4MADlCSlVh694laLUnazHkR8gc=.sha256",
        "size": 17883
      }
    ],
    "indexes": [
      {
        "link": "&Wz7jmU/TGxDw+DSJ/F+uI4BR+FCX3lqEX/WnZ8MYAZA=.sha256",
        "size": 2332
      }
    ],
    "refs": {
      "refs/heads/master": "81d1b4060e03c95cdc8601f5203d3012bdfbffa4"
    },
    "commits": [
      {
        "parents": [
          "78955403c2b49f7422334915a3c102963948e916"
        ],
        "title": "Add cargo metadata and update README",
        "sha1": "81d1b4060e03c95cdc8601f5203d3012bdfbffa4"
      },
      {
        "parents": [
          "563f23b7a39c6f7471477a2e6b435e898d5b5fec"
        ],
        "title": "Add async server API",
        "sha1": "78955403c2b49f7422334915a3c102963948e916"
      },
      {
        "parents": [
          "7af273c4c4fb6c330de8556c57a1cc865ed1070a"
        ],
        "title": "Add async client API",
        "sha1": "563f23b7a39c6f7471477a2e6b435e898d5b5fec"
      },
      {
        "parents": [
          "b87e825230ef916922e6e2c3097fbea5a482ab0c"
        ],
        "title": "Change API to take ownership of a stream for the handshake",
        "sha1": "7af273c4c4fb6c330de8556c57a1cc865ed1070a"
      },
      {
        "parents": [
          "f0f5c15035f382e60d4a782ea3e09f0cca085b90"
        ],
        "title": "Write API docs",
        "sha1": "b87e825230ef916922e6e2c3097fbea5a482ab0c"
      },
      {
        "parents": [
          "1cfe916b53f21619b33facf0a6524580c03e024a"
        ],
        "title": "Implement everything",
        "sha1": "f0f5c15035f382e60d4a782ea3e09f0cca085b90"
      }
    ],
    "tags": [],
    "num_objects": 45,
    "object_ids": [
      "9b0ad7cde56740a76e02029895f215346b95e6f3",
      "446d7f88e57f4179c1161c0c8f8a45f7dcd421bc",
      "29cfb3acdb4656608d5f319ea0a01b36f2261a27",
      "756d7cd840c1e1fbfa76c4d68dea72ae310daace",
      "a1065152e6c2544ebe6c065c157235d1d88232e0",
      "9b2161bf1661804048637ddd13656ca940c70281",
      "41bd22f836a81ae4dbdd538c5d7052fcb32de087",
      "de014bf807d088c1e44b75e69dce697e49cf89b7",
      "ea0abb2462d7e0abd17e4a6f7d7c69dc4a71f893",
      "786017a13c2a2f8aeef162d465f6386eb232d87d",
      "e7586c11da19eea843aa060d5c056f677ccd21eb",
      "fb847570f5218c178f84f3d1593f7c571110cdb9",
      "3eba433d9737b4540fce2ec02d547bce83b64df7",
      "f3fd0dba93c2eaad326db735661edfcd96f1f084",
      "c36321b0a4ac021db21d0ae8d08bd739b4494a01",
      "e4fb4863d96620f791c0214c2b02cb8c26eb1cb4",
      "be048499e3679ba4873a14df166a2cd26457a394",
      "6619cd95fbb9b6a8f4bb36bdb81a791c6396e1c5",
      "c7f0fc686fd76c727afed36c4e78e186b95167ba",
      "58b4246b5b37f1c078b027a68a74179d411c2734",
      "788958e0596e1b1a2e76d98e631feaf40e9edc37",
      "9f0d0340a4761a56ab2eb4a72e201bcbebcdc7cd",
      "ac1db56ff1d4f8a9a3bdf856ae1e1b35c75e68c5",
      "058f86bb2bc19c3916463c69ed7eddb9c63a7ae9",
      "3782eeb5d90cc1949fef117df5041c54d3f85059",
      "73da5c88ad9aae48ffdd8c1911fc6fff50b95e6d",
      "000d1fcba499c9851af875b6eb6b70fdd43d9b69",
      "c318d05c7a2442077960703374e383c38f5dc182",
      "d3b94b417c657d1222f555218dc00149fb04f548",
      "0b859102a443142399f52ffe99f2ec8b827cd8d6",
      "dea69fc24f0832ab1128041f70f5d16571fd59a2",
      "6e33f9918dbe24d6d1e0a2a32a2489c3752895a1",
      "da363902dcc32e44ddf12d0fe6f1dcf082a1bec8",
      "7b9d7ab7c3791c8a6e782fea65abd132ab10230a",
      "f8920c102d29fa5e67b80e9bfd0dbce869491653",
      "5bb281c7abdfff6b83b6d0c768100cc1c9d370e4",
      "d99c10e7adde315be3d2b70434c06afd533f62b3",
      "31deb39745e203c02fa18d4f9ddf463011f59583",
      "91c24cddf9bfe5ee50c5be1c8f464ccd1d8d5f3b"
    ]
  },
  "signature": "BVQqfJ05Pm0e6ceVSZcEp49VjLJkTI9Ee21hAipEqda5sm07oKQj3mzVTkBBfZq/taa9d9N+I5HYwHbsCJSXBQ==.sig.ed25519"
}

{
  "previous": "%9bWupDysldxbam0RO6+BOtaJ62hd0UraQcTXpKaxc2Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 290,
  "timestamp": 1501101330111,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Hfhnyhy/bv1+skGcKxjoCE03bwh0HtiW3DMF9DsbkCk=.sha256",
    "branch": "%gVALMgBeYMnW9Yv0Vv8u2PreyktirXgFtjpkzxzh+JI=.sha256",
    "channel": "ssbpm",
    "recps": null,
    "text": "Because I did not overthink this enough already, here are some links for determining which versions to duplicate if no conflict-free resolution is possible:\n\n##### (Minimal) Unsatisfiable Core\nTo determine which packages to duplicate, find out the minimal cause of conflict.\n\n- [Practical algorithms for unsatisfiability proof and core generation in SAT solvers](http://content.iospress.com/articles/ai-communications/aic462)\n- [Algorithms for Computing Minimal Unsatisfiable Subsets\nof Constraints](https://sun.iwu.edu/~mliffito/publications/jar_liffiton_CAMUS.pdf)\n\n##### MaxSAT\nIf duplication is not possible (e.g. with ruby's bundler), finding the largest set of non-conflicting packages could be useful. This is somewhat analogous to [MaxSat](https://en.wikipedia.org/wiki/Maximum_satisfiability_problem).",
    "mentions": []
  },
  "signature": "W4NkXKZkIeIfX1eKbMDytCYeLsTXXzDWKysBYWtC4H+6RHYoOZEXeNSp48QKT1L3pJOIxKRtMRkD3dGsyrmvBQ==.sig.ed25519"
}

{
  "previous": "%Red2O23boO78bX5lUL2D+Uw9XIBtJoLTv/jG9su4C8Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 291,
  "timestamp": 1501101612996,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%gEX4IFdX/CHll4mQpiqjL0DR8WxxFFlZVHw5TM1efPQ=.sha256",
    "branch": "%gEX4IFdX/CHll4mQpiqjL0DR8WxxFFlZVHw5TM1efPQ=.sha256",
    "channel": "new-people",
    "recps": null,
    "text": "Hello [@Dave Potts](@jnA0/zkHb0TYLheAhmzNxK6MlOWqHlsk+xxMdy/pRDY=.ed25519)  :) The initial sync takes a while, you download a lot of data about the \"visible scuttleverse\" (i.e. everyone using the same pub(s) as you are). But once that is over, keeping up-to-date happens pretty quickly.  ",
    "mentions": [
      {
        "link": "@jnA0/zkHb0TYLheAhmzNxK6MlOWqHlsk+xxMdy/pRDY=.ed25519",
        "name": "Dave Potts"
      }
    ]
  },
  "signature": "cy1VwOpa+EEBlVHWLwffmoFv3JelMfzqlOcCof0qMRwQpwr3AsuSNJZU/xxUCoRAKr2VVr/otSjGAhkbHBWdAQ==.sig.ed25519"
}

{
  "previous": "%YnVpIBWRN7dyoZYM5drr0zi3aG6MQauHVMVCcepN8/g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 292,
  "timestamp": 1501164063291,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%3xTJxgHyisIFXbepqEKoMU+oCRmprIfiMvA/U/ChFYs=.sha256"
    ],
    "packs": [
      {
        "link": "&uFRxgIExZ1xilQy5h/9Q+PnAO0PEN8O0/bGaJto2H+U=.sha256",
        "size": 2324
      }
    ],
    "indexes": [
      {
        "link": "&Ken3EJWXgzTkySlJJ2a6YMYmHaMKhU/e5tLmqEUxCRo=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "8f5a19dd1322cd36436f2a27f5dca846f41eeeba"
    },
    "commits": [
      {
        "parents": [
          "55cc87eab54a4c191b63a1f123ff7ac7e9bab02c"
        ],
        "title": "Fix BoxDuplex to properly use different keys/nonces",
        "sha1": "8f5a19dd1322cd36436f2a27f5dca846f41eeeba"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "27978986c0d0efaf07ca8207cd99c79db159bdb4",
      "cd8f724737a1440a32be15d7ef6ab8192c340416",
      "5d728582bf3818eb067bbe1d8fcc9a77325fef59",
      "51bc764aa217abf2c83c8c425130430376a39c8b"
    ]
  },
  "signature": "+QmWtOKywxHJdXy5PmYsDIAGC+bNH4hn1og5jhK9KpB6FTxwl3+oON8P81CJsTVB49XJ+ZYE+pr2E+O6jdU9CQ==.sig.ed25519"
}

{
  "previous": "%H+wCcn5rZCU79Cu3ECxIoqiSYYUrEqTZh+lSgKY2MiA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 293,
  "timestamp": 1501499281565,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%9bWupDysldxbam0RO6+BOtaJ62hd0UraQcTXpKaxc2Y=.sha256"
    ],
    "packs": [
      {
        "link": "&z3fQM9bPf7hOOhueetd4wLwlzfjbffWzoUvw6BkolH4=.sha256",
        "size": 6218
      }
    ],
    "indexes": [
      {
        "link": "&2ca6DjSiTLR7Xp5Gu/l31/ug3QVAWKYikPRg55N9+MU=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "e96a113c719f0ff1f360db4be2a8ade7654ac77c"
    },
    "commits": [
      {
        "parents": [
          "81d1b4060e03c95cdc8601f5203d3012bdfbffa4"
        ],
        "title": "Add methods to create BoxDuplexes",
        "sha1": "e96a113c719f0ff1f360db4be2a8ade7654ac77c"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "b46bb64b11193148f35a80a06481876b88789d77",
      "c986d0efd51dada3693eb0f7a436de7354bec776",
      "238e986208781b64205c7faf9858271c796c15c2",
      "6f55de2f9548efc3f1ec9f4cd6c0d79e63f2bc1f",
      "bebc820529dd30bd507ceeb63892179014b3845e",
      "f65f9588c51e8527644220e808f1c1d9957ef21f"
    ]
  },
  "signature": "yaxZ94v/cdLxB9Q6zg2+Yi8QiygGcjl43r+EjPzNjSoRi9DqTPMoiFUKuK7sgqW3iQX8No6pWcK7XCXeFdt2Ag==.sig.ed25519"
}

{
  "previous": "%DY2Z4MrvotTsUt/5XAMVmql9zoMvL3hzVTX8Tn8a8A8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 294,
  "timestamp": 1501625027331,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%mU6j+dMrigKfjnXzbKiiJE78aeewAoAow20oDJOE8pk=.sha256",
    "branch": "%mU6j+dMrigKfjnXzbKiiJE78aeewAoAow20oDJOE8pk=.sha256",
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Rust bindings: [box-stream](https://github.com/AljoschaMeyer/box-stream-rs) and [secret-handshake](https://github.com/AljoschaMeyer/secret-handshake-rs).\n\nThis took much longer than expected, efficiently implementing the standard library IO traits requires a bunch of tricky buffering logic...\n\nI reimplemented [packet-stream-codec](https://github.com/dominictarr/packet-stream-codec) today. Next up is packet-stream itself (the multiplexing logic in muxrpc).",
    "mentions": []
  },
  "signature": "vgV+4suL5noEDGHINxioEzNFYbVVO/583JaSnt7vbSM8sFrpV6n9psI3NyXLqmK72S/0p6EjrTFl2xrVz7bABg==.sig.ed25519"
}

{
  "previous": "%SdBxXJFvN410MPb549i1I0tAu8z+Hnzn0HPhfua5azU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 295,
  "timestamp": 1502008149660,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "lolashare",
    "vote": {
      "link": "%OtYvlt9gvfs2kGjM2EOBXY+edsCC4eR1xiTIcZIOPtY=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "dHKGcsTk62eDFL1uydayiqATFbpFAc/8NUIu1uR562LL2Pwnu83ZmBQ+cv/SFf35+OQilku8wMvR9HuiDk20BQ==.sig.ed25519"
}

{
  "previous": "%BKmPXKBXCUeThYTd88b6YvRYB2ba2llj2Ri5diJd6dQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 296,
  "timestamp": 1502277930132,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%H+wCcn5rZCU79Cu3ECxIoqiSYYUrEqTZh+lSgKY2MiA=.sha256"
    ],
    "packs": [
      {
        "link": "&uVhE3R9sjMV7xK0k10FYJgv85QyghhVkm14Tj13c5QA=.sha256",
        "size": 4243
      }
    ],
    "indexes": [
      {
        "link": "&uVjjuPNMUP1sZAgEu3TyT3TpMkCNBK/r4LKcy5BF/2c=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "d8dd68d39f53e546bc05f01b46bed942ce2d9cb3"
    },
    "commits": [
      {
        "parents": [
          "5fbc95520e8f73ad026ea033cb8840d2f292bd65"
        ],
        "title": "Bump version to 0.2.1",
        "sha1": "d8dd68d39f53e546bc05f01b46bed942ce2d9cb3"
      },
      {
        "parents": [
          "bfde35be96f4adea49b1a1f1c4a7ae8076984431"
        ],
        "title": "Delegate to inner shutdown method in AsyncWrite wrappers",
        "sha1": "5fbc95520e8f73ad026ea033cb8840d2f292bd65"
      },
      {
        "parents": [
          "8f5a19dd1322cd36436f2a27f5dca846f41eeeba"
        ],
        "title": "Update examples",
        "sha1": "bfde35be96f4adea49b1a1f1c4a7ae8076984431"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "e9ea01131439cec597d7030ba1bbefe5c7abbfa9",
      "a2035236ab86236fc28f9a02316ac8cf671fbafd",
      "6107c8838595025ec647dee7fa9cda73258480d0",
      "0a5bd26ad66fc9ea46ec10c3e4a22c5db92f3fd3",
      "5a00aeacf88363d29c673d2881a0aa26abef5bf9",
      "7a50dd2f8b228fa4c61fa3d3822019f188140e57",
      "b9c0e93cf0692d973fac7ceff27901491cc02472",
      "3ec92d41d969dfb70d31ab827e19d13df4a7250c",
      "bd2747d7db5b9a991e8a8368571be446c5b28ea6",
      "5eb3eff44f83a16d5e5232f148fe070d62e26048"
    ]
  },
  "signature": "hJQ6TGHe/JViVHonoCExKckUYHaqXeFeCmvh0DNVy9lRYY8qCBDfeMaqpPMS8QL3lV+JYd1eBMTygthCbEJ5CA==.sig.ed25519"
}

{
  "previous": "%0bqfzlWB5vsobIN19W/Zl1YVge9UTjkwQqNSG+tIpRU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 297,
  "timestamp": 1502278005199,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%DY2Z4MrvotTsUt/5XAMVmql9zoMvL3hzVTX8Tn8a8A8=.sha256"
    ],
    "packs": [
      {
        "link": "&N1sPeenfrNVWAW5nfG+HEqyOvvkyUC7m58PjP3bwLdM=.sha256",
        "size": 793
      }
    ],
    "indexes": [
      {
        "link": "&/LRaSwami56b0/yUZ3z2U61kekM2uxlS+c4G2MRwOJ0=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "ecdc047f6549f141337605bb77d14083b41939b8"
    },
    "commits": [
      {
        "parents": [
          "e96a113c719f0ff1f360db4be2a8ade7654ac77c"
        ],
        "title": "Bump version of box-stream",
        "sha1": "ecdc047f6549f141337605bb77d14083b41939b8"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "4ec2829592755db7da3b7d0468bccd508e577f4d",
      "a6603aba0296fe5bc9b3e65e5adb3c68ce2ceac8"
    ]
  },
  "signature": "pOo0sfMutMBm1nMY9+UZY6Gq9rj9OAxC37BzmCJTPw2YpL/kd+tRhDTOdXT1bdTG3ZUyYY5JNRsNuZpfnz3QAg==.sig.ed25519"
}

{
  "previous": "%0cTKrcyzcU0P3TxUPLHrwU2flcNyDY9cjUZC/6W007Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 298,
  "timestamp": 1504350954095,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%8wVPPZDqL0K1oD95jO/Wo0y3KLgzbvtX01ljdKz3Idk=.sha256",
    "branch": "%1nhEIWa0HOWytB2CK8sCi/yFGWS11CofMUXa6h1hJ+M=.sha256",
    "channel": null,
    "recps": null,
    "text": "Here's the draft of the protocol I might go with if I end up not using packet-stream:\n\n# Dialogue\nA simple abstraction layer for multiplexed, streaming communication between two peers. Inpired by/based on [packet-stream](https://github.com/ssbc/packet-stream), but with a few [breaking changes](https://github.com/ssbc/packet-stream/issues/12#issuecomment-326543887).\n\nOver a reliable, ordered, one-to-one, duplex communication channel, the following types of communication are supported:\n\n- *message*: Send a packet to the peer.\n- *request*: Send a packet to the peer, receive a response packet. Can be cancelled by either participant.\n- *duplex*: Send many packets to the peer, receive many response packets. Both participants can cancel the duplex.\n\n## How it works\n\nA `packet` is a type, which allows getting and setting:\n\n- an `id` (unsigned 32 bit integer)\n- a packet_type (an enum, see the section on packet types below)\n\nAdditionally, the `packet` type is generic over some `Data` type. Any packet may either carry data, or it may carry none The packet abstraction allows to:\n\n- retrieve the data of a packet (and in particular, check whether it carries data at all)\n- create a packet which does not carry data\n\nDialogue is unopiniated about how the packet determines whether it carries data. For example, it could set a flag, or it might have a length indicator of zero.\n\n### Packet types:\nThe `PacketType` enum has the following variants:\n\n- Message\n- Request\n- Response\n- DuplexInitial\n- DuplexRequest\n- DuplexResponse\n- DuplexRequestEnd\n- DuplexResponseEnd\n\nTheir use is described below.\n\n### Messages\nA message is transmitted to the peer, and that's it. Because of this, the `id` of a `Message` packet is completely irrelevant.\n\nA message without data signals the end of the dialogue. When sending such a packet and after receiving it, no further packets should be sent (and any further incoming packets should be ignored).\n\n### Requests and Responses\nA request is a way to ask for a single piece of data (the response). To respond to a `Request` packet, send a `Response` packet with the same id as the original request.\n\nA request or a response without data signals cancellation. When receiving a request cancellation, you know that you are free to not respond to the original request, without impairing the peer. You may however ignore the cancellation and send a response anyways. Responses to cancelled requests are ignored.\n\nWhen receiving a request you don't want to answer, you can signal this by sending a response without data. This way, the peer knows that it should not continue waiting for an answer. Of course, you could also simply ignore the request and never answer. Because of that, clients should specify timeouts on their requests.\n\n### Duplexes\nA duplex is a bidirectional stream. To initate a duplex, send a `DuplexInitial` packet with a fresh id. To write further data to the duplex, send any number of `DuplexRequest` packets with the same id. To terminate the duplex, send a `DuplexRequestEnd` packet with the same id. Such a packet without any data signals regular termination of the duplex. If the packet carries data, this data signals an error condition.\n\nAfter receiving a `DuplexInitial` packet, you can write data to the duplex by sending any number of `DuplexResponse` packets with the same id. To cancel such a duplex, send a `DuplexResponseEnd` packet with the same id. Again, no data signals regular termination, whereas data signals an error.\n",
    "mentions": []
  },
  "signature": "GWCZD5OU+O7MiyNZDiCe9FkqGMnjy+RSxyH9QTzcvjULQoLb5eNvN27k/CqCvvLBeyYxonnqxdT09DtM+xUbCg==.sig.ed25519"
}

{
  "previous": "%MeNvQmJ4D/wxQKxyt6ERVszo86XfkhtFGG1WRnAzYTg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 299,
  "timestamp": 1504353217175,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%8wVPPZDqL0K1oD95jO/Wo0y3KLgzbvtX01ljdKz3Idk=.sha256",
    "branch": "%MeNvQmJ4D/wxQKxyt6ERVszo86XfkhtFGG1WRnAzYTg=.sha256",
    "channel": null,
    "recps": null,
    "text": "> The length field of a packet-stream header indicates how many bytes following the header constitute the body of the packet. This would only be zero for a goodbye packet, or if the value is an empty string or empty buffer, according to encodePair in packet-stream-codec/index.js. So packet-stream-codec cannot encode a zero-length value (regardless of it is in message or request or stream packet). But there should be no problem encoding and decoding a message (with non-zero length).\n\nOk, that's good to hear.\n\n> I assume you are talking about end-of-packet-stream, since end-of-substream indicates no-error by using JSON value \"true\".\n\nIs this because of the packet-stream protocol itself, or is that just the way packet-stream-codec handles this. In packet-stream, there's a call to [`this.write(null, err)`](https://github.com/ssbc/packet-stream/blob/master/index.js#L280), which has the same problem as end-of-packet-stream: It its not specified in the protocol, how to encode/decode this. Or am I misunderstanding the code?\n\n> How about set the end bit of the goodbye packet to indicate closing with an error? Then end-of-packet-stream could be signalled by\nthis.read({req: 0, stream: false, end: true, value: ''}) or end-with-error\nthis.read({req: 0, stream: false, end: false, value: ''}) for regular end. Existing implementations would discard the end bit and treat either as end-of-stream, since they only check the length property.\n\nThat would be backwards-compatible with the current codec, but only for `value == ''`. But if end-of-packet-stream is triggered by an error, it should be possible to send an error value to the peer. Else there'd be little reason to support errors at all.\n\n> end-of-packet-stream already exists (the \"goodbye packet\"), and supports half-close. Substreams support half-close too: it is tracked with the readEnd/writeEnd properties.\n\nSince I did not plan to include support for this in the alternative protocol: Has this feature turned out to be important? Does ssb make use of it?\n\nJust like with cancellation, I currently think that any peer should be able to just close a stream without needing any further confirmation. That just maps closer to my mental model of communication. And more complicated end-of-stream negotiations can always be layered on top via a few messages/requests. But if there are compelling use-cases I might want to support this in the alternative protocol as well.\n\n>> - allow request cancellation (this can be added to packet-stream in a backwards-compatible way)\n>\n>Sounds good, but wouldn't existing implementations treat the request cancellation message as a separate request?\n\nYou are right. I somehow thought the cancellation packet would have a negative rid, which it doesn't. So to support this, packet-stream would have to discard incoming requests with the end flag.\n\n> But you can already cancel an incoming substream without confirmation of the peer, by sending a substream end packet - you just have to retain the rid until receiving the substream end packet from the peer.\n\nYes that works, but if I design a new protocol anyways, I might as well make cancellation as simple as possible. The draft of \"dialogue\" in the previous message manages to support this, but it still only takes three bits to encode the packet type (although technically empty/non-empty packet is another bit of information.\n\n- - - \nThanks by the way for taking time to answer these questions. The whole exchange has been very helpful for me so far.",
    "mentions": []
  },
  "signature": "jKv0tbtDtSxHafaBb9ACdtsKBrNgqnCg34uPFv7b1B/qmgXX1t5KmOvcRGIwOnAQFp65rtEeFHqQ+EMhVqcSBw==.sig.ed25519"
}

{
  "previous": "%wRdPqW/dtTsmvkkI0PZ6H6SsAWWXiVgC+ixk3td3VQY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 300,
  "timestamp": 1506026114922,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ssb-clients",
    "subscribed": true
  },
  "signature": "WEZCTkE74wC9wsI82IY0DdF3OlsK5l5G6BK8iBZZ1HRmGnQS1CZwzFvLSOMMCICKOxArJQHXEJSnMNM3FpNhBw==.sig.ed25519"
}

{
  "previous": "%rAyPFBEhZ3yttfFLof2ecnIds2g52ZwRW4InQezWIV0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 301,
  "timestamp": 1507626817178,
  "hash": "sha256",
  "content": "NFO0Z6+p9n71LgpBQPHChtG1pGr+kFYkStroXlDoJF77erJKa6LdeK5vAgBv+kXvJln1S6hxuDJfveqfA11AK5gD4Zo0klmJj446fePD8rmNhPqnp9/Hp0BRMi2GHlUuglLXg7rLtVptnuuwRbUn8ER52iNIba1bzPoOggfvHvhIRuNIRGNA42oKpMFHBghgZ/z15Q0PLMRypnbagNqsneOkIItYo4J7ad4R9RMKXTaZbFos6Yr9Ds/STTHanm+MdA6OCkvZumDBQ2XFZneasnVGh/l3GJcRdncALUtDIY1gO1o3RIWd0p6UXALkYTrD3TfMiTRy8Y2s5AvZLjmEXuqytICMyLLf4Cw44/LDdDJJyOWbz3yJjcpyy9LPnvDnwuYWQXdEDJz3R0yQzu0t5mabFqzXrFOClmeokIp/8FpWQEwjj7bvNVrxpubjS4sv+ddyji3ZCKyBJ5MSMK+bRau3uNaq7GS5eJZ8e8qM2TBGXVV16vkWoud0WkwenzFjwB+imgq7agNqxeX28VxorIDLhcszMFJFlnP4A4YyBSz4rZl0HhRqWVey52mVUBG7mPFlMOkHB7e9VrswJzyduBEHKU9bk8zOJeGHtBzAyYRamFmThTQZlFPFdkibJrPLMu2EjmWUivqTyi5NEG34EidFIMUET3J731x+tqF2JXFSSeAFAnUf76ACoBGgKCHn2fr3lO7AaRghWsLOyLodwUcycL33J6MeFxRAoaLZRC+9DpD4zu6iAC3ez3El6xlOS/aSB4CrMT8ODYmPoNGIo6I9IrP7qY/d647ax/PDfDwC8Dr2vtIkK9aqVEUzZXXHgkRTx+51lQU5+hcEvIpFtzYYsF6BZLDSEMMl5f1U8ISFFT6Khdoq6tBJv9ewXK7WOPpGBLccuuGYQh1gK2d0/3H/EVGGDHPcwCghhBzbWmNBGkhx9ksEkPSRt3ybz4+flafDfdcEzqBa3BJRJL/po1yS8dFFdbXQjV9/+5iJx7CFg1KVP+vmpw3BjWRh9jvbX48M96bLH8CribLKinwDzBNY9/EdAIoUOlwX6f2fBpBezIV8GUGLgJ9YiYdBoaThgEQcIkD28vPY9QQ6dloqSjU22QbZpE+I4t3UeM1ZilQrv6l0NbPiV8k66cB54/6ZgLQqYd5Mg+XovmLzNB5s+op1GYYT5+32QajzjIMkG5uDZPtu6QO9U+gBKMutrZuYuYfqHzCqq7Wa4A6N7rluMrR0gcVZfiBTe1XVlfLGvLI8quqq/gsv9Tzo1g9RK57Oys9O27754S3mZ/vcpcKfGE+OAUavsOVU67RzaMtQO/rxp4AI/8mHuI5cWcYqCpbNOVvLyD4bXA==.box",
  "signature": "pvMmf8ZYWYgSBGU1S0vXEPfkYZLpq/KWkRwaW2NE8s7DXf4tENGjaGk16z00wbeGwJ32EYzIrd8kebtuAXh3Aw==.sig.ed25519"
}

{
  "previous": "%ZaXFG6j8dxcwERIEWG0oxmyE1ARS65/LoAURq4AOh4A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 302,
  "timestamp": 1508106653803,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@fBS90Djngwl/SlCh/20G7piSC064Qz2hBBxbfnbyM+Y=.ed25519",
    "following": true
  },
  "signature": "mwZriN3HOItIus22VKUTEYCVdItJfz2Gj7nBuzyrkRqe7V/sjazjFsuiWSVqd6jgRsNzTH2RONXpGY7BZhGlBg==.sig.ed25519"
}

{
  "previous": "%L9oYnyX9qDMitp9BMErGLHBxVfqOlDfVepD0b0R4xPA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 303,
  "timestamp": 1508931539918,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ssbc-grants",
    "subscribed": true
  },
  "signature": "Q/CZMPjGkyS99r2mZcsnxXXASX4CGbUnX/exWfIjPTpYKm9QLWbO/WQcoHeDns0GPxSrnaoW3TmH/DBfpLjOAA==.sig.ed25519"
}

{
  "previous": "%42NFBzg9fEOFRJfpn8/Q07Y3R4cGxuqVkKD6lU820ME=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 304,
  "timestamp": 1509025358529,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ssb-grants",
    "subscribed": true
  },
  "signature": "rGKrdhEU92REG/dAdIhOuADvvZIwKu3L48uI5C315loHpH5HXwuzOWm2TfUmM1xCMyU4tZMfrxeLXLRas+X9Cw==.sig.ed25519"
}

{
  "previous": "%n2qDpD8dp7Q/tSlcnnx1XhQ4UjSA7bC+RvSlHt1qyZA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 305,
  "timestamp": 1509027235546,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@0002KC2jy61L099seug+nSrxzE6rFr1z/Qh8IwTah/I=.ed25519",
    "following": true
  },
  "signature": "6BSEqNPlItDbLguFbZpW/HEXwvr1xpLPsTXSLRodg5CfJrJqapjhm483JV3PcxR24BiDMGm8N+BZard6ER8JDA==.sig.ed25519"
}

{
  "previous": "%q9oAfpQMQ3bEULCIj3vvRs3RCY+2Y8PdhcmikVJ8h5w=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 306,
  "timestamp": 1509051267860,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ssb-annah",
    "subscribed": true
  },
  "signature": "s8gE+m1wMX2k/oVQM6XtT49VogCFO2IyHdkZjckUPfhpgQx17vKyiNEyorFi/khTYvpcS5FLfkbK7r3+vbcHAA==.sig.ed25519"
}

{
  "previous": "%/oersEBighDvAFRZuoYh5PG2WEQGk5qhTgNHsk00ots=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 307,
  "timestamp": 1509051272793,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@BCM6DHYJvWzwWi1lFl2tjDXjaqyZAEmJH5ZONSpXhtc=.ed25519",
    "following": true
  },
  "signature": "OYvpGHoCFsHw9fsydYOsVpbcQKoRPO8axce4cjI9sn2IPJqd4y4GuSwmGTvFUqnDC3tiN0WslO++Yqa/IrCKAw==.sig.ed25519"
}

{
  "previous": "%bYzYPOeVNhllNNouRDY9wZXVxUhmwaaG3f1AQM0Q5qE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 308,
  "timestamp": 1509051852052,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Q5ICH9OqZUC9E2FuJ/3Ro5ha6D0UVSva5mswDt5V620=.sha256",
    "branch": "%XDAySkyQCy2czxZ1gCNeyHf97YjoD13CrzAQB5uDres=.sha256",
    "channel": "ssbc-grants",
    "recps": null,
    "text": "Note that ssb is not tied to web technologies in any way. All current clients happen to be either written in javascript or run in a browser, so using web technologies is an easy solution in the short term. But outside of the browser environment, adding javascript support to a client is a pretty heavy commitment. There are other languages better-suited for embedding.\n\nOn a more subjective note, javascript is a pretty horrible mess.",
    "mentions": []
  },
  "signature": "Rs3Lm+UhqIJpYLF4X2y4LO7JKlt+X8m7CauiA3KvTT549fqRuuxOuaByfvLSil8LIvUept9XfpEJYDwUSx5YCQ==.sig.ed25519"
}

{
  "previous": "%rMkZU8+YFwp7KZmu9f6d6H8N3s0hVbblctoFzJjUc8U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 309,
  "timestamp": 1509055006701,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%UYfw3D1tArWuhY74o+YDx4crObxH0DJrF75E89TwNf0=.sha256",
    "branch": "%KFCi8rVWIG5XPlBMx1lUrPiPXzSLF7cu6oSfheZl2Bk=.sha256",
    "channel": "ssb-annah",
    "recps": null,
    "text": "This is beautiful. Yes, we shall build it.\n\nIn addition to language-level features, I'd particularly like to explore how some meta-features could be integrated in a language where the code is available as ssb-messages. Things like doc comments, issues, code reviews, deprecations, etc. could be implemented without core support in the language itself, simply by linking to code from certain messages.\n\nI'd also be interested in versioned modules (where you can basically say \"hand me the newest version of some function without breaking changes\"). In particular, having a message per function could allow very [fine-grained versioning](%HeJmbB8kGD2GBSyC80D6Uj451+v1xNX7q6oUSbw8t5Q=.sha256).\n\nThere's so much exciting, uncharted design space in something like this.",
    "mentions": [
      {
        "link": "%HeJmbB8kGD2GBSyC80D6Uj451+v1xNX7q6oUSbw8t5Q=.sha256",
        "name": "fine-grained versioning"
      }
    ]
  },
  "signature": "HTUN0UU+hDz9qhvf2e0XK//L+LmBdIhXdDtFxKZnxARKcHsGRUryXdlm0GsFvmjhjh5wml+fLYEDGZs/2BXFCA==.sig.ed25519"
}

{
  "previous": "%3rT/4mNpEcDy+flL7D/+g/5d0qaAgIXFfmeh9rNBJBE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 310,
  "timestamp": 1509058034523,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%q5J0q5ZWdfdrdc85Gb+A1OtOekBbKVAoZ1OKce0YUQg=.sha256",
    "branch": "%q5J0q5ZWdfdrdc85Gb+A1OtOekBbKVAoZ1OKce0YUQg=.sha256",
    "channel": "ssb-annah",
    "recps": null,
    "text": "Do I understand it correctly, any function can be run as a program, a program with side effects is simply one whose type contains IO?\n\nI did not yet look at how Annah handels IO, but I assume \"similarly to how Haskell does\" means monadic IO. If so, can this be more fine-grained than Haskell's IO monad? I'm thinking of something like purescript's [effects](https://pursuit.purescript.org/packages/purescript-eff/3.1.0/docs/Control.Monad.Eff).\n\nDesigning general, \"serious\" effects (for building UIs, reading and posting ssb messages and blobs, access to the native file system) would require a lot of careful consideration, but we could simply start with a debug effect for readln and println (not even tied to stdin, a client would simply provide some sort of text input and text area). This would be enough for initial experimentation and prove-of-concept work.\n\nHash-addressable effects and being able to gracefully handle programs whose effects your client can not provide sound interesting as well.",
    "mentions": []
  },
  "signature": "nf1fVHeHrJLjk0rt7DmLfcsM6/qoktuLJzbR96Fje2SExt8UgQYdtiLPBSvJRThPGs293kHFml2fvWi8/2c+AQ==.sig.ed25519"
}

{
  "previous": "%FzbZg3u+r+9iVfbMQFkJSbIEbMF2w/HAyF8DxhF9u8I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 311,
  "timestamp": 1509059139213,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%UUkqaVHDI2STmk7u8ba+7QeNhQNg0rfJMqoIvX9L1TU=.sha256",
    "branch": "%UUkqaVHDI2STmk7u8ba+7QeNhQNg0rfJMqoIvX9L1TU=.sha256",
    "channel": "test",
    "recps": null,
    "text": "asdf",
    "mentions": []
  },
  "signature": "pF4RI4AZ8vFGiQlX6f8L5P6x7q3gHAa5u4y88NTz8yNQ3aAEu57nQVJ4b4DFMtpfOWfZJcBlX4lbTHm/4ETJDA==.sig.ed25519"
}

{
  "previous": "%CYh/bP39VByB+lP6vzq0icEALh699FsOL+RTvjqbCGA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 312,
  "timestamp": 1509059412962,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-annah",
    "text": "### Abstract Syntax vs Concrete Syntax\n\nContent-addressing of code should work on the level of abstract syntax, not concrete syntax (e.g. additional white space does not change the AST, but results in a new hash). Using a concrete syntax with a one-to-one mapping to the AST would prohibit not only formatting but also comments.\n\nSo it might make sense to use some deterministic serialization of the AST (bonus points if the serialization format is also valid concrete syntax resulting in the same AST) for addressing of code, and link to that with some more lenient, human-friendly concrete syntax (with formatting and comments).\n\nAlternatively, the whole AST could be stored in ssb messages, i.e. a message type per syntax construct. This would make an interesting experiment, but would result in a lot of overhead.\n\nThere's also the problem of messages vs blobs. If I remember correctly, the hash of a message not only depends on the content, but also on the publishing feed and the preceding message. To get pure content-addressing on ssb, you'd need to use blobs. But with blobs there might be replication problems when referring to code outside of your FOAF-radius.\n\nOf course there's no strict requirement for purely content-addressable code. It would just be extremely interesting (see also the [unison](http://unisonweb.org/2015-05-07/about.html) language).",
    "mentions": []
  },
  "signature": "UIaqe2jeaHPmr6k3S5XiaWJWHU/YR+5RlDil3DdEVmdpO09FDQ5+MpNM3KpXpZ287Aats8Y9YeBqhEz2jVU3AQ==.sig.ed25519"
}

{
  "previous": "%EBqbv3tr0HDbaM4J1mXt7OXz+jXkYByPs603Y3lnYhM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 313,
  "timestamp": 1509059681826,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@5ovtEaQsrXYU13+02SIq7ny2milWoKusk5+CFI+twfs=.ed25519",
    "following": false
  },
  "signature": "v9vfjw9rA3nYica2DTfoT4WWJqUfocxP627volUiHfyjjoQ++6b7YAX9+K4yY9kpeccv4ZRTpiz3iwblt2sqDQ==.sig.ed25519"
}

{
  "previous": "%ZGXT9AeeAn7LTp57WhI7jyYX8rTdDBIsIvezJYxgMgM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 314,
  "timestamp": 1509095982977,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EBqbv3tr0HDbaM4J1mXt7OXz+jXkYByPs603Y3lnYhM=.sha256",
    "branch": "%ITKvOF1CcOjDvB9nx4tw0q6L2sf8Oc+cwlvgebxJikE=.sha256",
    "channel": "ssb-annah",
    "recps": null,
    "text": "I agree blobs are problematic, e.g. for automatically following references. In general, we'd need to reimplement a bunch of features on the blob level which the message protocol already provides.\n\nIf we are fine with not having content-addressable code, that also allows us to add more metadata to the code, e.g. the human-readable source code, or licensing information. *Aside: Can you \"copyleft\" a hash?*\n\nI like the idea of indirection to decouple code from specific feeds. Otherwise there's also the fact that I'd need to mirror your whole feed even if I only use a tiny type declaration you published. There's some discussion on these problems [here](%bcYK0JOPzKlgu1DRhxBmpU7O+xrW+RvKSJ7u48n8Zio=.sha256), but without coming to a clear solution. Another level of indirection could help.\n\nWould we want any reference to a public type/value to be a cypherlink?\n\nThere's also the ever-present heretic question that needs answering for this sort of project: Why build on ssb and not on ipfs?",
    "mentions": [
      {
        "link": "%bcYK0JOPzKlgu1DRhxBmpU7O+xrW+RvKSJ7u48n8Zio=.sha256",
        "name": "here"
      }
    ]
  },
  "signature": "CTeEc2eEawU+vvVydC5lQ3rnP0ggdcgk/M0/nhprM46uNidDJOLOW+uTAwiTrzL+cZVY1+GT8K0EPZPK9RdoBA==.sig.ed25519"
}

{
  "previous": "%fIcE79C/uYCuGfFTxtHBLM2vzp3+0TyVlWXqkzQW35A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 315,
  "timestamp": 1509096424944,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%q5J0q5ZWdfdrdc85Gb+A1OtOekBbKVAoZ1OKce0YUQg=.sha256",
    "branch": "%7MACg5EzjPEjJTvhj3nhyOGe5iZ//zOR5z1rxVILQqk=.sha256",
    "channel": "ssb-annah",
    "recps": null,
    "text": "Isn't every language sandboxed as long as you perform no system calls?\n\nAlso just as a reminder for myself: We'll need an effect for dynamic loading of code (and since our intermediate representation retains typing information, we can get a typesafe interface where you specify the type you expect and get an error if the code does not match). The lowest-level interface could operate on ASTs or strings, higher-level interfaces could take cypherlinks or even modules with version ranges.",
    "mentions": []
  },
  "signature": "8Z+AtknWkd8GEGh7hwmD7Zg22vFx33/pL7xZxq7R2FO6gKz0mkSkcQk6Doy0XSyNNYjQPWq5urdAmbD60MriAw==.sig.ed25519"
}

{
  "previous": "%FiyNlpg6MPyig9mzCrq8/AJYQ1W19gYPzzxjof0Eftw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 316,
  "timestamp": 1509125854378,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EBqbv3tr0HDbaM4J1mXt7OXz+jXkYByPs603Y3lnYhM=.sha256",
    "branch": "%6+0uIsOdL0v7OAnItHkmLNOLqIeZA1/2ROjxu7pX9Xc=.sha256",
    "channel": "ssb-annah",
    "recps": null,
    "text": "> I was pondering morte+ipfs type stuff a year or so ago. But, while that seemed kind of interesting, I did not hit the treasure trove of applications for it I see with ssb. That mostly seems to be due to ssb feeds mixing in data from other people, which allows for much more dynamic apps than ipfs where sure you can link to someone else's code/data, but you have to do it explicitly.\n\nIt would be possible to store code in the ipfs (having all code in a global singleton database makes sense, but ssb just isn't built for that) but linking to it from ssb messages. Both for running scripts in a client and for annotating code with metadata.\n\nUsers would need to run both databases though, and the codebase-singleton would not benefit from the eager replication between friends. But that might still be better than code not compiling because you don't follow the right people.",
    "mentions": []
  },
  "signature": "fmLkgDktj852yvZ3s7XwvidzIvRrnwxroshg5uoZRPnCQrPwalxU7BEC2avSca+nWKr3lheUigotBqvBMAVbCA==.sig.ed25519"
}

{
  "previous": "%FP154QYaxK8++4Nw0La2ydthTPMU1NCU9rbHqAi9DmU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 317,
  "timestamp": 1509126432636,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EBqbv3tr0HDbaM4J1mXt7OXz+jXkYByPs603Y3lnYhM=.sha256",
    "branch": "%FP154QYaxK8++4Nw0La2ydthTPMU1NCU9rbHqAi9DmU=.sha256",
    "channel": "ssb-annah",
    "recps": null,
    "text": "> > Would we want any reference to a public type/value to be a cypherlink?\n>\n> Could you expand on that thought [@Aljoscha](@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519)?\n\nThere are some different options for referencing public entities (I'll use \"entity\" to refer anything that can be consumed by other people's code, whether that's values, types or kinds (are there any languages where you can name and export kinds?)). You could do an import to create a local identifier, or you could always refer by hash. You could have the human-friendly source code use local identifiers but compile it to hashes anyways. You could even create and use hashes for private entities.\n\nSsb creates an index for backlinks, so if every reference to an entity works via a cypherlink, you end up creating some sort of entity-dependency-graph on the database layer. With imports and local names, thi graph would be more coarse-grained (but still far better than anything you get from the package managers or githubs of mainstream programming languages.\n\nOn the ipfs, this graph would be unidirectional, in the scuttleverse it can be navigated bidirectionally.",
    "mentions": [
      {
        "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
        "name": "Aljoscha"
      }
    ]
  },
  "signature": "P4KhlbuTQkXsQAjFzX5YILdMWzpM9YbIQ6PyKXt21cI7ISR82VqAxzYEPCRUEOpHa5DLa/JrQ6WvGUaCH4piCg==.sig.ed25519"
}

{
  "previous": "%ehxGG6aGthkmCuwAujnwRzlEiXbm/KBGcNBRCreykp8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 318,
  "timestamp": 1509142374125,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-annah",
    "vote": {
      "link": "%ixORoVH2Yg7GPPTEfrefQAJjY5d7hHW2C7b6IcUvFA8=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "ZC9SxONbkTaOnLVZYyywPxmGf+XZjmUZ/WWjJQk7STJ2ScsWhMPFexq4uuPWS1dEsrDjqCfUm4fAd8K+cRztCw==.sig.ed25519"
}

{
  "previous": "%wTtomgj+XeCLwHy2xKJE0YHJiRS7YKoAa66iBQaai8A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 319,
  "timestamp": 1509277597228,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@TSbWK9mHOBWJCDkdo0S5dqAg5yxlctycMHAz6R6UwGc=.ed25519",
    "following": true
  },
  "signature": "O7Z+zV3kLT7lPO9qm+a7rRQibnYB9CZGfh9OSlERbGIHscxMd0OUOhkwy7EOetwOCcfW4rF29fbiCA0N5VX5Dg==.sig.ed25519"
}

{
  "previous": "%N6QsQcHrlloI9rhZteaOGvbi7HlgZ1Nd69TeCOLYsKk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 320,
  "timestamp": 1509294533890,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-annah",
    "text": "I spent some time thinking about this and reading up on annah/morte, I'll try to provide a snapshot of my feelings/opinions in this post.\n\nI'm approaching this as a question of programming language design. The scuttleverse provides some constraints and guidelines for the design process, both via its technical details and its philosophy. What could a programming language for the scuttleverse look like?\n\n#### Collaboration and Distribution\nSource code is freely accessible, a user can always see for himself what code is executed. Anyone can publish their own forks of any piece of code.\n\n#### Modularity, Reusability and Encapsulation\nCode can depend on and use any other code. While it is possible to organise code in modules, you can also pull in specific functions, definitions etc. Modules group code. Anyone can publish a module which links to arbitrary code by arbitrary people. These modules only form a human-centric and subjective way of organizing things, they are independent from the working of the code itself.\n\nAll of this can only work if there are mechanisms to encapsulate implementation details.\n\n#### Effects, Capabilities\nBy default, code can do nothing more than manipulate (its dedicated, sandboxed) memory. All side-effects are tracked. A user may choose not to give code the capability to perform side-effects.\n\nNot all runtimes have to provide all effects. A runtime outside of an ssb-client would for example not provide access to a user's feed (since there would be no concept of a user). This is necessary so that the language can be general-purpose. As js and node have shown, at some point people will want to run the language outside of the originally intended context.\n\n#### Dynamic\nIt is possible to dynamically load and execute code at runtime.\n\nBonus points if it there is runtime information about the availability of effect capabilities, to enable progressive enhancement.\n\n#### Entities as SSB Messages\nEach entity (module, type binding, expression binding etc.) has its own ssb message. This allows anyone to build sophisticated tooling without core support in the language, for example:\n\n-  Doc-comments can become (subjective) about-messages.\n- Messages might indicate that another entity supersedes an old one, e.g. because of efficiency improvements or bugfixes. A client might automatically use superseding entities in the programs it executes, based on these messages. All of this would be in control of the client itself.\n- A message can indicate that a function is a test for another function. Test runners can use this. Anyone could add tests, every client has control over whether it wants to run/respect them.\n- tutorials, Q/As, core reviews, issue tracking, and so much more\n- IDEs run an ssb-client and use plugins to handle different message types\n\n#### Lightweight, Embeddable\nAdding support for the language is not too much work. Either it can easily be implemented, or there are easily embeddable implementations available.\n\n#### Usable\nPeople actually want to use the language.\n\n#### Language Diversity\nMultiple languages with the above properties can emerge. It is possible to build foreign function interfaces between these languages. A user might run some code, oblivious to the fact that different programs written in different languages cooporate to achieve a goal.\n\nIt would be nice if the effect/capability system could be reused among multiple languages.\n\n#### Formally Specified Semantics\nI can dream, ok?\n\n- - -\n\nThe thought of a language designed according to the above principles deeply excites me. There are of course plenty other implementation details, e.g. static typing, purely functional programming, object-orientation, mutable references, decidability. I have (some pretty strong) opinions on these, but that's out of scope of this post. And I'll gladly compromise there. For example, though I prefer static typing, maybe a Lisp with an effect system and an event loop might be a reasonable first attempt at such a language.\n",
    "mentions": []
  },
  "signature": "VGhRoof8ilEuHyU7n1HEptlvAHZumlIKofeediIeu0hR/unUS8+14wbd92RJ5sTfveWZBDg+XVs+tT2QlKa+DA==.sig.ed25519"
}

{
  "previous": "%IGJgSkkOmRMGVe/odiy5UkfOwqW3PiSWxOGXNvc2dTQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 321,
  "timestamp": 1509376799097,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Wizpo7cm8VU66aomoNpfRU+qXBNcpot2IAW7Je62bRw=.sha256",
    "branch": "%aZM7dyg1UnSbGWAqtHkG6KPgjS4V83mZkmtEiu6HRJM=.sha256",
    "channel": "ssbc-grants",
    "recps": null,
    "text": "This would have saved me so much time when implementing shs in Rust. Great work!\n\nMaybe out of scope for this grant request, but nicely complementing it: *Somebody should* build some language-independent tests. The test suite would take the paths to two scripts as an input, a server script and a client script. The suite would then run these scripts and simulate both correctly working and malicious/faulty peers. The implementation scripts would be required to exit with nonzero code when being connected to a faulty peer, and write the negotiated secrets to stdout if everything worked.\n\nFor the crypto protocols, I'd also love to have reference implementations in C, directly invoking the NaCl API. I wrote C implementations [here](%mU6j+dMrigKfjnXzbKiiJE78aeewAoAow20oDJOE8pk=.sha256), but these are optimized for memory usage rather than readability (or obvious correctness). [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), what are your thoughts on non-js reference implementations?\n\nI know enough C to write the reference implementations. I'm not comfortable enough with the language to write the integration test suite in C, but such a test suite should probably use the reference implementation to simulate peers.\n\nAll of this also raises the question of (implementing and) moving to shs2 (fixing [this issue](https://github.com/auditdrivencrypto/secret-handshake/issues/7)) again.",
    "mentions": [
      {
        "link": "%mU6j+dMrigKfjnXzbKiiJE78aeewAoAow20oDJOE8pk=.sha256",
        "name": "here"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "CvQlqCDroUG8+OwVQfpAetXRI39lZI9wJhkSTL/DY5imbJg/VmpNjPO4mwZMBdHWdx/fTKeqUGn29C++ZILuBw==.sig.ed25519"
}

{
  "previous": "%6AFEs38HL91bdLmshcGvJRYWAXbxUHUghUZx1V19Ad8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 322,
  "timestamp": 1509376881591,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519",
    "following": true
  },
  "signature": "qSVepyQvUQVS1a1J2zCVKukDjVFxPjGtuJManTFKpFxCsXJ10Knq7oiuEHM69bNSk+ZVF67JN+rMzhiQVDggCQ==.sig.ed25519"
}

{
  "previous": "%la66i5LZCseo/o1wgWB4LvzhibXEklj8mkaKYsd1zJg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 323,
  "timestamp": 1509378290456,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%tWI9YTieHrQoOVnS6B4XZX1d5k5bGlbD2ETKUu+Xa3w=.sha256",
    "branch": "%D5stxUF0BnNp4SjHlJe6MiWJqJ0MMa4eoyumebTvsAk=.sha256",
    "channel": "documentation",
    "recps": null,
    "text": "Obligatory reminder of [issue #7](https://github.com/auditdrivencrypto/secret-handshake/issues/7), which describes a discrepancy between the whitepaper and the actual implementation. An informational section of the docs could indicate that there might be a breaking change at some point.",
    "mentions": []
  },
  "signature": "UAIqVxAisszkNgn8RkUAevClUDU7cHSm0VaJVE1gBEZ8ZRsuqXj9MbRVrkfnvwJnF4+VWNkcgkMfuFFzvD52DA==.sig.ed25519"
}

{
  "previous": "%kyq4USz4UsA+rR8ngz+A54RYjl0Xms3bdhB6ybgQue0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 324,
  "timestamp": 1509390995421,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EBqbv3tr0HDbaM4J1mXt7OXz+jXkYByPs603Y3lnYhM=.sha256",
    "branch": "%FfyLX0ZMeeu+IFmRlke6DevXHLE39h6wNbnktSAN2ko=.sha256",
    "channel": "ssb-annah",
    "recps": null,
    "text": "Note to self: For content-addressable storage, use a [Higher-Order-AST](https://en.wikipedia.org/wiki/Higher-order_abstract_syntax) instead of an AST, so that alpha-equivalent pieces of code have the same hash. Morte sytax could be transformed to use [De Bruijn indices](https://en.wikipedia.org/wiki/De_Bruijn_index) as a plaintext representation of the HO-AST.",
    "mentions": []
  },
  "signature": "zD1bJTcdcj8KxZsPFIWxbJJXGm797u5Gk40SR4LxQ1Tj9cdDGF06pdvTgfKpavO8f5YdZxhmSQc+zhLWipkiCQ==.sig.ed25519"
}

{
  "previous": "%f184lElkMMrrwnrdzffnp8hxZl4CnsXaQd9wO9N6BsI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 325,
  "timestamp": 1509442614094,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%gaYxXAEoSKf3dnw2OlI2EuoduFmkiU4kU+CncbBImPk=.sha256",
    "branch": "%TsKoFXjDIrMKPGBAOLKJtg2XbV0yRPEiBuC0Eb5F1rw=.sha256",
    "channel": "decentralization",
    "recps": null,
    "text": "This is something I spent a lot of time thinking about the last few weeks as well. I didn't get to do a proper writeup, but I took some notes. These focus more on the overall API than the implementation details, but they might still be useful. I'm happy to answer any questions about this, since the notes might be difficult to read without the context of my brain.\n\n# Fractal Identities, or Beyond the Append-Only Log\n\n## Background and Motivation\n\n- ssb = subjectivity && avoid hard replication problems\n- blockchain per user\n- keypair as identity/feed\n- but: identities are fractal\n- links\n  - dinosaur's holons\n  - same-as messages\n  - ssbpm package owners\n  - git-ssb groups\n- clarify that this post explores solutions outside of the append-only log (but keeping the append-only)\n  - this might weaken the \"avoid hard replication problems\" and can thus be considered non-ssb\n- first half of the post stays on conceptual level, avoiding implementation details (i.e. merkle-datastructures and replication protocol implications)\n\n## Consideration 1: Partial Feeds\n\n- one identity maps to one feed, so when subscribing you get everything\n  - advantage of this: data availability\n- imagine github but to subscribe to an issue, you have to subscribe to all user activity\n  - this is an (unacceptable) advantage of other (centralized) platforms over ssb\n- key idea #1: a feed should consists of multiple subfeeds\n- feed owner can open up new subfeeds\n  - aside: what would a protocol look like that allows anything to act as an anchor for a subfeed?\n- make this arbitrarily nestable, e.g.\n  - Aljoscha\n    - github clone\n      - repo A\n        - issue 1\n        - issue 2\n      - repo B\n    - twitter clone\n- this is just to demonstrate the need for inductively nestable feeds, not suggesting that a github clone should actually use this level of granularity\n  - in general, finding the correct level depends on the usage, might be hard to predict\n    - to allow erring on the side of unnecessary granularity, implementation should be cheap/lightweight\n- subscribing to a feed would also subscribe to all child-feeds.\n- generalize to splitting an identity into its different parts (e.g. someone might be interested in Aljoscha the coder, others in Aljoscha the musician)\n\n## Consideration 2: Multi-feed identities\n\n- one feed maps to one identity, so different devices create different identities\n- this does not reflect the actual reality\n- problems (e.g. keeping subscriptions in sync), so e.g. same-as messages proposed\n- a protocol-level solution has advantages over message-level conventions\n  - no additional effort for app-makes to support this\n  - works for all apps\n  - nothing to get wrong\n- basic idea: merge two feeds into a higher-level feed\n- generalize this not only for different-key-feeds, but also for arbitrary stuff\n- this is on some level similiar to use-case 1, just in the reverse direction\n  - how does it differ? Because multiple feeds are involved. If you treat feeds as an abstraction without the blockchainy implementation details, it's exactly the same thing\n  - this implies that there should be a general mechanism for differnt feeds to contribute to the same identity\n  - with nested identities, this can become pretty powerful\n- consequence of this: loss of total order of elements of an identity's append-only-thing\n  - different feeds can post to the same identity without knowing of each other, so which message is first?\n  - note that same-as messages have the same problem, but if this is part of the protocol, developers need to tackle this up-front rather than as an afterthought\n    - CRDTs ftw\n  - mechanisms to increase number of comparable elements:\n    - link to newest known message\n    - lampert clocks\n    - scaling considerations: what if an identity consists of 10 subidentities? or 100?\n- also: identity could be part of more than one higher-level identities => identity-hierarchy does not stay a tree (as implied by use-case 1), instead we'd get an identity-dag\n\n## Consideration 3: Fractal identities that are not strict subsets\n\n- everything before treats fractals as strict subsets: if I subscribe to an identity, this includes everything reachable in the identity-dag\n- might want to subscribe to everything that is done in the name of the ssbc, without being interested in the private stuff of its members\n- aside there are different types of feed-aggregation with different subcription possibilites. Who is the judge of what ends up in a protocol?\n- other direction seems fine: if I subscribe to all of dominic's activities, that includes his activities in the name of the ssbc\n- this can be modeled by making an ssbc-subfeed for each of the ssbc's members\n- ssbc feed might again have a twitter subfeed and a github-clone subfeed\n- but if group feed is distributed as subfeed of members, how is it possible to refer to the group-feed as a whole?\n- which side initiates identity-merging? Intuitively the aggregation-identity should do so (e.g. inviting somebody into a group), but maybe the invited party needs to create a sub-identity first?\n\n## Consideration 4: Aggregating identities changing over time\n\n- identity aggregating different identities, membership may change over time (e.g. in a package manager with an identity per package for publishing rights, might want to add or remove publishers)\n- simple solution: everyone subidentity may add any other identity as a new subidentity, or may remove anyone\n- might be abusable, but in these situations, the problems are human, not protocol-level, and as such no protocol can prevent trouble\n\n## Consideration 5: Aggregating identities with hidden subfeeds\n- aka private groups: identity which consists of nested identities, but which to the outside looks like only a single identity\n- no idea how this could/should work, but it should probably be considered\n\n## Some thoughts on implementation details\n- full separation of physical identities (keypairs) and logical identities\n  - one-to-one mapping between physical and logical identities, or one-to-many (different physical identities can be part of the same logical identity) or allow logical identities to be backed by arbitrary physical identities (in addition to their sub-logical-identities) (many-to-many)\n- no more bloom filters for replication\n- feeds probably need to contain some metadata",
    "mentions": []
  },
  "signature": "A9jc+egbdxk4nhUw5t7Fy3ZmShpJmuaAgYx/o3qXSqlWzmMcwivJQfw9YseTTni7agQBjR6Wxm9OIIN8aPsKBA==.sig.ed25519"
}

{
  "previous": "%DrwiwQyz2AYTI+Eu6hsR5Kju05LHtpm/FCwHMObRgjI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 326,
  "timestamp": 1509443052181,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "documentation",
    "subscribed": true
  },
  "signature": "B8WBJZgE2sUcFVMgkOfTaZe92Xf7ld57yca96blI/iAWsrQXL6y1ysPzejwB9SBIHas5jNXNvtKa4sFUujMdCA==.sig.ed25519"
}

{
  "previous": "%zv36vgKC2zR/AaTpHxHfeAdtYr6CGz61PlF9l3QqTVk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 327,
  "timestamp": 1509444064792,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%tWI9YTieHrQoOVnS6B4XZX1d5k5bGlbD2ETKUu+Xa3w=.sha256",
    "branch": "%kyq4USz4UsA+rR8ngz+A54RYjl0Xms3bdhB6ybgQue0=.sha256",
    "channel": "documentation",
    "recps": null,
    "text": "I started work on a language-agnostic testing suite, written in js and more or less reimplementing the shs logic (sorry [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), but I find it extremely difficult to read, understand or reuse the reference implementation). Anyways, I try to use these docs as a reference, so I can give some more feedback:\n\n- The code boxes have been very useful. I'd love to see code boxes for the validation steps as well. Currently, I need to dig into the sodium documentation to find out how to validate messages.\n\n- I remember the protocol doing some key curvification (`sodium.crypto_sign_ed25519_pk_to_curve25519` and `sodium.crypto_sign_ed25519_sk_to_curve25519`), but that's not mentioned in the docs.\n\n- The color coding for public/private keys is great, but also a bit subtle (maybe just state somewhere in the text that private keys always have a black background)? At the shared secret derivation, I first did not see that suddenly private keys were involved. That is only indicated by the key color and the short suffixes `sk` vs `pk` in the code boxes.\n\n- The beginning could include an explicit mapping from key-graphics to the names used in the code boxes.\n\n- In the shared secret derivation question, I might ask the following questions as a crypto newbie:\n  - Do `nacl_scalarmult(client_ephemeral_sk, server_ephemeral_pk)` and `nacl_scalarmult(server_ephemeral_sk, client_ephemeral_pk)` have the same result?\n  - If so, why?\n  - Does the ordering of the arguments to nacl_scalarmult matter?",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "rwAwRtqWTg6M1/J7X1syxSTtE+rgqRyrd/9FWS6kaVz5r7745eNKeMK8RA150fj3CDU9F7Jwtm+e5GujEG5aCw==.sig.ed25519"
}

{
  "previous": "%DJ/k6KiRQ/pniJbc7XtB/WcYkTWqmlAJIZ6mdNIyJsI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 328,
  "timestamp": 1509456609264,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "documentation",
    "vote": {
      "link": "%7UKYhxJ9vkDNygVXdhhEu1C33J/CLIy/BdWW7yLGpHs=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "hDXhSlv+SHaWwbrjDPpQnir9Mv2uivPwkSeWZY/3ujIH2Y8dWl3gI0GLhCH3S4Zz0+lYfDGROsyGKMhcBDGlAA==.sig.ed25519"
}

{
  "previous": "%toGlLlYYHBAa6Hqj0DcJa95LxDgrgEwzLdfTiGF0BV0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 329,
  "timestamp": 1509458130455,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%tWI9YTieHrQoOVnS6B4XZX1d5k5bGlbD2ETKUu+Xa3w=.sha256",
    "branch": "%DJ/k6KiRQ/pniJbc7XtB/WcYkTWqmlAJIZ6mdNIyJsI=.sha256",
    "channel": "documentation",
    "recps": null,
    "text": "Minor nitpick: Could make it more explicit that messages 3 and 4 only exchange the signatures of some data, not the data itself. This information is already in the text, it's just not features prominently. I accept that this is a matter of style/preference though.\n\n@Dominic, I agree that an explanation isn't necessary, since the abstraction isn't leaky. And I like the light saber analogy =) Still, the fact that it is commutative at all is not obvious and could be mentioned directly.",
    "mentions": []
  },
  "signature": "knXd7kTN6BuwiK7bcy2gflhpGlHygzp5MoszztFSFmeiseoUSZBWl9/zbx5LOTOc8Twur1iFS6ZRdcdSDolQAg==.sig.ed25519"
}

{
  "previous": "%DTKNnc25L9U5IvAF8R7PJ4ONBePRj4TUXsGIoQrXVEU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 330,
  "timestamp": 1509467903644,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%aAvtv+ngPgtA2EGyDQEEJjugMTTSZEQbDLx1WslPBe0=.sha256",
    "branch": "%cLBb9xVLFstcgOiZJfB7PS/RXIadA5XD+5R9LxlBVhk=.sha256",
    "channel": "haskell",
    "recps": null,
    "text": "Please post here if you start working on secret-handshake, since otherwise I planned on writing a Haskell implementation in the near future.",
    "mentions": []
  },
  "signature": "q6HzrYtK3dxEmBhsRndHrb6vpD+rqelhtMg8+U03dnA8PybS4P5au7Fkg2xurc0bRX/amTC7jftneePA1U9HBg==.sig.ed25519"
}

{
  "previous": "%pxMfK7CnMw+8Jxv74hHvpl4z36i3fZUYMd54UclXmAc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 331,
  "timestamp": 1509476886863,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%tWI9YTieHrQoOVnS6B4XZX1d5k5bGlbD2ETKUu+Xa3w=.sha256",
    "branch": "%DKI4BuSYW5MJKVHh2U3znC1KUYtqm36lG8nL5UHOztk=.sha256",
    "channel": "documentation",
    "recps": null,
    "text": "And here we go, my implementation of the shs crypto in javascript, with a focus on readibility: https://gist.github.com/AljoschaMeyer/bdcac0377fdef904119a52c41bd50871\n\nThis came together somewhat accidentally, this is just a part of the language-agnostic integration test suite for shs I'm writing.\n\n#ssb-implementations #shs",
    "mentions": [
      {
        "link": "#ssb-implementations"
      },
      {
        "link": "#shs"
      }
    ]
  },
  "signature": "8oZBQwL6tO31PEK/apW6yDrxyPgvaUH+bzXqJs5y4HPxKoqagxlnxZC9TLA5bdjqR0J/4tREv9wjqN8f2gwQDA==.sig.ed25519"
}

{
  "previous": "%oHdPuZXHBC1c92/wCsw2POVde9ztIrPB4pWyDFzwczY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 332,
  "timestamp": 1509482642674,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%aAvtv+ngPgtA2EGyDQEEJjugMTTSZEQbDLx1WslPBe0=.sha256",
    "branch": "%ON/xrBMFbVE+hNhpApUt8HJfx+SNROnfd40V+b6jqM0=.sha256",
    "channel": "haskell",
    "recps": null,
    "text": "I don't want to \"steal\" this from you though. I implemented shs twice now, it just seemed sensible to me to get it done in a few more languages (Java, Haskell, whatever seems useful to have). I can probably write further implementations pretty quickly now, without having to learn the protocol (which is arguably the more time-consuming part of implementing shs).",
    "mentions": []
  },
  "signature": "/1Jam3sjJVEVyuM5D661NyjxKKV/9VDZQifIHEGZbkFpqQpmfwwtv5voetyhDiFPw1JpVQtEP5sENWFG4Vl9Ag==.sig.ed25519"
}

{
  "previous": "%2XkN2/0/5+GHMunXPwiNKqaYpUUJ3ysaqmyo5nvYX7s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 333,
  "timestamp": 1509484044484,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%tWI9YTieHrQoOVnS6B4XZX1d5k5bGlbD2ETKUu+Xa3w=.sha256",
    "branch": "%v8E4MhYqLqsgX3zB/EZiOPc1FgzbOPz9dhROohXxAyI=.sha256",
    "channel": "documentation",
    "recps": null,
    "text": "Ooh, I like that approach for the signatures.\n\nHave you tried directly representing the secret box keys as (green) hash boxes containing  \"all you know of\"? That might be a neat way of visually representing the exact mechanism for computing the keys. Might get a bit crowded though, hard to evaluate this without actually seeing it.\n\nThe end could also detail how the keys and initial nonces for box-stream are obtained form the final secrets.\n\nI'm happy this feedback is helpful, but i'm even happier that there is so well-crafted documentation to give feedback to in the first place. Thank you for doing this. I also don't consider the grant-request (we need to be careful not to accidentally do all the work too quickly) to be a second-class request. Excellent documentation and easy-to-follow implementations are a key requisite to enable diversity across the whole stack, not just on the client level.",
    "mentions": []
  },
  "signature": "DU04B1T3IyI7rRnTfc31wWN+8VCjZf5fcI1ILtqmtwjOQxZTgRgcWE+Nu0wKEtMFQuhtWhDTfhExGlsZDig/Dw==.sig.ed25519"
}

{
  "previous": "%J2fybflmvCN9Ae1wKfth79WHPlWn/52UqnhPDBypEuo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 334,
  "timestamp": 1509489585495,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%tWI9YTieHrQoOVnS6B4XZX1d5k5bGlbD2ETKUu+Xa3w=.sha256",
    "branch": "%ExageObHkl80E79krWfiPRVrnTs14ee8oiBNp4oH3KM=.sha256",
    "channel": "documentation",
    "recps": null,
    "text": "\"Circular feedback death spiral\" made me smile =)\n\nBut yes, I like the idea of e.g. sharing terminology/variable names between a reference implementation and the docs. Speaking of which, I think I prefer `x_y_public` and `x_y_secret` over `x_y_pk` and `x_y_sk`. It's just so easy to miss that one letter. Also, \"pk\" always brings \"private key\" to my mind, which is obviously not very helpful...",
    "mentions": []
  },
  "signature": "tKzRINTzmqLZVvPmt831TzFJvC1cpTGwR5z4A4EfA/3Ch8WKBlM9dspgMSZMDHqrSg4KLtzXQ9q9XxJ6E5q3Ag==.sig.ed25519"
}

{
  "previous": "%cUEzqhtBTWM8b+wcqZAiPMZhZdeVRp/LFt9PYha1hBQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 335,
  "timestamp": 1509525020084,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%gaYxXAEoSKf3dnw2OlI2EuoduFmkiU4kU+CncbBImPk=.sha256",
    "branch": "%8ltgZQFciCOFKyQd7v5jNMhjNbZSsbjnOLiPMMr9UuI=.sha256",
    "channel": "decentralization",
    "recps": null,
    "text": "Yeah, I wrote that braindump to preserve my sanity. Get it out of the system and start thinking about other things, or even more radical: Go to bed and actually try to sleep.\n\nI do have some diagrams (analogue though) on possible merkle-datastructures, but nothing concrete yet. I just really want to take a break from this stuff right now. But I'm optimistic that there are nice solutions, and I'll probably come back to this at some point.",
    "mentions": []
  },
  "signature": "OdCWQ20gLljYiwuzRH8XAMo4CyDihZS91o+cn7DSNvZGxQCC7HDRTM/P9onwuygzQAxzKLTKVVO+Hd50v5IjCA==.sig.ed25519"
}

{
  "previous": "%4w7TEDANo+cPOASJ3HPuip1+YSQNh6KbxfLahNQQbsU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 336,
  "timestamp": 1509629449226,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc-grants",
    "vote": {
      "link": "%n3BeZQNpHZH/CGd004DDmlFhX/uGqR8Z09BncpbUphc=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "7RP0bjPM/SebZcOkwypuSSLxFOiWiTpFwWWLffHF4Bz3vfymukv4P1jqwRtPWeqaompny+/pZTKjTfqTBbEWDA==.sig.ed25519"
}

{
  "previous": "%tw+zmbcvhdQ3qy+qiwnmr0SheHCIHjsKo7tccXT7J5g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 337,
  "timestamp": 1509665788067,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "unix",
    "subscribed": false
  },
  "signature": "kshBeTi47wBAlY0x+tHW/GbRLvzLcDlU/Zn7hdSL6YNZZcjR+8WBCYz/S4FQYhFPKe9di5b/MDj86siTxn5sBA==.sig.ed25519"
}

{
  "previous": "%QyabJFmEpgED5T7IuFiXy03sPkBGouh73/M6iZbvUwM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 338,
  "timestamp": 1509706769006,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ExDsVAvUpINCzjcITRmNquB1gFSjXZswNlltJEbyQiE=.sha256",
    "branch": "%bDuzCSLjcw2Z8eVknl3mHcX/Si4IZD3JlGoh5srXZiw=.sha256",
    "channel": null,
    "recps": null,
    "text": "The magical LAN is called [Hyperboria](https://hyperboria.net/) =)\n\nAs for the clients, there are some efforts underway for reimplementing the core protocol logic in other languages. We are not quite there yet (only so many hours in a day, and this platform offers so many opportunities more interesting than implementing wire protocols), but we'll get there eventually. I did some [work in Rust](%SdBxXJFvN410MPb549i1I0tAu8z+Hnzn0HPhfua5azU=.sha256) and will probably continue with that soon. The plan is to get to the point where you have a client library in Rust. Then, you could build interfaces via GTK or QT bindings. There's also some [go code](https://github.com/cryptix/go-muxrpc).\n\nOne of the not-so-obvious reasons for pubs is that they are really useful for NAT whole punching.",
    "mentions": [
      {
        "link": "%SdBxXJFvN410MPb549i1I0tAu8z+Hnzn0HPhfua5azU=.sha256",
        "name": "work in Rust"
      }
    ]
  },
  "signature": "ksEKyjsbWrapIThGiwaS4txMrYMsmXt34mlKmZyBe4MGyNtzpBrJPFMADJ5mi9jWO8hYCEZi8mnjRRz46v9UBw==.sig.ed25519"
}

{
  "previous": "%FCm5BlCBaSjvSInn+YSeMBr8uw3JAPOOej2gVhZBsUQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 339,
  "timestamp": 1509713643939,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%ExDsVAvUpINCzjcITRmNquB1gFSjXZswNlltJEbyQiE=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "ZNB2yOIR7JjTbyhCKFUz3gJ+/r/biwS3mpNBFt2VswrxSn9S9VQow4At2KfjGEcSgCLWsO4IL7A4hSB5eUTOCQ==.sig.ed25519"
}

{
  "previous": "%MW/lhkjtDoNF1gdtt9x9EBJNZAgmHyFzfxMGemK+Kg0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 340,
  "timestamp": 1509714240906,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "shs1-crypto-js"
  },
  "signature": "uEIIpqA9SQKpH+kB3RQqZzjWCq6VvYZzFpklyU20Uo7Cdawccq06l2WFbwQOrqPDrABFeQqQuCpXwj8HXCP0Bw==.sig.ed25519"
}

{
  "previous": "%rnd/M+M2X0eXzYMHGjvH6iqKLLsFJplqO+rObm58vcQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 341,
  "timestamp": 1509714307032,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%rnd/M+M2X0eXzYMHGjvH6iqKLLsFJplqO+rObm58vcQ=.sha256",
    "refsBranch": [
      "%rnd/M+M2X0eXzYMHGjvH6iqKLLsFJplqO+rObm58vcQ=.sha256"
    ],
    "packs": [
      {
        "link": "&HFsQzNkMdbwsmrvjg5zFpqstXdOg0y/4zzLWp6xWzI8=.sha256",
        "size": 58993
      }
    ],
    "indexes": [
      {
        "link": "&+Fbuwii0bhqd/1RtSd/PIad7JBV1OvHUQhPcKNs1JQE=.sha256",
        "size": 1632
      }
    ],
    "refs": {
      "refs/heads/master": "1b006661997f4bc1bca057167fafd984e78e24cb"
    },
    "commits": [
      {
        "parents": [
          "7ae95bd0fee620e313b111ce6c171fd8abd428e8"
        ],
        "title": "Add lockfile to git",
        "sha1": "1b006661997f4bc1bca057167fafd984e78e24cb"
      },
      {
        "parents": [
          "c29428f6cc77d7377742d54ba0a8a390f76baaa8"
        ],
        "title": "Make test scripts executable",
        "sha1": "7ae95bd0fee620e313b111ce6c171fd8abd428e8"
      },
      {
        "parents": [],
        "title": "Refactor crypto implementation out of test suite",
        "sha1": "c29428f6cc77d7377742d54ba0a8a390f76baaa8"
      }
    ],
    "tags": [],
    "num_objects": 20,
    "object_ids": [
      "9f68b0bd51305f02f01fdd8dc6d597de02219b12",
      "3c3629e647f5ddf82548912e337bea9826b434af",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "4445299ca6e7ede71c4e0223494011d45f12f517",
      "6335b4f16a023385bfb43e294ea4edb4b37fa67a",
      "704d3d4d731b72292d3f9708c1a1326e1936fbb8",
      "b3d6f7d42920cbdbb2c658cf4e3043dcb1ca9b52",
      "42d9194cd571bcbb740cd8308493250c5a8cd8a9",
      "852ffdb3c1965ede1541326e32a0cd1f1cc76ae6",
      "e9712d42826797c41eda7dd98e41dfe9a8734165",
      "76a4dfb4eb0c1747b7ad794f2539172d21bc3cdf",
      "3e091e8b59104d9d3a6afe673fa2250cc81876f2",
      "05f72e7bc295d136afa9c95066e0b3ece08759e6",
      "df1e2e5e7bbd455aff377a3c7c4f7f4124c88028",
      "a48fb13887d095cb56422a033dfe34d9785c6ed9",
      "56ef00c909cf417d1a3a60d804e8a974e6318f5c",
      "fbafbaca2ba39c40e59b6c3ec46a97feb3549613"
    ]
  },
  "signature": "Tm2fiD3gIt0/TA2pXT89ujRhGUirzbWRCv1Prpw6+zNYy3eahDayvEaKmEc3OAbML9l/6ujBjPWfMeBkkZy8BQ==.sig.ed25519"
}

{
  "previous": "%Ar51RZMAdvyiGLMCVu++7+sSw382XKWKginc0S2BgYU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 342,
  "timestamp": 1509714629983,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%rnd/M+M2X0eXzYMHGjvH6iqKLLsFJplqO+rObm58vcQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Ar51RZMAdvyiGLMCVu++7+sSw382XKWKginc0S2BgYU=.sha256"
    ],
    "packs": [
      {
        "link": "&o1zFq5Ves7gbGK4NB0LAAOyIQlBOMBOJXi62Sl9WNV0=.sha256",
        "size": 516
      }
    ],
    "indexes": [
      {
        "link": "&JA5HaZPVgTyX6ph6rLexUY/BTP8DoDpMsarWIyBhXL0=.sha256",
        "size": 1128
      }
    ],
    "refs": {
      "refs/heads/master": "7bb0c89fdbd8cb569ccf436c6139fb285b68f722"
    },
    "commits": [
      {
        "parents": [
          "1b006661997f4bc1bca057167fafd984e78e24cb"
        ],
        "title": "Remove npm lockfile, use yarn instead",
        "sha1": "7bb0c89fdbd8cb569ccf436c6139fb285b68f722"
      }
    ],
    "tags": [],
    "num_objects": 2,
    "object_ids": [
      "a48fb13887d095cb56422a033dfe34d9785c6ed9"
    ]
  },
  "signature": "idHms3hljApphxMcLqCc6sJd4QGbVf0UzuTvNdzB/PG1WTt8C6gTc/TbIbeCGD3LJp6hDwMZs+v3RtLXXogaDw==.sig.ed25519"
}

{
  "previous": "%Slfn+2HUKg3MsUuFlgOjOhuiXXcoP4zNl0XX9NWI0DE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 343,
  "timestamp": 1509714773215,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "shs1-testsuite"
  },
  "signature": "jo5y3kw/xZIClXlhUKIXashYgyzTeU5fEbSNm28ZmXNwltRQ4EaeYg1ybk9gQTLFSA62jqXEYo5BwckQS9ttBg==.sig.ed25519"
}

{
  "previous": "%riikqU1Zc/dgjc80vABMA3DkTzTHzlxEYxGU5NYwje8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 344,
  "timestamp": 1509714777955,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%riikqU1Zc/dgjc80vABMA3DkTzTHzlxEYxGU5NYwje8=.sha256",
    "refsBranch": [
      "%riikqU1Zc/dgjc80vABMA3DkTzTHzlxEYxGU5NYwje8=.sha256"
    ],
    "packs": [
      {
        "link": "&a83PB6a6TArxyoomKBBXrFfPd/Vo0qQanVM/QceQ1Ts=.sha256",
        "size": 72763
      }
    ],
    "indexes": [
      {
        "link": "&39c1NnPAbG3SXaUNJ3JUX1Vsils6n8ceOrKXamFmrRs=.sha256",
        "size": 2528
      }
    ],
    "refs": {
      "refs/heads/master": "66c5dd64c151ca4e3d6ad22e5bdc793c67358797"
    },
    "commits": [
      {
        "parents": [
          "3595768a3d499941e9f8aae00f38ab8fe31e76c7"
        ],
        "title": "Remove npm lockfile, use yarn instead",
        "sha1": "66c5dd64c151ca4e3d6ad22e5bdc793c67358797"
      },
      {
        "parents": [
          "f5aa4b8c8b7459fa0dd8bd3e9f8930630c0d4ec5"
        ],
        "title": "Underp failure message",
        "sha1": "3595768a3d499941e9f8aae00f38ab8fe31e76c7"
      },
      {
        "parents": [
          "1e8ff333d0ed5680c0da3cbf64cf7d2e9b18f111"
        ],
        "title": "Move crypto into its own module, clean up",
        "sha1": "f5aa4b8c8b7459fa0dd8bd3e9f8930630c0d4ec5"
      },
      {
        "parents": [
          "823fc02de56be80fb33de6a825af5e4a0382fab1"
        ],
        "title": "Add more trace information",
        "sha1": "1e8ff333d0ed5680c0da3cbf64cf7d2e9b18f111"
      },
      {
        "parents": [
          "d5180d68fe00824c41d3eebec461380038e97784"
        ],
        "title": "Implement test suite for client",
        "sha1": "823fc02de56be80fb33de6a825af5e4a0382fab1"
      },
      {
        "parents": [
          "6e9e600a8a0e76c5d9c8d4f75d1c2a8a4ba1e1f9"
        ],
        "title": "Implement test suite for server",
        "sha1": "d5180d68fe00824c41d3eebec461380038e97784"
      },
      {
        "parents": [],
        "title": "Implement the shs crypto",
        "sha1": "6e9e600a8a0e76c5d9c8d4f75d1c2a8a4ba1e1f9"
      }
    ],
    "tags": [],
    "num_objects": 52,
    "object_ids": [
      "f2cadc74c581a0b0b8caecfd64e0b0468c85080f",
      "d53aac10893dc3ba72600cc68c5d7a1461739a4c",
      "3c3629e647f5ddf82548912e337bea9826b434af",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "5b2f34f236dc76c0831dfd9291ac5c81589ffed2",
      "9ab957d3c353b16697dd696cc7b0a64e357b1f1e",
      "e7c16c3fb74151662bcf007828db74eaf4665264",
      "2e2d94171a89cdbfb3a3bbeba761f100438de7da",
      "5995574fc5742611383a664feee07c9a313793e3",
      "71ef543e51f212ecd7e2d2e556ddcce7db0b3ba7",
      "9a3741273dd00e36a915064ffddd1994920e09e4",
      "6b616a65a4454fde60529e61816edc23dab48b38",
      "7ed4757c03301db96195354f4f3c12d8aa039dba",
      "f901fb1798bc0792c4f21e362c876e29862b46e9",
      "08bdc942181b72c663c5a3f090f7bf088e82e53f",
      "d001efbdbee7de3dd2fe611b5f3b17ac78d2dd69",
      "4bae3dd3031cb3132f33425777891574c7c6af8f",
      "3863fbfd23f1acaa498f07ce292888449aa3dcf7",
      "b3cf6a8f7786c62c5db8360beb0b22a91e3ec026",
      "8dbf961416484b4c58f4864b1347f56e1c0a0c05",
      "6335b4f16a023385bfb43e294ea4edb4b37fa67a",
      "852ffdb3c1965ede1541326e32a0cd1f1cc76ae6",
      "0070babe1585db32c298986e9ecb18025592ffbd",
      "925b354b4fe875a0c61a123a1c14d024d7d62364",
      "46afc3341a15c88f7be435126116ee2e81ed29b2",
      "f0da3c1a09a52e57d4cd4afd3f41d24e1e18ed57",
      "1b962cc9379e30805755bf1cdd37ab54a175743f",
      "cd14eeabf6564adf49385531f41295af473b55b6",
      "10856d9235ea1eef1e1ef81f4766f8c68a179849",
      "d5802324d4b31dc9a42dac9d4400c5645228264b",
      "880524e63a718b225e0fe08580490ac115eb4a5d",
      "a5686ddc2aeb4bbcf9fc277030650a3cf3c886aa",
      "776c13dacfe652a9c8e76c64f6fdff793aacb813",
      "3d55df75eeeee9073ae0b3b013a1d88267df8ea5",
      "2ea7d20923b828e6d9e42d030ee042c813c093b5",
      "3aab236871140ee773d1b80179084b4040b4ee6b",
      "f4420caca0681435a632e10238fabfdead98d7f5",
      "6262ebace167c982d9c6e4c74c5be9f04fb93a75",
      "ca6645f233fdcc7bee715146e7635168fa32a109",
      "0ae7388e1ff86b519b8a61626bde6a59699a0704",
      "7e2e6865f915287be72f5814d98f7b7c66881c0b",
      "a8fa23ff85abdaeee1e11e7734be867649e2b070",
      "a82b49205bdad95d377234aa393c513469f8fcd9",
      "efcd91de66dc3c76763802ff940b4bacb0b5054c",
      "b4269d1f1b315d3e8d00776ed9d5022597330eb4"
    ]
  },
  "signature": "dVNm6gSYv8ROFbTSFQPqgf7HjY47OuSOb7S0tfg8NkuraiO0KD4U/5oGkk9PP4dcbwCE9mz3XBL+gFosREMQBg==.sig.ed25519"
}

{
  "previous": "%fYf333YFftwIiJld0/qXvrWbkVsmrzYN1gNd/0nLZPY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 345,
  "timestamp": 1509715233257,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Wizpo7cm8VU66aomoNpfRU+qXBNcpot2IAW7Je62bRw=.sha256",
    "branch": "%6AFEs38HL91bdLmshcGvJRYWAXbxUHUghUZx1V19Ad8=.sha256",
    "channel": "ssbc-grants",
    "recps": null,
    "text": "#somebodydid build the language-independent test suite for secret-handshake: [github](https://github.com/AljoschaMeyer/shs1-testsuite), [npm](https://www.npmjs.com/package/shs1-test), [git-ssb](ssb://%riikqU1Zc/dgjc80vABMA3DkTzTHzlxEYxGU5NYwje8=.sha256).\n\nAs a side-effect, I wrote my own js implementation of the shs crypto, trying to make the code readable (and reusing terminology from the doc draft): [github](https://github.com/AljoschaMeyer/shs1-crypto-js), [npm](https://www.npmjs.com/package/shs1-crypto), [git-ssb](ssb://%rnd/M+M2X0eXzYMHGjvH6iqKLLsFJplqO+rObm58vcQ=.sha256).",
    "mentions": [
      {
        "link": "#somebodydid"
      }
    ]
  },
  "signature": "XOX97+ZkkavcAwh9VMHXWwiKSaFeaTCc4wHge2VuXP95s+TTw2GgtmP4MDbj2dU3p7fIZmoGNXdCGAdB8ovtDg==.sig.ed25519"
}

{
  "previous": "%q0rV3fLsMCWrOJuCm3Uh/axLunokt7S5ugVM//CaoKo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 346,
  "timestamp": 1509715774103,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%riikqU1Zc/dgjc80vABMA3DkTzTHzlxEYxGU5NYwje8=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%fYf333YFftwIiJld0/qXvrWbkVsmrzYN1gNd/0nLZPY=.sha256"
    ],
    "packs": [
      {
        "link": "&T71OaOdD/j82x7Qzu+ZgP14UtV1h24EbI7WTqKKuhjk=.sha256",
        "size": 1636
      }
    ],
    "indexes": [
      {
        "link": "&UXRJSWdO7T1imu4eIjXFN5rObsDIBZTnsJeastFI1iE=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "bba206cd5d1c20c7e557fecba5aeb605dc8e56c2"
    },
    "commits": [
      {
        "parents": [
          "66c5dd64c151ca4e3d6ad22e5bdc793c67358797"
        ],
        "title": "Clarify readme",
        "sha1": "bba206cd5d1c20c7e557fecba5aeb605dc8e56c2"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "51bf5f058e1b869021c721015f6bbe17aff68630",
      "87191b4f497ace34fd11df9f13f251ae45893cff"
    ]
  },
  "signature": "kzvoUxsU+fKiOV5i+Yx9sfjkD+gtFUEH8tgi7qcL2R5cgkZiFdCjKj1PvgBURQZ/B0Yli/9JyU86Tz2mt+WBAQ==.sig.ed25519"
}

{
  "previous": "%kPAyMQeF35oX/frGwo650YQVz9xHJ5UeUMdUstr8clc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 347,
  "timestamp": 1510045987694,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%YfKSzDeMpcItbAVv/hatUlcNEMc5CdoOhSYuUa8BWdM=.sha256",
    "branch": [
      "%OanUV45gzDVTq+XrLJdQgojhC7ZbyMi30b1tQ1tdrXY=.sha256",
      "%wKO2uQHx6qhN8z3hCaxCa/jKcn9Hh4iCsZXs6rl4f8g=.sha256"
    ],
    "channel": "ssbc-grants",
    "recps": null,
    "text": "There's a not-so-obvious reason for 7: Documenting the protocol level not only makes it easier to write alternative implementations. It also enables discussion about these lower layers of the architecture. Currently there's only a handful people who know how this stuff works. Even though there might be a lot to improve, there is no real discussion around that. The earlier these layer become more accessible, the faster they can improve. That's why my vote (do I have a vote?) is on [@vtduncan](@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519)'s proposal. ",
    "mentions": [
      {
        "link": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519",
        "name": "vtduncan"
      }
    ]
  },
  "signature": "hyOGcaEYKb8wXq3DRYFxJiQrabABsY7fB1cuamh+Y6j0kiIpyX1lQuxlPKz4JrPFQGtAHFyh6ssT0xjofR0mDg==.sig.ed25519"
}

{
  "previous": "%Pm/0YLr9dkXjYhLMtXE6BD9Xqba205zZY+QpXXeFFng=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 348,
  "timestamp": 1510046016270,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "sbotc",
    "vote": {
      "link": "%lzzcAZlM21slUIoiH4yd/wgDnXu8raNLvwqjxqrU06k=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "WQ3SrhjQS1/0OYKRBXziUthHNQZO5YJpGyKV4HqbTvB3wEhPZ8xoBAqOi7V2y+VCdvoTwz48zZDdqXE7OC2qDA==.sig.ed25519"
}

{
  "previous": "%macN8e8bt93vtbJKPVRNZPGF74mGRXnIETtrmuq3EG0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 349,
  "timestamp": 1510076808171,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lzzcAZlM21slUIoiH4yd/wgDnXu8raNLvwqjxqrU06k=.sha256",
    "branch": "%lzzcAZlM21slUIoiH4yd/wgDnXu8raNLvwqjxqrU06k=.sha256",
    "channel": "sbotc",
    "recps": null,
    "text": "Yay, great to see this kind of not-so-obviously-important infrastructure being recognized and used :heart: ",
    "mentions": []
  },
  "signature": "JnRcss0RGC8EihIq3ToumvlMh/o6tOnhBtEojp6fqBfdIAbxIO8Vy8gTaajs/EHZt3H1VW5UvFJuCs+uxPakBw==.sig.ed25519"
}

{
  "previous": "%IcU2RfeKhqwYdEM9bt+AA7UwPtAJ7aOr1BY5UvCvFIE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 350,
  "timestamp": 1510081326899,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@ox0+Y0T+aJFvX8/nIC8Z1a78FI2wt7B6IEMd0XiTrn8=.ed25519",
    "following": true
  },
  "signature": "X9FxZveIVbKh67sbbSXhEw/E9Hf6ZNFMQaGNfLapk6okvONTbLWd1wevSR80R7E9SEaFUmL00lx9kgGjweP4AQ==.sig.ed25519"
}

{
  "previous": "%iydLB/jT+hudLn5QWQu+ErmgFuNtoc+SYGyg9bfdv+s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 351,
  "timestamp": 1510086492508,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "sbotc",
    "subscribed": true
  },
  "signature": "Dl+lfRKCg7cfrS+MNQEtLfIRAA7dYTfCZYJKTdsoBWgPTPGMR+/4rZ3kwUUjycVabVT5DNlPHhBqPnV+1nGiBg==.sig.ed25519"
}

{
  "previous": "%vmeLyRfG1PRJRcJfp8RXH4Gcs9XG9fM4mLq3k57DAmQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 352,
  "timestamp": 1510086801099,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lzzcAZlM21slUIoiH4yd/wgDnXu8raNLvwqjxqrU06k=.sha256",
    "branch": "%MkZKeDJOla7eQ30VdWe2NuPxCly8cRfA1LsniGhvMlg=.sha256",
    "channel": "sbotc",
    "recps": null,
    "text": "In that case, you can build on these modules: [shs-rs](https://github.com/AljoschaMeyer/secret-handshake-rs) and [box-stream-rs](https://github.com/AljoschaMeyer/box-stream-rs). Reimplementing the crypto isn't that much effort, but the box-stream module does a bunch of tricky buffering logic that was somewhat painful to get right.",
    "mentions": []
  },
  "signature": "2ftiPDFcNCDyGT/Ti6JB/l7fmoiTJXQoX/x4Ew05VZcsx+lKRIC/mzLR6IfyzjTqNLwcv3M3iC3w/xunahkWDQ==.sig.ed25519"
}

{
  "previous": "%e9XEh6vw0+m06g5srhtsGmXH4bNjOBsrhER+4aWrvkA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 353,
  "timestamp": 1510089717100,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lzzcAZlM21slUIoiH4yd/wgDnXu8raNLvwqjxqrU06k=.sha256",
    "branch": "%FyG6tGIVjTQ7hBaq8KPKzRUaHriEyUYz0Up9R2ZiQ/I=.sha256",
    "channel": "sbotc",
    "recps": null,
    "text": "Note that there are some (literal) [issues](https://github.com/AljoschaMeyer/secret-handshake-rs/issues) with the shs module, which I may or may not get around to implementing soon.",
    "mentions": []
  },
  "signature": "YINDegXS/XfPnOSPT0Cuf8AIwY8vZ3XxlNq5FhnBxzXxXJNZfJEPakPA+dg9npdk8gV4YqAsaHiNLyT9ZHvVBw==.sig.ed25519"
}

{
  "previous": "%RBjaf8rrqWB2N5EQjNzSjwVs+ytnxRwMEKsOChh8gq0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 354,
  "timestamp": 1510143476947,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%1jYUld49RT8PLzYES9qqhS5Yd1gb9uUb03NvOMkDZ6M=.sha256"
    ],
    "packs": [
      {
        "link": "&YN+3ieAcnEHrT3Jsrg+fgTXbemSB/OaWFiwvssAyFig=.sha256",
        "size": 3211
      }
    ],
    "indexes": [
      {
        "link": "&mekCBbEDEEUSq0OXTjoMX8kJV3t4YZ33L2pklGYbwhY=.sha256",
        "size": 1352
      }
    ],
    "refs": {
      "refs/heads/master": "dd0dcc61d70f9a53b37414dabc581eb420fcc33f"
    },
    "commits": [
      {
        "parents": [
          "f4a8585c4e03be4a0a2e928f1244a99f2bfd26b3"
        ],
        "title": "Implement client part of the integration tests",
        "sha1": "dd0dcc61d70f9a53b37414dabc581eb420fcc33f"
      },
      {
        "parents": [
          "1e67248255ad8826c1194616fe02735b84864892"
        ],
        "title": "Underp",
        "sha1": "f4a8585c4e03be4a0a2e928f1244a99f2bfd26b3"
      }
    ],
    "tags": [],
    "num_objects": 10,
    "object_ids": [
      "24ac28f903a2044ea11b792e496bc9416d5e54a6",
      "f559a332bb4090fefd92216d24354dd6b17bc1be",
      "3fe9d9743f8c81bb8c58ab8c22549161b05120a5",
      "727974a52ef6e6268bd406ba5e9e19cf5a4dffa9",
      "17d6e7bd3427a8a46ded228fce47b09da16cd4c1",
      "0313e17556ebb9ffda5fa9be900fbcc6855780bb",
      "e604992b73631acedd4b31ae93d480bb7cfe7f01",
      "f6965556755d32bd2454677ebb80f10a22fa2a31"
    ]
  },
  "signature": "Po4MW2QskBSrMftBCdPRO+lnwyXRpcLkdLqngWtVeRYML9CfJcrbYDjIQJNJh5X2g+MrgVRSKcEVH1itTlElBQ==.sig.ed25519"
}

{
  "previous": "%/trkWXWrPjGYo79l3JG5eOPLOWhe25jReUqP136Ne90=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 355,
  "timestamp": 1510144736844,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%/trkWXWrPjGYo79l3JG5eOPLOWhe25jReUqP136Ne90=.sha256"
    ],
    "packs": [
      {
        "link": "&9UzhFzC7OswyYfDIV0H1l5fANJlztgLgcTDtUqFOGxg=.sha256",
        "size": 3539
      }
    ],
    "indexes": [
      {
        "link": "&w7DT9E8CuZS8DCfgo6/iTRaTGNdd+hUQNYTlf9oF64w=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "3eb6c3afb1858e8beefaca222adfeeb965f8fbfe"
    },
    "commits": [
      {
        "parents": [
          "91eaa58df6ea5b780e8ed5dc24e6fdd7b9a2c961"
        ],
        "title": "Update readme",
        "sha1": "3eb6c3afb1858e8beefaca222adfeeb965f8fbfe"
      },
      {
        "parents": [
          "9d4f833f3a2eb943380c877c0a875b45c80af248"
        ],
        "title": "Implement server part of the integration tests",
        "sha1": "91eaa58df6ea5b780e8ed5dc24e6fdd7b9a2c961"
      },
      {
        "parents": [
          "dd0dcc61d70f9a53b37414dabc581eb420fcc33f"
        ],
        "title": "Use correct constant",
        "sha1": "9d4f833f3a2eb943380c877c0a875b45c80af248"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "0679f676ec40a88ac7b0ef92af177224db460843",
      "b5b401d98e9d2f777ef5b2c56e6807f83ed341f4",
      "9a53ff7ba66fe76ec435c9e1cf8cdd08046c6f05",
      "eeed5996c8a953f0b9ebe3e406cb85a7ae8be349",
      "4e619aa6620c60a287843fb930af13008f6ecb06",
      "8b8e9453e34507e508cfeaa65e99f29e3fef566f",
      "2dc2e71da9d889cb71b92e19d44db9ebbc595c1b",
      "d303cc15efb1188415196febe70853721806bb4d",
      "faa6540f2b98b0016653434383d8648d3c212c48",
      "7994db5134d9f403732b0bdfbe1a803ae716812d"
    ]
  },
  "signature": "e6p0vzfgtp5zg56BZ+fF0Y56Tfe1moZhgpr4vepudiBtQSx84AAqvgo5j2lHEBH5YlpNhwY9WFbvKFpv/O9JAw==.sig.ed25519"
}

{
  "previous": "%F0hlPdTAU1d1jHG2GcKSLgOo+xnpaucFRldzMpIXYXU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 356,
  "timestamp": 1510146085487,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%F0hlPdTAU1d1jHG2GcKSLgOo+xnpaucFRldzMpIXYXU=.sha256"
    ],
    "packs": [
      {
        "link": "&aifdm2Bo5r1xebmy0iCwrf3ccSawBo5I5Nfz0QTSDw0=.sha256",
        "size": 3476
      }
    ],
    "indexes": [
      {
        "link": "&ml2r3Sbk5eBP0KC1OdLgAH0Xbb+HdQGoH9n/4MRmp9U=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "94de2e245ce25ed00282c2ec78547ea3d4227d5b"
    },
    "commits": [
      {
        "parents": [
          "3eb6c3afb1858e8beefaca222adfeeb965f8fbfe"
        ],
        "title": "Add macros to use terminology like the js implementation",
        "sha1": "94de2e245ce25ed00282c2ec78547ea3d4227d5b"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "411b4b5c9a9154847f78e0f90d83b5e4f0c6faf8",
      "0900cf32a98c834f40e32b230ed5ae7575188abb",
      "0f967fd0468de07259b884466631f076ffbc8900",
      "04b30ab35297347787e9fcd1b7577ba471618c8e",
      "70bc08beab7cd310621c4debfcd72203c568d5eb"
    ]
  },
  "signature": "m0HRF8xv+YKELEUvKRZDWBjjjUXTh5wTyMBcnQQNaeVGZqtxS1OGn4b1jHWt+uetyZ/HkXl5P34VllfmcjZUCw==.sig.ed25519"
}

{
  "previous": "%Ajj/yr7x1DyR3d68ZhjJXu9Z/GtlH3mqha4AcrkHjJA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 357,
  "timestamp": 1510150600451,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%S6ntIuxo9sOBfFnddyTG1txNLKylAD+YNXs9iQKfZ/U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Ajj/yr7x1DyR3d68ZhjJXu9Z/GtlH3mqha4AcrkHjJA=.sha256"
    ],
    "packs": [
      {
        "link": "&B0xCrR7bAoCSZx5BndT1VPNrsxqZ0F8MiJJ3dECoxtE=.sha256",
        "size": 6964
      }
    ],
    "indexes": [
      {
        "link": "&qYQuihCADsMwFt7dRP8ZnxhGKKX2oDAmmTFOV34ac6E=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "594b1eae3f8157956a72ebdb345f077e98fa869c"
    },
    "commits": [
      {
        "parents": [
          "94de2e245ce25ed00282c2ec78547ea3d4227d5b"
        ],
        "title": "Add longterm public key of the peer to the outcome struct",
        "sha1": "594b1eae3f8157956a72ebdb345f077e98fa869c"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "28a40ffddeead1d5b82a11399da2dc89c8241fac",
      "1230c086589f55dae57ec8a8e35480b7bf0794f8",
      "a623180de5cceb9ac7d53e16eb2662ec75d69620",
      "50e94779117e98cb2432336090a23ff9fcc310b1",
      "89c8d89d231fd20a18baafc769776a2adcff31c4"
    ]
  },
  "signature": "iNeIY1yfwcxfno6UUDfDetlbeTvtEhgp8xXZ5WStyGA4WLtyHVedMl9qebDdKyJd21c2LNA1DabQlacNFV6HBA==.sig.ed25519"
}

{
  "previous": "%Bb4nBPegGfr8izxPw/DWBhCv8G0/5mrmF+nWd1RVxe8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 358,
  "timestamp": 1510157029085,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%0cTKrcyzcU0P3TxUPLHrwU2flcNyDY9cjUZC/6W007Q=.sha256"
    ],
    "packs": [
      {
        "link": "&vDi9utvByi46GXaXDVLI6tq3jrUgk6E12nMGyCpNB40=.sha256",
        "size": 6666
      }
    ],
    "indexes": [
      {
        "link": "&MFyUDV+gIN+FF2oe2s7TRnyB6NbmVenjy0v04OeO2EY=.sha256",
        "size": 1324
      }
    ],
    "refs": {
      "refs/heads/master": "3c47410b48507a300824d6ecbd6955d04ed3afc9"
    },
    "commits": [
      {
        "parents": [
          "ffeda144c319e390a6d15bc528a4cd035c1e8684"
        ],
        "title": "Add peer_longterm_pk to the outcome struct",
        "sha1": "3c47410b48507a300824d6ecbd6955d04ed3afc9"
      },
      {
        "parents": [
          "ecdc047f6549f141337605bb77d14083b41939b8"
        ],
        "title": "Update to new version of shs1-c",
        "sha1": "ffeda144c319e390a6d15bc528a4cd035c1e8684"
      }
    ],
    "tags": [],
    "num_objects": 9,
    "object_ids": [
      "0f466e8fe41d56b2ab025dd9d3c4daaa2aec77d8",
      "a4e80a73fae2c66efbf10f1617fbabef5c6a0390",
      "9b511e62e3f50273c285b419b538221f658ad9fa",
      "8a93664d127d6f1a0d044ce7ff1a98bc901f7162",
      "43d76591ae3ea63706276d43f15760e19213d96a",
      "eb8b237151f15e151646bf451a4ef594f6de21e7",
      "9fb24c048567f781d4a15c20b8ea34c5a6edbc01"
    ]
  },
  "signature": "IbTyzOj54YQJuukm0OpefDzZ9Dz3Jr5bYFCLyD45oemMDvdKdlbloYomoNpo5Jo07iwUf7Yghc1WxBgtJSS8Dg==.sig.ed25519"
}

{
  "previous": "%ltX5kY7U8JGjE2PoMkUZ1lqe7VA3qVmJMVnEPxl6N4o=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 359,
  "timestamp": 1510157176389,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ltX5kY7U8JGjE2PoMkUZ1lqe7VA3qVmJMVnEPxl6N4o=.sha256"
    ],
    "packs": [
      {
        "link": "&QsK7bdlzBm9L2v12dXgvcveyBwUxTcrzalxqcfGfu0Q=.sha256",
        "size": 1047
      }
    ],
    "indexes": [
      {
        "link": "&ezqEVvMr9Ot5/zXkJNXyQXJiYhChwPCv3ZQGzNhSexY=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "b477b946bbeb22290354d3596213c2a5f09fede8"
    },
    "commits": [
      {
        "parents": [
          "3c47410b48507a300824d6ecbd6955d04ed3afc9",
          "1832ae9917ee428256359b1553edd709cd101974"
        ],
        "title": "Merge branch 'master' of https://github.com/AljoschaMeyer/secret_handshake",
        "sha1": "b477b946bbeb22290354d3596213c2a5f09fede8"
      },
      {
        "parents": [
          "ecdc047f6549f141337605bb77d14083b41939b8"
        ],
        "title": "Fix links to shs1-c",
        "sha1": "1832ae9917ee428256359b1553edd709cd101974"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "96fffba0acfc3f8e89d93e866d1e114395c3f1cb",
      "7b0a2be9f79fcd28b945369edcda28106b9b4365",
      "73af4369033e26c40858b2552b8b0be2cef3c870"
    ]
  },
  "signature": "uKo8/4BRW03awfg0cO/TBH3ttTZMf/0Zoa203Txm2pUQv672zxv+njbetl7uUIr/MITgGjwDQcG6q7L2+WzlCg==.sig.ed25519"
}

{
  "previous": "%5Epe3UmHqc9FOCYodF/Vzpm7o7/79ZOPOPmWP43ajMo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 360,
  "timestamp": 1510218849470,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%5Epe3UmHqc9FOCYodF/Vzpm7o7/79ZOPOPmWP43ajMo=.sha256"
    ],
    "packs": [
      {
        "link": "&3hPcd0Zu546mkdo2Ja7iTZkDRZ28tDRAkVBkLg+kZ0E=.sha256",
        "size": 789
      }
    ],
    "indexes": [
      {
        "link": "&k7ide5kS7RquwS9x+il7pGT/2Jl/PZXjMzXgOIDoh2w=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "414cb5ae1624e095693d3504ca22a8cf0463f875"
    },
    "commits": [
      {
        "parents": [
          "b477b946bbeb22290354d3596213c2a5f09fede8"
        ],
        "title": "Bump version to 0.2.2",
        "sha1": "414cb5ae1624e095693d3504ca22a8cf0463f875"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "d859441168b2d1ba020ea767920fca939602548d",
      "7b4c2d5a0ec0d20db2baaef44d555bcc14cb248b"
    ]
  },
  "signature": "Q2KJAUACiVCsaRSkFvvkpgcGd11mNqznXCVtJbxCRkj1svNdF9MaWbqSbYEDMSVp6nVj63CwCkwKJprwh+cgDg==.sig.ed25519"
}

{
  "previous": "%ro/B/QYnsQ6Ph8qSQtBh5Q1IxjUXJmFKBV5fBfHW5gc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 361,
  "timestamp": 1510262779896,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
    "image": "&Gcs9kWaQAzJo8Vyw207B0IRUWrVJ+AW9rxCHbse8t/E=.sha256"
  },
  "signature": "DfoA99UFWfDzf9TnzAWS/tDfm9RMSF4nfWIGm6WnEcT9CtM6cJKjqWF50MvOr1unvvbSUHONHTc1KuXi+yQFBg==.sig.ed25519"
}

{
  "previous": "%UmFjCK+xaxv5ca0GhTxbikokDvLc+402g6DACH9O9O0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 362,
  "timestamp": 1510312757091,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%s8dKCzZB493csCdMfPK9aO9aWlzQBb4p90k/5YqY+QY=.sha256",
    "branch": "%s8dKCzZB493csCdMfPK9aO9aWlzQBb4p90k/5YqY+QY=.sha256",
    "channel": null,
    "recps": null,
    "text": "Can't make it today or next week, but I could join you on Friday the 24st. I'd just show up with my laptop, something to code on, and willingness to suspend my usual introversion in favor of getting to know cool people. That's how it works, right?",
    "mentions": []
  },
  "signature": "8+BX5BKaGAiKeapNNy1yKC1BtRAG48Exhg1YmufTfZhM2miEu+jLRpGYMgfCoTziTpwHJs/4u1Br2fZrapdhCw==.sig.ed25519"
}

{
  "previous": "%PAmT4KkrepxIKYO7ZNutvD3rnaaFBlv/88iDhBQJzIY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 363,
  "timestamp": 1510397082349,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@L+nPFTMUHWXuchOwuzT6Z8Ea8wD/Rtd7leVRxGaknVk=.ed25519",
    "following": false
  },
  "signature": "DcW+NJvu9/gKPeEzyViKfk98SgLaVyt2AhtkRqpZJ7aQ49hJourbSyN9PZiFMwSTsOgTGonM0YOG2iQQU4dmBA==.sig.ed25519"
}

{
  "previous": "%thP5gLuCM0ZQc1Q3H5Lr0ZSQJfYmsW86iV2BVhpRARA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 364,
  "timestamp": 1510416020418,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lzzcAZlM21slUIoiH4yd/wgDnXu8raNLvwqjxqrU06k=.sha256",
    "branch": "%RBjaf8rrqWB2N5EQjNzSjwVs+ytnxRwMEKsOChh8gq0=.sha256",
    "channel": "sbotc",
    "recps": null,
    "text": "I noticed some [severe problems](https://github.com/AljoschaMeyer/secret-handshake-rs/issues/6) with the support for asynchronous IO in shs-rs. I started fixing this, but I'm pretty low on time right now, so it might take some time until the fix is published. I'll use this as an opportunity to make a few breaking changes to the api, integrate the js test suite, and release it as 1.0.0 once done. For now you probably shouldn't use the module.",
    "mentions": []
  },
  "signature": "Jwy9LlNMEMChJ3Brpd1ipQ84cquvzx4ZQP8sKq5xBWjz0hHTRdy/oj6gGWEsfXnYbQXhcO7mkA0RSS0SUBe3Aw==.sig.ed25519"
}

{
  "previous": "%5qFX7/D9JOZ5+2V9Q7XP46S9MDyoHwnnPQ639snjPuc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 365,
  "timestamp": 1510416046500,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lzzcAZlM21slUIoiH4yd/wgDnXu8raNLvwqjxqrU06k=.sha256",
    "branch": "%5qFX7/D9JOZ5+2V9Q7XP46S9MDyoHwnnPQ639snjPuc=.sha256",
    "channel": "sbotc",
    "recps": null,
    "text": "cc [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) ",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      }
    ]
  },
  "signature": "K3EaFqu/rk3T1JjZz/4hdmiBZ1Ndh7M7hDmzQGTZI2Srld4t3wjVs/8tDMoupRah7+jX3Q2zpfIINH0Emgj9Bg==.sig.ed25519"
}

{
  "previous": "%e0PMmgj6asvcqhrFyx0KJcPlfTL6sKUsPKX9uU/GvNE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 366,
  "timestamp": 1510425643354,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ro/B/QYnsQ6Ph8qSQtBh5Q1IxjUXJmFKBV5fBfHW5gc=.sha256"
    ],
    "packs": [
      {
        "link": "&SA1aDyhcqAAAQ29CcqyuOO/bGxb+gyI+oUbY+NOKOxU=.sha256",
        "size": 8088
      }
    ],
    "indexes": [
      {
        "link": "&MWRnHFqWhixRBSk+Tb2cCcB4OCV3xQuN4s3wjIfg4go=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "282bcd15add7b6c4f2374dd8c4095cfa4040c3cf"
    },
    "commits": [
      {
        "parents": [
          "414cb5ae1624e095693d3504ca22a8cf0463f875"
        ],
        "title": "Reimplement server, remove synchronous server code",
        "sha1": "282bcd15add7b6c4f2374dd8c4095cfa4040c3cf"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "bb0ad08da5312c57c6c15f1031ef9a7398e695b4",
      "525f6e09ec5db2126d2a15e605f69055d16fd537",
      "212aaf04886e4c5056ddc770ae33e9c5f2394d55",
      "5cbdc9454a747f4d0d6432cc281729abf301c21b",
      "9c1e17217f0082497504cfbc6398624fe496f819",
      "2298053f17d97aa5884e820cb9fb1d8cc4124b0b",
      "c7b35bb1b3f04f3a0d110ee26645e4746abb9484"
    ]
  },
  "signature": "njXbBxOgsrk1TN/9ovXURqMuEslLP7dO1l11OJHLtkhC6dFdhR12YTyRFdATkXe1PR4AfYu5v9V+Ar0MW0ZcBg==.sig.ed25519"
}

{
  "previous": "%TxYlX48quZPp4s3flL4+G7k8UjgiHFmMUJWME4btfso=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 367,
  "timestamp": 1510429516178,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%TxYlX48quZPp4s3flL4+G7k8UjgiHFmMUJWME4btfso=.sha256"
    ],
    "packs": [
      {
        "link": "&x2CahFmy3BN34UwUIH0aGCqBsRNEPEmEGFmF4qC+l5Y=.sha256",
        "size": 5705
      }
    ],
    "indexes": [
      {
        "link": "&HFF7GXBipmiMyORVGbsIZ9iTjwt9dps/91eUeb+yrC8=.sha256",
        "size": 1576
      }
    ],
    "refs": {
      "refs/heads/master": "afb1ff929ef3cf1d1c24478c8c7305d76242b16c"
    },
    "commits": [
      {
        "parents": [
          "e764ea9126fcce1f56c48bd50d8ba4696c1c0413"
        ],
        "title": "Add missing doc comments",
        "sha1": "afb1ff929ef3cf1d1c24478c8c7305d76242b16c"
      },
      {
        "parents": [
          "aacae33054d5100e8b0bc28155c82e5ae0322388"
        ],
        "title": "Reimplement client, remove synchronous client code",
        "sha1": "e764ea9126fcce1f56c48bd50d8ba4696c1c0413"
      },
      {
        "parents": [
          "08849e44cab0cd220f44d8b6e4e19aa86c472972"
        ],
        "title": "Clean up server code",
        "sha1": "aacae33054d5100e8b0bc28155c82e5ae0322388"
      },
      {
        "parents": [
          "282bcd15add7b6c4f2374dd8c4095cfa4040c3cf"
        ],
        "title": "Improve auth handling",
        "sha1": "08849e44cab0cd220f44d8b6e4e19aa86c472972"
      }
    ],
    "tags": [],
    "num_objects": 18,
    "object_ids": [
      "4a4b211430ae5c07b539f9c2a6c7073f5263c529",
      "3debe14202785a427c2604bf3b8d6ea074dbf43c",
      "468a06674d362074bd040051dd7e3b274266455e",
      "f80bc62190f4ff46df5706ee1b54d2329f2150cf",
      "9bd34736d3918d3d340e076871c7e5260b050588",
      "24cb8bdf83f86e622729aa7e570ed4434bde3a87",
      "70e8fcb821301be470c79a10a2ee2d6320b40f46",
      "e7b10d32f3b5427d24218c72689f603b76ca8523",
      "a346a7b04d5fc42a080adab45273e4f08bfbe2d9",
      "575e1c5e8a88caa36a96d521a93eb157b6e34d6f",
      "4e40373595862f8e601572ad11374ecaa6769fab",
      "71aadf189f7fab23ff2e18e7a35ecc317ffe56d9",
      "59909e8d6615646ff8a296e41e2f1c30034213cd",
      "ad548ef33b5d0267edfcfcb28e94c78d9e7a6847"
    ]
  },
  "signature": "OuAWlt1dM/wxNqVMrQes1b1PXNZmU6LphZc/DFOPNAgAVERtDVkfUEL8KUW5RRIKCn0os37/OS2KY6qm4BTBDw==.sig.ed25519"
}

{
  "previous": "%4qjoFpM1t6Ge7B/537ZRZeCJfJ/BZiZ1Mj5vTv9TmZI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 368,
  "timestamp": 1510442335398,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%4qjoFpM1t6Ge7B/537ZRZeCJfJ/BZiZ1Mj5vTv9TmZI=.sha256"
    ],
    "packs": [
      {
        "link": "&q2li5i4XSXefIwl1lj2fx8NFE9uUU4Yc8885Ofjml5c=.sha256",
        "size": 7045
      }
    ],
    "indexes": [
      {
        "link": "&rSUg9G6DzDTzkXIAR0dLpHkz1TnvQ/NQiUy8TzmZ0Bk=.sha256",
        "size": 1548
      }
    ],
    "refs": {
      "refs/heads/master": "718d15af993cf6eb0734093a73f49efd938ed0a0"
    },
    "commits": [
      {
        "parents": [
          "c2092b6e151b3d5b020aab3bbc037dc06ca3488a"
        ],
        "title": "Remove dependency on the void crate",
        "sha1": "718d15af993cf6eb0734093a73f49efd938ed0a0"
      },
      {
        "parents": [
          "28cde60289ecf37078cbfa3571c9fa485e6c0074"
        ],
        "title": "Implement server without authentiation checking",
        "sha1": "c2092b6e151b3d5b020aab3bbc037dc06ca3488a"
      },
      {
        "parents": [
          "fc7183cb3a4ab6c9c451c240d44e0ae2393a85db"
        ],
        "title": "Use result of the authentication function",
        "sha1": "28cde60289ecf37078cbfa3571c9fa485e6c0074"
      },
      {
        "parents": [
          "afb1ff929ef3cf1d1c24478c8c7305d76242b16c"
        ],
        "title": "Zero out data buffer in case of errors",
        "sha1": "fc7183cb3a4ab6c9c451c240d44e0ae2393a85db"
      }
    ],
    "tags": [],
    "num_objects": 17,
    "object_ids": [
      "9cf5ace7d21cb99506eaba0d9ab6c1b17816ca13",
      "9579c3e8360d49f505a52f25fb7842b020d4ceb2",
      "e1e271678d7b9a900c70aa491a5ffccea962f26c",
      "ff1fb8b4cf0f3d776306371173b192f7865e0762",
      "f3caa9aeecd6a0cc8af0973abe1a97261cfa6e91",
      "4437dbb5e9c0ee1b268e6c9b513ab5ca35a3ad11",
      "f355a4069673056c5013b6a6cc87818cb513ac88",
      "09cb4120154d2b82a4f83d2d6f287c98fe9a78d4",
      "a4afed8ae67df7525aa2054cbc50756ce4a67116",
      "be70c03cd36eafc81270e6c385258be54f6fae98",
      "19cf97f7fa925f38dd1784375d494c74c8703498",
      "4dfcfbd9b67841492f1d8254b8aeb64ab5d98e19",
      "5a375254db57edc8c3cecb6c2eb38076b08c1288"
    ]
  },
  "signature": "4pBu9yC6wvgUKr8gmGGnt/vFD/smpoFGB1FWl+3iJt77C5tzWmVjJztm2AXlwm20JLDuMajBN4nBhPbvJTHZBg==.sig.ed25519"
}

{
  "previous": "%K0vbAeLB6/xVPuGzp39xkMj5RM9dFgOE8X7XQtBBBxQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 369,
  "timestamp": 1510487461095,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%K0vbAeLB6/xVPuGzp39xkMj5RM9dFgOE8X7XQtBBBxQ=.sha256"
    ],
    "packs": [
      {
        "link": "&OtEOieCOqVOY2hLM4O/km4Zuu+r+349GH4ovJmGLfIo=.sha256",
        "size": 8286
      }
    ],
    "indexes": [
      {
        "link": "&w8ex4WlF1glDtRgic8vPWKAh1IknSvMEO3uG0jRGilE=.sha256",
        "size": 1660
      }
    ],
    "refs": {
      "refs/heads/master": "be8fe45c935517061ded85d87eca34a912651220"
    },
    "commits": [
      {
        "parents": [
          "6235a0826dc795f9afa978b82f1f9da6c95094fb"
        ],
        "title": "Derive useful traits on failure types",
        "sha1": "be8fe45c935517061ded85d87eca34a912651220"
      },
      {
        "parents": [
          "c58b71ff44110c9b044d96c91f570937a4873b2f"
        ],
        "title": "Zero out buffered data when dropping",
        "sha1": "6235a0826dc795f9afa978b82f1f9da6c95094fb"
      },
      {
        "parents": [
          "2ca3525452a8a5b020abeb91881c10504ca111f2"
        ],
        "title": "Cleanup",
        "sha1": "c58b71ff44110c9b044d96c91f570937a4873b2f"
      },
      {
        "parents": [
          "718d15af993cf6eb0734093a73f49efd938ed0a0"
        ],
        "title": "Distinguish between handshake errors and failures",
        "sha1": "2ca3525452a8a5b020abeb91881c10504ca111f2"
      }
    ],
    "tags": [],
    "num_objects": 21,
    "object_ids": [
      "8e248b021b9c4956eae6eab321252a0642f18693",
      "4437dbb5e9c0ee1b268e6c9b513ab5ca35a3ad11",
      "22b04e4ff36d0bf158dcd86dbe9c989979e72499",
      "7913d6c836c27a5e707deca31258ae0d779036da",
      "5d80d4c8ad94e091aaf87798fa52d4200c9be3c0",
      "09cb4120154d2b82a4f83d2d6f287c98fe9a78d4",
      "c76bdd35af0c831864f51792e9c0fb0d5f63b5cd",
      "3eec88530083bc1e5e72b9ea2f2ec1810cb7c8cf",
      "19fcfe982b32735636145e5f0d13ad99a205dc06",
      "1441f8845fe17edc9079484fb4afa052106fe1dd",
      "a1e05856a02aa700fbf2a46c278b15b8df452447",
      "fc456a52caf5fe370892f909b2ba14b3604ea053",
      "468054cbe5edff4bb604440f97074cc6840550d7",
      "6b48c7c288af6a6f58a4bb6fbd407841da436785",
      "07dc5973af1d47e330b270661c162a52e20feba0",
      "8f2c42fc35cb9b89d6878e24bc486300fa8a92b5",
      "ea915d4ab55e9d0b53ad7395ebeca17b228f7067"
    ]
  },
  "signature": "dKn3fEgwONwINgN4p/HLwx03EAKOcubsisiJjsVWC5/wl1EtMbEE9LPSxxgwwzDg0Lov/t76E/BkUhEMnaKfBA==.sig.ed25519"
}

{
  "previous": "%ximasxA5MOK+A1cNX7kDbnZvuT31Smb+cLv9h3yPyHg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 370,
  "timestamp": 1510487896810,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%aAvtv+ngPgtA2EGyDQEEJjugMTTSZEQbDLx1WslPBe0=.sha256",
    "branch": "%2XkN2/0/5+GHMunXPwiNKqaYpUUJ3ysaqmyo5nvYX7s=.sha256",
    "channel": "haskell",
    "recps": null,
    "text": "[@happy0](@RJ09Kfs3neEZPrbpbWVDxkN92x9moe3aPusOMOc4S2I=.ed25519) Looks like it would be a (long) while until I'd get to this in Haskell. So this is me officially unstealing implementing shs in Haskell.\nIf somebody else does it, that's also a great opportunity to gather more feedback for [the docs](%Wizpo7cm8VU66aomoNpfRU+qXBNcpot2IAW7Je62bRw=.sha256).",
    "mentions": [
      {
        "link": "@RJ09Kfs3neEZPrbpbWVDxkN92x9moe3aPusOMOc4S2I=.ed25519",
        "name": "happy0"
      },
      {
        "link": "%Wizpo7cm8VU66aomoNpfRU+qXBNcpot2IAW7Je62bRw=.sha256",
        "name": "the docs"
      }
    ]
  },
  "signature": "TDxOUvIV0pdhDO1C2lG1OfpNOXxyhoS66lFt6sRB//OGUlPXAf9HWNy6Pa6x5bclWeIJtoYVmFjdeQNEx3lsDQ==.sig.ed25519"
}

{
  "previous": "%TMcVEb6yYLb1ee1a5e7KmO6Z9aVZU/nV0hTFX9zhXGg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 371,
  "timestamp": 1510604420691,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ximasxA5MOK+A1cNX7kDbnZvuT31Smb+cLv9h3yPyHg=.sha256"
    ],
    "packs": [
      {
        "link": "&3UJ2ohNmmbJM8JMfRi6ARN5UaQrJ5uMohcmj/vnDf5M=.sha256",
        "size": 4950
      }
    ],
    "indexes": [
      {
        "link": "&E7bV59FqgU7Rc3iMUGxpxnPzA4K+duupivokYc82e3s=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "5fb3f6a1ee7baf190a91cd799762cc7fc218bc25"
    },
    "commits": [
      {
        "parents": [
          "be8fe45c935517061ded85d87eca34a912651220"
        ],
        "title": "Flush streams during handshake",
        "sha1": "5fb3f6a1ee7baf190a91cd799762cc7fc218bc25"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "50872ec8055523e9cf895ef3501aaf4a030e6697",
      "d1bd4e4cd9a403dc3673015711196788d6ec3785",
      "f5c44b7a799aa0598c2b0169c8acc9e3d0778f07",
      "0e2135dba074257078627d8b2c46a29698b62a20"
    ]
  },
  "signature": "sPt7pPVlAlxOceF8LY+lvRWN7voDDL7pHr30QngS5zhf+w6dJytqbCTTK/BstomrY7PnmTSKPuxDVEiZhqMyBw==.sig.ed25519"
}

{
  "previous": "%yfSR/6j0K1v4H9CW+hmVfuE5OfMWl9Z8206w+MLnRTY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 372,
  "timestamp": 1510610392983,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%riikqU1Zc/dgjc80vABMA3DkTzTHzlxEYxGU5NYwje8=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%kPAyMQeF35oX/frGwo650YQVz9xHJ5UeUMdUstr8clc=.sha256"
    ],
    "packs": [
      {
        "link": "&FF6fnvumNs6Jo4PCxIV0kNf3y6+XbUF/+huDS7ScaO8=.sha256",
        "size": 6995
      }
    ],
    "indexes": [
      {
        "link": "&0zLJAt/Wt1ZuvziPIujG1nUx1EzPfRkoDsmhIP7VI1M=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "96a291fe708ffcadf6602901c2b2bf5e5fa5620e"
    },
    "commits": [
      {
        "parents": [
          "b5a158a85e3289d3614910c699b1596c55e4b4f2"
        ],
        "title": "1.1.0",
        "sha1": "96a291fe708ffcadf6602901c2b2bf5e5fa5620e"
      },
      {
        "parents": [
          "2ed34957909a7ffec11a5bebb5687344097fdf11"
        ],
        "title": "Buffer input from the testee",
        "sha1": "b5a158a85e3289d3614910c699b1596c55e4b4f2"
      },
      {
        "parents": [
          "bba206cd5d1c20c7e557fecba5aeb605dc8e56c2"
        ],
        "title": "Fix typo",
        "sha1": "2ed34957909a7ffec11a5bebb5687344097fdf11"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "28e958c66b320b1196efb4e2e2dfcd61a7c80063",
      "9fdde0938b294dc8626d521e430d5b6525417a28",
      "0633086cb27aac23ec1e2ef0ece8d85d4357ea33",
      "ce02a9a56a4126472642bd57f9ca1ce4e841bba6",
      "e5ee412743f345912d42a95cfaa1cad9aa2c4f64",
      "08b593e436059b7a2cf0d0389f755b797a446c30",
      "79045d248f451a1be2da635e6888ec84d2602281",
      "4abb0fa8d6e30d7aa793fd48d57d2ef4031748db"
    ]
  },
  "signature": "YH4b4/2HjJ/WPP8sI/8JcO1+ojDVujVPFrNtLrUwGlKK8hGoOIbpTDYpv4uooposkoncygJ+FyFkt34z12uTBg==.sig.ed25519"
}

{
  "previous": "%2xcMn77KCAhuKoDB9SqBRlNCxi5sRaA6rGWpNaK7Vew=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 373,
  "timestamp": 1510610670689,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lzzcAZlM21slUIoiH4yd/wgDnXu8raNLvwqjxqrU06k=.sha256",
    "branch": "%rQCPxt7m3r4ERXIvUHiu84G1q9s2a6GzUHewd48MRM8=.sha256",
    "channel": "sbotc",
    "recps": null,
    "text": "[@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519) wrote:\n\n> The final step shouldn't be far off either but I need to find a good way to poke through the otherwise protected members to create the proper reply.\n\nI just published a new version of shs1-test that buffers the stdout of the testee. A server test executable can now simply perform the handshake and then write the 112 outcome bytes to stdout, without having to write msg4 and the outcome in the same go.",
    "mentions": [
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      }
    ]
  },
  "signature": "RBGPzmLgMPi+28O7OEM/ROj61LQg65hVbA/c1OXuarqxO/AQ2yBYrI7UFiAE7gN0HPRfe3XyFeLfS92dZMntCA==.sig.ed25519"
}

{
  "previous": "%Uk8tbs7xqKCXFlCuSD9UDhtPKIgooPiJ8192WqqHjuo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 374,
  "timestamp": 1510672593183,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%yfSR/6j0K1v4H9CW+hmVfuE5OfMWl9Z8206w+MLnRTY=.sha256"
    ],
    "packs": [
      {
        "link": "&kyUkQCQcEDvvRdklxFShe5oogPYcLYI171s3bg8m+yY=.sha256",
        "size": 6512
      }
    ],
    "indexes": [
      {
        "link": "&aahk299YKdUXnGrgLVQUfWASblgPTLOXW2ZMMebid44=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "3a61ecd91b69375ff70d64ca5bb9e1106cc7b652"
    },
    "commits": [
      {
        "parents": [
          "0b7517725f0213efc31a7a36e4dcb3fedb7d4a2f"
        ],
        "title": "Refactor with try_nb!()",
        "sha1": "3a61ecd91b69375ff70d64ca5bb9e1106cc7b652"
      },
      {
        "parents": [
          "5fb3f6a1ee7baf190a91cd799762cc7fc218bc25"
        ],
        "title": "Take &mut stream instead of ownership",
        "sha1": "0b7517725f0213efc31a7a36e4dcb3fedb7d4a2f"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "a312699473e0ccf6509674f902bc2d792042d0c3",
      "ef39e4f6a89eda70e0624b7fe2e67774bb4aa871",
      "31c86291b3bcb6b3950944e3b9a22d6d3b1d902e",
      "edcdcf102c19d930766676eb2922ebb794be030e",
      "690dfb5f05b084498ce2eaa711399d11d498627b",
      "23ad2d0ebb9b8966bf9e732646439c2aa90285a5",
      "9e8df9e3c6fd4fdedefc166ef8bb6952d69ddb8b",
      "901d2a073a25b1ad2336cbdeb3065641a5bafbc5",
      "e06f07104b7ee4d481f127b3791bd720f9f9fd74"
    ]
  },
  "signature": "HKKbnQiajFb7rwU3lUss4q/uDd9LdiuOyC0kMj+m8l12R96QoTqMYlh0QD+2dQuKf3RpX0cYoWBVnlvQ50F4Cg==.sig.ed25519"
}

{
  "previous": "%tCURnYZrVBQ2DBkLwAuaNnOavwR+Otkrjqlkwno5oo4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 375,
  "timestamp": 1510865223265,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbc-grants",
    "text": "## Grant Proposal: An SSB Client Library in Rust\n\n#### What:\nScuttlebutt is a distributed database with network protocols for communication between peers. All clients (e.g. Patchwork, Patchbay etc.) use the same set of protocols to talk to the local database. The only full implementation of these protocols is written in javascript. Consequently, all current clients are forced to use that language.\n\nWith this grant, I'd like to implement the protocol suite in Rust and provide a client library corresponding to the js module [ssb-client](https://github.com/ssbc/ssb-client).\n\n#### Why duplicate code in another language?\nThe current lack of diversity in protocol implementations mandates the use of javascript, even though the core design of ssb has nothing to do with javascript in particular. To become a widely adopted protocol, there need to be implementations in more than just one language. There are also some problems specific to javascript:\n\n- Graphical clients have to rely on web technologies. This means either running in a browser, or using electron. Both of these choices have considerable drawbacks compared to native GUI frameworks.\n- People conflate ssb and web technologies. Even if the protocol itself remains language agnostic, client conventions develop based on the available clients. And if all clients are written in js, it becomes tempting to adopt web technology features into clients (e.g. html or svg rendering, embedded js, mathml, etc.). This would make it tremendously difficult to write clients in other languages. The earlier we achieve language diversity across clients, the lower the chance of this happening becomes.\n- Different people prefer different styles of programming languages. Programming language design involves a lot of trade-offs. Different use-cases might require a language with different design choices. More things will be built on ssb if you are not forced to use one particular language with its specific set of trade-offs.\n\n#### Why rust?\nRust is a compiled, statically typed language without garbage collection. Unlike javascript, it emphasizes efficiency. Compared to js, the rust modules should both run faster and consume (much) less memory.\n\nSince rust compiles to native code, it is possible to provide bindings to the rust implementation for other languages. Providing bindings to a client-library takes less effort than reimplementing (and learning) the whole protocol stack. So an implementation in rust would significantly reduce the effort to be able to write ssb clients in your favorite language X.\n\nThe major native GUI libraries can be used from rust. Clients written with these libraries don't have the large overhead of a web browser.\n\nStatic typing and the excellent documentation comments make it easy to use the library. This can also provide a good starting point for other people to learn about the protocols. Having standardized, compiler-verified documentation about all the inputs and outputs of all public functions is just something different than the free-form documentation on [scuttlebot.io](http://scuttlebot.io/).\n\n#### Other Info\nImplementing the whole protocol suite not only enables a client library, it's also the first step toward a server implementation. A reimplementation of the database and replication logic is out of scope of this grant request. But in the long term, it would be extremely valuable to have an efficient and compiled sbot implementation.\n\nThis proposal nicely complements [@vtduncan](@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519)'s grant proposal for technical documentation. We'd both be learning about the protocol suite at the same time, and I don't think there are better ways for providing feedback on the docs than by actually trying to implement things based on them. A rust implementation might also be a good reason for the benchmark proposal to consider language-independent benchmark suites.\n\nI already implemented the crypto-layer of the protocols in rust. I think these are the most difficult parts of the whole undertaking, which makes me confident that I'll be able to get this thing done. These implementations are released under the GPL, and unless there are strong objections, I'd like to copyleft all the rust modules.\n\nI would not work on this full-time, instead I'd stretch the grant over two months. I'm going to university, so I can't code full-time as well.\n\n#rust #ssb-implementations ",
    "mentions": [
      {
        "link": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519",
        "name": "vtduncan"
      },
      {
        "link": "#rust"
      },
      {
        "link": "#ssb-implementations"
      }
    ]
  },
  "signature": "Ty7mnS2WP4Vz2MdsmlYz5D2WOs1PVMzPWONdUm+z5n9EyGN6uZCBcZ03roJ/lhyY1PT4JClzGGf9nyKTGWtzDQ==.sig.ed25519"
}

{
  "previous": "%pYNveoqk1n1YobhscETnI/EE8aZd0itL0bnPqXIASzw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 376,
  "timestamp": 1510867236259,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GvdUSpIp//8zkn0GBnmaxLBv4ZAzfg3N5a5iOmQ/wso=.sha256",
    "branch": "%qGCH+QvEdc0lRj/OWGok5wKuItMSTviheYOrMed/DQY=.sha256",
    "channel": "non-dev-resources",
    "recps": null,
    "text": "A little bit of specific technical feedback:\n\n- The first paragraph refers to the internet, but the world wide web would probably be more appropriate. Calling the internet centralized while ssb primarily runs over tcp/ip may not be the best idea. Ssb is completely separate from the www though (which is the layer upon which facebook and similar services operate.\n- The paragraph about the fragility of a single server seems exaggerated/oversimplified to me. In practice, the centralized services use distributed data stores with high redundancy, storing data multiple times at completely different locations. It's a good idea to contrast ssb's local data storage and redundancy to the single point of failure in a centralized system. But this single point of failure is there because of power concentration, not because of physical limitations.",
    "mentions": []
  },
  "signature": "rcAzOMlRPdPaCBCTPli9sBaJZWzQ+LEQ2lfHX3nzweCss3demHbiYnR9xnBmlmQQVzlyPhflUgE6ZtoEPLzmAg==.sig.ed25519"
}

{
  "previous": "%8DGAK4dU+kUnKiNHcf+ORkWcK3ExIoHYIaUc3g4cisQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 377,
  "timestamp": 1510872003607,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%tCURnYZrVBQ2DBkLwAuaNnOavwR+Otkrjqlkwno5oo4=.sha256"
    ],
    "packs": [
      {
        "link": "&G/H1CACxS0Go3lwZ5UJxIt8ARtEgv6lIbgke6v8FiMs=.sha256",
        "size": 15749
      }
    ],
    "indexes": [
      {
        "link": "&LACQ/PeY+Y1/cfnR/gjs1+ZoDQfJTy/JpxPxToXzRdE=.sha256",
        "size": 2024
      }
    ],
    "refs": {
      "refs/heads/master": "ba271b75ed5efa319e6f17e8a59af4a1e9e76aea"
    },
    "commits": [
      {
        "parents": [
          "cb0813468cbe4a515fe7333c24ffa4ca5d318e66"
        ],
        "title": "Add server example/test-executable",
        "sha1": "ba271b75ed5efa319e6f17e8a59af4a1e9e76aea"
      },
      {
        "parents": [
          "481cf34bcfbf1c726377df1460e856804f6e06b6"
        ],
        "title": "Implement tests",
        "sha1": "cb0813468cbe4a515fe7333c24ffa4ca5d318e66"
      },
      {
        "parents": [
          "f1ad008854d91c1e9aec55a3153db7ec0c4dd70f"
        ],
        "title": "Add client example/test-executable",
        "sha1": "481cf34bcfbf1c726377df1460e856804f6e06b6"
      },
      {
        "parents": [
          "1bba9dc6da0d5f2c7bf48b393bdc7e0052192884"
        ],
        "title": "Export NETWORK_IDENTIFIER_BYTES",
        "sha1": "f1ad008854d91c1e9aec55a3153db7ec0c4dd70f"
      },
      {
        "parents": [
          "a6222a23d5d9aed77dcff864e45b6c2aec5e22a0"
        ],
        "title": "Have outcome return sodiumoxide types",
        "sha1": "1bba9dc6da0d5f2c7bf48b393bdc7e0052192884"
      },
      {
        "parents": [
          "b66b07af45d0995a163b7d24028e640607542a8e"
        ],
        "title": "Return outcome data directly instead of references",
        "sha1": "a6222a23d5d9aed77dcff864e45b6c2aec5e22a0"
      },
      {
        "parents": [
          "3a61ecd91b69375ff70d64ca5bb9e1106cc7b652"
        ],
        "title": "Change export structure",
        "sha1": "b66b07af45d0995a163b7d24028e640607542a8e"
      }
    ],
    "tags": [],
    "num_objects": 34,
    "object_ids": [
      "76f15724aec21fd7b1588d5f65f6e90438e6ec4c",
      "ffbc2a05e2e16be7b8b91bad495a1410e049e797",
      "4a2b8e28fb6c4a673672116e6d1f1928382ce09a",
      "8005788094e178e209a8d1f26fbaa11eb33337e6",
      "0f974d03c4435baa6239caf58c005a69199721e7",
      "05872f030a994a3de6740e8ba0f6f3267ae90d36",
      "468a471714bd91b6479674380a73f655ae216b85",
      "21df41b644252d3d0c3f5599b86948fe117587a4",
      "d85e28827caf94332e27710fc54861d4dbc4380d",
      "80a61215ec10d6a89e72571c50abb687ecf5ae27",
      "8f2f91bdae2d27ccecb4ce5436645fc3cd418407",
      "08115d5d5ec741f1ccb3a383658e56238cff7cd7",
      "a036fe292d871f24ea28b291cd669b02d9231295",
      "fb73d98521b414a1c1a7eff51fe87d42d42dd895",
      "68aac7c69711ebccfc1ce94b3285d9a8dc68fc53",
      "329a54f1eac7c719cf33e97d97992cc8e3a95347",
      "ff5fedf28acbb2d3c46c61de494687a23e9c82fb",
      "eb77ac7da9ab705982aadfbb0f2ec325f22c0ca0",
      "df16e1c8bf8a01e7854b8e2ac1e8ad0e386aab0a",
      "325a903fd89031c882b01c695f49c9be9c48ebaa",
      "9f1c23fa61c6690b1419106a85068ad57350ff0b",
      "73bc168a13dd279ffd9cce73a50664f370649225",
      "cdc42c73e2457e6c3e8b6ece3caa5a8210f5c092",
      "3a3281fc406b2d64eb114e6719ed941ab53a6240",
      "dcd41ee73cb699420229c0c168dcbb98b2b06df9",
      "c8f71d6efd436c3c93bb3df1b32139b27fa12bf2",
      "eb1ee44993979aeafd8d94bfb3601ea24d3b2d82"
    ]
  },
  "signature": "RFxGlvFNXtJp42jiSs/GoD7iYJfDzLWbOztHEM6cXsi7AtlUlItwyW/EYAVHPnnhWku4dKXrYgTbNtk9iunFCw==.sig.ed25519"
}

{
  "previous": "%bbfLRVZQONvU4nzvs2cyPBXtoAM3CUxrX3jY3KEqgzQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 378,
  "timestamp": 1510873264774,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%bbfLRVZQONvU4nzvs2cyPBXtoAM3CUxrX3jY3KEqgzQ=.sha256"
    ],
    "packs": [
      {
        "link": "&o4NfN6j4nleKazf7MLvWeP3r+90avms9RFSarFH6YEA=.sha256",
        "size": 13846
      }
    ],
    "indexes": [
      {
        "link": "&MbmqSErmuDPpC/+lIi1QiuXmhsFjLkFLqeAGOcwD/zY=.sha256",
        "size": 1604
      }
    ],
    "refs": {
      "refs/heads/master": "18ac407e4fc9e52e12672402af11ed1dc2ef2b13"
    },
    "commits": [
      {
        "parents": [
          "5aee35c364dcb9e9fc20e458467a0aa11b6c1bd5"
        ],
        "title": "Fix warnings",
        "sha1": "18ac407e4fc9e52e12672402af11ed1dc2ef2b13"
      },
      {
        "parents": [
          "3d7a92b8b951c79df29d6c637a48f07652607ece"
        ],
        "title": "Fix import",
        "sha1": "5aee35c364dcb9e9fc20e458467a0aa11b6c1bd5"
      },
      {
        "parents": [
          "ba271b75ed5efa319e6f17e8a59af4a1e9e76aea"
        ],
        "title": "Clean up tests",
        "sha1": "3d7a92b8b951c79df29d6c637a48f07652607ece"
      }
    ],
    "tags": [],
    "num_objects": 19,
    "object_ids": [
      "470a851735039d390fad03a2fb3a2aea0d9a8c8e",
      "4a40d224c4a23fdb586ebed501c9ab4bb817ff45",
      "5165e5ab7ed988eb2d3d19d9b7d90118f255c5dc",
      "ed3b9ad6fa9ea0535b035e8054a0ed05c5e3eeb0",
      "aef4e1e64a146acf66c1d85c5e2efeb94d9ce5c5",
      "e59c7187d25c72f049bef76163982b00d485dbfd",
      "c829ed20646b08d70a3123a4592d8b630d10ca28",
      "2a354b2e6d88efa6c8f3a1906dd4cfd2f725ef27",
      "16416d16dc493d784dcdbc1c269a92118616855f",
      "c11baf8bee1aec48ec4db063612a5e2b48173750",
      "8d86a9f90a9c0a70be7aa21aba06cbee120b58cc",
      "f41d56da8a077ddbe3a657f307ce7c351a795bc7",
      "55e25b0dd49e63128890c24b282d6b29c4b4ea2c",
      "4454da779b490a7343fa9f5718920b513c17d859",
      "a228aac55cddb38fdfef8d2a04b6531cb10439fc",
      "d438b38bcb2b80657c64bc7a527e73ed0198d722"
    ]
  },
  "signature": "d7CXxzOemiFwPAs77CrhAq8nYy3R9W5cQYD30PwHED46P4Wj+GthXdsWGe1m/Dnanf6civzrYfCqwGBKdh5SCA==.sig.ed25519"
}

{
  "previous": "%k4yq9PradcqQimkrfI6y3lS0LWQqOkkWhfSd5Ptlwrc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 379,
  "timestamp": 1510999671226,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%k4yq9PradcqQimkrfI6y3lS0LWQqOkkWhfSd5Ptlwrc=.sha256"
    ],
    "packs": [
      {
        "link": "&UFEnLncfKHUIKmKvwXlpOjC0rrs3LyalM50MpzZrv54=.sha256",
        "size": 5249
      }
    ],
    "indexes": [
      {
        "link": "&eg9UII3OcUzQcB9l5t/VBc2YJp+SUJ6HZdtWCOo9quQ=.sha256",
        "size": 1464
      }
    ],
    "refs": {
      "refs/heads/master": "55a88507da3a2ba3c4566a5c559a061c31995f45"
    },
    "commits": [
      {
        "parents": [
          "279b37042715a9e63a4afab9c125a049caa061b5"
        ],
        "title": "Bump version to 1.0.0",
        "sha1": "55a88507da3a2ba3c4566a5c559a061c31995f45"
      },
      {
        "parents": [
          "6a46b7a781ac41cec78af2764dedbfd366ac7252"
        ],
        "title": "Clean up doc comments",
        "sha1": "279b37042715a9e63a4afab9c125a049caa061b5"
      },
      {
        "parents": [
          "c56d03e719af8f9721e3867051a38857361d33e6"
        ],
        "title": "Mention shs1-testsuite in the readme",
        "sha1": "6a46b7a781ac41cec78af2764dedbfd366ac7252"
      },
      {
        "parents": [
          "18ac407e4fc9e52e12672402af11ed1dc2ef2b13"
        ],
        "title": "Update to partial-io 0.2.5 (fixes blocking on flushes)",
        "sha1": "c56d03e719af8f9721e3867051a38857361d33e6"
      }
    ],
    "tags": [],
    "num_objects": 14,
    "object_ids": [
      "0fc3f8cab481eea72fa79f9b9c3816e29f625ab7",
      "ca3868656d9e1747ef5fd5df927595c6ce910a14",
      "5b13abe5ba17da0fc26cfd1c887e732b56269678",
      "0b1aa80f666e76671a8d329f73fef054ff5ca073",
      "4ab5b9f7a64b5a51da47c847940573313855bcc6",
      "a5f1ee79176378a7d64aa4f40144538be6f293a2",
      "1ed79a583c45d04d04bcee1107eef08c17761aaf",
      "008e65f44e2ed8f9489ede179f068a221b604014",
      "16700f998114a522623f18cb35e2295a21483dd0",
      "38cdd9e130d0c4c17dea66f96d75908b3a92ff82"
    ]
  },
  "signature": "rLbrhUKRnFa7TxKXZFTIFSKf0/3Yo9NA61HaaLv7gKd1N8YUf0CldOK0l/hxjjDJ3Le0lGarfQAHtCiQ8P+GBg==.sig.ed25519"
}

{
  "previous": "%21BJwUbmKv96IF7wG47nvaVitqHcEXVBLfpEPdpNJeI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 380,
  "timestamp": 1511000105180,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lzzcAZlM21slUIoiH4yd/wgDnXu8raNLvwqjxqrU06k=.sha256",
    "branch": [
      "%Uk8tbs7xqKCXFlCuSD9UDhtPKIgooPiJ8192WqqHjuo=.sha256",
      "%e0PMmgj6asvcqhrFyx0KJcPlfTL6sKUsPKX9uU/GvNE=.sha256"
    ],
    "channel": "sbotc",
    "recps": null,
    "text": "[secret_handshake 1.0.0](https://crates.io/crates/secret_handshake) is out. Between the shs1-testsuite and quickcheck tests for the async state machines, I'm fairly confident it's working correctly now. I'm also pretty happy with the reworked API.\n\nNow on to fixing the async behaviour in box-stream-rs.\n\n#ssb-implementations ",
    "mentions": [
      {
        "link": "#ssb-implementations"
      }
    ]
  },
  "signature": "l414uKJxyNlVR2HTCRw5Bt0X1qxvgk28u30I+mpBzReRwO8bYOcl0W3Nd/VSujWJFYGR4K4Xtdk6tQu/Cl2ZCg==.sig.ed25519"
}

{
  "previous": "%TX9pZPXbXPMgbgdoLJe+9DaQzoVUisum5oA+Pm17paQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 381,
  "timestamp": 1511007513438,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%21BJwUbmKv96IF7wG47nvaVitqHcEXVBLfpEPdpNJeI=.sha256"
    ],
    "packs": [
      {
        "link": "&/Qp6J/MymL/s47Xlui7TFvAdfBdjAfgc8KHcomt6Nhs=.sha256",
        "size": 7621
      }
    ],
    "indexes": [
      {
        "link": "&7pKaN94tmgluOXj1h4fHRF0ApJ4bApgpbs5rsSBScko=.sha256",
        "size": 1408
      }
    ],
    "refs": {
      "refs/heads/master": "8a8f6afb5fe1f9a9e494f2f359674bf97d568a90"
    },
    "commits": [
      {
        "parents": [
          "e482dd2d68bcd3794a0a0546ab9704241055c2c4"
        ],
        "title": "Bump version to 1.0.1",
        "sha1": "8a8f6afb5fe1f9a9e494f2f359674bf97d568a90"
      },
      {
        "parents": [
          "83ccd469de1c5ae42cf5bfaf36bc3915eeb55ea7"
        ],
        "title": "Fix deprection warning in build script",
        "sha1": "e482dd2d68bcd3794a0a0546ab9704241055c2c4"
      },
      {
        "parents": [
          "55a88507da3a2ba3c4566a5c559a061c31995f45"
        ],
        "title": "Use sodium::memzero to clear data",
        "sha1": "83ccd469de1c5ae42cf5bfaf36bc3915eeb55ea7"
      }
    ],
    "tags": [],
    "num_objects": 12,
    "object_ids": [
      "c35c21ff6fe4b02b3d252ecbc331eb59da15dccf",
      "991df9ed10ae1a3afecde9297ce77c70afc5dbb3",
      "36bd39f0f17a0f7d73cb7bfda972e44a2689e236",
      "cb3fdf3757e30335d19f17ac935f417b84831791",
      "bb53b59500cdff153dc9dda5f0ff3e50267fcf44",
      "d22cfc1f3d4ed85db956d97156490338ec4f44ac",
      "495defa21b7b956a8adb6f1eb9727da471f39073",
      "0bd3ebb5e3f3c70b9d0eac91357d8e7cee650b2b",
      "42004eefc6d5fd0442057ad093859c5eff87d2ed"
    ]
  },
  "signature": "C2vuLRH5pfxrtbb0BxnTPLOptJxVYSWrE6lafh0uS6eIPuqiAP56LFlweC3xgnO+YR8AgX7BD/kRdlvXSSnDBQ==.sig.ed25519"
}

{
  "previous": "%ZWQAoGbQgA2ugXzhHUUe5WQ6Z6i1vFLzzjrAYMkp6/s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 382,
  "timestamp": 1511008159644,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ZWQAoGbQgA2ugXzhHUUe5WQ6Z6i1vFLzzjrAYMkp6/s=.sha256"
    ],
    "packs": [
      {
        "link": "&NKHsanHpcil3l/FLjdwlNWWgfdMtJfI4DTZT21uCwik=.sha256",
        "size": 1218
      }
    ],
    "indexes": [
      {
        "link": "&3l7DlxjnT/gGJAYXq77XoFtUUfnRERGIOIapgRoR9TQ=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "79dd6f3b3f8b25a80f4b6165fc41430f6fd1f069"
    },
    "commits": [
      {
        "parents": [
          "04fdc3c0a53bb57906943b76a0552966905f339a"
        ],
        "title": "Bump version to 1.0.2",
        "sha1": "79dd6f3b3f8b25a80f4b6165fc41430f6fd1f069"
      },
      {
        "parents": [
          "8a8f6afb5fe1f9a9e494f2f359674bf97d568a90"
        ],
        "title": "Use cc instead of gcc in build script",
        "sha1": "04fdc3c0a53bb57906943b76a0552966905f339a"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "e0fd113f3072b52a155a9864ac0c58d16eeb5e3a",
      "9b06fd616281b63690be4800a0f8e4fb33d8d883",
      "cd18b3379735ba2f9cb6e87d2def4d42b949a6e2",
      "25d1aa60815c35df65e28cfc3b60a2f9cd658c21",
      "1fd1a754bb5546e31766ad8db9990dab09589910"
    ]
  },
  "signature": "C9wvhjaJLlGDbHHmTxtdPSeCOGHpTSBNyYbDafqJnBUptmKj8AhxZFtGqDFU6agALhzS1tVjFhHEn33CMJq7AQ==.sig.ed25519"
}

{
  "previous": "%Nq6fw3zocumi367G0ca87fZwA6cl7yeB094gFHODA+8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 383,
  "timestamp": 1511043790107,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%0bqfzlWB5vsobIN19W/Zl1YVge9UTjkwQqNSG+tIpRU=.sha256"
    ],
    "packs": [
      {
        "link": "&IlMgFp16v6jNq67NsmhCC/l9PsANz2UoJiwasBd671M=.sha256",
        "size": 14343
      }
    ],
    "indexes": [
      {
        "link": "&pHvJ2yhdKhwHzaj3+UUGYgGyztru/2lziEEVQ0hYVKQ=.sha256",
        "size": 1492
      }
    ],
    "refs": {
      "refs/heads/master": "efa1ebf05e5469b58b174fab2d5219bc32c8eb88"
    },
    "commits": [
      {
        "parents": [
          "d20c6b26e3376c0dd9d393f8c24c8a0d34bfec3e"
        ],
        "title": "Simplify readers",
        "sha1": "efa1ebf05e5469b58b174fab2d5219bc32c8eb88"
      },
      {
        "parents": [
          "d8dd68d39f53e546bc05f01b46bed942ce2d9cb3"
        ],
        "title": "Use cc instead of gcc in build script",
        "sha1": "d20c6b26e3376c0dd9d393f8c24c8a0d34bfec3e"
      }
    ],
    "tags": [],
    "num_objects": 15,
    "object_ids": [
      "aebe01d5615d85dec1e3cb151bb0b408190d60ca",
      "538f07753fe40118c32d3515954bbd2834b16fb4",
      "84ad852a98554b6ca21148db54fac5be3c3d9588",
      "1016a1cc7b83eb35d1036b17b244e838c6ec795e",
      "721b23a5b86b1179c88c71d83bec45993feee175",
      "36d3367704f6edcdf81395118f886075080b0d77",
      "34f5f3cb02fb6f2ded3d4ee510c50a537756142d",
      "0771e9c2c94d479e943bf9892e1398aeb16b4dba",
      "5270a94e72955b331802894a8037ff2d70fa0ba2",
      "c9af0bf9a964b3a8868aec6edfbd8666c3b7dcec",
      "d608acc1844813e6cca5bd25f4c4d35b0c0442fd",
      "5d93df7972325109b97c3863bfab206fa86149b7",
      "6020d460b3a70c6305735605e8d199cf0367f36a"
    ]
  },
  "signature": "Mf8cO92Yz4tED3KlFGu7R2Xg5SOF845Lod+sBaFGyycezxznuNmjbwt5bCGwiQz1+MSddP1xXLcWRIQZMRQBCw==.sig.ed25519"
}

{
  "previous": "%5IZWFUw9XiIqbPTNtlTqjy80pUjaGsVei0bG9qGRju0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 384,
  "timestamp": 1511088381415,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%5IZWFUw9XiIqbPTNtlTqjy80pUjaGsVei0bG9qGRju0=.sha256"
    ],
    "packs": [
      {
        "link": "&OnmEGE4pMOUIDZpi7fuqlGzpBygVo6tevDfgopBQJeY=.sha256",
        "size": 7390
      }
    ],
    "indexes": [
      {
        "link": "&iXoYP+UhFJSPi7ytWOKW0+mDh0Y0KVSRuAqV56tec24=.sha256",
        "size": 1408
      }
    ],
    "refs": {
      "refs/heads/master": "56a2cdd1f234326c3b2012da299e1af9c9675995"
    },
    "commits": [
      {
        "parents": [
          "f1e909c7f9e5be4327b98d34561bb17897da53e1"
        ],
        "title": "Make error messages human-readable",
        "sha1": "56a2cdd1f234326c3b2012da299e1af9c9675995"
      },
      {
        "parents": [
          "efa1ebf05e5469b58b174fab2d5219bc32c8eb88"
        ],
        "title": "Rewrite writers",
        "sha1": "f1e909c7f9e5be4327b98d34561bb17897da53e1"
      }
    ],
    "tags": [],
    "num_objects": 12,
    "object_ids": [
      "1118fd9d6949fe35d29d07b28fa08190a1e4964f",
      "d0f11301a9c13dd6a2f70f17314c996f67718abb",
      "91d2270bdfa2b19ae91389e442062b226b6c1c06",
      "c653f5ade3b7684a3d263e30ada6bd8333045fb5",
      "47dbe54beba6f639b7f8aa643e3ffaeb1b17483d",
      "c527e91d31df91604e4e2aaa592d56b33ac2050c",
      "c6b37de415bab32c7ca61bb4721cd8fd4b2d2af9",
      "3789bc1cfc6d66fda28ab8aedc88e18f8cd90751",
      "b9943b0c3dc3322a83723596da05606116c31d9d",
      "b37c84b31b9d545aeca7c739c2be5df3dd5476e0"
    ]
  },
  "signature": "4qO5dNTHknHMGwdQcJESdlmKccu8NsoE08WmY4uTtvJE4aKKZyONxLso84bf3t/YmzGdlEroqUX9ZDeFEv5tDQ==.sig.ed25519"
}

{
  "previous": "%SffNQy8JfSwjfMZz/w5e4WMFgEIT39RKAKO1s/l/y/g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 385,
  "timestamp": 1511088977417,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ADyNCey6h0QNUGqxQ90IQJ5anF2N1hH74n1DmOIstg0=.sha256",
    "branch": "%Nd8uOo5cFqhhKs1HX1zk/CQg8nrIbpIwgS1J4Pye+Lk=.sha256",
    "channel": "deutsch",
    "recps": null,
    "text": "Moin zusammen, ein weiterer Norddeutscher hier (wenn auch gerade in Berlin lebend) =)",
    "mentions": []
  },
  "signature": "EX6kFZqpsrYGz0uGSX6mHbGKIq4CD1mfGzfQcD5ANzBJ57s7HcCelkyLDGgL3nYy2MCDLpmS7xLgdrUFb5rqDQ==.sig.ed25519"
}

{
  "previous": "%XhDpaMUj3FmyNO+nZkGNRADX4JhiDM/JQoQTbXgBN3Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 386,
  "timestamp": 1511109727684,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%SffNQy8JfSwjfMZz/w5e4WMFgEIT39RKAKO1s/l/y/g=.sha256"
    ],
    "packs": [
      {
        "link": "&hw2tr7xh9lmmohASucrS7E3cIncN+p+u9Aq5HeWrlBo=.sha256",
        "size": 3102
      }
    ],
    "indexes": [
      {
        "link": "&smmPbOVn4NO+yyT9BupIXNrzc7ForgeK/7j7f5/M8S4=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "b4574dbdf5ba0d01f309f4b5e77430cb3d8c2f2f"
    },
    "commits": [
      {
        "parents": [
          "56a2cdd1f234326c3b2012da299e1af9c9675995"
        ],
        "title": "Disallow 0 length packets",
        "sha1": "b4574dbdf5ba0d01f309f4b5e77430cb3d8c2f2f"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "066f38596631c99967d3f011e0574c1a5bcbd7b7",
      "3219df19a0670f253c786726a93598b8f8a2ee46",
      "6c48392fef5c32caeddfc2a657c2125973cfb278"
    ]
  },
  "signature": "Tclld2EsJyMnFu2Uh8hhTjdHMxbC9q9C6rxOsuyLUQ3lqRiAMUp7gGJJeIubCVMtWqKDuC7K49A1qVR02HynBQ==.sig.ed25519"
}

{
  "previous": "%wzgfBN/h8ueQS6U8ysCu6SWlQOvStLhMCComq3MoX48=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 387,
  "timestamp": 1511389508359,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "async-ringbuffer"
  },
  "signature": "AUm11lIAWEyqf4D18TWfR04ssyYqAk+e2ndU+CLphbtLkHh5dqL5WPFIsYqsh9Uop2KvtQIOTprPZT/Hr2kcAQ==.sig.ed25519"
}

{
  "previous": "%fDjtH40oENJrx8gvG0CxgDvAD4eY8QmCzLvordfUDSE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 388,
  "timestamp": 1511389526888,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%fDjtH40oENJrx8gvG0CxgDvAD4eY8QmCzLvordfUDSE=.sha256",
    "refsBranch": [
      "%fDjtH40oENJrx8gvG0CxgDvAD4eY8QmCzLvordfUDSE=.sha256"
    ],
    "packs": [
      {
        "link": "&KY/9Haft/MelcNtRLOHZ5aZrMmIArQvk8CNKYRoF/Yk=.sha256",
        "size": 20678
      }
    ],
    "indexes": [
      {
        "link": "&oHlziXUF8wOvuZriLP4mMo1nFy7wbKmMg4Zg2OBtRu0=.sha256",
        "size": 1688
      }
    ],
    "refs": {
      "refs/heads/master": "e3d5882edb2e8b90f0e334ce334fc0a5560d7235"
    },
    "commits": [
      {
        "parents": [
          "7b2d51e0f8816f9a18e3b8271a7f6f1f0626f8fa"
        ],
        "title": "Return Ok(0) once peer is dropped",
        "sha1": "e3d5882edb2e8b90f0e334ce334fc0a5560d7235"
      },
      {
        "parents": [
          "542579ea7db22ef3947c38c931093de5523326ad"
        ],
        "title": "Clean up",
        "sha1": "7b2d51e0f8816f9a18e3b8271a7f6f1f0626f8fa"
      },
      {
        "parents": [
          "468eef50d9385a97b0a277d0eba595aba5bf9441"
        ],
        "title": "Write tests and make them pass",
        "sha1": "542579ea7db22ef3947c38c931093de5523326ad"
      },
      {
        "parents": [],
        "title": "Implement the ring buffer",
        "sha1": "468eef50d9385a97b0a277d0eba595aba5bf9441"
      }
    ],
    "tags": [],
    "num_objects": 22,
    "object_ids": [
      "bedf723781e2fa4b8eaa156cc5281c10c6f1e238",
      "4308d822046df995d72605f3497d02ae5ae307d8",
      "c2c224f5ce05cceffd9b7053599a0795ba662cdb",
      "16f70ef74763ff6237e07cd07a401dddb39a86f1",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "16138c598993ba56d27802b9c53aa3d9e844465a",
      "ad4f76d0cf72fc88a155d3a758217fe03fe8a388",
      "93b38f16145e49d54681b2e609e96ad4179f6e09",
      "c39cb13caa3e0d4af97e8b8a32dfbbb0f7cccdf4",
      "2c1dd81a635699dd03947f78c8490edad063617d",
      "cd72d54a49eeb91252dd9197a97c8dcb89a97583",
      "d89c94162a07351b06ffb79a2788d4218a15bc5e",
      "9b804637ab7cb2b0e3f8b5636ebee1926429167a",
      "668c25915a8fe0ef572116ee2a08fcd7c2948e77",
      "004dbbb13c58dad2a7f0a44c1943653c3836b013",
      "c9df5efc5b8b108a6cc6bedf4fe011726a2fbe14",
      "e3bf515d983d7a6a499508e5133f96b19fee79f9",
      "98bea81c816592cb2a4cc99bdb70a7ff25c225d8"
    ]
  },
  "signature": "knPDZApKL3uV1lRJW0jACyTiZmTIjxYdOJzhlEnwAVG1XH1VjIalyJIlIVatXZvrigkV9DGStITKgMeVVcNWBA==.sig.ed25519"
}

{
  "previous": "%cg+1nINBqnjq3GO0DvKoW0DiOqzt9cMtaJgbe7XCYZo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 389,
  "timestamp": 1511390005645,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%fDjtH40oENJrx8gvG0CxgDvAD4eY8QmCzLvordfUDSE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%cg+1nINBqnjq3GO0DvKoW0DiOqzt9cMtaJgbe7XCYZo=.sha256"
    ],
    "packs": [
      {
        "link": "&LgAARSCyLUIa83c/0Y0VQMbRAyuHXOH9uVHkq4HjNkU=.sha256",
        "size": 658
      }
    ],
    "indexes": [
      {
        "link": "&jzTTTGO/ownMKzRSpTDDSqoChv/S8A0n6mOa0F99Bbc=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "b5cbc3082fe4f0fb757f9cba230b268dc2953613"
    },
    "commits": [
      {
        "parents": [
          "e3d5882edb2e8b90f0e334ce334fc0a5560d7235"
        ],
        "title": "Fix link to docs",
        "sha1": "b5cbc3082fe4f0fb757f9cba230b268dc2953613"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "6e04769b048cebf34a041a74cb4ca264971f5e12",
      "b28f65f1f21b1df5d0a205573e12393e6a9ecbbc"
    ]
  },
  "signature": "AsrqSBBpc82e9SMVij++CjrrydOAtax4bDzfJucKqHLSuEsYArkZRB3+RsyjcWkydxnktR0E6UtufsvTq7GnCA==.sig.ed25519"
}

{
  "previous": "%zFeKVy77vzuFYO/euIG5/YIBLm0mdKzZsOPF/VknzIs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 390,
  "timestamp": 1511433529581,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Nq6fw3zocumi367G0ca87fZwA6cl7yeB094gFHODA+8=.sha256"
    ],
    "packs": [
      {
        "link": "&Cmm/FCF95v+gdPz5j4JST1hQud/rfCnf2doICyWUm40=.sha256",
        "size": 12768
      }
    ],
    "indexes": [
      {
        "link": "&n3gD6oXNAlO9uKJ3k8T7E0jb/CyhA9Sw1m6DgrMWQ0U=.sha256",
        "size": 1856
      }
    ],
    "refs": {
      "refs/heads/master": "6ccd3f0fee9d44d0efa76846d6d168eaa0f5b1c9"
    },
    "commits": [
      {
        "parents": [
          "5540afb6a83b77921113485d8254ad6e058ba067"
        ],
        "title": "Add test for a client and server performing a handshake",
        "sha1": "6ccd3f0fee9d44d0efa76846d6d168eaa0f5b1c9"
      },
      {
        "parents": [
          "8ac1478f5c830bb066766e02f4328e32f550cfb9"
        ],
        "title": "Bump version to 1.0.3",
        "sha1": "5540afb6a83b77921113485d8254ad6e058ba067"
      },
      {
        "parents": [
          "cec6615275f4c11cef909abedaa18e09abe40308"
        ],
        "title": "Clean up",
        "sha1": "8ac1478f5c830bb066766e02f4328e32f550cfb9"
      },
      {
        "parents": [
          "511ef55bd6932c0c7b3b21b1ace97df7280d0aff"
        ],
        "title": "Error on reading/writing 0 bytes",
        "sha1": "cec6615275f4c11cef909abedaa18e09abe40308"
      },
      {
        "parents": [
          "79dd6f3b3f8b25a80f4b6165fc41430f6fd1f069"
        ],
        "title": "Retry on Interrupted errors",
        "sha1": "511ef55bd6932c0c7b3b21b1ace97df7280d0aff"
      }
    ],
    "tags": [],
    "num_objects": 28,
    "object_ids": [
      "dd8a3e459fe9196877c27e708923807225fb1ece",
      "03fe6b2faf5f9f768e2458cd88b5fa634577cd78",
      "e1c41676b1e6ee7e77340168e09f7452371beccd",
      "2704b1d5af0c85a813485bf670f3bd427e12c8ea",
      "15dd9bb9d7836e9e5d739dc2eee870cda169db22",
      "e9008f787ff514b43e09d60abceb30e8cab8f449",
      "27d94b11dcc3d71c3c6fda65da530f581ff08463",
      "66d3b6f66388f9d5795ddf611890a517e8916985",
      "eb6c82e815e79812f1ec79418670a1ed955fdf82",
      "b595ab9681455c9f9c56ad4fd8a73b112b3a5eb1",
      "a43b72ef13e222b12832c88c2e9760929c1666de",
      "fc958ba60cd8c3c73d5847d24d7a544dd5901439",
      "b8d2504bd06f1653dfc443e7d833d6b665e824cb",
      "ff91ce8dd7b5591b5047389749c0298a2fead347",
      "0b0443dc2628dcd2a289658f04af69644c87900b",
      "086dc2445ed3b5481d1f9b3d5c5e5237c769c317",
      "23f20f6fb540b071e46ca46cb413d80f6d5f054d",
      "349f4176c380a5801ccadc8ba15b6c3b1f898a03",
      "95aeec194423416b64c9c28b3f52e5c7fe49fe8a",
      "d77fbb74493d4f133998f565bfcb22158531de38",
      "549b53d42647ce5c2aec5c05dbc11ba2b642eca5",
      "b4e3f8982fd7123433f60f371c55724773787226",
      "907bda4301cefda589d91e13773d3fa46991fbea"
    ]
  },
  "signature": "DlSReERqSvVNhGGxfNH04cfgtLO/fCiShT7UWoYLQW7VWYyD1OBB09RJYXqhZzJ2N7QgiwQe80Veg4f9tzsKAw==.sig.ed25519"
}

{
  "previous": "%39gfVSBOM7fS3Vy098BMvPkff8MuGRNV+RaPrV5zQ38=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 391,
  "timestamp": 1511561264018,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%fDjtH40oENJrx8gvG0CxgDvAD4eY8QmCzLvordfUDSE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%zFeKVy77vzuFYO/euIG5/YIBLm0mdKzZsOPF/VknzIs=.sha256"
    ],
    "packs": [
      {
        "link": "&evFkGR5LeDd/e0Iad6SJWbCPGMM8V1k2o4x9G4TSxd0=.sha256",
        "size": 4852
      }
    ],
    "indexes": [
      {
        "link": "&3ufpa7NG2jc+fLCA0PpJmaZ1mFm75BCXc6KF+2Jz1q4=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "09b1202abff0b9e186a784e74696ce2a13bf2117"
    },
    "commits": [
      {
        "parents": [
          "b5cbc3082fe4f0fb757f9cba230b268dc2953613"
        ],
        "title": "Test that read does not return Ok(0) when given a non-zero-length buffer",
        "sha1": "09b1202abff0b9e186a784e74696ce2a13bf2117"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "3950d7a5ef614df6e39a22aebca02522e419ec6c",
      "2690b1bb91377f27530bf35118efd663dd2fb24b",
      "0bb575969238f3571a106f9fb53d194bfe23f136"
    ]
  },
  "signature": "cadc4K5/NtGbo5qoPBhthDR9KNIkkSlwWonTAQHheGxtFCKSRXNIRLjFPdU6NG75lu03VTjuE1iqYdmrk1XnCA==.sig.ed25519"
}

{
  "previous": "%soMlhI11HL7zeHJwhdbH3ZKGb+Ky//usLfOBSsZMGbs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 392,
  "timestamp": 1511608522132,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%wzgfBN/h8ueQS6U8ysCu6SWlQOvStLhMCComq3MoX48=.sha256"
    ],
    "packs": [
      {
        "link": "&Ujt1gksLoIsFd3fWzvN+O2ZP4TR80jPj7+aP5HUU644=.sha256",
        "size": 8684
      }
    ],
    "indexes": [
      {
        "link": "&cnr/u5v13+j9tphuT6J9pNvIa3VxVBxhm+8pN+yiH0o=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "993165738fd50d56aa4e934dfdca8a37584fd535"
    },
    "commits": [
      {
        "parents": [
          "b4574dbdf5ba0d01f309f4b5e77430cb3d8c2f2f"
        ],
        "title": "Add quickcheck test and make it pass",
        "sha1": "993165738fd50d56aa4e934dfdca8a37584fd535"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "e60993e95e835d2ccac7ee54f0beb9bcc4cbf5b1",
      "b01916f2393ec91b849ed739fbfb168ac66f6824",
      "01152875ac4be9650f70dbc7e17077a3a6b18ebd",
      "ee962188be59831310cfe6101348d4a16752028e",
      "4f9822eb0c819da9febe1e3b48ef127c67032d78",
      "284fa8a375f0409005409b8518972023c824a457",
      "4b737751cab874587f8cfe300f1238dba3cc03ea"
    ]
  },
  "signature": "u+LZ/yj0escXeqY3QzlcShLyiuo2fCGT5O4V5gpErTqyqZnavWDfD1z2m26ltZpp/RjyzU+0PaZhfFbkH8ICDg==.sig.ed25519"
}

{
  "previous": "%jb0WyOtHJ+qowizIMuA45M/4msMbUoS6WIfzhOD5M74=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 393,
  "timestamp": 1511651912906,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "atm-io-utils"
  },
  "signature": "rBuQbvwnbkD0wHbsYFp2MRWYYIslhf8QRlWYuvCHT6EQ050Q1Lo0UNWpp5yrsx1gLvdjxgtXkxsi1MXHKgYbAg==.sig.ed25519"
}

{
  "previous": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 394,
  "timestamp": 1511651917762,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [
      "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256"
    ],
    "packs": [
      {
        "link": "&Hux/KMoyeHltaDF06CzsZsv+VjBCKXXchRAH2hncpAk=.sha256",
        "size": 16696
      }
    ],
    "indexes": [
      {
        "link": "&+Z8hj2AUm/1WWNOecUyOX3h6Vq9hKXB4OAKUQG2dlfM=.sha256",
        "size": 1940
      }
    ],
    "refs": {
      "refs/heads/master": "90e915126c4f34d32bd2bf7c281cfc3295558515"
    },
    "commits": [
      {
        "parents": [
          "741499a4577e028d306cdf9d574c336f17497040"
        ],
        "title": "Fix export of MockDuplex",
        "sha1": "90e915126c4f34d32bd2bf7c281cfc3295558515"
      },
      {
        "parents": [
          "78cbecf9392d44d134602bb094e96d1298a62f80"
        ],
        "title": "Actually add MockDuplex",
        "sha1": "741499a4577e028d306cdf9d574c336f17497040"
      },
      {
        "parents": [
          "780f97c07b729ce92a4a5642546b4e64f9449802"
        ],
        "title": "Add MockDuplex",
        "sha1": "78cbecf9392d44d134602bb094e96d1298a62f80"
      },
      {
        "parents": [
          "5a4a2598edcee8d04a17d1a464fcad5c70d62f2c"
        ],
        "title": "Derive traits for Duplex",
        "sha1": "780f97c07b729ce92a4a5642546b4e64f9449802"
      },
      {
        "parents": [
          "cb0e0a6f325ccb9059de1877b63acd5360134223"
        ],
        "title": "Add Duplex",
        "sha1": "5a4a2598edcee8d04a17d1a464fcad5c70d62f2c"
      },
      {
        "parents": [],
        "title": "Add retry and retry_nb macros",
        "sha1": "cb0e0a6f325ccb9059de1877b63acd5360134223"
      }
    ],
    "tags": [],
    "num_objects": 31,
    "object_ids": [
      "86e6194493b2803fee290e21c0a7a7aaa8e0bc8f",
      "4308d822046df995d72605f3497d02ae5ae307d8",
      "e4c091e73d17a161af8e21827145f51a296bb2e2",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "39b291e7c5477e6c4221ae2cdd1753674b94ed62",
      "04a750b5b62e2222b0d83b6a7293e1bbb33f7fcc",
      "f12e9a2344c3699c6a91dd76eb57df8e0ece70b7",
      "78b49af7d3f165259ce0a36443238650e187f78d",
      "f9b7cffde01d273a75e6153ff9fa8949a23c1503",
      "5037dadf47fab174a6f265c51386d1f83f3fa56a",
      "1900c7f5e8572553720e0afbc5b0cda4778c0695",
      "589a11d0c6691df19056e3fa03077ce1a11a4a36",
      "db3aa439b3dc1cd568127871f5a89f3ec069c355",
      "861d6f7a6ba5798fd90a99bb7dbbebbae8db94b7",
      "2729b81c01df502e5db05ea3a5b542661b1e7468",
      "c4eaea8bcc3475efcf1f1ddbac118398f2438dd5",
      "f3a594a93ceaa66753fc5d179a9ecb2ea7909cde",
      "3b53cf5cd26978ddb9594e6abc1d6d5fc859d648",
      "2bdbdde3ba540378277a85562774b9f38f415311",
      "b23504283078c00df53b3d3ba244c846e3e1c298",
      "0d302d18434893c049ddca57cd1e602b9f76857c",
      "3f7f2445a93d9c849e3e875700eef3c1c349339f",
      "6450be65fb2789561b17c7e1615e5a3d4f6a0b25",
      "40b8ad316b14e1c0b4ca5452784c47abf7a71e94",
      "8ba9a644aaf6b18479b41b19f750837c1a3bf8c1"
    ]
  },
  "signature": "u00oyFbUgK5qYfEPLJyJ95Ynd6D42b5dlyug2RckCZF7qBGEo9ArIL6S8OpbnUF6UHbw32JbWb8qkRVdhkmZAw==.sig.ed25519"
}

{
  "previous": "%IZwooiW7mQ+OWXRAYEwirClh1AUsFo3lbU0fAKNAJhs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 395,
  "timestamp": 1511651983875,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%IZwooiW7mQ+OWXRAYEwirClh1AUsFo3lbU0fAKNAJhs=.sha256"
    ],
    "packs": [
      {
        "link": "&jfvo8yB1xcsqKVjGZYvsjyampNpofvxA8z/NfbvzyPY=.sha256",
        "size": 1329
      }
    ],
    "indexes": [
      {
        "link": "&AXOnU23ppojliDePeKx7ULC8u2hQXkNHpmpK7lO7354=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "dff3b5613269b03c2a8ed58ff13c75d2aee34027"
    },
    "commits": [
      {
        "parents": [
          "90e915126c4f34d32bd2bf7c281cfc3295558515"
        ],
        "title": "Remove unused import",
        "sha1": "dff3b5613269b03c2a8ed58ff13c75d2aee34027"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "cecc079ec90909e96689b3604fbc95930c354601",
      "079c0bf82ff120adf8a42ef493b43c8e9b92cf2f",
      "80cfbc2e4936e7d0648617311152231a29d5980c"
    ]
  },
  "signature": "9BF3fLgTdhjQ+ORYqJcZ7ZaV9blR+Gbop7+HSj1zFDqFjmlphsJYWW/hBLYQtNhVIr4jqf/Mr8jBeyhaFasMBw==.sig.ed25519"
}

{
  "previous": "%7NbvDJeDCknlhTcgBmj1RqtV5AowDH2fB5pZm1ol8XM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 396,
  "timestamp": 1511652661539,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%39gfVSBOM7fS3Vy098BMvPkff8MuGRNV+RaPrV5zQ38=.sha256"
    ],
    "packs": [
      {
        "link": "&iaEZINRDQYk312+CuN2X2wtDXNmgLVYrU8+GTEU5PiY=.sha256",
        "size": 14487
      }
    ],
    "indexes": [
      {
        "link": "&aWvuh2bq1U/bHMge/RbSCMp7U66sHoBCB5NjKD6NgRs=.sha256",
        "size": 1688
      }
    ],
    "refs": {
      "refs/heads/master": "2b9fb56df2f33d86fc267cdcb12675b57260c090"
    },
    "commits": [
      {
        "parents": [
          "1c60f4282971c9edd93bb005786acbeb62ad4a06"
        ],
        "title": "Bump version to 1.0.4",
        "sha1": "2b9fb56df2f33d86fc267cdcb12675b57260c090"
      },
      {
        "parents": [
          "cd7c7f7cb483df83d0d5ca7d375ffa07bc24da1f"
        ],
        "title": "Cleanup and refactor with atm-io-utils",
        "sha1": "1c60f4282971c9edd93bb005786acbeb62ad4a06"
      },
      {
        "parents": [
          "49ee35e8f53e04584e4f1faf1f1ffffba93a6627"
        ],
        "title": "Remove duplicate repo link from cargo.toml",
        "sha1": "cd7c7f7cb483df83d0d5ca7d375ffa07bc24da1f"
      },
      {
        "parents": [
          "b5493f27f94d18d1f30ad9864266ff7db9abafb0"
        ],
        "title": "Add repo link to cargo.toml",
        "sha1": "49ee35e8f53e04584e4f1faf1f1ffffba93a6627"
      },
      {
        "parents": [
          "6ccd3f0fee9d44d0efa76846d6d168eaa0f5b1c9"
        ],
        "title": "Use randomized ring buffer sizes in test",
        "sha1": "b5493f27f94d18d1f30ad9864266ff7db9abafb0"
      }
    ],
    "tags": [],
    "num_objects": 22,
    "object_ids": [
      "d3b993a07f4a0b7b0d32d2e3b6086a2818b762e1",
      "04c4cc5734a2e5e8ade616ca69a04d14631b5a68",
      "d08b36bf19da0e6818273b56f5094b2f3a00b60d",
      "c76dd7e74829917e48a927b2cb066963479cacd8",
      "beada48b2e00130801e76c200d2f06b5bca0fc81",
      "ec91fd89f959cf6fe269c4e1b27496c9e2e7f885",
      "040e8ecb5120e2c18e6982aaf3854ff2608ce751",
      "83d545b582303c00ac3a3da773a72742ed3f8584",
      "68a10511f9ebb78c1afb4916329b27825f4dfdbc",
      "cacacd14f0f6d0d30614b5fbc4fcb8e36b544ea5",
      "0c5e0777490ccd351c940839fe20fef75a69a163",
      "b9be29476eae7e142aca96eb1ed0f3d47788a80d",
      "8c7d1e649f5b6399ba0b4dbce8faed40fea02d1d",
      "421d4425fd889503bf2ee3fc96c8729877846be3",
      "099ea9e5447479c90857410f215572107e7d9c95",
      "0456b593eced1ce89e34ffad344f6a8c52ac0623",
      "7afe576b79a11fcaa0ad861434c11628d533235d"
    ]
  },
  "signature": "FeCjx4DCYwB23x4W+GqwATKGGccb0LfiFQfuZP7xAAmRtie3ecWeAM81vuohfrCy184zfh1zyVPZOCmKgEkLAw==.sig.ed25519"
}

{
  "previous": "%rqS4wd7AKFA/Epz+eQyrKVWRtb7HYOLWY0d9GaPRPg4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 397,
  "timestamp": 1511689269060,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%fDjtH40oENJrx8gvG0CxgDvAD4eY8QmCzLvordfUDSE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%soMlhI11HL7zeHJwhdbH3ZKGb+Ky//usLfOBSsZMGbs=.sha256"
    ],
    "packs": [
      {
        "link": "&nHrNADKuHCZCpjz0m9tKKuGdhu5RjUShhaJaaqxYuyg=.sha256",
        "size": 6700
      }
    ],
    "indexes": [
      {
        "link": "&s//VGg7Ar/egQfAa1ua9BJaPZalh9aAC1ypG9Mu3L9s=.sha256",
        "size": 1576
      }
    ],
    "refs": {
      "refs/heads/master": "4798d59c26a3ba76a6ffe6f31871cba256493fa3"
    },
    "commits": [
      {
        "parents": [
          "fea470123044244f7224710bf1cd48f771cb3837"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "4798d59c26a3ba76a6ffe6f31871cba256493fa3"
      },
      {
        "parents": [
          "07fe3455d8b5c786c4c3c904a0bcb6eace104fbd"
        ],
        "title": "Test that write only returns 0 when given 0-length buffer",
        "sha1": "fea470123044244f7224710bf1cd48f771cb3837"
      },
      {
        "parents": [
          "2944f6a604e83c6295ef5143ab8ab300e698992e"
        ],
        "title": "Test panics on invalid capacities",
        "sha1": "07fe3455d8b5c786c4c3c904a0bcb6eace104fbd"
      },
      {
        "parents": [
          "f601b43e2428f773523b24bd773bc49a4bb052b7"
        ],
        "title": "Implement proper shutdown",
        "sha1": "2944f6a604e83c6295ef5143ab8ab300e698992e"
      },
      {
        "parents": [
          "09b1202abff0b9e186a784e74696ce2a13bf2117"
        ],
        "title": "Add repo link to cargo.toml",
        "sha1": "f601b43e2428f773523b24bd773bc49a4bb052b7"
      }
    ],
    "tags": [],
    "num_objects": 18,
    "object_ids": [
      "d07e2e11b2ae5f98542371d4f81b46e173db6871",
      "b41d4aeb346227195298df57d432db64ec9e3e42",
      "0b3e55549c130e2f1aca498e9547ce04c9152136",
      "895b23ef1807bdb17845b705d774e69949d8548e",
      "fc87e17689a744d9721a80dc2252d8c5e1cd466e",
      "8a420f79f3bb1f0c2bf30edf69c71f2694e8ab49",
      "9c069f75a036a28f0b73c084885cf911f7299276",
      "4799235445bd02e27e71f260432561b302505522",
      "6b566a1486b347d1e88a716e5bd53b38449af4c6",
      "7e9197c480974ae6401fc87127b518925763c698",
      "5472a8783f3f40a4fdb2dcb93127eacaa194779b",
      "c873ec0efee5d62b9c757be9b3f217056d86e860",
      "f64806c86c00726aa921f836d36434b3431899cc"
    ]
  },
  "signature": "HyIK27KsfxXyWqRA9i3BnXfTtprVcBNdQw40VsxgHdgqE2ytw+Mup+/juoQNwm+Xq/+RANrwquXPdZd5HDZUAQ==.sig.ed25519"
}

{
  "previous": "%f40inmXIzFJzWqqHYsV8lArq5FjlG22CFHLzNoA0eNk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 398,
  "timestamp": 1511709194044,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ldBZhCx9qOBQ8zVMv6eIOTVF/aBbnBoztTQkd0KBGpk=.sha256",
    "branch": "%TMSFPsMggVOf+WAMkGYyNx5806yetO0R9sm6yzfdmNM=.sha256",
    "channel": "rust",
    "recps": null,
    "text": "Shameless promotion for my [grant proposal](%pYNveoqk1n1YobhscETnI/EE8aZd0itL0bnPqXIASzw=.sha256) to implement the network protocols and a client library in rust. I didn't mention neon though because I don't know how well the [rust async ecosystem](https://hackernoon.com/rust-async-libraries-cheat-sheet-for-node-js-javascript-developers-6f1d7a4092a8) plays with the node event loop.",
    "mentions": [
      {
        "link": "%pYNveoqk1n1YobhscETnI/EE8aZd0itL0bnPqXIASzw=.sha256",
        "name": "grant proposal"
      }
    ]
  },
  "signature": "M0EJfWWojzHuf8j8ExS1V1uDPcG+59dGoPNjXuzQxyfqDWLEft3484rbZQXbazD/J+Suh2dkBg1ECZPjZtUVBw==.sig.ed25519"
}

{
  "previous": "%60Gl53fjYg7cqMOL9L9iuu1xnqZFuXFXDQqlvr5+Ya0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 399,
  "timestamp": 1511808343470,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc-grants",
    "vote": {
      "link": "%+ZCJrmlOLxpY17U4WsEPgyOHKYw2dtkUwiy0oqEAH9g=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "WvLAAsnnOAKBoo+rgMHA/NtMlleh1nxiZKwhYTo9gvgc1esk4kI9oXFlfDXvL0VXwY7FIxGeKAMWuBp7pdHfAA==.sig.ed25519"
}

{
  "previous": "%0bhEYdAgGP3eHD/quVi7mEi0Cl0uVb9u5O7P6ZsHAfE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 400,
  "timestamp": 1511812642161,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%jb0WyOtHJ+qowizIMuA45M/4msMbUoS6WIfzhOD5M74=.sha256"
    ],
    "packs": [
      {
        "link": "&h4DmBj8myEH/TvF7jHP5Ezt/sfixcDhU/dOoYz0uoF4=.sha256",
        "size": 11237
      }
    ],
    "indexes": [
      {
        "link": "&aiLcZxn2sGnfrm3Nd6RIyRQ+veVY3CUd6OMZo+hI+7Y=.sha256",
        "size": 1716
      }
    ],
    "refs": {
      "refs/heads/master": "f348e07315bb8eee17f393d7bab13eceae05e86e"
    },
    "commits": [
      {
        "parents": [
          "d3d8743dbcb201f5642678e2984f6db7d0573f53"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "f348e07315bb8eee17f393d7bab13eceae05e86e"
      },
      {
        "parents": [
          "679fff31dc6391c08a6949c06cd63892fe9d7619"
        ],
        "title": "Move trait bounds to where they are needed, also fix some doc comments",
        "sha1": "d3d8743dbcb201f5642678e2984f6db7d0573f53"
      },
      {
        "parents": [
          "f2ce8c87f6fb52c8b49bc8d2d42f09ce9489098a"
        ],
        "title": "Cleanup",
        "sha1": "679fff31dc6391c08a6949c06cd63892fe9d7619"
      },
      {
        "parents": [
          "79db91fedb92c0ca1538fcbb8c41d6cbcafc05c9"
        ],
        "title": "Remove duplicate repo link from cargo.toml",
        "sha1": "f2ce8c87f6fb52c8b49bc8d2d42f09ce9489098a"
      },
      {
        "parents": [
          "993165738fd50d56aa4e934dfdca8a37584fd535"
        ],
        "title": "Add repo link to cargo.toml",
        "sha1": "79db91fedb92c0ca1538fcbb8c41d6cbcafc05c9"
      }
    ],
    "tags": [],
    "num_objects": 23,
    "object_ids": [
      "b6fe3abfa0edd2987084980656c2718ee582ec31",
      "7ce222c68af71705d1cdb67006ec1f2ae6569ae5",
      "75fb4f7db6fe6b95691a442efd637a9516c9bf89",
      "3a56b86031a09bd9553eebd3fd5e3b058fe5afae",
      "282b62beeffda8b4f99eb612276ed4a4c543f107",
      "7b8b0fec930045bb4b2c926817e89ce346f47eff",
      "23366b545072b6fb9ccc6722092fc2485275ede4",
      "6aad78905e7f7283b5fd4f5b00bd540dc5a9cdb7",
      "c9a73b6d420e31dbea7a9747a5576a9e11f8bd89",
      "a35e350aa427ec4311cbe53597f41baa918ec985",
      "344246881ae03b1280ce2dd3f06837a7874607d1",
      "9d744ff0a7dc645918bac344004cd634c5f26244",
      "ee9b95e5d7025161fff8778b33d60c37ef0b689d",
      "13845506d125070833eb3d8f62a7f7953c827101",
      "0849fca712a3cf45dd04f0c3eb6345feb3661658",
      "2e54e83931a79ef95482a4a62fa7eae26849bc4a",
      "3efc157158e8b2881049807871fcced0a8a81e7a",
      "929b90d8dbe279e38d9ab2384cb746df7a24f6e5"
    ]
  },
  "signature": "vywdFMUwX+m+8RuNp3aD1ZSw6SR9l2d4Nxw4FKXYp6KBB9bFSm3lSKQj0Ji58KuBJLo5pZHKYcOsUqgi9OAHCw==.sig.ed25519"
}

{
  "previous": "%ku4+59/HuWxzbp7GO5DQl1DeQpxsaltT1x53/nFYp+I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 401,
  "timestamp": 1512148966315,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%t6uqk6pV4p+wfSCFZpCB7XbUe2AhXPifHnxwq6hLxDI=.sha256",
    "branch": "%nvy8qI/uJZkRk2gqUT9rURQEfVCO9qhAvtX1hNicB/E=.sha256",
    "channel": "ssbc-grants",
    "recps": null,
    "text": "Pings to the remaining grants from last month:\n\n- [@gb](@ya/sq19NPxRza5xtoqi9BilwLZ7HgQjG3QpcTRnGgWs=.ed25519) - [couch sailing](%OS0bspvwFvQWbBVVXNx7p7alCGVEN06KmzEsExYK49A=.sha256)\n- [@dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) and [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519) - [benchmarking CI](%j4opufqPRxHoi2v/3mFp03XGQcyLKxByv0CPu+6x+8s=.sha256)\n- [@vtduncan](@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519) - [protocol documentation](%Wizpo7cm8VU66aomoNpfRU+qXBNcpot2IAW7Je62bRw=.sha256)\n- [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) - [scuttlebutt.nz revamp](%S4UddT5cu7QiqCeL6tw823gY1K4R0ohPyaIJThj4i6o=.sha256)\n- [@olizilla](@8eknhbALZv4xn31LfIWJ4iBoR/shQFkqVENbprVIRYM=.ed25519) - [parental leave](%nFjYiv0/DEMkc06z71rHeW/+iA43A4yPT8oVB3WW5o8=.sha256) for [@mixmix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519)\n\nHope I didn't miss any.\n",
    "mentions": [
      {
        "link": "@ya/sq19NPxRza5xtoqi9BilwLZ7HgQjG3QpcTRnGgWs=.ed25519",
        "name": "gb"
      },
      {
        "link": "%OS0bspvwFvQWbBVVXNx7p7alCGVEN06KmzEsExYK49A=.sha256",
        "name": "couch sailing"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "dominic"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "%j4opufqPRxHoi2v/3mFp03XGQcyLKxByv0CPu+6x+8s=.sha256",
        "name": "benchmarking CI"
      },
      {
        "link": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519",
        "name": "vtduncan"
      },
      {
        "link": "%Wizpo7cm8VU66aomoNpfRU+qXBNcpot2IAW7Je62bRw=.sha256",
        "name": "protocol documentation"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "%S4UddT5cu7QiqCeL6tw823gY1K4R0ohPyaIJThj4i6o=.sha256",
        "name": "scuttlebutt.nz revamp"
      },
      {
        "link": "@8eknhbALZv4xn31LfIWJ4iBoR/shQFkqVENbprVIRYM=.ed25519",
        "name": "olizilla"
      },
      {
        "link": "%nFjYiv0/DEMkc06z71rHeW/+iA43A4yPT8oVB3WW5o8=.sha256",
        "name": "parental leave"
      },
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mixmix"
      }
    ]
  },
  "signature": "RQ1gzFVQK1tMyQCXDYvaOcYdVuguHYUpFSKclOeFuZ+KO6cD5c2x27XZvPsIbWe0PF0AoWBev02ePYwRVqfTDg==.sig.ed25519"
}

{
  "previous": "%lfXR54zKNUQ08MO2QiB7fHRqOvPLI/kaCuOkS+QE+lU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 402,
  "timestamp": 1512299804432,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%t6uqk6pV4p+wfSCFZpCB7XbUe2AhXPifHnxwq6hLxDI=.sha256",
    "branch": [
      "%RWileSfpPDbz+5RiMUpPRGQ1SfQF6iuj88K9XDkxsyk=.sha256",
      "%VBNlpFQ26IvQ1Ek7pAc8MZYyP1WvNFQtPPaJqOeqGGI=.sha256",
      "%mSoKZiCFBqw6WrzJMPLnSan8IsCy6BFc4Qz5bT6OsYg=.sha256"
    ],
    "channel": "ssbc-grants",
    "recps": null,
    "text": "Unsurprisingly, I'm in favor of covering the non-flashy, low-level proposals early: Protocol documentation, benchmarks (is that grant active, [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)?) and my own proposal. These don't have the immediately visible effects of new apps (and might also not be as fun/rewarding to work on), but I believe they will be crucial in the long term. Beaker support also falls into this category: Its not directly doing anything by itself, but it enables others to build awesome things.\n\nOf these proposals, documentation is the most important to me. Like Piet, I spent some time working through Dominic's code, trying to understand the modules. Across the scuttleverse, you can find decent high-level overviews of the protocol stack, but for the technical details, you still need to run your brain's javascript interpreter. Since we are all aiming for mainstream adoption of ssb, that's unacceptable.\n\nI also plan to write language-agnostic test suites as further protocol docs are written, just as with [secret-handshake](https://github.com/AljoschaMeyer/shs1-testsuite), independent of my own grant proposal. That way, we get early feedback for the docs, and these test suites really help with implementing the protocols (or at least the shs suite really helped with my rust implementation).\n\nAnd just for completeness (I know I repeat myself), protocol docs empower more people to discuss and improve ssb.\n\nFrom the remaining proposals, I like the loomio one. Not necessarily because I think that's the app we need right now, but because it would be a great showcase of the things that can be built on ssb, and how the inherent properties of the protocol can be turned into advantages a centralized system can not match.\n\n- - -\n\n**TLDR**: My preferences, starting from the most important:\n\n1. Protocol documentation\n2.  ...\n3. Seriously, the protocol docs are by far the most important proposal to me\n4. ...\n5. Rust implementation\n6. Benchmarks\n7. Beaker integration\n8. Loomio",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "gjufvWJhUUkCWjoFkpqGJElFSMo/y1FvH3u4MPpz67XQmpyBYrgkkT+D2XtNNd7+zXA8Xc4Gs0NAB8usF8PhDA==.sig.ed25519"
}

{
  "previous": "%8GElGNCsZF2LokAWd0S6aoJp+K7q/TQaPdOMsjul66c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 403,
  "timestamp": 1512300194136,
  "hash": "sha256",
  "content": "i+VjBJYwEey1pTwk5rX44u7sI90+plrS/qNJuQYvHVrOoAnEB5zu7eWNqJwK+9AT54gdXxAiPRvuKibuy72SyUPdB0kD9sVJ8iN5LHOFO+e7uy2ky3u525yPmAnRdWQkzWOaeuLdhiDn/LE77k+54pwmliytpu3twGC2M56zzzxcXYXiSNksm64s+upHq4BcbS+osnROjlxSfR+y371s/XVhXT6fKCvc/fyonvK0X6DSS1W+XjdmNcDvjoTAAq4Z4eslXjemk+cfmeJMoStCH1ToM5g1IG31NksUasMhOPCNRZrwoi8IfnIh1zrN+leZLDX3h73y80vDKOQsKAdM66PgmUWZ4hQf12M6S6Fr5qvOyikWl0ySrVDYtpRatIEcDrShgFOcJnkQHk9BoZY8YuZXyqdcCtQtPYaYv7ZcGKU7YAepPnWdbWY24vrEB2t7nUfoAh6yW+XFcBt6Ws3jLCywo3Vsqhv7FZTrY6vtqU3omA6rpixnmUZZMiE4KnQacOTOs9EPxFdXktWAlCyKe42omkA/HvDEalE03Wb1G/Jl18NgIJF9pyCXGOwq4Czpww5rtncKMa8yxsM+IhdqCQ0NQ/nOs5HRHj/cRcuDBmmh/Q/Kicw9bbD1jhhI04i0ha4uK6leg+gRJ35Ph4UtB9rRazrAYHNwrytKY9ru8mvMBXYfGjpBaIbPIuE194CCGZhU9xKa/PcikW+G+kt4F/MKvncD7iMtzQdifR0pR6yEBQ5Irj8ZWzlHz+6D3M1acKvUA/bvmxDa0jAN4OnS6BKR+bt5/S2rUPdDHbqe3DJT+63pGKTHU1/d7CshPyYFVlFysBceB9U0sWlfwArQq9n7w5gsOt7bzfXU6ITNQK3cikOPXzDP4fVSWgkF4X84FinEgCpvga8bD/Edsaondop8JWf0W4JM9MLPnYeZ1TjiJYp8Bus12wC5frIjTsgd+XDMu6xVJyhRrUQ31QUFF3nFRxO/9gQDiv5ciCQcFBZcaY3+k8MzCBFPrc2kVEE3ldQaA8KpLDAxxUAaBobhrQSoMdN3ay3WUHPbcW6skeWjxE1Bhyq6OLwUZv5yXrDGYDb5AVokC0uvi0vzPlKtgTBQyGLlfsRhMxxwK9d9xM6QOjdR8JeDWgEqjT0VdG8EIyddhoWk6czksm5QR1XSnj2Z3VmHjQ+++pSpHm2C0U1YjGlHc6ixPoBvJPJqqqHiTgkM+HU=.box",
  "signature": "sMX+8yFtO+IUHn0l8ZpiqUjbnwtQ3bsXohfngfeCUjQQyXyJ0NsBG8k5PDDMMC3M5lIIKXMV8ZlxZZ8qUGIZAg==.sig.ed25519"
}

{
  "previous": "%oQkOfpMdvKYbEhPEKt52AzDtyD2OdE0LnSvH04w07K8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 404,
  "timestamp": 1512653715495,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc-grants",
    "vote": {
      "link": "%WCCgqU7CofYuIZ5hD2uKXT71AM8ymYClWYGPGNNEFyg=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "YYyLOHx4BBZhv4VdAxviJHt4f5tcsYn3Wez5TtLIiZFOtgJXOwdG6wo+FIdy32WrVLzXYJqS36o/exzUN2JzBQ==.sig.ed25519"
}

{
  "previous": "%lAnnV406l1FdGlVRaaOmwy99gAq3N35fNjID5bO9YA8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 405,
  "timestamp": 1512753742406,
  "hash": "sha256",
  "content": "q2ZCJdNIYWHbtmANr4ZV0WSW3eCDYCQKwgg+Xkyi3jh37aWSS8fIVdFyUD9ZfB5s860BLJM2g2KomOfw5rpyHysA7Q9nUMR7rCgD6JXyWLQIJAgVUHgJNnfbpIbkeH51PW/P7ngMwx10HuKGuQXH+tbSfYYBvzensoLynLj8oKjySNfYtkonbOj7upg+FnXTQWd4GF45uENU8oyLvWwbZBlfRklpKKA/d7qMQ8Nnu0zif7bUvs/104S+EcE+dQHdXt7+rBbnnBQvNzuULrVtHIpN4to3ILoRSvE88XRaFul9WUdQfsSj3J80Zfc017EyynXC6yo7LUXiUoFua25eUI0Z3XAGULHtpNI+fGkNULWi6bLIi0FymN8YIjwkbFYVZM/bDsZNGS7qBoNdxP+8RygVVm+NT+ykokgPsw98+zQHZXzPZj7RqGOA5VzZNDAzbDWezBi3Fp4jIJO5aNrl+Lx+pcoMHF2Lf+YuJDt2d676orJ/32DwP624DNdhx19q3/qS5VPmlLo35P4mID5KTQBqiT5LfX2K+v5W8rcXgxs5hJjJqSDP9HdCgeyLQx6pg1l6WM+O70OeVXkJrr9tkrtrmYSjEj5PaQyfPAxmUCkx+wYjGTBh6vG2PiNPf7Dg8LB9SlKVTC+VwTt1WaNa++ziFYuG3q4aKiuC4IiQVuRaidP9pLcz9OwFshEl/CjWaFApnyU3zD+V5M/00dzV45hyDhw5m4bS+9NRS8pHO/iNSg7OBYlMxPr8bNCC/Fy8ELx5sJ7czCTfH/k6CvynHJORZ3/L5/cLzcqAVV8I7hhozU0A0LLIxlB9unfk+aT1AqgT9lgCJkOaJpzkLcC/u7MHoBQJXXxH52lO1/6dFg4ITs36dyNdfLfV0OND+LAzlOzNFjTbXJMuIcxnJeYrXAD32hyAKUhDvtOjUUs7H5yzSo6Fh/HsBQCzuSLSdrAeQ5CmfzFfZlSCLVJqsEOY1ZAetHwd7E20zIJtDecWYoOl9rjDdfotCV7dfMzazdLDctRHnAYdhbNGbxGXCTFFHgmyGD9c26w78h7GyicUu36odi6JV5y8UHe7pxw1HOZ2XyQW5xvybUWgkqgGlmxd4pTJDD2UzXkbB4Hs2r26jFCpqviqO6IaG+7EYJ2qmQoaXWCSt20ZnefHwJO+QY50eMb2GHhVnt0/noA+P5FOWD4uOVQ34Tsc8VgJaZrqYKQu4eKyaep5J2dGs0n2kchoGfFGVRVeLAAtkAR4P8XeN1PqdSShLxK289dUpFh5Jfkn0vtp0f2NaMYypmblzOOvzT396blirhcLBAg=.box",
  "signature": "3MQlog1ts7tiOrk0MidWoVUoKWxY7yAa/X1qj7t3FGfPoz30wInkFuaj+ocxWnbZnJP/OzJYvw/nVOmXuVDcDQ==.sig.ed25519"
}

{
  "previous": "%jTk0vtP6QNyIE9lSdGz6UfKglA5NHVHYJqqMJ89cXOs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 406,
  "timestamp": 1512942226455,
  "hash": "sha256",
  "content": {
    "type": "post",
    "text": "Does [packet-stream](https://github.com/ssbc/packet-stream) allow zero-length packets? Does [packet-stream-codec](https://github.com/dominictarr/packet-stream-codec) support them? I hope the answer to both of these is no. [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "ZGTMsuhC16MhNwEXv3NFCpjKiI/BUBcQ+S3QdKz+Qayz7ErGsZGCifWiJvlbkJ5pznSXiD8TklNHpUJeT+w2AA==.sig.ed25519"
}

{
  "previous": "%+GL+j88iWJma+BRkESMTzju7DkuCrmijiCIRHLWdWOQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 407,
  "timestamp": 1512947271206,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%+GL+j88iWJma+BRkESMTzju7DkuCrmijiCIRHLWdWOQ=.sha256",
    "branch": "%1ddXWzXa+lotUVGyHBJ7nktD1MxRlbqAys+3gH48jmA=.sha256",
    "channel": null,
    "recps": null,
    "text": "I remembered that the request id is set to zero by packet-stream for messages, but forgot that messages are not supported by the codec. With packet-stream-codec, a zero-length message would have the same encoding as an end-of-packet-stream header.\n\nBut since messages are not part of packet-stream anymore (?), that can't actually become an issue. CC [@vtduncan](@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519).\n\nShould a packet-stream-codec implementation reject all headers with a req id of 0?",
    "mentions": [
      {
        "link": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519",
        "name": "vtduncan"
      }
    ]
  },
  "signature": "o+YVyWxzZ+8uYhjEMcOs95svl69Ch6WVl4c2EVWomurArT3kuKidmB7u7ZJTofS2nF5172wdov1P3JZaGQ/LDA==.sig.ed25519"
}

{
  "previous": "%FC2l5zWq71+xhFb2tP/+6zzCEDzGoNcI/HVmHv2j1x0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 408,
  "timestamp": 1512983748403,
  "hash": "sha256",
  "content": "/QDDj/rA3Qg3OdHEFppD5rHtfIoeJzrJtLQksLvocXeYuvWZqvPE9GXQA/p9gU7E4N0fK7IArRq76Q2O4G1L9lx0QYf6VxP2WkIiIydvzYOFj53yVUQQSSL0l66Ynej06w/hJRoFEWr1eDHGo6/NisCO6mIez3q2wypoK8U8GWlL1OPsv+31EHBRfoomMnli74Z3Kiiqmb+8yqk5o+9VIExxeWkhL5J2B5yALd9cHfPu3duMZ0YRMaEJxogUa8lY5me7/yIGG9yNY/X4UpdllBI7GjEYd7arVhKgW3JznDNWA3jydGWHHXnr98N3UbhROR/pT4h7vPfWZsh5ql5vmvJjngw04tFY02j7HCT1+Xkpo2OUwOhVox8GLblFarSW7I6CEIQMCfGYvARa1EVbxpVrIaBFdv62SBYZjSNMJd/tbrJa3W2GdQpJzc1aMJ0Gyy1TmHPKiyH5B8SVLJZVVAtUAQE2GqieRbtb1uTGSEMw8j6qp2fUpMBHwmxuDcyfnb4vb5NDDI4ATqKBjtdkVt2N/x7xILbysxqDUS64vBpgcumWYBC3NM3uKkQwwnSUcX+E3f460l8qqmF8yfgZUYV5VWjrM+G5Jn37rKG1thKuAVx8oh0BWifiBaI+r4VvWH5obRVzKHg0rkOwW/DYDbTs9iEClKFLD7rNstLRC6ecqjq2N96SfHj/svlVOTgiEJz5R+QhAvG7E31u2pix7WJNtb+/at1imQg3TBQWgDV89vAMvVaV52KjzAbIDfHN509zopn63S5UDkcx3VJId4c/MHxqcjIXCpZqmDlNlnYlgkJiMd1H3O+taQ/wwelIlUkf3CgpW7vr50iIf3Z7O31VBCbPw4BOZBTqVksEGub/woZvY/fC7HA4WbGiqqruDA66Ruy/0RrHzIXtfycEjhU1XlpLYLXG1Gml06eRd/fb/bPUejzT1VYloFFBQ8/rC/rW60xwaO2jZrDjfjwaWeZf+hQdeL+2V5H7GKGXLY8kR1BxBwIwW5iVP1sQIOMAFeXDEkd7se6/IY39CoGad3/zmpfWEo7UCGQraP9MRAsK+/i3M7Y/nT3zIa/SMkWZCf4Tiir9/9kvtqUM1+0/HI5Z6D+EKD989Zg=.box",
  "signature": "5KTcfWmdoEy5Gi+RxoH/KMOiK9dwgN4dzlB8GBmgkTo9UazEfvl1u64SjTLvTOTiGvjfmmJsfTxEYJync+KCCA==.sig.ed25519"
}

{
  "previous": "%2KletLgmThTqSKG/XgUCk7QmAC2UwHJzQ3NdN/uoVVY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 409,
  "timestamp": 1513033231575,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%/VBlyaxgWFxQluvnrcATslGoGJW3OuJuUh1mHY4YXp8=.sha256",
    "branch": "%3TOWhHObMOXCCfVUe/AWDDj9+FQG/GBAPjb9yB/TXk4=.sha256",
    "channel": null,
    "recps": null,
    "text": "Once the rust client library is ready, I plan to experiment with writing a [termion](https://github.com/Ticki/termion)-based frontend. Like blessed, but without the javascript.\n\nI might want to steal the name though =P",
    "mentions": []
  },
  "signature": "qlPSs+sknsfm8u4Xvc2ESP/MVJUllLQvw/sb7TtjLpJGEzZKEXdnqktWwdy1S2D9dzJjBX2+dofYCNHLa5NBBw==.sig.ed25519"
}

{
  "previous": "%M3ykIKOLjS3C3IlH66xKAgjfzxSdvEHGAoBqCnLGZ6g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 410,
  "timestamp": 1513033273827,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%/VBlyaxgWFxQluvnrcATslGoGJW3OuJuUh1mHY4YXp8=.sha256",
    "branch": "%M3ykIKOLjS3C3IlH66xKAgjfzxSdvEHGAoBqCnLGZ6g=.sha256",
    "channel": null,
    "recps": null,
    "text": "Also CC [@ev](@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519) who did some work on a blessed client if I remember correctly.",
    "mentions": [
      {
        "link": "@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519",
        "name": "ev"
      }
    ]
  },
  "signature": "ZVmNwyYa07QXCxQ8+Ep+Tu3veNjv1RrqX0YyIZE3fPui9d9Tq/NER+LHGF8LAy+R8hj5dhi+F2h9SC5THzACDw==.sig.ed25519"
}

{
  "previous": "%rW8TaqNe4Bj4lyJSPpAlpqLz3sEotgxEMPAI4k7XxAk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 411,
  "timestamp": 1513112186250,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-implementations",
    "text": "# Rust Client Library Dev Diary\n\n[grant proposal](%pYNveoqk1n1YobhscETnI/EE8aZd0itL0bnPqXIASzw=.sha256)\n\nI'm reimplementing [ssb-client](https://github.com/ssbc/ssb-client) in rust. Ssb-client is basically a nice API for communicating with a scuttlebutt server (i.e. [sbot](https://github.com/ssbc/scuttlebot)) over some data stream (usually localhost).\n\nThe first step in reimplementing this are the network protocols. A connection is iniated via [secret-handshake](https://github.com/AljoschaMeyer/secret-handshake-rs) and encrypted via [box-stream](https://github.com/AljoschaMeyer/box-stream-rs), these are already implemented in rust. The next layer of the protocol stack is [packet-stream](https://github.com/ssbc/packet-stream) and its binary codec [packet-stream-codec](https://github.com/dominictarr/packet-stream-codec).\n\n### Asynchronous Rust\nNearly all functions of the ssb-client module are asynchronous, since data has to be sent over the network. For asynchronous programming in rust, I'm using the traits of the (defacto standard) [tokio framework](https://tokio.rs/docs/getting-started/futures/). Secret-handshake-rs and box-stream-rs work on [AsyncReads](https://docs.rs/tokio-io/0.1.2/tokio_io/trait.AsyncRead.html) and [AsyncWrites](https://docs.rs/tokio-io/0.1.2/tokio_io/trait.AsyncWrite.html), packet-stream-rs will bridge the gap to the more convenient [Sink](https://docs.rs/futures/0.1.17/futures/sink/trait.Sink.html) and [Stream](https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html) traits.\n",
    "mentions": [
      {
        "link": "%pYNveoqk1n1YobhscETnI/EE8aZd0itL0bnPqXIASzw=.sha256",
        "name": "grant proposal"
      }
    ]
  },
  "signature": "UqJrmXHSPN8LAbtRWpyo7YVejM9DMIecHFe0+7/7N/69osRQOGDci/qOXL+ixD2YDf4ul3ZWmCFzTUDTxG4wCQ==.sig.ed25519"
}

{
  "previous": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 412,
  "timestamp": 1513112904567,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "channel": "ssb-implementations",
    "recps": null,
    "text": "### 11/12/2017\nImplemented packet-stream-codec. The API provides futures to read/write packets over an AsyncRead/AsyncWrite.\n\nhttps://github.com/AljoschaMeyer/packet-stream-rs/blob/master/src/codec.rs\n\nNext up: Implement a multi-producer Sink adapter, so that multiple different values can write to the same Sink. This is a pretty #rust specific thing without corresponding concepts in js. The compiler wants to make sure that only one mutable reference to a Sink exists, but you need a mutable reference to write to the sink. For the multiplexing part of packet-stream, I'll need expose multiple sinks to the API consumer, each of which should write to the same underlying Sink. That will require some messing around with [interior mutability](https://doc.rust-lang.org/std/cell/index.html) and lifetimes. Also, since there is no implicit event loop, there will need to be an explicit state machine maintaining a queue of [tasks](https://tokio.rs/docs/going-deeper-futures/futures-model/#tasks) so that (non)blocking of the exposed sinks works correctly. This is going to be fun =)",
    "mentions": [
      {
        "link": "#rust"
      }
    ]
  },
  "signature": "QxSYOaWkSWpb7OwYspc6RCwvyrBS6VqnqbADEMUZV6PAdfEx7lsAIY2kFDHw+8LGefaXKDuGt9wAhdBcRZBKCQ==.sig.ed25519"
}

{
  "previous": "%QAb4nE/W1AsYKSUhvVWGiAYft3tPGAO7BmfwX3eYTRM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 413,
  "timestamp": 1513118650011,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "multi-producer-sink"
  },
  "signature": "8c3flUYUgIdAl3yt0B2nyeE+sknaSYBvK+F17/4hrju284jZpfheKjrlTh0nhxUDagJeqH4XxgbHk7U7fqTRAw==.sig.ed25519"
}

{
  "previous": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 414,
  "timestamp": 1513118660799,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [
      "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256"
    ],
    "packs": [
      {
        "link": "&AIHA5brRy61adouY0+JyrmtKwpojB9nqpXTYq7lhXkQ=.sha256",
        "size": 13124
      }
    ],
    "indexes": [
      {
        "link": "&uKzbi6sWoUQd2BugnQDEH6QSGvMGzAbKlcjCfx1/hRw=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "9b06bc989502bf58778004119fd978951b0ec8f0"
    },
    "commits": [
      {
        "parents": [],
        "title": "Initial commit",
        "sha1": "9b06bc989502bf58778004119fd978951b0ec8f0"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "342da8a562cc2072290bfcafb4101ef40fdefd92",
      "4308d822046df995d72605f3497d02ae5ae307d8",
      "6a528a04680da938528347dc71323149e379de23",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "a980c3bda0954e149cee6bff749005f4523325f9",
      "948bdfc98bfac74463406f0e9fe78706987fa01b",
      "db48dc16ec77a990c23cbe0bdf1c877d7e7d73d0"
    ]
  },
  "signature": "PrQAgowwTXO7ECT45GJdLCViViVEt68ONsSUH4zE9jRPJAMfRF6DSPkAmS7Wul/vPstonuw0o9BD5wfwTYD5BA==.sig.ed25519"
}

{
  "previous": "%poSmxg6nCcqgdziJgxtg4vbBR3NNhI2iI+fO6ym7oF0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 415,
  "timestamp": 1513119385510,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%2kFF7xRw32gdkH+v5vNb9te5Z7ppZ0pXCOTkMqnFgcU=.sha256",
    "channel": "ssb-implementations",
    "recps": null,
    "text": "I'm trying to stay clear of the high-level tokio concepts though. Tokio_proto is too opinionated: To fit into its framework of a multiplexing protocol for example, you have to use u64 as request ids. But packet-stream uses i32. I might implement [tokio_service::Service](https://docs.rs/tokio-service/0.1.0/tokio_service/trait.Service.html) for packet-stream's requests, but there doesn't seem to be a real benefit in doing so.\n\nSo it's really just the `futures` and `tokio_io` crates. These seem to be the minimum common denominator of async rust right now.",
    "mentions": []
  },
  "signature": "L/KOqLsIo6Xo849T2S/b56omqgo8YZqjI6ruJ14gD/oO51QjQnMJyWqGmjdSXqqcoW3af7GWWcwzlCjTiwwwAg==.sig.ed25519"
}

{
  "previous": "%mFKaCIEhnFZQyfWyJwPoBw/IZ7W1EIjZiquJc+OLZeY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 416,
  "timestamp": 1513169458129,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%poSmxg6nCcqgdziJgxtg4vbBR3NNhI2iI+fO6ym7oF0=.sha256"
    ],
    "packs": [
      {
        "link": "&v7YIrFO45LWz3aw3Tp/2Yb5Noxry15RxpsZupb60brk=.sha256",
        "size": 1295
      }
    ],
    "indexes": [
      {
        "link": "&IKxIhHCYAY93V1Xf3DX1294l0Ib4/iPsmv9rKbpGL5c=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "8dbeb8d2c053910980e498bffe55097ee09955f1"
    },
    "commits": [
      {
        "parents": [
          "9b06bc989502bf58778004119fd978951b0ec8f0"
        ],
        "title": "Implement SubSink",
        "sha1": "8dbeb8d2c053910980e498bffe55097ee09955f1"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "92d81c886f10ad769abf5ebbe154a8ce1c456aed",
      "a0b561bd24e1cd0ca39e76c326c73d49eb389815",
      "ed4305225d07c9bf76f762f63cd47015b28dd13b",
      "b559808f0ec52ddcc41d2158a2fefe563d00e96a"
    ]
  },
  "signature": "JO48weJaP7OB66PHeJ43ZG7TAfssIsflD/MqUVCC7BJE+/nds6PSEyV5kx0kbKpJQ5dlKyAlnUsRggX7Rr6MBA==.sig.ed25519"
}

{
  "previous": "%TJO00x71G0rl67SJHy5YifaQfyjWP6SGrkPqgctRKrk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 417,
  "timestamp": 1513260298298,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%V/lTKtG8JBp5JtXdy0Or0Mn2Lv75kj+NOQZs676W5ms=.sha256",
    "branch": "%OkZDzXBN7Zb0ideRVzeR4jsQGuKefIdEF1m2ak3ee78=.sha256",
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> I want layers to plugins. As suggested here I think it's important to have lower level libraries which validate, parse, and publish threads / documents.\n\nAs usual, I want to call out javascript-centric stuff like this. Libraries are nice, but even more fundamental is **documentation for message schemes**.",
    "mentions": []
  },
  "signature": "Y0ZFuBoPnk5wf8WNGE6Y19J2dnc9faNBLVUboSJDyM2Uti7P1qO5AtiBdeGhyoBQMjy4f7UVOxnDGvuD+S0fCQ==.sig.ed25519"
}

{
  "previous": "%93iRBy2VZy7X4SnCB3whbmNsbDeSSIR+glbNntR4oIs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 418,
  "timestamp": 1513263119738,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%TJO00x71G0rl67SJHy5YifaQfyjWP6SGrkPqgctRKrk=.sha256"
    ],
    "packs": [
      {
        "link": "&VT0oyQ5e5c+cLRcPsHCIxWVja2sssBayPbtpt3LGrNY=.sha256",
        "size": 2527
      }
    ],
    "indexes": [
      {
        "link": "&2fSZEZo9fLKU/IYqIHCuXQvpoc/k0QWrQl7oU7fejGI=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "d8b7ecb300be0d842e94917a001bff1bc716433f"
    },
    "commits": [
      {
        "parents": [
          "8dbeb8d2c053910980e498bffe55097ee09955f1"
        ],
        "title": "Implement MainSink",
        "sha1": "d8b7ecb300be0d842e94917a001bff1bc716433f"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "9fe1999abebb92a00e99a4a7e98d64277ea42721",
      "2a914f287cbdf1fe764ebfac8c970ad05c9bed43",
      "30b88a0866e16f1409bce365519ac35f4c70bb56"
    ]
  },
  "signature": "hQKNBN8fRfE+Y7IubRLGkbFZddTwM1PpbC93HkzqCAD0iDueTg3r5S2pLmyg+ne3/dxntYP8A62B+1F+bTPpBA==.sig.ed25519"
}

{
  "previous": "%YJJeuTtUP1sEeijmy7bAzW3M+gbsPBvYRMhjmEhjZ9Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 419,
  "timestamp": 1513263807840,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%QAb4nE/W1AsYKSUhvVWGiAYft3tPGAO7BmfwX3eYTRM=.sha256",
    "channel": "ssb-implementations",
    "recps": null,
    "text": "> This is a pretty rust specific thing without corresponding concepts in js.\n\nAnd here we go:\n\n```rust\n// Due to multiple mutable references, we can not simply match on\n// `self.send_tasks.get(0)`, so we do a little dance to appease\n// compiler.\nlet mut is_empty;\nlet mut front_id;\n{\n   let front = self.send_tasks.get(0);\n   is_empty = front.is_none();\n   front_id = front.map_or(0, |pair| pair.1);\n}\n```\n\nJust finished a first draft of the [multi-producer-sink](https://github.com/AljoschaMeyer/multi-producer-sink) module, which will handle the tricky ownership/mutability stuff for the write-halves of packet-stream substreams. I'll still need to write tests though, and for that I'll need to shave a (tiny) yak: Implement a Sink adapter that allows to test blocking behaviour and inserting arbitrary errors, and make it usable with [quickcheck](https://crates.io/crates/quickcheck).\n\nFor the AsyncRead/AsyncWrite stuff I relied heavily on the excellent [partial-io](https://crates.io/crates/partial-io) crate. It allows you to wrap Read/Write implementation and control how many bytes they read/write or what kind of errors they throw. It works with quickcheck, so that it will randomly generate Interrupted or WouldBlock errors, which need to be handled by the Futures I wrote. I'd then include a test that would e.g. perform a few thousand handshakes with random non-fatal errors thrown in. I highly recommend this crate to anyone unfortunate enough to deal with AsyncReads or AsyncWrites directly.",
    "mentions": []
  },
  "signature": "VU7TJWUJBTi88w555RNPS7N38Yk0bVGAjSGFY9BoDohKQHqwlPM+nBE6Dpm8cC2z7Hh2KZO337459f0t6xsSCA==.sig.ed25519"
}

{
  "previous": "%kwZhSAu8HWkDc9mfTzk0/iDg21SXnPdVdLVE+sWN69M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 420,
  "timestamp": 1513264244863,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "atm-async-utils"
  },
  "signature": "enUqYPoaZlQXKYs91xN/AsyMrBa4NYbqmrMLBC8L95zl/ZH79c+sr0rEbrsXGkG4YOPT7CRWyg+Cr0IOQsqTDw==.sig.ed25519"
}

{
  "previous": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 421,
  "timestamp": 1513264248446,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [
      "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256"
    ],
    "packs": [
      {
        "link": "&+PNKPQ0MVuGZIXVPs8q+DDMzycRHCkAeW7TBJ/sv+QA=.sha256",
        "size": 12893
      }
    ],
    "indexes": [
      {
        "link": "&IcXc6EZtbdTxYklFv9Bg/ZJjrqCUXoKyAmilpDHt7bg=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "667e2e573ddae21637566dd5039bf67f9654d843"
    },
    "commits": [
      {
        "parents": [],
        "title": "Initial commit",
        "sha1": "667e2e573ddae21637566dd5039bf67f9654d843"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "2d8393f89b9e1878eda008a441df3f10d460b59e",
      "4308d822046df995d72605f3497d02ae5ae307d8",
      "13984313b5911c4d66eeef34ef9682abc83851f7",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "8d578cd24e377e3b790f33914c54e5d184338c4e",
      "734ad5c101b3030eafb4d9be36fc260c9bea22c1",
      "cdfbe1aa56211bae14441b017b79cfa5fa0b0986"
    ]
  },
  "signature": "ymaEiPV/UMZLvFv5uE3JZNDiGOZeLHTO+7Af+yzB0rR+y5eLzRWwzEkorAT4PgUYdt137t4pfOYBb4+5Ae89CA==.sig.ed25519"
}

{
  "previous": "%2WEvJeExP08kIX+6WS/EX8/dTuQLh2KZS0sCR70bswc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 422,
  "timestamp": 1513267711204,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%2WEvJeExP08kIX+6WS/EX8/dTuQLh2KZS0sCR70bswc=.sha256"
    ],
    "packs": [
      {
        "link": "&AQQP5DGxSYIy3ceExw7BOcrQE2/8VhdufyPWqSepWHo=.sha256",
        "size": 1873
      }
    ],
    "indexes": [
      {
        "link": "&aOztOdRSbi5W8zUfzYTgsEF2JWhsACKlciHrQEdX3j0=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "eb5e5aa492fde6ce3bcb551713d1babb087d5d69"
    },
    "commits": [
      {
        "parents": [
          "667e2e573ddae21637566dd5039bf67f9654d843"
        ],
        "title": "Implement TestSink",
        "sha1": "eb5e5aa492fde6ce3bcb551713d1babb087d5d69"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "5f65c8d92a50db3f0c2fe60b88a229bfcfdc2733",
      "5823fd6cbb2d8a6fcf9a171b7f8d3f5028e0b506",
      "c6e5751f92a35537a09d460022ffadbec21ba803",
      "82c5f06ac7c0db23c4c4860b762862e4cfef3974",
      "018ce051c36362b831849b6f4c59554bd633ede1"
    ]
  },
  "signature": "0+mhqrHG9rWFOu9DOJ8zM3Vge/EP/JC74Zh19y37odTl46DecZifwmflP85wRemcurMpAbWa8HRtgAOfcm4UCA==.sig.ed25519"
}

{
  "previous": "%07fK8ZNJUS78AoqWm+pQmLIWxROidqTK73wuFb7M+ls=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 423,
  "timestamp": 1513267734871,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "solarpunk",
    "vote": {
      "link": "%qEx0Y4d6kFHHeggGa2WnlutjHCAVGm4WZB3LapFavS4=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "n9WDoH01wbyiTGRnBPb0kNXvCH29USbPzY7alesKX4WSGW3y1Z0M41sIjpGVUvo0wjkUV5QnYvAmKz36ZImVAQ==.sig.ed25519"
}

{
  "previous": "%+i8Vv3kuSpdicyQjT04ix3PxYqxaCayOAhOgE8c20As=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 424,
  "timestamp": 1513269015428,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%07fK8ZNJUS78AoqWm+pQmLIWxROidqTK73wuFb7M+ls=.sha256"
    ],
    "packs": [
      {
        "link": "&BckU3cP+EjZ0oIjsp4cfznmFUzSGoTV5et610Wz6650=.sha256",
        "size": 2074
      }
    ],
    "indexes": [
      {
        "link": "&a2RJ14O+l3JAuz9xBJXy25P8KPllzqmLjSVPTiJ/JNY=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "cfabc2bd000b59fb215b26b137fb0e2bc5a7be16"
    },
    "commits": [
      {
        "parents": [
          "eb5e5aa492fde6ce3bcb551713d1babb087d5d69"
        ],
        "title": "Support quickcheck",
        "sha1": "cfabc2bd000b59fb215b26b137fb0e2bc5a7be16"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "243199321b2d61915ac724d925ad5beb6c7192b4",
      "48a4d09e86f7714a85d1ab799829ba56ab368ef3",
      "51beeda83d801eff098a24601cf08f4d85ab4019",
      "0efa2f8e7d9b6a22e298d4a60524428fa8005a39",
      "c0fede8697cc3aa35c20b544597526cdf7449226"
    ]
  },
  "signature": "1A8Sl9C/BLn9jYqFzYatzecrwR+h4FPnwExvZglMN5EvzyWyWPCI72/arF9eYt8yQn7gtdWaIJ4TXU8zjvqvDg==.sig.ed25519"
}

{
  "previous": "%b7dILwBDKP1WPQRUb+uZ4b/FjorGSb3atDHsl+3nYYo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 425,
  "timestamp": 1513271210207,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%kwZhSAu8HWkDc9mfTzk0/iDg21SXnPdVdLVE+sWN69M=.sha256",
    "channel": "ssb-implementations",
    "recps": null,
    "text": "This was quick: [atm-async-utils](https://github.com/AljoschaMeyer/atm-async-utils). I'll extend that crate with related functionality (test wrappers for Streams, maybe some sort of dummy sinks/streams, etc.).\n\nI probably won't find a lot of time (if any) for coding in the next few days. But then, I'll try to build the reverse thing to multi-producer-sinks, some sort of demultiplexing streams. I don't know yet whether it makes sense to implement that generically, or whether to just hardcode the packet-stream demux logic.\n\nAnd once that's done, I can hopefully tackle packet-stream itself, without having to fight with the compiler about ownership/mutability issues.",
    "mentions": []
  },
  "signature": "GDXAi1lJRfGoBPDg2PCdQVj8kBZ680pcfgE4jypQk9CdDnZ4yjaqXHF4RPHOeGUlvyBykOzIV73/+IQtwuqACA==.sig.ed25519"
}

{
  "previous": "%eHzjpW+l3VwQM3hUV01vYv+d6+mHREbCMOWBtUzpUbM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 426,
  "timestamp": 1513340377612,
  "hash": "sha256",
  "content": "2jkFVjpmKwHPnVM3uRCScgNny2te6hmUI6cUE5QjwoKqS0g2zpFD+yCFZUiqjOW9Csw4l6i+q35gJ2/Hoo24cLjvIOAc8DXkmUyr6Nv6Bf3EKKx8FzO4CtuwNmm39ujyClLq4pIQHZR6FpMkFUwXg290tQjJd83ECQJ7HpVSLY7Q+NMULok+29GepkFXFNNc4QgP3kPkuZ+z5ErtQLuct3fT2Jqu3zvZ/OEx3MiMcOhvp25kWgjCzPgVsn+0jjD59aECLTS3x3Oh/n6p216By+nbKkcJ5wZ+APCxLFuXyg/mRtn6I/LZuVYD5iTgnKRchXyqUBGSRqfJLz89zroIEdMVYugJ/REpEyVx2Id5q88l8+JgH3brZ6Orv3Upe5fgQNY0WyvR8Y2rqEYBzP70iRy/8cN5MWwSNof5ViXDymbdZOMP3jYpROdGfx2SFRw8wAOJ7LB2GMUcfRNkrUt4EzKJclMPyPNk5CqJeJMWGwdeu1iRZY4Rapga6LkAbCqjQ67Uc/nzwhWTMiDbERv6La2c/GLGv4REFu3641xYFpr7+J7slk6BS1WGMFPbYg9rHRIOlo+eeU37hDvZt/uClvzQ0bZxRksK+XHqvqSD4FV5xc34QNpOYSpxsRCAxctl/mV0sLJf0Ao0MPx9ZmLpEGez2+OUl3kx64wCixM2XLF91n5bzILhCtxKV86OZQkMxRImLtMwMCGI3SSv+7GSSbMY/mTX5nvUhpoTWCS4TBY1+jORipmWFxerjAFtzyDbpMrfqi0/oZsPdSCe70NP6+vNa2W940iOGShkz7jJAGapgbOjg5lR9EiXpfdIEB3TpbyLXEb1CFqHI9z8isR1MUG04iAkKp8OkVPH0pVvVwWHZL2pjdJvLihBthWrL6rA6ZgGMbzHqqDlDAaHsIoW6fLT5vsCf6l2tzWtZYUQUOk3R/KqNqdZR+UMEFBBNphvqkWSOMG8MgxmhTlyGdcLTli9eg4YL7heYDf5UiCUBqlSW4JW2dX0qBZcDfhsYYQ6R1+aDt/gaRO9r3HJyF46NURWqk81bfeCEXtcPyjFd2fq5As/8hwTW0OGEXV6Qq6DqyMcM/7Hps8S1w045QE4FrvxL7eaqVBPI0GXg6Ida06hXPEX7thEoK2yfFaPWyc9Jq2D6NLzpv3uSZbe3m99k6qlFlr3et+lV1ao7rDyRzU5OLWRsmvHdqGYYVtPiagE6Vu5KIZZ1V5S6LMcUmuDGWL8j5OkceL2PSUW4JCQrkPOSeMweVMwMed18h9Oz9LcvLvQvQ7Q2ptmYsNYFrvB8BmahExCVZuEp/uv5m2JMxWNziqXEh/lV6fzbMv+mewOWAQX+t3K59hQO8PFAWYevAWrgThCMXvHeB9wTlKnfT3kLzmp11kJs11LgdTVSNZH8W1S11UaWIRt6VEr2s21mTsWopmJb0+utnKgI+hlnz7o9unHACc0tPI4vyO9CkRA0mLC6K5ZwJ69R12eYXkHc/Zkqd0fhIPR1E8qGjbxgAKqINX78hBzEzTjfdrr0I797k3GrKQpjl3VzjknKgNujf2ghZn/CT69lHLZJJcvJE0GfnUOfxzQkM7wcZLF5WyRuBr2cfZYmUzeDgErZAQvuEbgtbZPkgmPvEfCUM0=.box",
  "signature": "JWCN4T3TGhvNUjAyzEPuq6mm5F0RnkoZrwx/DZc/QU0Lmxq8K7OQ2Zzj68KTKI6z03G/LWmUSP8rIKbPmZW7Ag==.sig.ed25519"
}

{
  "previous": "%pcC2kud2mttG6YD0zjd6S/BT3/PkETLTJRd84Rgkkl4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 427,
  "timestamp": 1513355885807,
  "hash": "sha256",
  "content": "xWNC86qn0BSlBgo7zhpjMfrMVhB2XGYngerup3rKrI0pJFnAaFBB02zVJA+LCukOYvH1z9m3SjwoYGsKXeN462vzfQB/ovkmL7v6nGRQoNG2pE5GX88FK4ivavDS+xISHE+vV6Koxo9Jqm+f3fEnidDbWFG4LYB3XjT9gvTa6+MhMxgw5mG9veCwqB9o8uuwyCQhjg5OHQtEWCjzdjjpOI2lmlvtvbYsrQxZHCAVnkRUnex7Xb/x0paMoqe2w8sXd+GDcwNZktQXlBwMFPhiz0McnHJvOF1tX4i0wP2UrxVeCqdJjWK5xZJ4VarGbzcQUOcYjs2h1F15tk+CVwzigyqsSGr458xHZ1oGebgj2gWW9p7bkJfu85ln7jqQrF7m1tvG5W1gYL9L+4Sf5onudoTv6rPNPDwWLixo3eqtNGOAiZy7h+lOWOuyoJDn0atcFMH/ZXWzRz3QdgVOIScs2kUrvZ9K/LT+YA9gDQbGW/s4KtOpNSKIq6wZSXkScyoRdrmgS6YA4R4YYKYqEPGjfDnA/t7SaCWdUF7DQdDAJbrKU8292Rf9c/4AlcEqwV4yX4LP5ONSBkq8hzpv6r8hj4J/QMNXEXc8qYW9PoN+DHBFEFFIRnoZPv/eqJyi7w4WGhY9tmIhcXg5OniSd39jD8cwSQxgWz6F9d/Upwey3gfhYAS4O5O5/jTHQc3FQzzHOQcKfWVtWpx0tgkEZnk8xKENl6j667pkfyyLArvL1ZAKdwTFXEgOFFMEe/rGhOq2PU4zYTU36UL1fnfl78hePNycO6e2y2En1RbrE64uGrXc9EsNrx5ZpNAtOYFdcG5byzZc+55vT1zwA3VgHHM29VQ4dI04NxzwFDBhaTegP5EJkqKWBO4//7Mz4dJO18nk/NHGNMatAQuvBmiw+vWP7Uk8S0z9+9v3OKwtHt1fnU9Iso6Oo5LNXsDGzpKDBuH2jLC890QMvDQh8icc/RGpxBxlHGKoSI3MhHLD84KhTJq52zCcdHnFuOwfRCZRm4xWHiqmr85uS2xbvA+oHKEwpujlfWmcWllF8X0G0/Zs1xRAX2tuGLuE10RuCzkZ1J7Tos6IXJJWqqi01SjQKi66rzf1tPP8IipYwIL5UHvg+bvV8FNc1YtK4LjUXkZVpOU+wvljUfOnSCZyFls3jJnBhjTxlhqwskh/pu/lsRwCwhv9wX5FJxSRZDuj5ab5ia5v5NatJGSUvifE4u7d+GckhFHRSxWScsQ1TXwVaw==.box",
  "signature": "dKA99mLNQ/lf+XH4j6EaO9EXNWBNQI2mf/SL/NUCi2JvQS2buLE7+XVdWFYHzMD8s2EIuZRE+KON2+sZ9jKnDQ==.sig.ed25519"
}

{
  "previous": "%5QrorLiJ06l9cb+W2v2STQ2bdTCumfFnlLdgy8j2L2k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 428,
  "timestamp": 1513424684513,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Laa1b3X1GXl2gy6rUV7GIbmw5Amu5NqTryiNlmLGspA=.sha256",
    "branch": "%EYrut8/MLdLDfOu2VQZAU6VSC1z18Df6aNTuWDdm/9c=.sha256",
    "reply": {
      "%Laa1b3X1GXl2gy6rUV7GIbmw5Amu5NqTryiNlmLGspA=.sha256": "@pbl3z06ULvRK2lykFmtvDdb5dvquKO0wrmTHIHXlt48=.ed25519"
    },
    "channel": "ssbc",
    "recps": null,
    "text": "As far as I understood it, you need the whole feed to verify cryptographic integrity, but [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519) didn't mention that. Did I misunderstand that part?",
    "mentions": [
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      }
    ]
  },
  "signature": "kVLwjCw5wMDmURkyhsV6DtMQOHi8ja6lrIvGk9bY0L6fKoKLZWEK5lhebjPK9UuMpROScHMTrXRMnKwDY7nNBA==.sig.ed25519"
}

{
  "previous": "%5ojYj9fPclJJE1Y7xkwRbhFxP4izZWDw74dk2lAWvUk=.sha256",
  "sequence": 429,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1513464195513,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%b7dILwBDKP1WPQRUb+uZ4b/FjorGSb3atDHsl+3nYYo=.sha256"
    ],
    "packs": [
      {
        "link": "&cv716ghnXjQnh7SXvbdFagDaC+AJm3Dl+CeQUGN6o7A=.sha256",
        "size": 4876
      }
    ],
    "indexes": [
      {
        "link": "&Bq+9zegeLQwfp6T12URI+JueldYjpvpgQPKCHXbh6vA=.sha256",
        "size": 1492
      }
    ],
    "refs": {
      "refs/heads/master": "c6d9cc69d71138f419b9e766fbcfc1fc9ffb3ecb"
    },
    "commits": [
      {
        "parents": [
          "6061c637839f17254093d3f52c2426f5e2c961ea"
        ],
        "title": "Implement TestChannel",
        "sha1": "c6d9cc69d71138f419b9e766fbcfc1fc9ffb3ecb"
      },
      {
        "parents": [
          "2a2e39ff13145a418d19bf3142ec915750ec064e"
        ],
        "title": "Fix warnings",
        "sha1": "6061c637839f17254093d3f52c2426f5e2c961ea"
      },
      {
        "parents": [
          "cfabc2bd000b59fb215b26b137fb0e2bc5a7be16"
        ],
        "title": "Sketch TestChannel",
        "sha1": "2a2e39ff13145a418d19bf3142ec915750ec064e"
      }
    ],
    "tags": [],
    "num_objects": 15,
    "object_ids": [
      "0f247ae36245f0ddd6aa48e619ba28c399421bea",
      "3c4bc57310195d9a5ef605159046a8358e906d51",
      "9355fd1f065b9e038739e9003ff230079ef6801e",
      "ff75310ec6b52377eb89ddf0c1ca5b7bc449b891",
      "364233c0ffa76532593059d6434bd863dd8d94bd",
      "4d9cf407240a246545442ed99608213b2b6a7954",
      "eecec52d1cb8460a702cd71ee868d2f936288bd6",
      "1c79e035dcfef52f8e0af937e2d0c7a54c140d90",
      "89bb72d132cc4d34bf7342c4709d5a56c76f1d64",
      "434018780aa51f6dba61c0302f869954797e7347",
      "e96cd17fbc3a988d86d6df1039932f0281413857",
      "93501df20b5fcbfc0002ebfbdbed9dc3d071809a"
    ]
  },
  "signature": "ArTouyCHUC75IkPE+TqKc1z2FnUSd7RnVhQfIvy14QqhCfxipk8iVeP1kZw+2Jno965C/SVMB7BfJOenJu/pDw==.sig.ed25519"
}

{
  "previous": "%UGGB+XaUmB1zVde0rgxrA6GxYBdsjnU8c9fJmyGiknE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 430,
  "timestamp": 1513547487296,
  "hash": "sha256",
  "content": "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.box",
  "signature": "la4e4WCzvkjtBBUAizx677FeZBYxuh5YB+gY5qEDTs1VA8ljkoIx9VgkoA06vL0pnHYJr6eHN481Q1IN8kyYBA==.sig.ed25519"
}

{
  "previous": "%Rn41sLe4bcwelOgxae8eERfN+zhY+ChtcucvEFSNp9I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 431,
  "timestamp": 1513635369163,
  "hash": "sha256",
  "content": "zMxAyul7R4OaEP6J+4gSohxoy9ukWJyzqa23ioxYnKXPaRe3X7aUi+H5EZJrlSyfo/4k92M1fk0iptEKfRsbLILW59XDP0coo38NLZ9CX4J08Ksd5zTKfnVDSL0TndAAavj1ao1+evNYPukLN3HQ8wsTnDRbNRAfVReD4DBL8bNpScixPQdPIubNvAHbDRTcnpF98PuB2Dl6ICZkD3U+idNPxO+1H43ILIRa+D3FZsW9tUgOkxRQRq7ayPGBEnQp/zVyHHYi2YLrTFWdSTpxtH1aZiYtaFun3gU9uI5nJn0YV+1b/SkliHYxFN/u15LQBr9nTfDex+RozIlAqW6nEhyktAIi2sHXz8xFhuOuDNpHtlLb76lqQrEjAnVAIogRodt8VezkcWWLH2hV+YXwyzkSnnam5bN5JQB048rkOahAKip7UpTve/sA3CsRmeoHLD1g/hiTbDIK3nRyLqCN5rSSfMCjlCzc9RaV/3YTfn5ZqgABND1u6F9lVG2Tuai2eIyD7z9Wj4idel664HXMn5sLx3S+gzY0yQiPV+D8rpDMa9twzREiI/yhZw/goubZ2eaAsPpSvaLIb4VWhptt+BaAAojsj8ZXOJkaYqHA15+sx+g4vYOIVKfNjCFJr6onC228Z9Oqg4RV2jf+2Uo7+YdhxNF1+LGAInSQbnGkJkFSW0Jv19S3/HBkKx0uLQOLT86GiYNmrnuRnQeig1Up+qqD4a1iUsi9t9VrTgd5mCAljQzvs2XyduYL/uhw2wAuLwrk2/WL5T2UCXyKPY+0a6y5HhtVQ1RoudqMceX8gtOitvSJKG84K/vKZ2Y/8JVOlCvLHkb+K161j5QI19KY+UJ+NQ1JsbDwaddsfhonfk0tfZSDnmwKVHIR6Vlu1sBxwD57qJovmDl3bpAgnpSiZK6agyZZelx3X89J+Bg4cjDsIQfGs3zTRc6Lhf3aafRc3QQ6UxOkMv8zAhFrhAk69a9xNmmTinn4038dKxjiefUp0oB7SrAvwsCUpIfAgMykTO6Up2hyaHJ5VtpOf+xtzoTL05m3YbmsLfr1ugB75N40DtZE1Mjq/fVFYjLGHDUBn8Cd/KWaSogM/ltp+AufqKp/3BPaQrznq4YOybeVgnTPCXNFANyWIqV0YdFNDQCykN/5xHhN6IVGS4z3cw2YCJJWXyFv0+dXR/VZio7n6lwIRWSpaxwT11vSs4KngZSvQZAsU5JmADPxBVbLyk5yO8iHrobxZSMyZaqkf8sF8XraC7/eMFeWUsm+Z5775iAYu/2uTODyE2GgA7j5KLamPNs7qeggFfWTUVlqgdz5ZQdf/n0NrKDRSOo03VAiwwt4mNmCNFB54vSNLP5KG4CFYCm0HGmTvDYvk1jR7ug6Kxa792Rm7pZieb8nfbTRJZ/mFHrYEqvSBv1h1LDCn5a56UjeHpwfPHBTlktKchOP5cKW9Fl01bjczYr2e27yRfvv5zz8WeJbM2RdoaVMGlfJ811jahekSwDq+b9mincYiUnPGMdHIyPVvZyl7DY52bmWCfVwqreL0wcS9HQ8Eg1gXSuXM1qwY3nlCb2mZclhYNWXABtNwS/giG2oCC86zzwuF/W6rvxdqVUJ3NnDXr/AEHWEnJRNKt716mWc+ldaSm8evXAUxijzCuj5T7Y0o5bgd7+WOy3dw9Ua03nYkrhAyWmSdXf4cDYemzGNThnhNMAZ3e6ib752+I44SKCYbIKGfuZICqglsP79hGtHW/tujg3DjPQ/YgDkVt610Gh5adveVFcFYxjWzQjboGV+1RajP/0trSDlskNExu9NiYvIPi7KJgKzEfnv1/kzmJCQarIdCIj+fwnd2lJ/OvmOkN5DY6sDG3120t/8wX2q/t5SvWfMZNNhyxJ6eqjTqpziHQzxYcs8KlxQbkUdPyPOEBcYaKLPO8aEMh+i51T48NLdOV0DRN7nLaxCUQ1YgHwCEL5VtTg35vYfeqRHmRz1iCf42+hpJjfu/eDd0qXoGxIW64dhRdU/ZJZoseQKamxDmcnYZ6xq7Or9NKgkPSsU80IShI+6M8BG1tt7Q+i2hvOoMixbt01YyKiGKIITX9OAsWC3lkxeWErz0f7qOg4nVGESAVhvFiohXorqigm81oKjlSVBU5ijKurI8J1Ad2ruBnkkZ+XZBjM1jy37sf95Nrs03IevfLSu/HLD6OU0NByy8JpYzvWS55fSSeqRK5KsGvJuGgyFBnZ0P0x+ER0Mms/rtYO44RA0GsIh/70NP60hx966KTEfRBSeJeItnalT3JNLsRV+MXMgY6KeILpRDJvETrSQnedYhr6hx0LqxSyBZxlOC/aC6gxDXy3OeMNVjyIvGEhjQ+f/gnvmP074snOlUecHesO/fFzMMmoE0k3vFRKy3jl2VeKva9BCpXIAXQiwaEVHJOA6BO6TgOyaCW/FItseNAZ2TBJQ7dBDGjCQznEWp8QkGF+nPIPY/DxxGLGzuJD8VAjxQLD+mY0R/eyvRImsYMYpPKMhv8u5h2sN22vAUepqPhUAWtSebfuBvrExIgTK4gSxLeoPuR/x+gHfjJDkdwBEfx4AKcha/aMeuTwSfQAMGRxJgtwM3L9ql8nkqnAAuihqCQDVlcYKAiCjvCVbvOxlEcnBHFWTnpqj52ediIOIFtSVHB8nK69QyqKWzu8igdgFVEznaauK3qs7kRjotBkn0ceqyRft/K7FnbVECQWUkwdRt4HoiXVT+kURA7Mr1K7LYbpY494EabMWVgFWDloujmE1ZIaFgoOtlVSqqgr4JHbhCeKj7KN4UsEGmhEQ38vx/XA606QFPBKYtZdYVn92+DNG0tP4As7AOY/AOHbzbf4qZbc+9gHwZzynzFUwHenT0b12PV4JEJolX98b/VL+Y248z/h3cJ4Nk6W5ISwShRmIymunW5wFyOpPoOcPHIgWNQgZoxEtBWta4/qgQEpiT2mhDPDUv1SmqlUjc17+qJsg1NiaBTngfKe9sDv4FGqfSxgqsftJ7TtnUtPh0tG37wAHZbEg85HJTDUTn0VflvWVURZbBtw/pEg/ltvzJz1XV2TmUsnRy1vtvJh2JnJT5g15nUYaWPdmX4lm68BvymHFPq4xuu6AcBxsHV3ut4lrvXN60z7vja8HDUYPYNR3lZdmFIjMgkdE1lPiMxzZMtCVHT9GqDVOCRI0dEY6TE/ieqS6uOoyb1xyL8bfKS93/DVg50Dq5W6OpYI5nNF74l5Z3f9g96b6gIlZTf6AgfagUGwoG+nZTRBb0SUl+PIYZPCcbMiWrUsRAMzb0WVUtJ+U1WSocy12Fh4JUwjy1X35KvnWsktB4Khw1mMZQpAxprp+OzGpEzZJp7DE+4Twh1Z+yWKJojJzJ554JShSdXEkrCRLL7PCwJY7wI16FdiV64Brq6E/ANrZCpAxxVER+UNAU5AM5MlAVpkFodNGHTADD0LeXW9IkdaTdaO0DGEV23rvc7ZOp4+TblyYM7+HycsfH/Gmou4aH2xfI7xU3CNkggAsMyM+72+Dxp0lIRS2GBePFeTbcUeE4rNY+8gDM6NBWRBG1mk+NcnF2KXpatfRn26zQc7eO7wdFopik19NrQmksM0jG17Z3WQYw6SO6okp3V5yMd9Mgk85tVT4rAp83ZzTuF+yz4mndkbXxaePrwVxgDn8J9GyUl3vAaddF1mfVm1AvfQfXyqPZMqYdyInCOpXOgxisbQwQ35bDw==.box",
  "signature": "jhS2mJDb1azmZSu0ewhPt93lVKHwISfxTvJTja4oF9QVhcBWDqoC260mXE19DP3OcaSzQFezyILFBHR1WXGOAw==.sig.ed25519"
}

{
  "previous": "%U1RrHwuyRGFTEfebP5WSszgmKfErnuByTIYNi9AKlmA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 432,
  "timestamp": 1513721575537,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%VQqoiw0KbV3RPPk0YpqcD8jK4nXGHeIxAg0qZwE4rFA=.sha256",
    "branch": "%tRZBXBm/yzx1tCjcjNH7rAIueK2lTNbrUHjzfUo4dOc=.sha256",
    "reply": {
      "%tRZBXBm/yzx1tCjcjNH7rAIueK2lTNbrUHjzfUo4dOc=.sha256": "@E49518H7TRFUzTr60d1Gh/81OqejEPc0/Fs22b2qc9A=.ed25519"
    },
    "channel": "ssbc-grants",
    "recps": null,
    "text": "So have I.",
    "mentions": []
  },
  "signature": "Dovrmf3rQQ/pAxdR3ECQtTkRYobjMhZtJO64PxsYHxh/1EasVWsHLt4YIsoY4pBtv4jKqCNuNvsoGf3dMzfvBw==.sig.ed25519"
}

{
  "previous": "%M/gYpGxvaw8njCPQYfUjWzYSKu07dX3wbatmT3REWT8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 433,
  "timestamp": 1513757664528,
  "hash": "sha256",
  "content": "CU97t6egaNggpdXDM28bWZMuJea/6v8uc0wn4jbTKXHbbXI/YNVyAcK7kQi5PfFwXQ0OK3wM62K11xd+70vIxUa3+oPNIQI66k0Bw93PUkKG7bWUzZ0dY91nwS6DZv1prCwkvRyP+xRFE5zuldHAhgbcAh7etMYIN6bmPA3wBrzEn+WxqKr4n42YJ6hwyoVYVhReiznbX0EHzmbYJ7GEf1I6ukVt/AN/W+xXgnHLYV8iuN3PzzO8uhNz2upBdveg8r9KbogiquK+KIDcZ+0kLzEMD+UKtd2s2GkyASvwGlrmOkH8WkpQv3YbXked5eOFtdVDHKo9LizJqnu5OhALAprtHBp/HXLMmORyhkt+Z5TGwqTzn9yVdchgo6zfXZv2KewbGj5f3S5sbxaC3YWbbcclSPmhIdrem4oFxWoxtQjUsVTx3qQzVnO3aOR/Cbc1T0PGZyu5hhUgAIsLwZyKBy46jDcGTPU0iGhERkozbTO2SB8+f+nK3UZDSk8TZavWiMYcGyLzebwN7csE+T02RjK+RhKxPccONkQqXnJYld9+e1q5yUkkkdBtxOq3XwPaF1rbY3NYu9o+aDZeIr/8gmdK/2CMG+iLxAbiSqaRXFXVzMiipDkJwkfIlowtFaizbpKuAE08yZx7IiBpPdJ+pj9FkZfHE+8drlhChOQADm4DDQRzUAixvqHaRg2fiYmbX6hjaUUr8T//fYSUhgfUc/fJZRiwaUUMqjhoVv7qEJRf87tybamo3+IIrLoLF4njVfgpjihpt03vx45GQQ8+/OTFSpmHAA+8uduPZ4dfRkaGZlVE38qrBYV7Aruq9SZDqGWegpy1RjAS4qB2ebU0Z9o8x76otLMEswa2mNcl8fTVZwyn4oX4qQT0z/W1hns8PCVIH2SmnhvfHkvltxJS8XFCBUkl25bgPklFhMn+OVEUhLeVDsxf6YkHgPtj9EmusyeH2U/jwXHbeouleajtS/VpHd7UYe1O94WEnGlxopx6iFdVUCd3nfM45g8LfcO9Zqk0UIgEVT643XSee0+/510UD5xlQ9wG1O8rLxe78yS0bpvyl9gKYm4m6yBso/joQYq+vlUldsCG9CL3F/nfbwh8adHcXy/fgo79+fXltA43bjijdeOvmN02XT+i4aQQCy1fxv5N5Cj133WblznlgmMT8UDp5TxXEjwE6SyMttGL/vZrqS3/HLBTuDp0xW4RBEQYsxjr19FLLGipeLFzPhJbFQJ5MQCJ/dcmQuZRyL00RUX6WnfexCOG0vDF1osU+JVIp8wrrjzXYydr4ZMruwW36D0tXhYozex8mj3shclDrr03kjMmgHNytMF8GgiArgswjVExFPx/09o=.box",
  "signature": "UDTU2paz1iVsBNEXCAQm0VzirFyPeDo2QLFoxd7oGoB9F/EJO/0E3LCp4Hn8pTRts8BJiV/+K3zZHzOXZiWeAQ==.sig.ed25519"
}

{
  "previous": "%J10BZHKNbHFOPP+fOzoevWQ+HXRcmLBUfrHTDfeqjnw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 434,
  "timestamp": 1513758301027,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%Z8iFh8P4wVY5QYI2ouUmmOkxc2yhil4vJlHrKdFBi1M=.sha256",
    "branch": "%UmG7JclpGSAUs7YJygcuW5i4A52XakGQOITRyE0gB9Q=.sha256",
    "reply": {
      "%Z8iFh8P4wVY5QYI2ouUmmOkxc2yhil4vJlHrKdFBi1M=.sha256": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519"
    },
    "channel": "protocol-docs",
    "recps": null,
    "text": "Initial feedback after quickly reading through this:\n\n- Since shs and box-stream are not inherently coupled, I'd prefer if the docs for each of them were completely standalone. They are not inherently tied to ssb either.\n- For consistency, it would be nice if the label \"plaintext header\" would appear for the body length + secret box 2 boxes.\n- The text does not mention how nonces are used during decryption (there's the dance of using two nonces or both incrementing and decrementing it.\n- I'd love to have more nacl pseudocode as in the shs docs.",
    "mentions": []
  },
  "signature": "SY+spMS99Ixq7r03jKRKbOvOOPBJhIoW9C6nSNZT0DTpnp+uAvwZP9Wl3ST5KXnzC/VXssX9EMdM0FK55kACAQ==.sig.ed25519"
}

{
  "previous": "%sECX3/8nXAoCwCjHzbPi97PzsEiW0JcaIFVdeSVhq48=.sha256",
  "sequence": 435,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1513782134152,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%UGGB+XaUmB1zVde0rgxrA6GxYBdsjnU8c9fJmyGiknE=.sha256"
    ],
    "packs": [
      {
        "link": "&8WsxVvTy65nVPHIlgT4FjFvGT4tIBII8VV5T5OMR1is=.sha256",
        "size": 3465
      }
    ],
    "indexes": [
      {
        "link": "&PyZKcWv3lhH0eBYsbYLjrZ2nKc6gSVa2cbrBFaKfrBQ=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "a78e12206da79ecbd52912388d01089fdf5a248d"
    },
    "commits": [
      {
        "parents": [
          "c6d9cc69d71138f419b9e766fbcfc1fc9ffb3ecb"
        ],
        "title": "Strengthen requirement for Arbitrary impls",
        "sha1": "a78e12206da79ecbd52912388d01089fdf5a248d"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "f97edf120abd4d132ebb6168d1e5415e732f6fd7",
      "c9c845f988986428461fc59873a40fd2ba5e0ee3",
      "e229a16826a7bebe7d7044156edff6f8c5ef390c",
      "f9df01c4bb849da0e6456adb47de4f6a909c41c1"
    ]
  },
  "signature": "uaykPZOG4+U3T4jABPW8lyREQWBybemsBlax6oUs47oR5BMh/kAt6ppRNrjaCSjJn+pg2bWCzvV/+3dp1RkKDA==.sig.ed25519"
}

{
  "previous": "%Bu8ihdHsA9f2qvPLhSe72690YPRWOf5T/a/MHL4tmeY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 436,
  "timestamp": 1514019786060,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": [
      "%eHzjpW+l3VwQM3hUV01vYv+d6+mHREbCMOWBtUzpUbM=.sha256",
      "%mFKaCIEhnFZQyfWyJwPoBw/IZ7W1EIjZiquJc+OLZeY=.sha256"
    ],
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "What little time I could spend on coding this week, I spent fighting the compiler. I like the API I chose for multi-producer-sink, but the strict rules about moving ownership into closures make it pretty unusable with the default futures for working with sinks. This was both frustrating and felt very unproductive, so I'll start working on some other modules needed for an ssb-client.\n\nHere's an overview of the (relevant) transitive dependencies of the ssb-client module (cc [@vtduncan](@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519)) and which of these are currently done in rust:\n![ssb-client-dependencies-done.svg](&JVUa4tFQYK5wGbksaLqCcS9M0OR/Xs/FwxM0Po/6ccM=.sha256)\n\nI could either start with ssb-client itself, sketching a bunch of the relevant data types (multihashes, cypherlinks, messages etc.), or maybe I'll take a look at multiserver. Muxrpc is blocked on packet-stream, which I will take a break from for now.\n ",
    "mentions": [
      {
        "link": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519",
        "name": "vtduncan"
      },
      {
        "link": "&JVUa4tFQYK5wGbksaLqCcS9M0OR/Xs/FwxM0Po/6ccM=.sha256",
        "name": "ssb-client-dependencies-done.svg",
        "type": "image/svg+xml",
        "size": 8513
      }
    ]
  },
  "signature": "4P/mmt0qM+JuB8vCtsOpbl349Q8A6HBJzGZmXwNS/rfPWxZFZZle1cue3kFvqmEVHsh6pC/KxgLsQkekPulKBA==.sig.ed25519"
}

{
  "previous": "%CFC3XjTAge6Wpc7OWy6TjLX/QEEUbqsUg3f9C4QBkvg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 437,
  "timestamp": 1514019839206,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%CFC3XjTAge6Wpc7OWy6TjLX/QEEUbqsUg3f9C4QBkvg=.sha256",
    "reply": {
      "%CFC3XjTAge6Wpc7OWy6TjLX/QEEUbqsUg3f9C4QBkvg=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "dotfile for the graph: https://gist.github.com/AljoschaMeyer/2dbb2c568f55a84e78d5b6f75d058c98",
    "mentions": []
  },
  "signature": "gTAufD4wMn4+zZlLFI5lgMs5F4+hj4T3ecj0mLi21SEQUiySgTANdKAHYcNxDHOPX+KIZSdgvmuu5psCTbmsDQ==.sig.ed25519"
}

{
  "previous": "%DLQ/jSaK+PEOxx3lCbHiMz9djnEQrIjl3VkyKB92LdQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 438,
  "timestamp": 1514067233458,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@PNRgWW7JSRryPFhhWiRPQ8edpRytABQtzrv9yF5EHRM=.ed25519",
    "following": false
  },
  "signature": "wno8TuJoFGOIjlG7WVZT8LZoFHCipMa1tVvrU00xlfSfT1ayQeONjcVZO44bo1Epn3o3FLTy1cZOAIDay5iwAw==.sig.ed25519"
}

{
  "previous": "%iiK+lEe6RtTVqGChTKDmMAqmB6kQ/rVacqowy6BIOQQ=.sha256",
  "sequence": 439,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1514202136421,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Bu8ihdHsA9f2qvPLhSe72690YPRWOf5T/a/MHL4tmeY=.sha256"
    ],
    "packs": [
      {
        "link": "&Ot87evojMnzR9f4DeylTGWfDrWvX08HDP2l8WLbBnYU=.sha256",
        "size": 2219
      }
    ],
    "indexes": [
      {
        "link": "&IMJCSXlnNExydLHkCBNYNtvRn4JSbb0slkEL44udWpc=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "101dd2ea36e8a068df73beafcffa7502437d83a3"
    },
    "commits": [
      {
        "parents": [
          "a78e12206da79ecbd52912388d01089fdf5a248d"
        ],
        "title": "Fix TestChannel ignoring buffered data after closing",
        "sha1": "101dd2ea36e8a068df73beafcffa7502437d83a3"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "e814110d98204c4d434b8dbf3e835f669c768fa0",
      "3fce289bed2f97d191279c0232b1dfb1377cb3f6",
      "dd19b10b314a913f80d0778de4637b8ff3d94c72"
    ]
  },
  "signature": "xMYA8NLZ+L9CuqhPXm7VnH/rtXC/qMNx+KXwIebwlweinUmdrtq95VsU+Kd/UQA4HlF9FFt3T+wg/v72uI5HBQ==.sig.ed25519"
}

{
  "previous": "%q0B0VMAbqEBqRQudqtUiEmRaqAx0yY0h9opoA+FPkU0=.sha256",
  "sequence": 440,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1514227609907,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%q0B0VMAbqEBqRQudqtUiEmRaqAx0yY0h9opoA+FPkU0=.sha256"
    ],
    "packs": [
      {
        "link": "&PLHdf8QaHs8WalTmhgb/cLmg+KUEATMrWoxlSA+hHS0=.sha256",
        "size": 1820
      }
    ],
    "indexes": [
      {
        "link": "&9uDv1mN4pqKzVE9Uf4RajqB2Kn5uJsqlTIN7OUplVuQ=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "a565b0c2bd8ae5a25022681cf3107f70132f5212"
    },
    "commits": [
      {
        "parents": [
          "101dd2ea36e8a068df73beafcffa7502437d83a3"
        ],
        "title": "Add sink_futures for closing and SendAll without closing",
        "sha1": "a565b0c2bd8ae5a25022681cf3107f70132f5212"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "c9cb9cfe8ddf2d07f0c85bf6635ae9d4d48e3bb9",
      "05da6513d09cab290db7947073d75d2607a26a6e",
      "678d3b90e4f1300788e0b6c654a5c0784a76a215",
      "2c660f4435c95968346461170f22fbb0f33d9af0"
    ]
  },
  "signature": "umXwTEvGRNijtNYO2WgosrngSvpvPKDb+TX0FwbC8/mK05Yo9QAh9VAZ0kAtVbCkAvMgFwk7/0vCd3TPUpI7Ag==.sig.ed25519"
}

{
  "previous": "%cRWYi6ZN4v8dJojaknf8KQYYG/L2n1qpYoNIrA3Sj2k=.sha256",
  "sequence": 441,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1514228002829,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%YJJeuTtUP1sEeijmy7bAzW3M+gbsPBvYRMhjmEhjZ9Y=.sha256"
    ],
    "packs": [
      {
        "link": "&gaF+72jGhREo3N+5+I991l36NMDuKJywFIQmxu+rk4k=.sha256",
        "size": 6726
      }
    ],
    "indexes": [
      {
        "link": "&V/ULHhBSWo/YaGmpl9kA0g0cjThRtUkyAXJoRpdRgYg=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "63ebb5431a4b4f7648e83fdc50df4fa3988c2a2a"
    },
    "commits": [
      {
        "parents": [
          "5105286b4232d40b8144f2e3101c3bb36f43e39c"
        ],
        "title": "Clean up",
        "sha1": "63ebb5431a4b4f7648e83fdc50df4fa3988c2a2a"
      },
      {
        "parents": [
          "64c1e83e8bf2ffd4bc29c598155cfdc3fe2f1bea"
        ],
        "title": "Make the implementation actually work",
        "sha1": "5105286b4232d40b8144f2e3101c3bb36f43e39c"
      },
      {
        "parents": [
          "d8b7ecb300be0d842e94917a001bff1bc716433f"
        ],
        "title": "Save debugging code",
        "sha1": "64c1e83e8bf2ffd4bc29c598155cfdc3fe2f1bea"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "a923bd37384c85e9fcfa30aa5ed7a2bc579e6539",
      "c75272bcc254d22b50e63a2ef21c086d906e7b77",
      "ddaf70db7fbaf0769eda1145959a2f9938402bbe",
      "87d380cc1144746400fc22d2e1a6f8803ad7efc2",
      "794aa1991cefa22e5b54c0bc7226b911526edaa7",
      "914f3206b59ea5bb39bec1ac33ca1240184f7b18",
      "b64608ab595775e95d32b40bd2e04775ea6c2c9f",
      "0543bcf9ef70f4b1d4608dd1e0376278c08df07f",
      "3662f650e9910c770c4641fcaf35f07b99be168e",
      "32e01840a797934fb09e94a4220f83b4e7c08ae7"
    ]
  },
  "signature": "KwaUdRcPK165p/noFlw34Q31EjNMgDsnKAYLKxoy7zp323ym3s4qxyaAuaTxf4QjH0b1OStBSQLyqtp2IIR5Cg==.sig.ed25519"
}

{
  "previous": "%5kvImkMlEDkg8pfO8+OqWXP01k4MntJh9+yBA3laKSo=.sha256",
  "sequence": 442,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1514228270924,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%5kvImkMlEDkg8pfO8+OqWXP01k4MntJh9+yBA3laKSo=.sha256"
    ],
    "packs": [
      {
        "link": "&tNdLZLkeXRefx2B6TK7BaerltmI+xl1L7++9It8yjhs=.sha256",
        "size": 3265
      }
    ],
    "indexes": [
      {
        "link": "&fAz6nw+svLZdW2FHwrKiZ2/z6LbPdz2GE7UBjaCAmUs=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "87ae7f6df591803c5d6eaf8d3527c87891e200da"
    },
    "commits": [
      {
        "parents": [
          "63ebb5431a4b4f7648e83fdc50df4fa3988c2a2a"
        ],
        "title": "Remove debugging printlns",
        "sha1": "87ae7f6df591803c5d6eaf8d3527c87891e200da"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "e828b6d3b7a6d42a906e99fba9131bce5fde31cc",
      "545f594b132f614bec0a83157c18d92911f46da3",
      "ed7fd84ff6783ba068466e857015fc5f7e25093b"
    ]
  },
  "signature": "vRXygwiWjivjoqV1ZO/BgoHZ+dnzUvqhSf40okGhro9rTHgn0dNsAVVXoW9LHi9UOWbP0bGqCuBaGwhBHHQcAw==.sig.ed25519"
}

{
  "previous": "%1I580fLCSxoH1ebV71huPqKajc2bfrAtEniqsDW3c5U=.sha256",
  "sequence": 443,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1514300526603,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%1I580fLCSxoH1ebV71huPqKajc2bfrAtEniqsDW3c5U=.sha256"
    ],
    "packs": [
      {
        "link": "&a7Wm+iBYdxYLIMWDC2Msnwkydn3r05a7BpoP43900+8=.sha256",
        "size": 3468
      }
    ],
    "indexes": [
      {
        "link": "&r1rM4StSLIa06SltxmtHEBMuYUrzVGFymujdSEFelzg=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "17095903a14c0d5edb6c7ed47ba5708ad7ac8de8"
    },
    "commits": [
      {
        "parents": [
          "87ae7f6df591803c5d6eaf8d3527c87891e200da"
        ],
        "title": "Implement removing subsinks",
        "sha1": "17095903a14c0d5edb6c7ed47ba5708ad7ac8de8"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "f2789dce3ae7e0712c59974c3d0657168530386d",
      "be87ea1e0cf76c158f0a0a7f6c731612a4d5a102",
      "466e3f0a0118bb6eafb19c3f6aa6d3ab56d34ab2"
    ]
  },
  "signature": "7Pg4oi4Z2VqntFsDCKG/fXFM4iZrZEdqRX3CS8EVy/rGjBfVs6AxrQlZpEYj5UUrfYJh24Q3YqD5jC77MCBeAQ==.sig.ed25519"
}

{
  "previous": "%Y2EfI/DdJGY33jBLL7Nx8EZbijMYXlywpUg+WgsNLUY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 444,
  "timestamp": 1514307183631,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%DLQ/jSaK+PEOxx3lCbHiMz9djnEQrIjl3VkyKB92LdQ=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Current state: Back to fighting the compiler to enable packet-stream, making slow but steady progress. Got a working version of multi-producer sinks, now on to multi-consumer-streams. These two should sufficiently encapsulate the tricky ownership/mutability issues.\n\nI won't need to implement multiserver. The js ssb-client only uses it as a convenience, to automatically be able to connect via tcp, websocket or onion. The rust ssb module however will just take an AsyncRead/AsyncWrite, and does not care about the transport details.\n\nThe usage of multiserver in ssb-client is an example of [simplicity vs easiness](https://www.infoq.com/presentations/Simple-Made-Easy), where I always try to err on the side of simplicity. If you want convenient wrapper modules, you'll probably have to write them yourselves.",
    "mentions": []
  },
  "signature": "orRxRVWE1PdEfu8XZSTnxyBG0eUYmpV7y7Uqr6+Jb5/t1w4lMii9Nv91tArErtyHC72BV59m4FKcTDAsPgEpDQ==.sig.ed25519"
}

{
  "previous": "%UAHnjIZHqbh00or7bwU1M1LOqi6PerFvbYK2H3dPqkA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 445,
  "timestamp": 1514632932476,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%7pe296iDjF3W9Cfnnj0OzmpkAhZ472W+l3ehr7com/E=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "I'd appreciate any help, [@Ross Schulman](@4IJsfS0cntIiHt4DkuPtp/PUNlR+FLTD0Gr2HVhuQ+E=.ed25519). I'm currently working on [packet-stream](https://github.com/ssbc/packet-stream) and then [muxrpc](https://github.com/ssbc/muxrpc). Since the code is pretty messy right now, it probably won't make sense to work on this with multiple people. But there are a few other things that could be done in parallel:\n\n- ssb-common-rs: common data types used both in the client and in the (as of yet non-existing) server. Some things this would include:\n  - [links](http://scuttlebot.io/apis/modules/ssb-ref.html)\n  - messages\n  - static typing for messages built into the protocol\n- ssb-keys-rs: http://scuttlebot.io/apis/modules/ssb-keys.html\n- ssb-config-rs: http://scuttlebot.io/apis/modules/ssb-config.html\n- private-box-rs: https://github.com/auditdrivencrypto/private-box\n- a module for building database queries\n- this would not end up in ssb-client, but would still be nice to have (and will emerge anyways once people build ssb-stuff in Rust): https://hackage.haskell.org/package/scuttlebutt-types\n- and if you feel like your sanity is expendable: https://github.com/ssbc/ssb-feed/issues/11\n\nThere are no repos for those yet. If you'd like to tackle one of these, just start and post something here =)",
    "mentions": [
      {
        "link": "@4IJsfS0cntIiHt4DkuPtp/PUNlR+FLTD0Gr2HVhuQ+E=.ed25519",
        "name": "Ross Schulman"
      }
    ]
  },
  "signature": "RSwi7ZU22zYAVdNNOxsz8aCfvnmJpHrigBCrtiXC1OAmivSG3EkunhjvYpiVH2IBmNbU/1Ryl6XNP1cLMgOqCQ==.sig.ed25519"
}

{
  "previous": "%yRyMl0WGHjlW7LOZX/vj/eXvo+Xpc6e+h3TqlqOvkcA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 446,
  "timestamp": 1514882034261,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%yOw57mabPYGt6ma/ohmguChPGEZGl8DiRVPbGPxZlPU=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "HDxYNDeuG4Qpfk2SZj0mvY1g9MTO/uQu0zKYuacJuesiBRf1T7jxPx2/i8hcGG3rO4FzHo+ODjoedwfY5Y6tAA==.sig.ed25519"
}

{
  "previous": "%gr0iOqac90qAPNCUeQEdEmOa0eWl6s+AwgLxaAzG6jM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 447,
  "timestamp": 1514904719497,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%G4+vldze3paKuOqbTUXTMT80YdXQKdPYFwdwvJkbM74=.sha256",
    "branch": "%GMVrp2w98RgGXzUJZr3jJp54H5CgN8NWjMzZBu1DTks=.sha256",
    "reply": {
      "%G4+vldze3paKuOqbTUXTMT80YdXQKdPYFwdwvJkbM74=.sha256": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519"
    },
    "channel": "protocol-docs",
    "recps": null,
    "text": "I'd like to see more information on the other rpc methods. At least a link to the [authoritative method definitions (?)](https://github.com/ssbc/scuttlebot/blob/master/api.md) would be nice. In order to make sense of that document, the reader also needs to know what a `sync` method is and how it works (as opposed to `async` and `source`).\n\nThere's also no mention of the authorization mechanisms in muxrpc.\n\nWith the current approach, you can build a database that can interact with other servers, but not with the default client library. It makes sense to have different server implementations offer the same interface to clients, so that both client(librarie)s and servers can be freely interchanged and replaced independently.\n\nOn a more general note, a collection of \"primary sources\" (i.e. links to actual implementations) would be nice to have. Maybe not as part of the main document, since the docs are intended to be stand-alone. But since implementers will probably look at the actual code anyways, there's no reason to make them search (especially since you avoid the names of layers like packet-stream or muxrpc).",
    "mentions": []
  },
  "signature": "7y/b0UBoEaNP735IlRmTDmss05q/g1Osh4vZSvmHEYNuC2E3L7HwM4ksxOGMlYo9V2ZvXGihhU1ceFlaS1K+Bw==.sig.ed25519"
}

{
  "previous": "%TMcC5ifwClNBITu/Y1dZUNiVrDvmad/ns+xrGsqVsV8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 448,
  "timestamp": 1514939049253,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%yRyMl0WGHjlW7LOZX/vj/eXvo+Xpc6e+h3TqlqOvkcA=.sha256",
    "reply": {
      "%yRyMl0WGHjlW7LOZX/vj/eXvo+Xpc6e+h3TqlqOvkcA=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "### Updates and ramblings on lifetimes\nTLDR: There'll be progress soon, but I'll need to make some interesting design decisions first. I could make heavy use of lifetimes, which would have pretty cool benefits, but would also make the API more complicated.\n\nI didn't spend too much time on this over the last week, because repeatedly banging my head against the same wall wasn't very fun. The wall of course being the borrow checker. But today a lot of things suddenly clicked. I basically gave up on finding a lifetime-based API for sink/stream multiplexing and started building a multiplexing abstraction with RCs and RefCells. And in the process, I somehow got a better understanding of the underlying mechanics. It's too late for today, but I'm confident I can pretty much write a lifetime-based multiplexing thing tomorrow without too much trouble.\n\nSo for the packet-stream API, I'll sketch different versions: One based on lifetimes, one using reference counting. I hope the lifetime-based one will be ergonomic enough to use. Not only will it be more efficient (no runtime overhead for keeping the underlying stream/sink alive long enough), it also reduces API surface: Since a subsink could never outlive the main sink, there'd be no need for an error when trying to send over a subsink that has somehow outlived the main connection.\n\nThe main problem with a lifetimes-based API is the following: Ideally, the packet-stream would emit a stream of `Request` and `SubDuplex` values. These would be tied to the main sink, e.g. the `Request` would have a method for sending the response over the main sink. In a non-lifetime-based API, this `Request` object could outlive the main sink, which would require runtime error checking. In a lifetime-based API, the `Request` type would be parameterized by the lifetime of the main sink, so that it cannot outlive it. But here's the problem: Such objects can not be emitted via the `futures::Stream` trait, since the trait does not specify any lifetimes for the emitted items.\n\nThere's no direct way to mitigate this, the necessary polymorphism isn't possible in Rust yet. Possible workarounds:\n\n- Emit opaque data types whose only use is to be converted by the packet-stream object into usable ones, receiving a lifetime bound during the conversion. The conversion itself would not have any runtime cost.\n- Don't use lifetimes, do reference counting instead.\n- Don't use the usual `Stream` trait, use a custom one which forces items to not outlive the emitter.\n- Parameterize the main packet-stream object over the lifetime of the underlying stream/sink instead of taking ownership of it. I'm not sure yet whether that would allow emitting appropriately lifetime-ed `Request` and `SubDuplex` objects. But if it does, that would be a pretty cool option.\n\nOne nice thing about all of this: The `ssb-client` API will be able to hide this complexity. An ssb-client does not want to receive requests from the peer, it should ignore them anyways. You still need to actively consume the incoming stream in order to receive responses to your own requests, but the details can be hidden behind a single, opaque Future. So the increased API complexity would only affect server implementations.\n\nSo over the next few days, I'm going to decide on an API for packet-stream and I'll finally implement it. The packet-stream module will do a pretty good job of encapsulating the whole mutability, ownership and asynchrony details. Once its done, I'll actually get to write (mostly) synchronous and hopefully straightforward Rust. I might even feel like I'd actually get something done.",
    "mentions": []
  },
  "signature": "sVaXI/3jgn96QEN2KM/GU2Rvvkq8Qc9gPHXmbvhS3GWoEz1PkTxQ0gpfWYIcRo/mupUsS86o/7DTKXM4UlYhAQ==.sig.ed25519"
}

{
  "previous": "%GU2RVpRfoLm8lS9RpmOPWiYCqizLFkrqIoiVDt6sTVE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 449,
  "timestamp": 1514939580818,
  "hash": "sha256",
  "content": "kYobt0gmI6WR5r+WoTA/vdexnJIbkBLUQXAvl2sqSFC7MLQZVk+dScKxpiXqMyMSK1TKCglTOWkGlVNCoNdi9dv3YSkqGQGs7iKDk2edyOabygOo3v1dB5DIm2u5eeWnnB6+I7OUKqRGaEzgqUYVkraCax795csfzCUZdtEvlXsVxwUb1sZPxMUdwgIdGaEX+ici2YebBSJZBwVDsLSxNqkIJ4n7W3RB4fQc8CgG2prSk8SK3f8vUITO+trzgaOTMVcfNKn0pxXwGJeBJq/p4uOPgWkWM5YGl79c6q7lO2+1Ioe23rcblL7KVhB558G4ppVvtCxArn/lt1+qqHmdZEYlI9qz1vLBIFkactYDyJDP5HvIoPLPiNnNRAIl1/lM7cimV+AeSe72y5ZZD0wbB8GUP5A1GpFkQF9IiZc7CZZ9/AXHRfNTurJRKHfSlYIheWuBPjkBfhfCP10YVoO9VGxabH4LA8pFYa6QWri9Pf3HepT8loN7gKVUCg8kX2ePnkqxaOqru4lNWNuKVEhTJTJtJDxNluolPHFWDtCWHDXW0lf3hwwnsypHJ0ZMtxmKVtoRAxRvPJVz89Mtwo+XmoQG8mYawkSMUwelSOW25MwEP+Ahq7SHmKAndFRI0/Yg6vBROd5b3fzVYKg482Vnzmc1YteUVM9SLR/GDhZUsD6Wi4wwPGPuscUFGfjyB3SiQCIErK438+TDzh/IubWFrN9n2GQPeuSGYPZHZuC9VD9WPe3xBygfGMGtAhN7/a10c34Wig/518NrpEZVdRHn1JiTU1+Reb9e1XsOkpMa7GK4SO+gOYDgyactWor1Wu/Hz19KkpXb4ccL3LzgKl7Jxr/K5MmVFtgtm6+9u9A/NlxJ4bWP8Im83Xk5JFyt7VLpXAsnHbi40kDCNDP/o8+ENi8crDLCdLlDeqswE0Cto4JzwXhpWhASyY0wrPA+QWiJrVdU7UJy/vY4maWRCtkPk+qOqMinMdh0SblL2LLHdqo2wa9jhB/DdlJ6ccqCoXuwbEztNWiqNYlmxwT/ZJsI51dATLJyX7v1r1lV6jrln+f3a2Pp8+wbZPlePtvBYKja+20Y3fmUZif37asnD0FvncV9FXKByP8jojC/G+7W1QQEgI7vNQ7hWgpj+bLV/iY+eqFh+9icEDLBRngBVCWXiLxNwXJ2pfis1sXkWDmrM8KF1P2R3frVfX8gd6hFendbiqCxVZCdvEzoYA5QigCRv2UecpAoFh9qgURjTz4KQ4Lo1LOaVFrIjVMQGeURFxkOS5Fk7MPQux34qOsoWpwm+FNdmW9qpbPhH74I4TgGVzGoOCb5GfHY5ELA758IrEJkRYfgmrylfJBeIGmujj6qPEymDdcf2jkdNdpe2M2f7YCpYYFtGkH2I4mpZyTlbe8WixLfTv2ZgrHVdNUYEU1Vpi5M2qpTZJYW4ESti+IxLtqsRRYPeWM5G97A5A1w+1kBEyF/j6uLomb4Nd3AOKonPxZa4PMSddITj4wezmwGu+ZflfsgHb/ndTl8fAb7j433ylLM2hoSksJCwhLXDW5cPRs9lx30zZyh961Tr7PXV3PQGuZ9ZjLZemjqwQ5cBaUDcR3VeOmAnJjr1JB7vZlujVpbkzPrI7Gmga5KlXkOv77OI21ZefXDybOWoQBSAoE3SzPoUXK1QywcVyWAYyYPntRxqFhTl+nqU8/rlek=.box",
  "signature": "YFl5dmxAyrGVOCB+MTjEcNR9J6/tdN/I8HOMBDanqEjZorubhF1xrgOP2MPOOiRuvtd+TqKWXRwWlk7kxvjEAA==.sig.ed25519"
}

{
  "previous": "%WzLc/c5WySQG19cUHeDC1EGRS69IShbJ8ej/AonfAXE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 450,
  "timestamp": 1514940503198,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%KZOndfLAejl5EUA8LShT/hs8IjzWjX4WvF1SLWt5Hsk=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "klXxF0jqrsX94utivl5+NtXFm10rCiZRwEqIQrIVLBvoVZbkVvjMLckjGIIFvVD1r/+9VCpjipmeua3EIYYGBA==.sig.ed25519"
}

{
  "previous": "%AicI+dKQjsUxS99ZqQE2mkctwnJ3hjqtLXP09mfqbOk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 451,
  "timestamp": 1514973629901,
  "hash": "sha256",
  "content": "ZA1gnyIryDNj3vz2PZg7EF81bFkGqzuoNVY3+JGlqBG1vO7wU8fHKEumi6ZBqaF5awAF312U2EzTSncRzi9cK12w6zsOtrkqrOVxCm2NEKRnCQfjxw0aQcDPqgvLx7FTUqVL6E9koMx+MyI6gdpDv4byBbKhsnsEy0rssP5BmYjU6iB5hWMoPDaJzsrizbKIOrsd58rP6g0XmYCYaI8bO6Z4Vq7zlqm1l43fghfaukLHoLwhF4zhNBJA0Gl1fet6nUDajIG6UNBkBARL6stJaaPOLemDhFDknb0TnKbXGO8CL32XQpEbc2TLjOgaOSrMvsdwKnQG6lVybmRzQxGI33LUeaVyVzWKFlZ3J41Lv0i8SkPEXJMhQKeYw1AjxAqVp+HTaXXKMIl9NUUKe/V4ywkScYO0JzqNSJeD64D/pWbFDs/rfEnc95BiM9P4oTT6/7daPBg5EgtUb7qLVUROO+H6ai5+H77os0A0ZJzAAghBSX72VCr5Hge2AvR+PYgDRKl5t+8PIXAX+LaRSFH+UbwkO0SwnHNfUpJU4AEkzHeKVHLq6D78v8MVFFl1dFhx3+AmsLT+Ba38uqF5jg3Apx+O77KDYsaCFMrn0z4NQXrIAD1RxV/RjBNwANO9qMvwqa8ONtFz7GOlXz44fGCeCY7s70EKERq4HOvG7DpDrICqftqkBPpBVp9DuYIhe/gFBG0JnIQWixaXpNJRTFca9cyka7BccjPKCxCMBWd45n275seYN3OhCA1ScQgLe+pA98PtPNALPzuTyl9kMnpWFXbemaESKbRAbKx7B2+1CdWqJGsZDI4Oa8embik5BprtOMnWarO8DZth6QUZ3M5iOlHGU0ge+QjI8oyWnznm51vOM6fOQAoDD7rErqzzFqMXLIC1NgpFrqBncHxvmpcuYw0ydg8eZnl+ys7kl7MyA5UFNMsb8thczcRd78MGiE1d0mZmLrmvRqZM6Q1t09pahfWm+GLsUWj7p8pXh8hsBxoHZQ/IHNkgAxXQn0Puf/0hUaQKyz50rfVDhhce28MaU1ZIr329ZDKqCLDDHlE5EM9tH/ZoR6k7FQysRsGdpQd9IZGVUQVhlk2xiiBKIXiuVyDSyakZyUG2H6b2mJo=.box",
  "signature": "Sdmdekwz03m6dTmZEzA8OUjHZ9d39ZbjDhm3i3YnJLe/SqGkfkDiHOQb7+x3xbCNOkrDdcCVhndiC/dlTI4zAg==.sig.ed25519"
}

{
  "previous": "%C9t+vtT5c20IR1ufsl/zsLb5cN6vYEpNQ2TLiACO2Fw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 452,
  "timestamp": 1514974411877,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%bTLfuncQ4PRukIie5F4WBeBuDHQlB5Y7JtylmKfM7zY=.sha256",
    "branch": "%UmYkMP9Q71FYmgunoOoMKTnBLisHXwdJ3uNMKuKl3IA=.sha256",
    "reply": {
      "%bTLfuncQ4PRukIie5F4WBeBuDHQlB5Y7JtylmKfM7zY=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssbc",
    "recps": null,
    "text": "+1",
    "mentions": []
  },
  "signature": "GB9w6ttN2QI2Vy0wo6qHQfAdN1y5s5R/aRFQ2OYuJvWKUtb6Ixfs83US/GtlO/MXrVR90KSvdfEJbWw2tlqDBQ==.sig.ed25519"
}

{
  "previous": "%bS2NuoqROneNTpWANunEB+J8FFjBUphwskZS3iMbR5k=.sha256",
  "sequence": 453,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1514980609122,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Y2EfI/DdJGY33jBLL7Nx8EZbijMYXlywpUg+WgsNLUY=.sha256"
    ],
    "packs": [
      {
        "link": "&ua11kvr/d/IhU7yh3FTO3WLbmNHi2LDxBQzOoDVp4W0=.sha256",
        "size": 4444
      }
    ],
    "indexes": [
      {
        "link": "&gPy21zJx81ik1n+VAxmDchOahQ52tOI2/X307/qzAJw=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "b37b872cf84fcef9ce261f492cabb16bfd233495"
    },
    "commits": [
      {
        "parents": [
          "17095903a14c0d5edb6c7ed47ba5708ad7ac8de8"
        ],
        "title": "Reimplement everything",
        "sha1": "b37b872cf84fcef9ce261f492cabb16bfd233495"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "55ed79ebb8bb2d7f015e005d80ac2e79ef37e75b",
      "bd751f0f91acf4619ebfdc2c5d263a7ad23baf67",
      "f68b07b199cad0ff363c809603193a2112e327b1",
      "975ce586894d46c5bcd163391b7f2dce93942ea5",
      "2c0798732582d30224997b2efcb7752df7ff5357",
      "f35d230057a63685bb65d39260957f1077f08fd5"
    ]
  },
  "signature": "guj7s77tyerTM5rjGpG7Ib1RfV/juvPSxWKSi69Jt4WWfdhOzBqokDWuRlMluGi1RUAe2M9418nRM6VCpdGXBw==.sig.ed25519"
}

{
  "previous": "%TsjAGdSguGNt1W23AtIRujtcf8GfdcbzJLAuCluixD4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 454,
  "timestamp": 1514980824260,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%bTLfuncQ4PRukIie5F4WBeBuDHQlB5Y7JtylmKfM7zY=.sha256",
    "branch": "%d+5H41WSbWppL/NABUviIT1fSuAcDmpmBC4XxBwXvzY=.sha256",
    "reply": {
      "%d+5H41WSbWppL/NABUviIT1fSuAcDmpmBC4XxBwXvzY=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssbc",
    "recps": null,
    "text": "I'm in [Berlin](https://www.timeanddate.com/worldclock/germany/berlin) (actually I'm not right now, but the timezone is the same).",
    "mentions": []
  },
  "signature": "DaTNMlZxjA8jHN5bzEpwZqZ3mXizSMvCBH5YRBdfGZaxg1X1ZBQvjWgHFLP5C+rHEw68ZsNZu6HYsJNLwMqWAA==.sig.ed25519"
}

{
  "previous": "%o2OdtebP0ZZCi5FwAXDICwb4zNYJdRWekuiGJ7YukEk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 455,
  "timestamp": 1514980878412,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%bTLfuncQ4PRukIie5F4WBeBuDHQlB5Y7JtylmKfM7zY=.sha256",
    "branch": "%g8RX+1tnGVI//c3Nub+yQCNZ/nqbzuOKUB4a7NhNCeY=.sha256",
    "reply": {
      "%bTLfuncQ4PRukIie5F4WBeBuDHQlB5Y7JtylmKfM7zY=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssbc",
    "recps": null,
    "text": "Which software do you use for these calls?",
    "mentions": []
  },
  "signature": "UGeWDaj9XksJ/J5qyZ529FyrAo3rQih5wfa9vuBQ0Z0sdnfhq8uMnRI/TAVdt16kCLIj+/9U/CHp0jJC3Eq3DQ==.sig.ed25519"
}

{
  "previous": "%/cZ6sGRi0SI4Z6PckVCf6bgKEgt7eNZ6FImAYgANJT0=.sha256",
  "sequence": 456,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1514995335220,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%TsjAGdSguGNt1W23AtIRujtcf8GfdcbzJLAuCluixD4=.sha256"
    ],
    "packs": [
      {
        "link": "&BuiZKwNOQxl4P8ddWPliQvZse10tVViBvS/7w99u4YU=.sha256",
        "size": 5652
      }
    ],
    "indexes": [
      {
        "link": "&NKHbXiz4gCbWB6y4b/6Vv6LJP9JKZLbPjHYNiPuLVpk=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "328bc1628fb827d20f9d40e6a08c2f4d2ecda6b8"
    },
    "commits": [
      {
        "parents": [
          "b37b872cf84fcef9ce261f492cabb16bfd233495"
        ],
        "title": "Implement borrow_mps, can not use API (see tests)",
        "sha1": "328bc1628fb827d20f9d40e6a08c2f4d2ecda6b8"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "cb6e987369b9c3f6769d3a0fdb34c92817ccf317",
      "0f50e0bb1bbfc8d27f953d3f87f717da5523284a",
      "d7fccada0e5d9a0887d000c9d0f8882ea0d31be3",
      "2d8ba79cbe71224ed9000207fc4928e2946d5f0f",
      "2c5778f8118bb3139f4c37e5fa4fa04dfd48f6ec",
      "f6c0d11329e2bb2978b751e2224c07469cf81777"
    ]
  },
  "signature": "veZIBJkepVIf/xE0oMRCqIWlvkYXeJcXzzxAtt3SZWMoYhaChlCUmDPrER7emYvZIOdC+oXedSpc8oY7s9auCA==.sig.ed25519"
}

{
  "previous": "%QKvnljzzvA4abFeD6Z39aJbmD/gYOs1anPvKBxHOlBw=.sha256",
  "sequence": 457,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515001020301,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%QKvnljzzvA4abFeD6Z39aJbmD/gYOs1anPvKBxHOlBw=.sha256"
    ],
    "packs": [
      {
        "link": "&6o3fOx1dFpc0GUF/R0XuEG+oVSsJvnK8dDItCmPWLLk=.sha256",
        "size": 5481
      }
    ],
    "indexes": [
      {
        "link": "&lWCcDDl7UXLccOrt8rGpgL+TuT+D7wXj6uCkAsRuw4w=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "81839272488033c57f54cb404d0d69077a561d30"
    },
    "commits": [
      {
        "parents": [
          "328bc1628fb827d20f9d40e6a08c2f4d2ecda6b8"
        ],
        "title": "Track closing on borrow_mut, share code",
        "sha1": "81839272488033c57f54cb404d0d69077a561d30"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "b485f8655f8fd6217992ecde6d0f64ef36508e36",
      "3374ee5b158635acb8ec4aa23cce2c6b1c407611",
      "ff45dc4f600a26d0352f86220b2cd2a1ffe09509",
      "3704023919718995af0bad3b42e6a7a67229aeb3",
      "4a66ee388252c767f8507e7bb50fce968e153c9f",
      "4dce24260ba9782a7d3a5782bcc24e0b7651d75c"
    ]
  },
  "signature": "WU1axdk31selZ0R/h6rfH0J3VjuFVYDpd2M2sXqFhuy6db8UGksc1YMiSbnwtNsXEly1ZEGPFM4ZjWtDimmvCA==.sig.ed25519"
}

{
  "previous": "%o6K5kP18WQrhbtU3UA4Y5WjIuHXWLLWhx9JpsPUOOmY=.sha256",
  "sequence": 458,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515002194369,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%o6K5kP18WQrhbtU3UA4Y5WjIuHXWLLWhx9JpsPUOOmY=.sha256"
    ],
    "packs": [
      {
        "link": "&IykZp5xUlYXZvomOQJ5w+yvKRImFTHLLQA5bfe1J0Wk=.sha256",
        "size": 4675
      }
    ],
    "indexes": [
      {
        "link": "&vbASg8jG23dvmxC6xtMSpNy10B8bSW1tx11ZSel4woU=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "ffd7fb9b07485e8a278bc8aaeac558f559f2b760"
    },
    "commits": [
      {
        "parents": [
          "81839272488033c57f54cb404d0d69077a561d30"
        ],
        "title": "Improve documentation",
        "sha1": "ffd7fb9b07485e8a278bc8aaeac558f559f2b760"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "f88770d879cbb6e7a5a378d79ae3e53694446caa",
      "832fb07e23cdad95236f46d39aca99574cc0b2ea",
      "9568eb7bde8bbc0d6ec5f74d370f2003789c2b8c",
      "b4a9e1f8084c718e4b292ab270902b70cad4285c",
      "cbe5a2b30c624646e3fa65b4fc01407ec079741b",
      "91e09480a8a479d374218e405c880d347a4e97e9",
      "e13242eb7341d56a7b2b692886619253ea294292"
    ]
  },
  "signature": "+UEpxl2QgNLzMjv++RKf0dVvgHqj+Ha4insj1bCnHA95ES+XH97VuLgeoHcbxykb/HmrSoWuSGffGbPQopkqCw==.sig.ed25519"
}

{
  "previous": "%6nL7Cmu4LVnn4/M0NrqsDrs0gRFe/c4WL8dwFNAy3p4=.sha256",
  "sequence": 459,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515006341554,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%cRWYi6ZN4v8dJojaknf8KQYYG/L2n1qpYoNIrA3Sj2k=.sha256"
    ],
    "packs": [
      {
        "link": "&9q+4Ty7qRynU3fV4cxy0KP26FlKNxNkn21p1Oe44T2o=.sha256",
        "size": 3247
      }
    ],
    "indexes": [
      {
        "link": "&p0X7dHpLP7ZftpYxDSYyCN7clTwzIN46hEpvKDzqR6g=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "b9e2a4d23df10cfdaa5bfb1c272f28c636a2bd02"
    },
    "commits": [
      {
        "parents": [
          "3f087262f02ecb99ace79671d75e58d8602b05db"
        ],
        "title": "Weaken requirement for Arbitrary impls",
        "sha1": "b9e2a4d23df10cfdaa5bfb1c272f28c636a2bd02"
      },
      {
        "parents": [
          "a565b0c2bd8ae5a25022681cf3107f70132f5212"
        ],
        "title": "Comment out SendAll, it is buggy",
        "sha1": "3f087262f02ecb99ace79671d75e58d8602b05db"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "693b4d40f287f52237b44b07c45db98332f62370",
      "9f558e1bee28d48cc14509d1dbb0322dd0d271d0",
      "f9a1b00a132c501b256a9d5462c3809254698c68",
      "03deee993b01200134b2d23cbeeed8537f506732",
      "e42a2d814dddc4ffa2a6fc72f80c49ecf827af5f",
      "48c21e5c595583816befa8f10f218880702354a5"
    ]
  },
  "signature": "jbk/OunHdfBCYMqt+9z4QyGYHolULk/OrxdFxVgedxP6nuk5Sm/tCFE9EmzFKhG0Rw8rLBT3jqy3zqL1ik2zCg==.sig.ed25519"
}

{
  "previous": "%4sSyJ44S2EG4KgfiXxp/Wqlep7+ums4606UslVoYxVE=.sha256",
  "sequence": 460,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515006583442,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%6nL7Cmu4LVnn4/M0NrqsDrs0gRFe/c4WL8dwFNAy3p4=.sha256"
    ],
    "packs": [
      {
        "link": "&SWl7mDODcBM9IsXm8sD0eRLQpbwZ2yeWO6GPCON2g0k=.sha256",
        "size": 3259
      }
    ],
    "indexes": [
      {
        "link": "&OhjAPQdptBUey0UsTUEWAAlivfd8Ig/np5LfC23F1DY=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "d6009315424ae33e3e4bc15092db74968f2f3d5f"
    },
    "commits": [
      {
        "parents": [
          "ffd7fb9b07485e8a278bc8aaeac558f559f2b760"
        ],
        "title": "Clean up dependencies",
        "sha1": "d6009315424ae33e3e4bc15092db74968f2f3d5f"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "d7fa9816b535193f38f22c021f9c76b4d167924f",
      "4f15e081a55e732d66c7091a0018bb0c87a97074",
      "6a9c745e9a01d09430bc35cfd757a85cbc856402",
      "fdf2d89041f2e5eb3f8901d2368fddec3df4b9ec",
      "62e9a7fb9331995e753592e69a4f3b15e2d243b3"
    ]
  },
  "signature": "+3j/jXwA/sdxb36clbPuFXN3ipCUm4uyJsQNov0B/6dbGK7+h5GvV/ibD68dwuIrP9pZd3WKV4Zg6UL1Pdi0AQ==.sig.ed25519"
}

{
  "previous": "%nsCrlf1l/qJFMFeBactn5Yj8Xjq1kzCslUycgik5XdE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 461,
  "timestamp": 1515007524526,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%GU2RVpRfoLm8lS9RpmOPWiYCqizLFkrqIoiVDt6sTVE=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Here's the module for multiplexing into sinks: [multi-producer-sink](https://crates.io/crates/multi-producer-sink).\n\n>This crate provides wrappers around sinks that allow multiple, independent tasks to write to the same underlying sink.\n>\n>`MPS` uses reference counting: You create a new `MPS`, which consumes a sink. This `MPS` can then be cheaply cloned, and each one can be used to write to the same, underlying sink.\n>\n>`OwnerMPS` consumes a sink, and has a method to obtain `Handles` to it. These `Handles` can be used to write to the owner's sink, but they can not outlive it.\n\nI initially wanted the lifetime-based handle to never call `close` on the inner sink. Instead, the owner of the sink would need to be unwrapped, which would have only been possible once no more handles exist. However, this does not work with spawning futures for actually using the thing: To know whether the handles are done (else you can't close), they need to still be alive. Maybe this would have been possible if the futures API utilized ownership (e.g. as proposed [here](https://github.com/alexcrichton/futures-rs/issues/458) by [@Kixunil](@PJ8k591TK9aAsrM3zlXj9BerLL+69wguuuoj16lVsIo=.ed25519)) instead of just taking references. But since it doesn't, the multiplexing code tracks how many handles exist (and how many of these have invoked `close`), and closes the inner sink once the last handle closes.\n\nNot sure yet whether I'll write a generic counterpart for demultiplexing from streams, since you need some sort of logic to decide which handle to give each new item. So it might make sense to just hardcode it into packet-stream. We'll see...\n ",
    "mentions": [
      {
        "link": "@PJ8k591TK9aAsrM3zlXj9BerLL+69wguuuoj16lVsIo=.ed25519",
        "name": "Kixunil"
      }
    ]
  },
  "signature": "Tdl5aFAJ67MbelUDAozU1/H0QnHmbLuTi0U+UXWkyjfp7hthFGBhubwquRmnWS4scfm7S4AuE24m7cg4+wZDAA==.sig.ed25519"
}

{
  "previous": "%wQzVs48gLbB0KDPKXAfCi6lS7kXAPBBaCSEPJo4sJto=.sha256",
  "sequence": 462,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515085860380,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%4sSyJ44S2EG4KgfiXxp/Wqlep7+ums4606UslVoYxVE=.sha256"
    ],
    "packs": [
      {
        "link": "&KcqiD1y+XWOcQHLbotienbsCALrq9TJEaPDhaEwChEI=.sha256",
        "size": 2648
      }
    ],
    "indexes": [
      {
        "link": "&nuhtdjJ7F8G96/tpKC07eOG42cGh9Z4iKD3JgHLDP7A=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "9e4ffca4151c08a04785eb4b6cac4ee1fefa2a44"
    },
    "commits": [
      {
        "parents": [
          "b9e2a4d23df10cfdaa5bfb1c272f28c636a2bd02"
        ],
        "title": "Implement TestStream",
        "sha1": "9e4ffca4151c08a04785eb4b6cac4ee1fefa2a44"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "96f1af2dfd4d426977edc68e50ac102b01f77877",
      "09c4b69d3c46032d44f01349deb619ab450df42a",
      "525658cf35c453fe64ebbe6162e4d464f9d91cfb",
      "166a8aef1bb6559e339dba902caa86c20f8e739e",
      "7c0ce78d561c26432660e3a85b40ff3f5f13f86a",
      "14965b2d29cd3324614be30e2d764f591e6fcb60"
    ]
  },
  "signature": "Hy/Nr8jzHXrpd4e64MXlHKgBYP2cBBk0cmI8DlGnM61N56nFaUX+HssHZ1+g/s0sgxWFhpd94Igr3ffTfzqxCg==.sig.ed25519"
}

{
  "previous": "%0p7eSwJ5Z+T7yT8K23+L7ZPgmh6GnQyeiKepRrHkJnw=.sha256",
  "sequence": 463,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515087336039,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%0p7eSwJ5Z+T7yT8K23+L7ZPgmh6GnQyeiKepRrHkJnw=.sha256"
    ],
    "packs": [
      {
        "link": "&Inr/52kL5er78QcSwuIeU13vG1Ej5nlKHUhIYdazRaU=.sha256",
        "size": 1643
      }
    ],
    "indexes": [
      {
        "link": "&GiJOV89rhMSFO9IP6ZtFT9t6EJZ1ULL8ZEKD3OOO860=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "0f3e7423ed0df69e17c42ffade4eaac971fd1001"
    },
    "commits": [
      {
        "parents": [
          "9e4ffca4151c08a04785eb4b6cac4ee1fefa2a44"
        ],
        "title": "Remove superfluous type parameter",
        "sha1": "0f3e7423ed0df69e17c42ffade4eaac971fd1001"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "bb895ec35b28fe2ac95c6e93db0696bf3f5f62c3",
      "621e2084ae8097b61f1925de2a465425fee9656e",
      "4c4d6912f7ecd36b6f092731f17d1c62044b482b"
    ]
  },
  "signature": "OnBo/JjCeH8JU8EtBLisxUXZB+N93AF8BaxKr16DEwAOI0ybvNoyFnmbRq6TIqwAxbGxROCwWhFRfbSrSHLPCw==.sig.ed25519"
}

{
  "previous": "%sOoomLDdmh0VkZJc2mG7Lw/xonPb4bcgLh0to0ec3Z0=.sha256",
  "sequence": 464,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515163457799,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%sOoomLDdmh0VkZJc2mG7Lw/xonPb4bcgLh0to0ec3Z0=.sha256"
    ],
    "packs": [
      {
        "link": "&I+cRTVp/Jh4le2lE4F5cmTw+7HoLVlKIR5utO84DLZg=.sha256",
        "size": 653
      }
    ],
    "indexes": [
      {
        "link": "&AqKt2BGoMpgjB4ErJcqg93gDYCfQN+nNX9lbG++ds14=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "a993170e7a1281704827adbdeecea6c69e49ec34"
    },
    "commits": [
      {
        "parents": [
          "0f3e7423ed0df69e17c42ffade4eaac971fd1001"
        ],
        "title": "Bump version to 0.1.1",
        "sha1": "a993170e7a1281704827adbdeecea6c69e49ec34"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "98f2e7366f493fe124da52064ec7bce47b1b469c",
      "b0d9a32463671815f902f2365579f34c08f822cc"
    ]
  },
  "signature": "/bI6M7StbESvanFZ5n25xjjhqbVctHVbpbkURSTbE2U4ypw+BP6csI2jZG36oZ/MSMQFn4TKuK9PZzcu8463BQ==.sig.ed25519"
}

{
  "previous": "%bpVfVHm3eOu1qALEYT6rhBPRY9tVmIU7P2SNVjIkuCs=.sha256",
  "sequence": 465,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515163814688,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "multi-consumer-stream"
  },
  "signature": "9cHH/UvrKKBaqnKGX9vDqimKRNk07EOkZAMzRwPkajIX+17h266YjOEOTCZa8PyK6TLBwUSQcYEE3dKkK5q+AQ==.sig.ed25519"
}

{
  "previous": "%xmaiCBaEKCXPo2yJbqsoeK8Re3tp67cjOSd6IOS847E=.sha256",
  "sequence": 466,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515163823628,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%xmaiCBaEKCXPo2yJbqsoeK8Re3tp67cjOSd6IOS847E=.sha256",
    "refsBranch": [
      "%xmaiCBaEKCXPo2yJbqsoeK8Re3tp67cjOSd6IOS847E=.sha256"
    ],
    "packs": [
      {
        "link": "&yXnUNlhUYl85R4hRR9yy8DO2Os2CkHP3MjxRsqd3bE0=.sha256",
        "size": 16819
      }
    ],
    "indexes": [
      {
        "link": "&HVjeSAEbzPI4lvb1moxMFeXIiJ4JWxzAvwyHKSQjkQk=.sha256",
        "size": 1352
      }
    ],
    "refs": {
      "refs/heads/master": "f4019f43e1eee92a8f28c6de47af4f8eaaf9b2f2"
    },
    "commits": [
      {
        "parents": [],
        "title": "Implement lifetime-based mcs",
        "sha1": "f4019f43e1eee92a8f28c6de47af4f8eaaf9b2f2"
      }
    ],
    "tags": [],
    "num_objects": 10,
    "object_ids": [
      "3982f05e5451c9812a9d8713da342e52066e6497",
      "4308d822046df995d72605f3497d02ae5ae307d8",
      "b3c090ccc4a7e06c04b8c0f84cb8916a31b62463",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "cb7f31c4088c9f26d19bd845c798c561156ac03e",
      "8fd6d4782cdbd76ea210119e2d3abc6115b6129d",
      "8b137891791fe96927ad78e64b0aad7bded08bdc",
      "8d98d429e146420e39625951115b122de8975363",
      "90418f8176a39a5448f7a409a9343bb2029b1885"
    ]
  },
  "signature": "5zVAkC1nypT+wrWiT7BYQ3Qu7Dtnz8gVCwgnC2sVr/cYor6rFDMKqtek4AGfVMmBo3NOarJ/45XneGQ/625xCw==.sig.ed25519"
}

{
  "previous": "%x8vej9zTU00DFeYygXG9FtxQsWUfFyTEwNhDdHNINts=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 467,
  "timestamp": 1515185422989,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%wQzVs48gLbB0KDPKXAfCi6lS7kXAPBBaCSEPJo4sJto=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "[multi-consumer-stream](https://github.com/AljoschaMeyer/multi-consumer-stream) now exists. Next steps: Bridging from byte-based interfaces to packet-based interfaces, that is writing adapters `AsyncRead => Stream<PacketStreamPacket>` and `AsyncWrite => Sink<PacketStreamPacket`. These are then wrapped as multi-consumer/producer-stream/sinks, and the remaining packet-stream logic should actually be rather simple.\n\nThis was/is a lot of effort for the ps abstraction, but that's because we don't have an implicit event loop and no garbage collection...",
    "mentions": []
  },
  "signature": "PKRMK+sn3g/rFmQ9Qtzhw6gBdFkdZ4HjAdpzgS/E5eGcrlKdxRtUzsNf80L7G1tmA/2GVC6+Z8FRMAcNMqjVCQ==.sig.ed25519"
}

{
  "previous": "%1DjgX7AHuJgDY6ZwgsHOvt992pglnkS5qGu6ug+GDuQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 468,
  "timestamp": 1515236197689,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": [
      "%1DjgX7AHuJgDY6ZwgsHOvt992pglnkS5qGu6ug+GDuQ=.sha256",
      "%N5s7+VyrR/3G2bC9bSQsi318iJ2zawPcwBzTFumDp0g=.sha256"
    ],
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "I have no idea how to do a good code review, and I did not start using Rust too long ago, but I'll just list stuff that came to mind while reading the code.\n\n- [L1](https://github.com/pietgeursen/private-box-rs/blob/master/src/private_box.rs#L1): By using `sodium_sys` instead of the `sodiumoxide` bindings, you forfeit some nice properties like keys being automatically zeroed when going out of scope and appropriate `fmt::Debug` implementations. My modules use the sodiumoxide types as input to the crypto-functions (e.g. like [this](https://dnaq.github.io/sodiumoxide/sodiumoxide/crypto/box_/curve25519xsalsa20poly1305/struct.PublicKey.html) one). For consistency, it would be nice if we'd use the same level of abstraction for out public interfaces. I prefer the static typing, but I'm up to discuss this.\n\n- [L21](https://github.com/pietgeursen/private-box-rs/blob/master/src/private_box.rs#L21): What if you have multiple modules all using libsodium? It is not true that your init function \"Must be called before [...]\", since it is also ok to just call `sodium_init()` (or the sodiumoxide `init` function). My approach here has been to document that sodium needs to be initialized, but not to provide a function for it. Again, this would be nice to be consistent with shs-rs and box-stream-rs, and again I'm open for discussion.\n\n- [L50](https://github.com/pietgeursen/private-box-rs/blob/master/src/private_box.rs#L50): Another good case for sodiumoxide instead of libsodium_sys: No need for unsafe code. Having to rely on `unsafe` blocks to use the library is highly unidiomatic. This example code is fairly unusual in that respect.\n\n- [L66](https://github.com/pietgeursen/private-box-rs/blob/master/src/private_box.rs#L66): I'd personally provide a wrapper type around a `Vec<u8>`, so that a user of a library always knows when there's crypto-related data. Plus point of using a custom type: You can implement drop to zero out the content.\n\n- [L70](https://github.com/pietgeursen/private-box-rs/blob/master/src/private_box.rs#L70): Direct usage of libsodium_sys in the internals is totally fine by me, as long as that does not leak into the API.\n\n- [L78](https://github.com/pietgeursen/private-box-rs/blob/master/src/private_box.rs#L78) `(recipients.len() as u8 & MAX_RECIPIENTS as u8)`: Using `std::cmp::min` would be more idiomatic I guess.\n\n- [L102](https://github.com/pietgeursen/private-box-rs/blob/master/src/private_box.rs#L102): `Vec::with_capacity()` is more efficient.\n\n- [L159](https://github.com/pietgeursen/private-box-rs/blob/master/src/private_box.rs#L159): Again, I'd use a wrapper type for the return value. Especially for decrypted data, memzero on drop is nice to have.\n\n- [165](https://github.com/pietgeursen/private-box-rs/blob/master/src/private_box.rs#L165) `&[1; 32]`: Why is this initialized to ones instead of zeros?\n\nI hope this was not too pedantic =)",
    "mentions": []
  },
  "signature": "NkII936EgA/7Z6vQ+OQoDpTxPXqKzio9HdFFepDCe/k3NqFR9ASsngt2TnBddo2aB82C76UAbn+NEcGyy36MCQ==.sig.ed25519"
}

{
  "previous": "%6IVnebYmOzul09g4/+WKVlsTqK3B77iR5Vfzfx18oEM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 469,
  "timestamp": 1515236340932,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%6IVnebYmOzul09g4/+WKVlsTqK3B77iR5Vfzfx18oEM=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Uh, and I forgot the most important part: Awesome work [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519), thank you so much! It's so nice not being the only person working on ssb-in-rust.",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      }
    ]
  },
  "signature": "zdGHpiqaVj2KS45caBkPL4i60Pdj0bDHgdaxa8FfnIno6ElgBOLW/ZqwJ0NonP2q+Wtom8IeJOkhMKQm+0u2Aw==.sig.ed25519"
}

{
  "previous": "%NUljTuLxTuzBzvusL/ucGXwPxYHMx37uyNQcxeim4FQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 470,
  "timestamp": 1515236349569,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-implementations",
    "vote": {
      "link": "%pTsxrzxe6HAw/R7JL9f1S+8ssWwbvVuUCIQwaVFG+Z8=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "xytphGr65iboD9V82PfYvePaZe6ra6bEYN6OS3fcpsBwNeBmBAQcgqLvd2uDP5U6MkTv2NQNJqJ0G89c3qixCg==.sig.ed25519"
}

{
  "previous": "%va7PPNwEycp/0K4d53k+p/GVTIvvIPwrKg1lcAJU0Os=.sha256",
  "sequence": 471,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515275149200,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "packet-stream-rs"
  },
  "signature": "yoX9mm8Flf8zRBdWwjGvSVVPHIc1mxEZ5WVtjCqq9l/pQxocIIY+Tvm2Yj08yJpSZVktJBvZd+hNlIeokhfWDw==.sig.ed25519"
}

{
  "previous": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
  "sequence": 472,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515275153156,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [
      "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256"
    ],
    "packs": [
      {
        "link": "&1eQgqKh5lWCeiYd3MKeE4xL4LK3Z9Cs8w1KhviU5q/4=.sha256",
        "size": 7832
      }
    ],
    "indexes": [
      {
        "link": "&IxFNhgB8Drx+38HYTN25V9NmEYYe8nakVgvPbwWsnxs=.sha256",
        "size": 1604
      }
    ],
    "refs": {
      "refs/heads/master": "bdd440abbe346b864b85c7729b309bf1a7b19d63"
    },
    "commits": [
      {
        "parents": [
          "e109d9b0077ce541571eb7653acdd4287644f1b3"
        ],
        "title": "Add sink codec",
        "sha1": "bdd440abbe346b864b85c7729b309bf1a7b19d63"
      },
      {
        "parents": [
          "fd0d33709c424ced210c4742f03438307c4bdfc2"
        ],
        "title": "Clean up codec",
        "sha1": "e109d9b0077ce541571eb7653acdd4287644f1b3"
      },
      {
        "parents": [],
        "title": "Implement codec",
        "sha1": "fd0d33709c424ced210c4742f03438307c4bdfc2"
      }
    ],
    "tags": [],
    "num_objects": 19,
    "object_ids": [
      "67ce92097a2c7235e0b28b0730f403750a47aa93",
      "4308d822046df995d72605f3497d02ae5ae307d8",
      "3ad5cd225dd3a402b587d8b59701c26e40b34690",
      "ede6f2c22e9f6ef7052d45779efb10064ca936ff",
      "442c1b049aae31bd3272f807e38a8b441339134d",
      "c8673ba3da557b298f73be3ac2c86a1ac4ea4a92",
      "05a1ccdf9375ff38374b3457efaac86fa87c1118",
      "13df5d25c6318259ef02fe5ec809e787147d331b",
      "72f49f9efa8e1a31a2548f892936280ff6326ba7",
      "c95ce2494c116ceea63b8626d5e72fd09ed66f15",
      "6d858c517a8c7e0590825f90e205ebc4e363d956",
      "31959d358b0f4ef934e46b100cb05e7c83ad0c23",
      "6ac70fa320488b21ab54f3a90c505b687a61b510",
      "575c8747932c5fee6d87d6ecc1550f6e14f28ab6",
      "5e8e6e89bd02b8f3ad02662dcd714e7f0e61362e",
      "7aeaf65705a2b53a018a06b98d4202b390976f92"
    ]
  },
  "signature": "kyzwEM8PQrc0kc9KNSYmaZAf5O0pHcmDxmaDXOf3Q651W6FmpjOXV87rdu2wexu7CWeisFjuKf6nMkQ3oAcLBQ==.sig.ed25519"
}

{
  "previous": "%xC7RLxSeufPy6YP4RoZ9gzeZvCaMZSwXrNze6xIhE8A=.sha256",
  "sequence": 473,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515275593927,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%xC7RLxSeufPy6YP4RoZ9gzeZvCaMZSwXrNze6xIhE8A=.sha256"
    ],
    "packs": [
      {
        "link": "&hFJfb2Qsc1k37NTav/82jFdS9nnzS3T5TRVPnSY5D28=.sha256",
        "size": 12918
      }
    ],
    "indexes": [
      {
        "link": "&iqvTjf4oPDCthPW1s7zLxZTpze+q4SOTOHQ9J416Kw0=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "e1660ed7066a73822a3a9e5444308900dadbbbac"
    },
    "commits": [
      {
        "parents": [
          "bdd440abbe346b864b85c7729b309bf1a7b19d63"
        ],
        "title": "Add metadata",
        "sha1": "e1660ed7066a73822a3a9e5444308900dadbbbac"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "1dbb1611ce3d1bda1ce8bf4e0da066ce7ac708fc",
      "41eae019d7809c79ed55f0c47f4708b2badbd418",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "cfb16f2444206e3eb0d9e03570ddfd79658d46bb"
    ]
  },
  "signature": "m4D43pbxu3jOTKqOGu5W0S1JBrjzAq2lUbDRODIby6gazPrLKgSdDpEsRynXzLnwI/r5H7Uo+FfazPhubZvRDw==.sig.ed25519"
}

{
  "previous": "%VK/HU9OZIpRfxFmx4FxcVsWpgqobxrmoNV2Vnc9xsXk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 474,
  "timestamp": 1515322530269,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%9psz2xPwGhGG7mIkTIgCEy/xX7r6uQDNQyjl0Nopiw4=.sha256",
    "branch": "%kmwd/+e8E6qO/54sBcL/hB1aV5w1GhpJIW/TgRsyBhk=.sha256",
    "reply": {
      "%9psz2xPwGhGG7mIkTIgCEy/xX7r6uQDNQyjl0Nopiw4=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssbc-grants",
    "recps": null,
    "text": "## An ssb client library in Rust\n\nDecember 2017\n\n**Summary**: Reimplement the [ssb-client](https://github.com/ssbc/ssb-client) javascript module in Rust.\n\n**Proposal** : %pYNveoqk1n1YobhscETnI/EE8aZd0itL0bnPqXIASzw=.sha256\n**Dev Diary** : %y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "mentions": [
      {
        "link": "%pYNveoqk1n1YobhscETnI/EE8aZd0itL0bnPqXIASzw=.sha256"
      },
      {
        "link": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256"
      }
    ]
  },
  "signature": "XSrhWGOCaOMM7xn6cfJkaxaMk2afkJXH9A3khU9IfSVuyyCVibIk9Mckb0B2O5cYzOylZ3hIx+So0x8EOu5lDw==.sig.ed25519"
}

{
  "previous": "%H+FY5tBY2mjm6zO07ao5tKrx3VSQ0e+cxlgu5d5p9rY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 475,
  "timestamp": 1515323347198,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%HtOaUIyVLYYctoFplqdc91HHjV5TrX3fcA2ZSnuy1Fw=.sha256",
    "reply": {
      "%HtOaUIyVLYYctoFplqdc91HHjV5TrX3fcA2ZSnuy1Fw=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "I'm using \"outliving\" literally here: The memory representing a subsink will always be deallocated before the memory representing the main sink is deallocated. Everything else would involve a dangling pointer. The main sink however is not deallocated on erroring or closing, it can live well beyond that.",
    "mentions": []
  },
  "signature": "4J0FLLK5YCNGk1/QDHGDkb7luXaBIEubZt2pP9VlCtIty7sVQawSroCmKYYz7zOAj4ua4z/cCBwQjIxxcuFKCQ==.sig.ed25519"
}

{
  "previous": "%22taC6nShCwTXdwGqTogwb6D47sjlhksjLbJcyELtCo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 476,
  "timestamp": 1515337531523,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "%AhkKYTCv1kNc6DJk4bYs1rnitHUJHP7V6/ebbnGa0wI=.sha256",
    "attendee": {
      "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    }
  },
  "signature": "hUgFKfZB3yxSkWu8O4R9jopDUxi1l9zXiQZCd5PckRdavguBHbNb8vWIxuBRJa7xAaqobMkVeogyp84OJ4BBBA==.sig.ed25519"
}

{
  "previous": "%I6COU0M5QeLHjwykwFXE/+L++b4o9PMGBppbra/dRzI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 477,
  "timestamp": 1515340911703,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@7snGJQdhw12HrUTzeaWMfxuBO8c2U75sG7sNkeEfYOw=.ed25519",
    "following": false
  },
  "signature": "hVRjtW+TBtGStXgmZz38gC2oWxyhyn8CRmLcJJk87tXEkI6DjadOEa0cV80e/mV+zFkKu9HXINhAWe6BsY5VDA==.sig.ed25519"
}

{
  "previous": "%pOwukIAqu2dnYcw51firuiI8NE38DprrtojZghXbLaE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 478,
  "timestamp": 1515340922816,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@0YTV22Eg35HneBaqZtbebkG5bTyRZxxKvjnsYtI2adY=.ed25519",
    "following": false
  },
  "signature": "f0ZM8C8ZaRztTX3mYlu3UgAbD+ZgbLXnTzTIFwNAAeSgvz6vSHvMa09VT7Nt3S3DvUFI7oGpO4qJzqs2aFGOCg==.sig.ed25519"
}

{
  "previous": "%Z9q5IKSDV9RxbW/AURrm0bt3mILFRxhh0YyW6ayW9rY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 479,
  "timestamp": 1515454521814,
  "hash": "sha256",
  "content": "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.box",
  "signature": "wvn7nOdXHI8oQG5G1KoiYXGbHPAUHldZmC44Kl5qRll3lzAlIHD1n60+VuEwZn0ggYcfIALHrsLN8O0PbRWMAw==.sig.ed25519"
}

{
  "previous": "%EbDxSjPC8Twyz9k7gH+z96gIzxQTBU0k+yMZwjyT5x8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 480,
  "timestamp": 1515506601776,
  "hash": "sha256",
  "content": "+QRiLAFGD4Bv43n8c8ZQDASJNUtji0qE+2dQiuJrSgA+WV1jXq7ei2MuNRXI/zUC5n5318lImDHQ1XehV6zDbBbofcLM4hEDlnQ1tNk0jmEariuwsWa90nHh4F3RIatS7QF06VsVdbZZA1fHhlOqg1nhHOmAcRx6DMF6fS22ZKLBEGi8sM09SogfLzFR6tiiKF2YPW9mqJP6+jUOoStqD8Fkfvmg88OXNF0Grhpb/J2aH+Tf6/UuvrSEkqZZSU+RInT6PcUFgzCkWaHcTws6i0apdDODjN6WYNj/9p7pTYvxjpFLQVTmzoivhalRtfeA7Hxz+EH5f1uWVujjr3GDs2VAIP3vtI+6R1CETFEMEyostzzbW0sigW+gq+aPfqydPwRo+Lur2SyGvUrVo+7gwO3l5ha+Oe3Cur0eLeiqGcxigm0ju5PxF9nSm0FkZyCCX7ThjXlYd6Cj0F/0McEniOR2GR8LbpB+SpSz9YWzv9Fztv5z3Ejy/EDRYFDyLmvV22vgdIkbb6IoZSFc/S6OFaZVSnrWKnIOOQjylXZdZDhcUHUVYURd9lw7B3tRAsGGcS9l80aYH0U5eKIZ0QyemfvMpkAxF0JDHmiwTI1vtTQ1UYubjV5ppabawsMmAKtuZljWkwv/QpYJtE+cSxV0VF7JTnzq3D+EmucvUjnDLFskZkfujkpBMUMm4jM3+rNL6G7eKQtp0/eBVS6EhfXs0VZ9bOWLpKSLjy680KntEk+rXuRenWc/XivBchyPc180TVy9FyHxLfFKuP57B8Gnf5bcRTSlMMKxUHpK7/0Nxroe5CnUGMh3SqNvR1B/FmKvtIi5XKGJwwGsfcAG2GttqeeZEDpYLuJw4HwjUjFKkfTDJn6awgHmM16jA4n8IUpoVdbmxfkQvqaDMoSswG9xquSk/RqM0M5SV2rlZqUSOXsexfAo90x4babhEG5jvFCp4upme4sZv8tcuE6s5SIqdUi1N36U6prN2jEdy6Ex5sX02rJPDqEtxoIK0R7QhcvA+YI/h5Pg0e/C7YAOr5NUBsVv4bCyPZn3bqmSIZqXMrjuEVOwlX5r66+H2KGlBZegDZGBUoJ8AKsxvC9IBPPlomOSM8P8wzy9fQaUdAU58FDsXktaJrN8xUZ1xbn5KhrI3ElrRWheJX69c+ADWiOjYD2LlAFm5PHcuIuK6kF0dpdUftDwWyrT1eI5/Xiu9vy0vuP9vshuuMtWyayNvzRK+SJnR+8SxhutgVzHLAzJgQn4KRnSihjHZRy/Cr0BB/a4+u0sT+LGYrbNU93Yqg47R092vnCfoZ6OoSXe8R4VKoaRX5zCa40AQVD7ZfV0JYQgMhJesbdO7iuVRMiCvQv2lifoktB0JASg+4PEKh6BZMlcg8pr/fgWmo+sizgmmTzZVusQVIh12lPthP5lZkV6dbkuOCvmlaByuRtk58n8YADwhH8aO1PrnY/1b5VO0OHiQg==.box",
  "signature": "vGe7wVbxkED2NmFaoCTkzG4GkKLfwugFX1qETmshpNDUiaU4KIiGFL5Hs3zgJ53gVdc9CfGbHPB9MGJSZiaKBw==.sig.ed25519"
}

{
  "previous": "%oPTcCTLPWfqNWNJHt6wsXKXIoQkI0PiQnIyQ1dw4Z30=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 481,
  "timestamp": 1515531419346,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
    "description": "[ssb in rust](%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256)\n\nhttp://aljoscha-meyer.de/"
  },
  "signature": "XWQQODMZ7UMIew8vj9M6iYDjsTVOOe0F5ftFCAiPuqr1QJRja/SVFYKDf7nqo0J9nVsqZnZJcfckTm2uhqw0DQ==.sig.ed25519"
}

{
  "previous": "%uhI/EAg07kVGs/kbdZxfvivrSZ0+8zjHIfCzispuww0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 482,
  "timestamp": 1515593383720,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%mQhpaM0zkSu/3jz7eg5vLnG2ki2wjXfMykO0n1e3aA0=.sha256",
    "branch": "%axa6BPuR4Y8brbDjOthXSNK4V9Gs46jdh3ZY2/0Eo50=.sha256",
    "reply": {
      "%axa6BPuR4Y8brbDjOthXSNK4V9Gs46jdh3ZY2/0Eo50=.sha256": "@KuVEJqnauqVDu7XcJn5tp/xy6iy6etvqTdnGV7OtaBs=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@mnzaki](@KuVEJqnauqVDu7XcJn5tp/xy6iy6etvqTdnGV7OtaBs=.ed25519) [Here](%gaYxXAEoSKf3dnw2OlI2EuoduFmkiU4kU+CncbBImPk=.sha256) are some half-baked braindumps on the topic of scoped subscriptions you might find interesting.",
    "mentions": [
      {
        "link": "@KuVEJqnauqVDu7XcJn5tp/xy6iy6etvqTdnGV7OtaBs=.ed25519",
        "name": "mnzaki"
      },
      {
        "link": "%gaYxXAEoSKf3dnw2OlI2EuoduFmkiU4kU+CncbBImPk=.sha256",
        "name": "Here"
      }
    ]
  },
  "signature": "cBpqz2UlCb9Cyc+vUmegn6p0wqAwaegyJMsMgMeqeFT4gO4SiqvPa9OkVtAuBaE7FtdUPZOw0yVVJI7i9X5EBg==.sig.ed25519"
}

{
  "previous": "%XIWmn9TUeh0mAwog3rQv7pkJ20cAViOUThX+IztWPlw=.sha256",
  "sequence": 483,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515626066055,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%VK/HU9OZIpRfxFmx4FxcVsWpgqobxrmoNV2Vnc9xsXk=.sha256"
    ],
    "packs": [
      {
        "link": "&i2xy8hLVC2G/hdPWjsfkSsa62hdV/qHhsJgwH6ZqBaA=.sha256",
        "size": 7931
      }
    ],
    "indexes": [
      {
        "link": "&jESKow6ucu/oPx/MA9vVCS1LDOQV5QnoeSfH9otdUFs=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "c9b070f1570bb145dbeb7ca7c6a278de69de93e0"
    },
    "commits": [
      {
        "parents": [
          "e1660ed7066a73822a3a9e5444308900dadbbbac"
        ],
        "title": "Refactor codec, add codec Sink/Stream",
        "sha1": "c9b070f1570bb145dbeb7ca7c6a278de69de93e0"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "20b79c4994ca265a3bb446809e379a468c6a23e9",
      "53ee92cd4698b619fa810e8a4090c4e259be13d6",
      "4a7e7cc78f952d92fe6bd9eb3fc0048cfcd7f9ab",
      "795241e3f27a5f217585c13fec4911a8b76bb191",
      "a7f0d517cb95a17701083c2f5035f06c4a66c9f3",
      "97055f67ed412f6654126cb8ccb72e9b8668649f"
    ]
  },
  "signature": "pCZMdrQsNAFex5yPg6DAIk1mDTyVUxfwZwuubgIAtEsvHp90BM6Z/YwAAcHuxSGdLtsU+tdUBvtvqDxz2ucRBQ==.sig.ed25519"
}

{
  "previous": "%c3jR0IvXsTJvzH7hADd4vke+/2U2rAmG0PSmqdPG1EU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 484,
  "timestamp": 1515626643672,
  "hash": "sha256",
  "content": "h6Ob1s9bTceYDI9vZjIiySLnwR/+mjs9M95XiHQTT0k9OH4J850OocGCQ2aVzBmyB9WVKTZXJFSel30LswITBePb4RaMDZ/EAPI57Eaq520Q9FSwu/oojsPEFrNwHSPtxq5kMNZpIZ3oWKcjt431sn1/vicvSNlHQC8l/w0xdFoFC5f3HCFusvQ2ZIgr1AZM4HkBTJlAzaR278c50dkENOj6vGJzRK0qIZdQp9QGIuhkmCI9fRmzjm0u8CxXhZdUYx4wVkJVfQVpZqG8Apw4f+HdnFHypnExQgaL0/z4k/f2W0u+5DNkPYzqb/Y2bRp+rrtTc8O9KBY/ZJNQ5bJ2s5ywzyh4FUDRG3E8V+ULXncDsXRSZBVyUSnifAeo0kuLKkDlF0EEjvSBoPObLVom7CFkj4ha5Gik/zh8JB/oOw0L/67sUZeIiTo2c5AIvOjuLancEhyzV5YeM/enNPaop/f2f94vOlVr8hoYYks3v7S0fShmgyQY3ArLamwFRfLyZo5CwYkWjHISvhQ1kTYekXafCMushDZLNFER6PXldmrH2CIxc3yuYs2aaZuvM7UdawtbCSWycxsizyU1e9ID73XVRR1hc0r9vX9Vh0DO6idAhYjLH8jzpysRhRf2rS04HiCCinhBY9xE4IC3VDPOGL5Ad0wTaAMdDtBolTY6h4dQOiIgbLv8Pl8ovIFyYtrSEBxb+DTi6f4/tV7bFZpXBIZISWoDObcNTqk+IhenPDDyFIEosevw01ZnTqUrUUKKximLQxU2YoWVI0CS1g/HZoEcVwZ6fHozi4KnkvFGcONQANMvHPistS9eXahGBTfBwu9WiwA3O3NNs4pMO57AeaUA+RTULArYh2LE2z37j8vvfR9klRCyv1WUZOI7Gy8+kLbdHuzLgjTi4fccT3uImP1xeVFdkFRRRuOx5uqQJmKoRUavsD/xjpeveeMEdZP9sV8vImXN84o67nVISsQQ8slybIt5/efTt0zn9jRBR7SBl1UzZPQFh+oR+N5w/aLkcS3FKTUfYHZYkTX5sJ9qMvIE8ODhNKS64eG20P7Mm6SwxBbXVo1RvbTjsdUnlTEXMCQMMg9Hui/EVoos58uJldKMRbejwCHtWWrqjxltRBoGPeTA+XRnlyffxz0MTtQv3vdYm+kLAwFnFvSsN7AZtLr7KUZdddr/IaGo8oEB5dwu5aEZuKTFISHYs8g3x/e4Sy5dFi4x8PTN9GnPHBHPIXYocWwZsp0VFhAquyTjqfbP7QaKtmBkddnxu+/SFTPp01YSKYh97WuBr7xl7G/vp4L5FgMv+EcGMTi+2kHGu+5PssKkC8KIQkyg6g6a99cTwAixNW1ObVnR1GTZqb8GOJ60oJZ3Betc7i5oRBJAdGfSnSSEp0vmiX1uNdzRkOCUw1hlkF6UidEoWIGZ8jfRtobSm/cLzi6iLQ4f0UcVKDyXNM/pMfGcmkrr2ZOjUhDE0/O9rMzngT+jTmsqzW7y8svrz2pqR2Of09EEGgDkCj9fpycIVtKkix3GZv56qR29W0QJIXoO9RIFLra/qBO6jutvIc5ZP5SEjM17FgXXcsK4OHPPnNsg+sf+t5VwcAH7kmxcDfOlez9MiXafJigqU/PtPYqfrJhm2iubrNG8oTlwE+7hlcW8e19TjOHyeyLX9kF1wL6QdpEdY2Zq.box",
  "signature": "EzeSpPRr+ZJ2yZ7kGRMHml2ieIZJ9iRz43LjxrSVripvk5O1OrAIPMh+Dx3iKqsMvx+9/aInliw69mHkJVR0Ag==.sig.ed25519"
}

{
  "previous": "%sDWclJNjeZgZzLWEeBqQoYMPh5Pg9jzLCQXUcshdMY0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 485,
  "timestamp": 1515660861406,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%nvrEFwpS1w6d9LCyXopypT/KyRvk/oB7zrAeVPxMPi8=.sha256",
    "branch": "%Jvw3Q2dtU3AaHtCBPhe7GM0TDQYCd5rY60SyP3Hj7tU=.sha256",
    "reply": {
      "%Jvw3Q2dtU3AaHtCBPhe7GM0TDQYCd5rY60SyP3Hj7tU=.sha256": "@ZqH7Mctu/7DNInxuwl12ECjfrAKUX2tBLq1rOldNhg0=.ed25519"
    },
    "channel": "protocol-docs",
    "recps": null,
    "text": "For archiving simplicity, html with inline svg for the figures sounds like a good solution. It's just a single textfile, and html renderers won't go away for a long time...",
    "mentions": []
  },
  "signature": "jf3Ed9nXpPp3sppal81fPrATgl/Uw69NMPY3ZIVurutkW5IsC1yvhqhcIFyTbfGx0gt+7rglddA9lGUghiZ+CQ==.sig.ed25519"
}

{
  "previous": "%1XcWytQMgFn/jYgRf9jX9BblmaDWMigkdUyJP3nbJm4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 486,
  "timestamp": 1515662107347,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%nvrEFwpS1w6d9LCyXopypT/KyRvk/oB7zrAeVPxMPi8=.sha256",
    "branch": "%LRa+fHV611DoPPKbqk51gOjrOc/+27+nUBU0/nV5e4g=.sha256",
    "reply": {
      "%nvrEFwpS1w6d9LCyXopypT/KyRvk/oB7zrAeVPxMPi8=.sha256": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519"
    },
    "channel": "protocol-docs",
    "recps": null,
    "text": "I like the feeds section, some questions it might still leave:\n\n- Why is there a timestamp? How accurate should it be? Where is it used? Is the field mandatory? Should an implementation reject messages without a timestamp? Or with bogus timestamps?\n  - I suppose the timestamp is there for database queries and otherwise unused, but that's only my guess. Can [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) confirm this?\n- What is the purpose of the `hash` entry, if it is always the same string? Why does the id computation not depend on that entry?\n- Which base64 encoding should be used? Another part of the docs specifies it, but only for its section, not in general. ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "fQb4k2TrWpijAXbZbYo/2dlT3oVaNWHSI+seoJhTqcydlUp9GqF69SDpqd4nKB7pLVdGpK3Ch8qnxCrhiY0yAg==.sig.ed25519"
}

{
  "previous": "%4eTbrIce3BnBzTGklZrI3BUL1F9Yw+Z7ymVn0u6Nmr0=.sha256",
  "sequence": 487,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1515669282782,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%xmaiCBaEKCXPo2yJbqsoeK8Re3tp67cjOSd6IOS847E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%x8vej9zTU00DFeYygXG9FtxQsWUfFyTEwNhDdHNINts=.sha256"
    ],
    "packs": [
      {
        "link": "&WJed39Xlf8Ud3xmJdDCsRLnAwx6fuyvKFw8xD8p0cis=.sha256",
        "size": 4327
      }
    ],
    "indexes": [
      {
        "link": "&skV39RcYvX8U5g/o0gv+2WdGiY8/EEXvow81TcO2trU=.sha256",
        "size": 1352
      }
    ],
    "refs": {
      "refs/heads/master": "6dbe15fd26be97a52aece04d260387d46f724dbc"
    },
    "commits": [
      {
        "parents": [
          "58648a33aa23e9047ffcdcd9e2648511fe3bf9ef"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "6dbe15fd26be97a52aece04d260387d46f724dbc"
      },
      {
        "parents": [
          "baeb49f4ab6a6ecb621b7b64951986bed7f43ea4"
        ],
        "title": "Use references in key_fn",
        "sha1": "58648a33aa23e9047ffcdcd9e2648511fe3bf9ef"
      },
      {
        "parents": [
          "f4019f43e1eee92a8f28c6de47af4f8eaaf9b2f2"
        ],
        "title": "Delete unused files",
        "sha1": "baeb49f4ab6a6ecb621b7b64951986bed7f43ea4"
      }
    ],
    "tags": [],
    "num_objects": 10,
    "object_ids": [
      "2da37e4bf05d23ad696ca31f1f9dbe580899365b",
      "5c41afc7c5b3091335110a9d1c1c32441d248c06",
      "e9e97cc2ec46493ecac334c7430d6d20c40ca860",
      "0c3d7ff9e9de6d3c423c86394a64c97f29dc23ed",
      "5b8c76e1cc5e1c56c3dafe18b8a89837d4fee25b",
      "09286ee9625763b0ceb979602b8524e2b886df96",
      "24b5f5b8b9030d44bbf53a9f40f64637433dfab6"
    ]
  },
  "signature": "1q9gUtlg0tazzhajdvITGCtrczVkvQ3SFD/i0lLznmj6huQCB1RCjo/dOnc9bmQAENphWEI0f6NWXqt7fjJ+DA==.sig.ed25519"
}

{
  "previous": "%s8bB6cy9g9z+d9a1UYIsp9u1/LUgl4MRCuILRc2dtaw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 488,
  "timestamp": 1516053315065,
  "hash": "sha256",
  "content": "mHV8LG9INH7lYks/MkTE9Sd5y2amFXiK8xtxPft1oPt71Tz8io/+VekQWdahSVEl+cknpWuX12vOtsn/PI69uIc+li6gXZvIJ16/VSZeZ46CYSyrl178E6s6t0HD1dqkIQyBlc24bRhgsr5EfXd8dxeqBO/d+IzcVy609cJ44+8R4vQmWn+/OuJ3CAJInXIGxMCeeWwOgJuhgNngc3WkX8Rn2r7iv3OKgVaFk1pxW09PExbzVsXT6lG9ziCvpGBGMsSxx2NGOxnRWTtZzU8JdZVZO0Wx7vztaQs9kB7kQRyGa1+qCFuhybxMM0yDVozT+Yvef5z2fhPjHvcFkNrgrzg5EUBb7G4tVmQvHjsaPBnQF+bAcAqqUEHxle1dkhXJfrkRHvCXwMX/Y3foUrtsvodJUUSpEJefNgXkUXw5PF5hKcGjrsb8yQt2PB4ZnjOGINemleYLUC/Cuj1Q1M9s9B5t/IRdsHSQP9wuDzGgNey2AVxvG/dcJJVeJjf99VvlgwvfOuB/jlE08aA1KE3j4P7LgyqfrcpjPrrpc0OzjGprDMC1j75M1XsZL9po5Y9ifBGaojjWgnE4h6kjSPI/Jl6+o3ze/2oB41kndJIhmO+N6nTqfZI+DlkPyO9o/s/go3H3s8oCZQ7rMDTLv3OsjIuA7y6nOgbBf6H5lZw+8i1RpcgUhUs05it+GZHFzOToblerpMFRPJEsDPJNNmWTnHfN89x4d0a6SzbI+CcpKqSpW0PdaE//BMd44mr6J/EugfI1+W2THT6dsUtlDNtX7fXRpWNggJOf6yfz1rXOIYdSFRYRdgQWhSRopj5yTIbzjYN2cqlkga0npgitYRP0KuYjbB6PPljxnbpqdYr2SxlIoZ9hdTl1iOKfs4O/EZ5FQhBdQff/xUDyxOe3Xju5KhivAlD3rs72TnpHcZrkxysTe1rGJ1A9HfRuh25ByWUvu8Soe4Hlb6u8TmVr5xi3bXEtSSOEpB7XkQdiofM0Zg==.box",
  "signature": "Ke9WymB24r5lceg767XOWHr58WQmE8uLd85LiS1T0WVLFIqnBl9BR8TMZeAgFmz5RAfQqacg5WVs4GGN1dgeAA==.sig.ed25519"
}

{
  "previous": "%oHRpQpVDwCYaRTDpnCsjXYgVgCWJi0LgsR6UK0k+9kU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 489,
  "timestamp": 1516382347730,
  "hash": "sha256",
  "content": "rc78a/+GYT8V+Jbk1zE70HNdki6bgiMFBV5Sakol+Dyx/0kT9v62jpzHoo1dRMR2c/z5nom9wWTvsGKw+ZOegwd4pGCBmNysAw07lQ5q+LPSjDEYd+ZOixwKyzU1TVb6dXgpPvl0ULyXIeqsP+dOpIhr80KvuLPQzvz4yx672EiC81yiQsSIYJK+mTuhzVS98fOpvi8Ew2bDIy8NUrDIUJrcpl6LEOl41HTPrQNchhnk/2lfsWrra7XISaICM4QxqxEtLY/aNfy0YnBGrSq6rK3Rk/JK7B2kGMH30ylatXDZ6YyRk5ytAUtn0slUKfNClF8w2TVDC3HDnLIvmgPY8vEmww+X7O8NqVQ/r9AwNw2DukYS3b9WwHYdPmMjA7/T5hhDy9YXlplVql0G0U0ogQbcdojKFQ418Zg1pN0kBld9whxENddo11U0wYBcx06IvlyJiv0DqsnMaKrDVk74qtQnwmmzUiUQOvXsLIUyiuSHvAuQN5v2UN+WsHMIvC/qRQSDqwob/P1PK+ChWHDVBbsPwzjHJnhdbFbGmxrGq6tI4wUcpFCqQysYpC4pffKxoF/o42OOYN2evFcmRBJ/xLx8b+hpQrgFj3fOqgaSYMtH+ekvAzWQ8HUSm5Hm8YWVEpU2+5rT5KhVArK0rtaXVjJrUIMN7yUPUy1Sl125/br1uiPwysYsAW3fKqewxgxWU1+9ACx4zu7haNeq3atbIEBDgHkjTPCUs4CzS09iu6US4uBxNW6pFWTrevqE6dYwPjoCUhwk+9Mz7rDYeD53X7vwjPKv16/r5JkcGnzZ4j96E0llCLkgYX5EE92ejzw14LO645FgFCv78kqXprvWOAlTvqmgeQ4SObjfLxCU2lEA5PUNJgwhuQq7wjmR7wHQjfKw6ZW3YtXUpaqCwvnZRnm7160JxSUJVADu0k2//8KrQbqhcbJDw4BHFuSF3OJeykuni1YEyON/4Otx1K/VAsKqr4flIrXJgquU+Nrvr6FXeUvLgrNSSEYUWTcG0YjtHc0e+e75iwN9WnWrEaZw5EjydpZrMeRpLDE6aILXk/hvik566r9jT0EjtTOLm2/5PsOom05Rl1MUAhm5hZdfLFgU64miEbAK7fEhxqnyLWPbM+Wk7L29AOrAER4w5m8yoV93rAXgZmLK7Fkm/gpIaAZoOi1T/ribxMc3wgOs3ZWtpkYjFFxW.box",
  "signature": "TgKzNEMgOBPU+gftRqC+gKQbpqX0tpF6WqvdXDEknq9CvSg8r0XSzpeL0502x9Cs2ksSjxS73tv5z+oM5Qx7Ag==.sig.ed25519"
}

{
  "previous": "%JvfWAXMeE9EQWXXWF72mVfrMdGDaQ8/L+wIoCN/23TQ=.sha256",
  "sequence": 490,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1517259667764,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%c3jR0IvXsTJvzH7hADd4vke+/2U2rAmG0PSmqdPG1EU=.sha256"
    ],
    "packs": [
      {
        "link": "&csA7aYa1tfpNt+01Ukm54n7aZI5k+XRUmeDN2aORNVQ=.sha256",
        "size": 8916
      }
    ],
    "indexes": [
      {
        "link": "&CQ3WdMkZApzQW2989ponXfiTgUTKMm552OFQ16WQu8U=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "7d6aa1006dd4b7961aa6dc1607ba1e4fa4800729"
    },
    "commits": [
      {
        "parents": [
          "c9b070f1570bb145dbeb7ca7c6a278de69de93e0"
        ],
        "title": "Implement requests/responses",
        "sha1": "7d6aa1006dd4b7961aa6dc1607ba1e4fa4800729"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "8e67563a7d08236ffcb72e3ffe82442c50d82cde",
      "c48b0b024113480a4a4a7d6e4bbb1b5ca18724b4",
      "1846a85d67d6fde9df6b7b894732240af520b3eb",
      "0bc7be44196aaca92fc6779cde6eecbe03d54a48",
      "fe3c57724437285a42bd1dfde2111a23752dcca9",
      "e572bbb0197fa5a37b88192c49c95f51e4a07002"
    ]
  },
  "signature": "Xy2CNpvgT/wKsqQAamJjdYyyCQtk1D1nHTZ9VxOmM7m4YKh93ymToW1F7/2RksWax8w8FswuObIkLIjDeAf7Ag==.sig.ed25519"
}

{
  "previous": "%ZgolawsnwgQsVJe7L6+UMoRZ4CqS/RVZ5xRldiSHrI8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 491,
  "timestamp": 1517400999113,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%22taC6nShCwTXdwGqTogwb6D47sjlhksjLbJcyELtCo=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "This year started out with life throwing a bunch of unusual and mostly unpleasant situations at me, which is why I did little to no coding. But things are starting to sort out (and a lot of these situations are actually turning into something positive), and I've been able to do some little chunks of work again. I've felt pretty bad about not being able to work on this as much as I would have liked to. In a big surprise to no one, putting myself under pressure didn't exactly help with that.\n\nAlso, a lot of the coding has been rather frustrating. The `futures` crate promises zero-cost abstraction and easy composition. Either I'm doing a lot of things wrong, or it's just not as good as it presents itself. A lot of this boils down to an [API design decision](https://github.com/rust-lang-nursery/futures-rs/issues/458) that does not leverage the type system but instead aims to improve \"ergonomics\" in using futures. With the annoying result that implementing futures becomes a constant fight against the compiler.\n\nAnyways, so I've started fighting the compiler again. But just now something unexpected happened: I managed to win the fight:\n\n```\nerror: internal compiler error: unexpected panic\n\nnote: the compiler unexpectedly panicked. this is a bug.\n\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\n\nthread 'rustc' panicked at 'assertion failed: !value.needs_subst()', /checkout/src/librustc/infer/mod.rs:629\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\nerror: Could not compile `packet-stream`.\n```\n\nI originally wanted to report that requests/responses work. But for now that's just speculation, since the test code blows up the compiler...\n\n#rust ",
    "mentions": [
      {
        "link": "#rust"
      }
    ]
  },
  "signature": "zbxx6apVMOOinaSFZKJnwajkVqdcwu/JKNNQ1WU54akWCiUirN84Zal2b99j41u7VgPQC6Ictg5SPzu3AO1xCw==.sig.ed25519"
}

{
  "previous": "%VWBg33iDY6Pm3ywpBq92TrDZ9gTLbVFFZ23qfPbej0E=.sha256",
  "sequence": 492,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1517401929443,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ZgolawsnwgQsVJe7L6+UMoRZ4CqS/RVZ5xRldiSHrI8=.sha256"
    ],
    "packs": [
      {
        "link": "&gI01PbKHOZvLS/JukSkiCSv2zZywuFFa/4qCW7GIvTQ=.sha256",
        "size": 4493
      }
    ],
    "indexes": [
      {
        "link": "&ogz+fKJ+JPoCrDbRUTvh9K18YrKziANy7lHoA8hmAO0=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "215e8f1476c141a5d01e1a19134f872ac8792377"
    },
    "commits": [
      {
        "parents": [
          "7d6aa1006dd4b7961aa6dc1607ba1e4fa4800729"
        ],
        "title": "Crash the compiler",
        "sha1": "215e8f1476c141a5d01e1a19134f872ac8792377"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "4e1039ef176be6858fd6de44893da6e87a1b0bf3",
      "3160a838ffe454846b2618ebe500f72184190908",
      "6f6fbbfb4904163965228c694005bb292f3fe433"
    ]
  },
  "signature": "/8mAmxaS84qCAgagDV2nMzBH6dbpbhQYTuseZBVGKgYqfKGXjmVL80etTD2fkNQ7Kh+DU2CEoXw6vfvTU8MRBw==.sig.ed25519"
}

{
  "previous": "%epfv9T/zMO8CAt+eU1sRN3Adddug2tR7ufFmvJ80G4M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 493,
  "timestamp": 1517912086972,
  "hash": "sha256",
  "content": "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.box",
  "signature": "odfBavbI8XR3RsybvznF/AU/PngpgZQPsCQ+O9eob/MYpzpvl6euvoo/5+noi2+IsM7OQkGRuBMDNBuFGXd4Dw==.sig.ed25519"
}

{
  "previous": "%SvNo9uoYVRNCf57JQGMh1huQb+gPrT/s2eHuNV9wBx4=.sha256",
  "sequence": 494,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518259984775,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%epfv9T/zMO8CAt+eU1sRN3Adddug2tR7ufFmvJ80G4M=.sha256"
    ],
    "packs": [
      {
        "link": "&ZA9k7l4sbT9+SP8G+Yyg7CzVkDVon2AMcWoM9dF8go8=.sha256",
        "size": 4828
      }
    ],
    "indexes": [
      {
        "link": "&ukpBTGO55N8QbDo+C+fzQ8Ihrg4Y0Lv1/19wobwlbvo=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "be5c9af0dc21a3d1e46f1b02bbe560b0095485f5"
    },
    "commits": [
      {
        "parents": [
          "215e8f1476c141a5d01e1a19134f872ac8792377"
        ],
        "title": "Backup",
        "sha1": "be5c9af0dc21a3d1e46f1b02bbe560b0095485f5"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "0f6b384979ea52a2a5fca207225d94f86785f1d9",
      "125fa2b732abca9a7d44e7a300de940ac27422e8",
      "64021175d14b2731e646ddf7f95135899df46865",
      "7c85494e9aacc121d8278406052c13735242905f"
    ]
  },
  "signature": "skO9dTLoGMIwK6UJ06hlKutRClJ830Vb1TqgDL9MKx7O2V9i2AC3Ai4dLXJwbQlGqZBuLKg/NryFHHN2qVnYCA==.sig.ed25519"
}

{
  "previous": "%ATkB/vHbAtcmgikBwxpWHW7TbH8CFTlWpE3JIM8yHNc=.sha256",
  "sequence": 495,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518266659240,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%xmaiCBaEKCXPo2yJbqsoeK8Re3tp67cjOSd6IOS847E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%s8bB6cy9g9z+d9a1UYIsp9u1/LUgl4MRCuILRc2dtaw=.sha256"
    ],
    "packs": [
      {
        "link": "&KDWSBWN6JqbZPBc0BVqoS4vd4LMUTKREHrT8ipRU2+U=.sha256",
        "size": 4656
      }
    ],
    "indexes": [
      {
        "link": "&Bm7s8yiKpqGLAna+D/5U1p7dx7jJHY9guhOup2CS46Y=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "c1a5d36ee05a60b68211b8b1d89676d24ab935d9"
    },
    "commits": [
      {
        "parents": [
          "6dbe15fd26be97a52aece04d260387d46f724dbc"
        ],
        "title": "Add reference counting wrappers",
        "sha1": "c1a5d36ee05a60b68211b8b1d89676d24ab935d9"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "8a0ed7ddbb67aafeafaa09aa6e09e9db88e879f2",
      "665a5be537eadb2a518fbbe4a78582cbb51dd4a8",
      "629416dde70af68ed47626d0f4f4a47da914843a",
      "bf05836d2f86ddd2adc25a529f101ceab891fbd3",
      "08000841d8bcece7ef277022ca2ceb0c328b1abc",
      "cb45ff22848c53b2bb1d92434531d4ae1d41f22e"
    ]
  },
  "signature": "c/LWdEZhcaaxEI2Jb54qWC0LypwZPlGpUhuD3U7wnW2Ls+pWsJGyEdgeVZBaiI1ngS0cU2NO3YhpF1hoatwyDg==.sig.ed25519"
}

{
  "previous": "%DvEebnBXrw1AUEoqb3JBdW1j24V+7kUAfjQEKZxWtuY=.sha256",
  "sequence": 496,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518266705589,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%xmaiCBaEKCXPo2yJbqsoeK8Re3tp67cjOSd6IOS847E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%DvEebnBXrw1AUEoqb3JBdW1j24V+7kUAfjQEKZxWtuY=.sha256"
    ],
    "packs": [
      {
        "link": "&P7aXOJFYhv/sH1uvWWNeRnTZJTv7bwVSo2oawijdfdY=.sha256",
        "size": 694
      }
    ],
    "indexes": [
      {
        "link": "&V6gQisIUgwlqw29giaJzG+A1Z6qlkqrWVEU1eZlG+gI=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "39003f27390a44ea335f8ec58a89df3c77ec8df3"
    },
    "commits": [
      {
        "parents": [
          "c1a5d36ee05a60b68211b8b1d89676d24ab935d9"
        ],
        "title": "Bump version to 0.2.1",
        "sha1": "39003f27390a44ea335f8ec58a89df3c77ec8df3"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "6e3805bec42902737de36cf11637c0094f8dfc97",
      "eab5bdfbf8aef67b55ffe7d34eb601bf7d9d5bee"
    ]
  },
  "signature": "B4rhgjnTfd2t/yF9U8hazaVkL8j7EoxcOxf+GxeHfYFkNiacIVtH+PEy7MQQDzJS5nNBB2eMXCvvFOD2DxchBw==.sig.ed25519"
}

{
  "previous": "%W+cLjlDKrIQMIQFIQlK9g3atAC6V/Yyy3rUkitWmxLI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 497,
  "timestamp": 1518286881541,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@dnr1swLSAgf36g+FzGjNLgmytj2IIyDaYeKZ7F5GdzY=.ed25519",
    "following": true
  },
  "signature": "ok1qndAbF6mrVHbX/FbjCh7RCYZFjwO43cR9UqR12kF6JUQxHL0EvbJWek/oH9mJ8SnO0T1AyK+5q4N3OKkzDg==.sig.ed25519"
}

{
  "previous": "%z2RL+PNa3Gg1LmI1jyRFQvz6xI7tizWyqkDpA4LH0ZU=.sha256",
  "sequence": 498,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518363081972,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%nsCrlf1l/qJFMFeBactn5Yj8Xjq1kzCslUycgik5XdE=.sha256"
    ],
    "packs": [
      {
        "link": "&iiQuI0TPPa9B2DZCBKkIqReWRiaYERpxAfIr6/OraUI=.sha256",
        "size": 3102
      }
    ],
    "indexes": [
      {
        "link": "&A5sl64vWxms9AnXDLStpdu7FRpfLXGm7tUmsl0Q93yA=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "9122953f90ac23675084086e6778ee44e8a050d6"
    },
    "commits": [
      {
        "parents": [
          "bff21b5c00ffc3f71681fad0526bae21c4ff823e"
        ],
        "title": "Bump version to 0.1.1",
        "sha1": "9122953f90ac23675084086e6778ee44e8a050d6"
      },
      {
        "parents": [
          "d6009315424ae33e3e4bc15092db74968f2f3d5f"
        ],
        "title": "Fix reference counting for closing",
        "sha1": "bff21b5c00ffc3f71681fad0526bae21c4ff823e"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "8a77409ef9442de24be702c522fe84e9e4b4545f",
      "a635b0e8984fffec4e0d28824c609fbf2141374d",
      "0c4bffda2a1ead4bb1d482622a3cf3d52aaa5365",
      "fc57cbb660d587c50e45b2637b81bbd5b638865c",
      "62c256a0631d47655df21ff31e1e1ccbaaadf9ab"
    ]
  },
  "signature": "CXmatSlwfL0xHP8XvLnDTZXXSEif5bjckUYNY8ee+7+Po0SPvkFufd//2O9T8ILhnW0NHiZO3hCRRI1N20ASDA==.sig.ed25519"
}

{
  "previous": "%AfExRNUanmLs2sUKc/Ut3YGlr5Xfl38qVou66M3sC3E=.sha256",
  "sequence": 499,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518363450211,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ATkB/vHbAtcmgikBwxpWHW7TbH8CFTlWpE3JIM8yHNc=.sha256"
    ],
    "packs": [
      {
        "link": "&CgPXvsjftGZmPwbyWzdb3EfwABBo9DtLeNyeY6Xo/ZI=.sha256",
        "size": 4691
      }
    ],
    "indexes": [
      {
        "link": "&bSz4jeX9C42KDN9RQPFoCxIT0efQ00AUZNfa9uOPucY=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "d2b7bdc10d523990ad88984d43fd3d422c19aab1"
    },
    "commits": [
      {
        "parents": [
          "be5c9af0dc21a3d1e46f1b02bbe560b0095485f5"
        ],
        "title": "Switch to rc, implement requests/responses",
        "sha1": "d2b7bdc10d523990ad88984d43fd3d422c19aab1"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "4fc8e9ec391c1f6dfab470c45d36c91157c9d3ef",
      "cec16081c81b4f3814a2cac82e1ac1a18e247a81",
      "93d642293d3bf3b4159263318c3fb4206a32de90",
      "6223e5ee043713a97d76fbb20c04173effad39fb"
    ]
  },
  "signature": "pKqdYOAe8xMtigKUOUu0uFSx6Jwl1knnG4/6ZQ17QAl+a1md4L4TVkP0nI8eU8OBf9igbbRDiE1EXAvrWWoHCw==.sig.ed25519"
}

{
  "previous": "%xiPZJF72QIrelBo/NdZ+XlLjSLG85SqFPByqq6VluaA=.sha256",
  "sequence": 500,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518637453259,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%xiPZJF72QIrelBo/NdZ+XlLjSLG85SqFPByqq6VluaA=.sha256"
    ],
    "packs": [
      {
        "link": "&RI0wI793/IEobfp8QWwByjMQtYxkm1MRg02Sya9K9XQ=.sha256",
        "size": 10323
      }
    ],
    "indexes": [
      {
        "link": "&UWECW0JP9VztWN5BdPip41zIZrRf3Llz1mjgS01W/UQ=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "becbd36cbeb715ae7c36da2e4834345ba48aabd5"
    },
    "commits": [
      {
        "parents": [
          "d2b7bdc10d523990ad88984d43fd3d422c19aab1"
        ],
        "title": "Implement duplexes",
        "sha1": "becbd36cbeb715ae7c36da2e4834345ba48aabd5"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "3b3a4ad386f7a921ac98b29ef4aab74b3f17cb4b",
      "870709a8e80309ffbaac6be5bc3bf2dc58e92749",
      "c157119eaa3f167c8140651760057df87b487937",
      "fa538afc949d413e472018d37f0a6b487d8d4378",
      "78d86ddbbf900ad64f1890d4483dbe4875d16bc2",
      "7b988cdd1be1f3b4b3193ccfa41dec6440a73440"
    ]
  },
  "signature": "MbXrKctEMrJFJ4QcwrMe2283HyF2ScpUqWwoRgBH29txGn+WTCHxLyz9MMemwR4yFJk5tgrEW1eH3jnjdw05Bg==.sig.ed25519"
}

{
  "previous": "%mFiiRZ9+uFDRaTef47CaQRSWA/M8gvOHMaRr4GHYgSw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 501,
  "timestamp": 1518639345539,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%VWBg33iDY6Pm3ywpBq92TrDZ9gTLbVFFZ23qfPbej0E=.sha256",
    "reply": {
      "%VWBg33iDY6Pm3ywpBq92TrDZ9gTLbVFFZ23qfPbej0E=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "At last! [packet-stream](https://crates.io/crates/packet-stream) in rust.\n\nI gave up on fancy lifetime-based resource management, this simply uses reference counting internally. The overhead should be negligible, and the final API is pretty clean.\n\nThis module took way more work than expected. I learned a lot about rust's lifetime system and about mutable aliasing in the process. But even once I figured that stuff out, there was still a lot of debugging. The asynchronous programming style imposed by the `futures` crate consists of building up large state machines that may suspend their execution at predefined points. Getting that kind of code right on the first try is beyond my abilities, so I spent many frustrating hours debugging. And I'm not even too confident that I got everything right as of now...\n\n- - -\n\nNext steps:\n\n- provide a secret-stream module that combines shs and box-stream. That will require a breaking change to the API of my box-stream module, but that should be mostly mechanical\n- implement muxrpc as a thin wrapper around packet-stream\n- start `ssb-common` module for data types used by both ssb-client and (the as of now hypothetical) ssb-server\n- start `ssb-client` module, providing statically typed wrappers around muxrpc for the well-known rpc methods of the ssb protocol, as well as direct access to the muxrpc connection so that you can still experiment with stuff that has no convenient helpers defined yet\n\n`ssb-common` and `ssb-client` will bridge from the json-based interface of muxrpc to static typing in rust. The main protocol logic will be finished when the muxrpc module is done.\n\nSince packet-stream in rust turned out much more time-consuming than anticipated, I'd like to wrap up the grant with starting the `ssb-client` module, without actually providing wrappers for all the rpcs. But at that point, contributing will become very easy. There's not much you need to know about the resource-management and asynchronicity issues behind the scenes. So I hope that the final, static API will be created collaboratively as needed (and will also be extended collaboratively as the set of rpc methods grows).",
    "mentions": []
  },
  "signature": "NM+jr/+9/2XWhfRAQ/aaNG6JYUmVIvGsUzwIBbP05wneWNG4Q5YoLc6sFspjiWRrMzUVO26dCmALefS3keDEAg==.sig.ed25519"
}

{
  "previous": "%9SSlQynYeZSV5K/1YZsIq17QHnTOADP1Um1GJEDE5iQ=.sha256",
  "sequence": 502,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518709661871,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%rqS4wd7AKFA/Epz+eQyrKVWRtb7HYOLWY0d9GaPRPg4=.sha256"
    ],
    "packs": [
      {
        "link": "&W9+n9olJt614d8DpsNA+5YSyyE7NyWunla9UTcdT++w=.sha256",
        "size": 12200
      }
    ],
    "indexes": [
      {
        "link": "&E+l3MpkEXtjkSk0WjUJTW8YjaqPmd9debgvNqEX2VQ0=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "6c0b793275234f382df41711749326ae70587c81"
    },
    "commits": [
      {
        "parents": [
          "5b1b58b613296fd54b17f77918449f32110a71b3"
        ],
        "title": "Bump version to 2.0.0",
        "sha1": "6c0b793275234f382df41711749326ae70587c81"
      },
      {
        "parents": [
          "2b9fb56df2f33d86fc267cdcb12675b57260c090"
        ],
        "title": "Change API to take ownership",
        "sha1": "5b1b58b613296fd54b17f77918449f32110a71b3"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "9617952312f1c12d6360152f55d0e86ad8be3347",
      "97fc25bced6efcafe2f3a427cc7c19e4e4f7978b",
      "5a703a3a4d2142fe64e55e44a29fbb57d01bc38e",
      "f17b8725b224a344b09c47966a6466b361ec71df",
      "52fb883e696f1138afae4681df7e1b1d86382be3",
      "f035485b34fe954c7f5072bd676ae3377438a813",
      "e53d334168cd6f07dec1dd5947495d4846a58a09",
      "e23f29500f5b543a27ce5d7496033d81cf963cda",
      "bbf53b4ae5290ccdedb4b94fc7b4f71d839c6490",
      "a46970fdcf614d7115c03baa9baa5fec3694427c",
      "cebd94f5d8a423b72b6548f9c21f94c9db32f376"
    ]
  },
  "signature": "5QvlkfooyjSImxzzfLb9Qd2MhDELMMDgRtKkyzra1JmoZENB3TCw+94lw3P4VpCcOl0Af21eDEMrnl40y/FsDg==.sig.ed25519"
}

{
  "previous": "%DUuuknwBqNlrkEXJPjZWvj+6iMe5OftVyatYtcZvNQU=.sha256",
  "sequence": 503,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518718819464,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "secret-stream-rs"
  },
  "signature": "FyGV+pOkK8QCafd7wUfg+T30FXyop7rpQ3zIw8HG1ZNj8tS9loSvm1H3bof7asXPgYiDxC2BGHR9WQwnwNG7Ag==.sig.ed25519"
}

{
  "previous": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
  "sequence": 504,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518718824186,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
    "refsBranch": [
      "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256"
    ],
    "packs": [
      {
        "link": "&ehlu76VHVRehNnWirgfH1e6pyeDhR9DSIgwH1p0re28=.sha256",
        "size": 12942
      }
    ],
    "indexes": [
      {
        "link": "&XD0ds+q5jVeBT5zhK5nhQ45ZLb442+Et1sV3rlcx6jc=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "5089d2fed3cbcd4d469223949a74f695ab42c874"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "5089d2fed3cbcd4d469223949a74f695ab42c874"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "13303f7da7b333715f4e2aa57767a46e3179230f",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "e7056fd2174e7feffbaaf5d29e01916d8fba67ed",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "1fbf0fe756de9e2058f440fbfb8dcc0fc83242d7",
      "0c1087b2e9db8a09fa0cf49a9377ee7be12ad11f",
      "f309169f8456e8ae026346bfc624eb8ea7127065"
    ]
  },
  "signature": "w8UjqVUEiHClnjImrhC6z15lVA3uOOGsA1uDlP7LFXvp6+vx/gBfamoLLJXBZ10Dy/qgvgMCtg2jObdptuEqDw==.sig.ed25519"
}

{
  "previous": "%gSkETKdfWRX352I9sGOTvJvjOjVmeqNBxyBNymljeic=.sha256",
  "sequence": 505,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518728504736,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%DUuuknwBqNlrkEXJPjZWvj+6iMe5OftVyatYtcZvNQU=.sha256"
    ],
    "packs": [
      {
        "link": "&FD/MrrUf8m/4K9SUpnc/kNohgUGeeGy5HLyZOWqGUDg=.sha256",
        "size": 14466
      }
    ],
    "indexes": [
      {
        "link": "&RIVud2G7MM5bmGhvatvf6bMhl8KatT+35tM2KcUY7aA=.sha256",
        "size": 1548
      }
    ],
    "refs": {
      "refs/heads/master": "c4aa35611b691654454d5f37715249c90a784b8a"
    },
    "commits": [
      {
        "parents": [
          "3e5bdc00b35ec3d30cb461fc39f92fecdb031a72"
        ],
        "title": "Bump version to 3.0.0",
        "sha1": "c4aa35611b691654454d5f37715249c90a784b8a"
      },
      {
        "parents": [
          "4e901ddfee1e37a7ba69980adbfefa2b57f5861f"
        ],
        "title": "Cleanup",
        "sha1": "3e5bdc00b35ec3d30cb461fc39f92fecdb031a72"
      },
      {
        "parents": [
          "6c0b793275234f382df41711749326ae70587c81"
        ],
        "title": "Add lifetime for key pointers",
        "sha1": "4e901ddfee1e37a7ba69980adbfefa2b57f5861f"
      }
    ],
    "tags": [],
    "num_objects": 17,
    "object_ids": [
      "46d98d7202cda4f053a2f1cd51c122f9baba5ef4",
      "0a0a53594a1ce313f94998a196a513b204c03617",
      "ae69dc7b7193c4b40eef4e2e7410fbec530c2391",
      "faccc912d252de8bfef94eaf5e0ec6c188ff442e",
      "e8ac011910e8d7c98d0e2796715583e09e38969b",
      "acc801ea6dc24a823d1a361584cc2c7208833608",
      "e9366fd18fa53c232f472b47334b018dea5819f0",
      "6f076af51154b51db34b3aba1ad09ba325f89446",
      "6aae4924174b80ab9b323e51513d8d01edaa60c8",
      "7620758edfd5de9ce7ea00ddced6d86499bf85e4",
      "32d687c7d23f1101cad2935a6d2ccd8e282b6265",
      "c4b983b9d74500febe9b2428819ce184c07d1f5f",
      "a4f754f95eaf0bbe54d4e9f08f4acc9ed107a281",
      "e61f586b4f0b3979804781f1fd204a5232fe6ce1"
    ]
  },
  "signature": "aUmPz9ZN1LKnCemBosHaIpvzcaNTAbOaIS1MZCylUvyxzdtwVuPc/rvf4PM6wmYiRkXQNV3IJIwBKC+Pre4GDw==.sig.ed25519"
}

{
  "previous": "%HDxRgjLghtu0VujhefMS3qy5LCF34ot5jb0c3VYxnZU=.sha256",
  "sequence": 506,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518731122675,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%gSkETKdfWRX352I9sGOTvJvjOjVmeqNBxyBNymljeic=.sha256"
    ],
    "packs": [
      {
        "link": "&xDxS7Fg37u7iKnPAxV+0Ga6FK0pJAerzUgdSnLBpN4w=.sha256",
        "size": 2098
      }
    ],
    "indexes": [
      {
        "link": "&CdqLrqqqyat6djMvlNs7rkbUhm+TIuxuNIML5wTydI0=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "bd7145a70abda927b2a422a16dc578ceb244edea"
    },
    "commits": [
      {
        "parents": [
          "5089d2fed3cbcd4d469223949a74f695ab42c874"
        ],
        "title": "Implement everything",
        "sha1": "bd7145a70abda927b2a422a16dc578ceb244edea"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "d523199f370320844dc39adc05511ee4f38cf909",
      "996731026073af6e0452763699825fc5d54fb614",
      "30db785ed34789634632d75a18cfd662a80c76f0",
      "e7ece4d076dd805d581a9c828c35a6a89e727741"
    ]
  },
  "signature": "PzBi+j7b0M1+mzx8BuT+45DmGnekgDfnPVBjyL3KTn8dVtaJ41llwID9FS6LJ7wNrQ5pV0/TWdX0m0Rw1IR1AQ==.sig.ed25519"
}

{
  "previous": "%HFlgVOFegFuQc9/vBC+9qtwfjGffxQ2Vv1+o+BrHfu0=.sha256",
  "sequence": 507,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518773239336,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%HFlgVOFegFuQc9/vBC+9qtwfjGffxQ2Vv1+o+BrHfu0=.sha256"
    ],
    "packs": [
      {
        "link": "&85OppxgTIQS7iTvjhXeYwMQTOvfwiMq4brTeqT6j5Fo=.sha256",
        "size": 635
      }
    ],
    "indexes": [
      {
        "link": "&ONG3KDVvbUj+ZMznzHE/xjoCjktWc7qcLxhiaL0MXkg=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "2bf6878d6bf7ff720b8a4baed2212fa85208453f"
    },
    "commits": [
      {
        "parents": [
          "bd7145a70abda927b2a422a16dc578ceb244edea"
        ],
        "title": "Fix crate name",
        "sha1": "2bf6878d6bf7ff720b8a4baed2212fa85208453f"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "482e1bc2470c5f165144a8624741305aa0618cd7",
      "5af810b052cf82285b9c8d59cfadb345b79b5475"
    ]
  },
  "signature": "TJgeArtJQ0vhXup0ozYhEpoaVvyMdu3/fZDk+zkg+RJpaplIfltDxBZmDnTgqxfeAcE45LajuIlxDCHC4WiBCQ==.sig.ed25519"
}

{
  "previous": "%lCWZ+lRKmfPcbtbhuEyp6z2HPt5y7ulLA41LtLHQ/ek=.sha256",
  "sequence": 508,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518788870841,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%mFiiRZ9+uFDRaTef47CaQRSWA/M8gvOHMaRr4GHYgSw=.sha256"
    ],
    "packs": [
      {
        "link": "&CS/9MxcoSI10TYW1fS1HgyEiWah3v5EQPLp4Jhyi8AE=.sha256",
        "size": 475
      }
    ],
    "indexes": [
      {
        "link": "&1mDpkVWyyFbTN6mDgXLwgybfMUpZ1Clshxn/yK6zG5k=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "bddeec46437f350494adbd663631108daf26baf2"
    },
    "commits": [
      {
        "parents": [
          "becbd36cbeb715ae7c36da2e4834345ba48aabd5"
        ],
        "title": "Remove unused file",
        "sha1": "bddeec46437f350494adbd663631108daf26baf2"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "b82fac42f19e8bb84711b9b191138bcff23891b9",
      "574d97d709b12a6af7215276dd05bf87c9403795"
    ]
  },
  "signature": "aQKiHC3KHO/FvluCiYjJG1unbfh6X2UzHwHsY25bURHnz/vT6o1+PuVVHMp4qaq09EhPbFfZSwprnfpMa0s4CQ==.sig.ed25519"
}

{
  "previous": "%xrtU8+Ypv6lZqVNaksSH8h6PMDJ2z24lqqLMKXwidlE=.sha256",
  "sequence": 509,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518793035912,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%xrtU8+Ypv6lZqVNaksSH8h6PMDJ2z24lqqLMKXwidlE=.sha256"
    ],
    "packs": [
      {
        "link": "&dkLDb4jU/YNeAw+SDq8n8LtrykqQno3QjPHPVhqUj6E=.sha256",
        "size": 751
      }
    ],
    "indexes": [
      {
        "link": "&MpVcxrMQEUhTTXioVwRrxBjWFMnIPuGDAFXVJQOopqQ=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "1825a7b59ca2ab997d2bf2440b1d6fad46dcc0aa"
    },
    "commits": [
      {
        "parents": [
          "bddeec46437f350494adbd663631108daf26baf2"
        ],
        "title": "Remove reference to the unused file",
        "sha1": "1825a7b59ca2ab997d2bf2440b1d6fad46dcc0aa"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "23e770465acb2ff12bdc1e39b39aea220cae0eb7",
      "bae1617f1beeb7ee699d03451ee4888a3242d6ac",
      "2357ab5593028fd6ace74c70be28366194f06caa"
    ]
  },
  "signature": "YVenVg5/AOylAHQA8YuKsdRwE76kX6wW79BpCBS/iJzK1srJaWyAr0rz3A9jU4zhL+Q4Z9m+QyDwPJyhGCiMBw==.sig.ed25519"
}

{
  "previous": "%8nBk04ewR7oMpgZPEHiK27CPOgm4DmHvR7BjXhGJIoA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 510,
  "timestamp": 1518860309373,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%9SSlQynYeZSV5K/1YZsIq17QHnTOADP1Um1GJEDE5iQ=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "[secret-stream](https://github.com/AljoschaMeyer/secret-stream-rs) combines shs and box-stream (so it basically does what the js secret-handshake module does). Name stolen from [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519)'s go implementation.\n\nUp until today, I've been working on a bunch of disparate modules. Today I put them together for the first time and successfully sent and received a `whoami` rpc method (the hello-world of the ssb rpc set). All of the stuff seems to actually work!\n\nI'll port [ssb-keys](https://github.com/ssbc/ssb-keys) to rust now, so that I don't have to paste my secret key into version-controlled files while testing (and also because we'll need that module at some point anyways, so why not write it now...). And then, I can share some code examples on how to use packet-stream without any fluffy wrapper APIs (i.e. muxrpc or ssb-client) to talk to an ssb server.\n\nAnd after that, I'll start work on the fluffy wrapper APIs (because honestly, getting the whoami example to run was a pain...).",
    "mentions": [
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      }
    ]
  },
  "signature": "Ig8e/aF6r7JQ4nAiuPBnqP1o0VRn2VJT7a6uIq+H8DAJ17ibJti8s59ZgjlSiszd8ExApcffT9pX2Mx/G4P3AA==.sig.ed25519"
}

{
  "previous": "%/Ndd+7DxIxcF8wJdaXHk8HsA7RRTXURQFG2S+XbvvtQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 511,
  "timestamp": 1518861627171,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%1cmNsvktH2/4e+oOtnZ48dsw6j2hXKyqvQl0Dbcy50Y=.sha256",
    "branch": "%3tPUPAXnMuSRckVdM+IzhBbkGpBk3qdZjyx5wS8Ywhg=.sha256",
    "reply": {
      "%3tPUPAXnMuSRckVdM+IzhBbkGpBk3qdZjyx5wS8Ywhg=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssbc",
    "recps": null,
    "text": "I hereby formally ask for membership in the github org. I'd like to put up the `ssb-common-rs` and `ssb-client-rs` rust modules as somewhat \"official\" ssb(c) projects - once they exist.\n\n[@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) ",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      }
    ]
  },
  "signature": "GFz8+AZuWwC/nUyQeoUd0kY+0w6/812mpeitPPN8eSDq2raB1ShzcLXm5zzWWLPdpPBx36DKr0Rg7wjei2LVBQ==.sig.ed25519"
}

{
  "previous": "%yahQA8AJSn9nk2D9fMHPNhA4I+KZMYrlXCiKL68Kg2w=.sha256",
  "sequence": 512,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518867177004,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "ssb-keys-rs"
  },
  "signature": "0EUKvFzW1NT9Wg8DPqBSS+ud8DPwyTzQmMM0IhJZJi1lmjKzyxuYbRJZdGqB697BhYzb0a0vaPMhu+zn6b8pCg==.sig.ed25519"
}

{
  "previous": "%ZEke1Q2BQJOahIcuasYt8ywddWG5oakzmgAcMaIsMGU=.sha256",
  "sequence": 513,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518867181400,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%ZEke1Q2BQJOahIcuasYt8ywddWG5oakzmgAcMaIsMGU=.sha256",
    "refsBranch": [
      "%ZEke1Q2BQJOahIcuasYt8ywddWG5oakzmgAcMaIsMGU=.sha256"
    ],
    "packs": [
      {
        "link": "&q2rR3OpeX+s8OZEIEuLVG4oSLRI0zOGzkFrzxiFED7g=.sha256",
        "size": 731
      }
    ],
    "indexes": [
      {
        "link": "&PdpHeHENzC8RZo5ReQVmN2o3+SJqC3KhOAAvxcaPNXY=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "52e3bbb4a64e214f689134d036deee25d736c050"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "52e3bbb4a64e214f689134d036deee25d736c050"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "fd119af164b4e6cceda9371738843229527918c8",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "93404427daf6374e86ae8e2476e2898fd17a3b5b",
      "c4e206d04c668d697cc694e179a5bc1465decbe6",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "QArs0C8R6QjO2f4iEIlGe77dxdBXjcWZF/1h4iMKFrBxNwBUeVH20XjkARKh5sBvsfsQfl0EQ+1ubIJ/WbHuBw==.sig.ed25519"
}

{
  "previous": "%C/AORa1hI/PAUy9UXP/crSo0SDBLGL936lGytLV+xqs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 514,
  "timestamp": 1518867367266,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%1cmNsvktH2/4e+oOtnZ48dsw6j2hXKyqvQl0Dbcy50Y=.sha256",
    "branch": "%54sYK3CNCUqKdZqL5ri9oxUB3zDCxV36+16g+YvFaMw=.sha256",
    "reply": {
      "%54sYK3CNCUqKdZqL5ri9oxUB3zDCxV36+16g+YvFaMw=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssbc",
    "recps": null,
    "text": "I'm https://github.com/AljoschaMeyer/ on github.\n\nI'll ping you again once there's an actual repository to add.",
    "mentions": []
  },
  "signature": "v7YnvFhsFmyiF3IpKrLjL+FBIFMJehG9TUXpAl/d+P+oftn6Sn/3iGhYXvALhxaDxH4BxoTUvD9rojX3ZFPvAg==.sig.ed25519"
}

{
  "previous": "%ASexK2iYkh+pacMvXKA4iAWNp27rH++lvFe6T/30jSQ=.sha256",
  "sequence": 515,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518897177137,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "ssb-common-rs"
  },
  "signature": "NyBW2/33vgXLhaihbJy38VlWgh9ZvA/+KnrlEFT9kXBfzr2ksllQBJvGFOmzQPyzlg3lFsq0XppP/pjiXo1kAw==.sig.ed25519"
}

{
  "previous": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
  "sequence": 516,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518897182717,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [
      "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256"
    ],
    "packs": [
      {
        "link": "&sqlq2xu0QF3OE4bvfXuvW+4CSDd+ohSx2GxsKTmqLbo=.sha256",
        "size": 12711
      }
    ],
    "indexes": [
      {
        "link": "&DD2nnXXKKNKTXRdRUNaYgvYThR575tFhToNosdbwLSs=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "1cc019a89a1ca6e1438cf20aa8cfcb45a655157e"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "1cc019a89a1ca6e1438cf20aa8cfcb45a655157e"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "a60a72c27785ea24a8492eaca8e4e4ee9264ae83",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "f7ce7ae37156bb2d4bb54e8cd002520353d11da5",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "c3738118e2ae49d5be0dc6c7b7acc6644850d21d",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "gyR3xNSKcvB0w/6v+mxVoWq+x4DQ4j3W8OPXFIBCgXxuRZULKrCeHcqmM9K1f7PCE2nB4blHRJcrn+L5uO5HCA==.sig.ed25519"
}

{
  "previous": "%coILaxPaJYE/YqXHWacjgDtMRAWgS1kKe7cY6lmb3wI=.sha256",
  "sequence": 517,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518898495330,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%coILaxPaJYE/YqXHWacjgDtMRAWgS1kKe7cY6lmb3wI=.sha256"
    ],
    "packs": [
      {
        "link": "&Hrs9iQeT73dwjri0GGJknxJyp01qEIcJwryJ3vJxVG8=.sha256",
        "size": 1105
      }
    ],
    "indexes": [
      {
        "link": "&V8wLYePfr0ioCIfH5cOZH/9fhyPoSIDXHx6CendaD0c=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "cd07f88f9e4a4f9ea21a9331dbab6e5cbf162919"
    },
    "commits": [
      {
        "parents": [
          "1cc019a89a1ca6e1438cf20aa8cfcb45a655157e"
        ],
        "title": "Add some useful constants",
        "sha1": "cd07f88f9e4a4f9ea21a9331dbab6e5cbf162919"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "8995aaf0c7eaa182bf42404678adc768dbcf7ebe",
      "fd20320ae53443df03e1a5b45a76edf7d1e7d0a1",
      "7333de8c4b61a09e1e5eda738de520ddb4caec6a",
      "92b6196975529b5830eca1ab0ae9923e5e611655"
    ]
  },
  "signature": "134sbJEJ0YzkDTRpIoh2o8PYwMqQO6UBXS5xKd4PPPpxw+045fr6a3e/Ijh84Hjf3pXyNqq3pA9hx305ZgtDDg==.sig.ed25519"
}

{
  "previous": "%45AVHa9luGpFpcp8LLS5KPulNu3EUIlVdBHD1vi+h0Y=.sha256",
  "sequence": 518,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518903445629,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%45AVHa9luGpFpcp8LLS5KPulNu3EUIlVdBHD1vi+h0Y=.sha256"
    ],
    "packs": [
      {
        "link": "&JsJVYThnP2Eh3g3MZKkRRvPA600ejCRYyNnam6uc0RI=.sha256",
        "size": 1879
      }
    ],
    "indexes": [
      {
        "link": "&vAyzJPIEG7Q/RmbNj58m5lktwfVSjT7+cwIwT082TC0=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "0f96eb7d2f21baeb2088e490ed06fb3853203daa"
    },
    "commits": [
      {
        "parents": [
          "cd07f88f9e4a4f9ea21a9331dbab6e5cbf162919"
        ],
        "title": "Sketch key types",
        "sha1": "0f96eb7d2f21baeb2088e490ed06fb3853203daa"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "0867b21bb8eea25d969e94107776c3e386506f6d",
      "84b67bf4d26c87f59cf972172831814d9262d94a",
      "07b61ff10205689dcba86a8436612592e7b354cd"
    ]
  },
  "signature": "aKM/kY7Vv9CjHgyVCTD7iLyz8EJruObrlqKdwLq2s1dSW2xH/PW3oj+XTRYS5pmdq+4LLxMiTQdQR8sTCFSrDw==.sig.ed25519"
}

{
  "previous": "%/3Henh2lv2i3kCGnc9qqoESA3M5PTeH+VVFCKG7L/YY=.sha256",
  "sequence": 519,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518907037044,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%/3Henh2lv2i3kCGnc9qqoESA3M5PTeH+VVFCKG7L/YY=.sha256"
    ],
    "packs": [
      {
        "link": "&Lk0U9ltjWO7FqxbtgFmqWHXq5skgQIXXLnDinneDyn4=.sha256",
        "size": 2510
      }
    ],
    "indexes": [
      {
        "link": "&SZ1dAROak3HY0KtiV3+rj6qEhZZ+ahhhigulajfhl98=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "d7c536d55cd1409fc88cfecc2f3153f3f80fc488"
    },
    "commits": [
      {
        "parents": [
          "0f96eb7d2f21baeb2088e490ed06fb3853203daa"
        ],
        "title": "Implement key types",
        "sha1": "d7c536d55cd1409fc88cfecc2f3153f3f80fc488"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "8426169bc53ca5366b0c18cfcc17d15bc7ce71fd",
      "e312ce14d269bfa0b25835a2e2b5b4e73b55f785",
      "a0a87fd4e81a625ccd7e71ab9a744b5fb69b1802"
    ]
  },
  "signature": "GIfVnwRMck5N32sR27ft5vkcrRPnLLqv5JGq8Wf7+OqTGn3J5sdXw1NB33R6YX2T1O2JwFM8FoXWoApyP8xyAQ==.sig.ed25519"
}

{
  "previous": "%+Sx7uAEP9uVE7viMR3NrmkFlhMSTvK6f/Ocd7s95dOo=.sha256",
  "sequence": 520,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518946012860,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%+Sx7uAEP9uVE7viMR3NrmkFlhMSTvK6f/Ocd7s95dOo=.sha256"
    ],
    "packs": [
      {
        "link": "&tajwdhy/8a5i3DEk3tmAuqadMAz1Ho36PtFwgKStgsc=.sha256",
        "size": 4209
      }
    ],
    "indexes": [
      {
        "link": "&AedxscnYZaykAuXwTfxr8aDQcQYAhlipZxbsW8//6iI=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "74b03c2e579f41040dd603aa310c03f5d4674469"
    },
    "commits": [
      {
        "parents": [
          "ea1011c136f8708114ecf5bdd64463efb6823124"
        ],
        "title": "Add TODO",
        "sha1": "74b03c2e579f41040dd603aa310c03f5d4674469"
      },
      {
        "parents": [
          "f8d2d3a377e9c0b5596ae9d6e8af7b610c84abac"
        ],
        "title": "Add simple tests for ed25519",
        "sha1": "ea1011c136f8708114ecf5bdd64463efb6823124"
      },
      {
        "parents": [
          "d7c536d55cd1409fc88cfecc2f3153f3f80fc488"
        ],
        "title": "Add a few more methods for keys",
        "sha1": "f8d2d3a377e9c0b5596ae9d6e8af7b610c84abac"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "9c3d816f32c865e54cbe68d3dd5cb46feaa78434",
      "fce8271c6f39ea8c8981854db07bb1cc0112b1bd",
      "9d83dbbb22129895f4fce7bb3ca8d785111c5976",
      "c6ebdda2478cff21ab874f41c214cc462c6b1adb",
      "075a72d792c5c7acddf8e635dd3b0e1bcf4b97dd",
      "79747727a9ad8c56c54b105690484eedd5c5f4e1",
      "82e1353d2e61c9e9ef893973a98f6721572c5c4d",
      "ff8d9f4a1f6a9e4a961a2d5e714b78a99e045202",
      "620be67d48faaf83d81f9c27c1858d6ac788d4e6",
      "786343204c1a7153deae2931c243d226f09a1bba"
    ]
  },
  "signature": "3IeV3CJ+w/GmU1/3yeTCwS9eskCU3U7xXFkNq6ynWkIDgW1ArcAFEKePdF0BQznm7mI2UjwBcYTBL33OTwURDw==.sig.ed25519"
}

{
  "previous": "%+jwmMuco4Lm0LFUP93jiDPCxsOngCm6EMI3+bKxndFw=.sha256",
  "sequence": 521,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518980506358,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%+jwmMuco4Lm0LFUP93jiDPCxsOngCm6EMI3+bKxndFw=.sha256"
    ],
    "packs": [
      {
        "link": "&Rko8NIoXkFvFGs+7SXfHnaXp8nFKd23sEDxGlYSo6u4=.sha256",
        "size": 5855
      }
    ],
    "indexes": [
      {
        "link": "&WrXUwJh8v0ttMktwcW5DvrjBks4WqrjrV4X9jwfLRGc=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "807fbb554c89854dcdc9f3e9a47b51a0cb414904"
    },
    "commits": [
      {
        "parents": [
          "74b03c2e579f41040dd603aa310c03f5d4674469"
        ],
        "title": "Implement key encodings",
        "sha1": "807fbb554c89854dcdc9f3e9a47b51a0cb414904"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "d66dd999c921e86aca74742747a1c0b1cfee8bdf",
      "7c566c0eaebd948febc67900cd99d983f8c58703",
      "dd5590d1b21e165569f87b99690e2ed7a78764bb",
      "4ad07351651312dd976ebd9974529b592ffd28c2",
      "8fa1e03deffb9c6242474e7a156b50184eebb60b"
    ]
  },
  "signature": "rkarUEt1idGB9ZLn2euexC8R8WDqgBqFVGJUdxPFDzXZij3gacDz6VL/zHRkkkS+00jKEgEOGQqtX44hTHCtBw==.sig.ed25519"
}

{
  "previous": "%NDjFgJlQbtxtxEwBpoEjhPq9Xv01JU8TUbb2QeikTTI=.sha256",
  "sequence": 522,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518986678793,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%NDjFgJlQbtxtxEwBpoEjhPq9Xv01JU8TUbb2QeikTTI=.sha256"
    ],
    "packs": [
      {
        "link": "&sJcPJWCXbndftDRsFQJNmcLcVNf+lY7/dTJd2Q4bPa0=.sha256",
        "size": 6156
      }
    ],
    "indexes": [
      {
        "link": "&SYUpEr9mWGLxXH4SFBbBfkZSLIWssuCAk9EQnNXE/O8=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "14efa0280f6aa9bc787495c1eaf06804b9f7aa1e"
    },
    "commits": [
      {
        "parents": [
          "56c50fb4c79f57d88a65613e3731432f23110c6f"
        ],
        "title": "Clean up keys code",
        "sha1": "14efa0280f6aa9bc787495c1eaf06804b9f7aa1e"
      },
      {
        "parents": [
          "807fbb554c89854dcdc9f3e9a47b51a0cb414904"
        ],
        "title": "Provide appropriate drop and debug for secret keys",
        "sha1": "56c50fb4c79f57d88a65613e3731432f23110c6f"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "1bd8691d3fba084341993d9f86652ac4309bb365",
      "619057e6a8ec026a7e10bde4720bada12e700036",
      "0af3994f3e1e9b51929bf744c072f9b2ec7a21f6",
      "198c7d3b85a7c46aa5bc2a240d95d2e945d63d63",
      "e560c77111c84f41831c4bb42c07fa60f37f0c31",
      "890aa626a810790db381b5511648bcd404f83c6a"
    ]
  },
  "signature": "LvoYhfTO4aaWnNq9KQiIIXwJd5e+3bmOSZOw/ynh5NznVxiIVTPwxMfxrmgLZGe+qSbNVntpTHtLu3dR8Kb1Aw==.sig.ed25519"
}

{
  "previous": "%7swZjabGwYKav2WVECMjsh7L7HW7rexnN6NR8eJPulE=.sha256",
  "sequence": 523,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1518990163752,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%7swZjabGwYKav2WVECMjsh7L7HW7rexnN6NR8eJPulE=.sha256"
    ],
    "packs": [
      {
        "link": "&4qXtJPLKhuDCJvzOSwEXq0T1C4n6rBrHvfLPUnJc22Y=.sha256",
        "size": 5329
      }
    ],
    "indexes": [
      {
        "link": "&c6CQbhV5tPqlEJeX50c8ems0UWRCG9FZ4eoRUIzWpmI=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "3ea577359267e2565559e7774025eb77a2497502"
    },
    "commits": [
      {
        "parents": [
          "14efa0280f6aa9bc787495c1eaf06804b9f7aa1e"
        ],
        "title": "Hide key and signature enum variants",
        "sha1": "3ea577359267e2565559e7774025eb77a2497502"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "8feba5361f272edfd8a8347036e52623433c2010",
      "4ab1856f3ca769bb1b3e3a7da602825c93e19be6",
      "d75deaaf2bd6ed9300790c2402b56b95f0dd73ad"
    ]
  },
  "signature": "eBIRe7SU4rF/9B17hmOPh0xCEyVRf7wKwecNwiyAbUcR7R3RLb8oRBIXQWqXYYdmUpSfRwXximvvjGWqiF1VDQ==.sig.ed25519"
}

{
  "previous": "%a9VOqru5QHwy9o6lgpep3laXXpCMoBktq4V/ukK3wwI=.sha256",
  "sequence": 524,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519052438401,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%a9VOqru5QHwy9o6lgpep3laXXpCMoBktq4V/ukK3wwI=.sha256"
    ],
    "packs": [
      {
        "link": "&Wo+9HlSuR42K33UkiGG/yf5/vRLKYXJJ/kldpxWZY4g=.sha256",
        "size": 1286
      }
    ],
    "indexes": [
      {
        "link": "&IQfJDSUjOsbJnaVXyQeG42WUaFKAiJn0FfqkAyRYaqM=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "cd2622bcf7a304119b27c5455aca53d05fb181f7"
    },
    "commits": [
      {
        "parents": [
          "3ea577359267e2565559e7774025eb77a2497502"
        ],
        "title": "Add port constants, move path constants",
        "sha1": "cd2622bcf7a304119b27c5455aca53d05fb181f7"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "f7bd49f7acc65c3ee6d4a8e5df3efc522be503b5",
      "9c409af322738bfaa0d7e91210da9fef5ff73e1c",
      "df17f5ea92e0576f33b60d100f0cec8db8c6a001",
      "2a7bbceb890d3eca898160ab81df1ba5013a0991"
    ]
  },
  "signature": "J2hRcEsCu7OfWxalnWJDcXHsiZemyyJ/HoS56tYkDFd5ioTMQ9bbyvtSwvsPYs+q/u5XucHYg/aavX3ljMiuDw==.sig.ed25519"
}

{
  "previous": "%oA4/VvouL9UiOPi4FUEIy8oNGnG64klTFtNr9+s+om8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 525,
  "timestamp": 1519071233612,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%1cmNsvktH2/4e+oOtnZ48dsw6j2hXKyqvQl0Dbcy50Y=.sha256",
    "branch": "%ASexK2iYkh+pacMvXKA4iAWNp27rH++lvFe6T/30jSQ=.sha256",
    "reply": {
      "%ASexK2iYkh+pacMvXKA4iAWNp27rH++lvFe6T/30jSQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssbc",
    "recps": null,
    "text": "[@Mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519), the [ssb-common-rs](https://github.com/AljoschaMeyer/ssb-common-rs) module is now at the point where I want to depend on it from other code. I guess that makes it ready for moving to an ssbc-repo.",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "Mix"
      }
    ]
  },
  "signature": "n2j3ZyQ5JE5Qc9amJrKAadvUnaNWy0mRFXaBRrmJgx+9/Z4wBAqG4PV5yfz/SDJVkginVw/KsCa51cc8ExPOCw==.sig.ed25519"
}

{
  "previous": "%7aaCd6xV8EOfDMZYfy30fCLpUEkTKMSWQs1vtC2Ralg=.sha256",
  "sequence": 526,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519074278122,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%oA4/VvouL9UiOPi4FUEIy8oNGnG64klTFtNr9+s+om8=.sha256"
    ],
    "packs": [
      {
        "link": "&2uJ5XrwVFb1YixwxZdcMcm/CmG5VhkOEn+M9zOiZA1s=.sha256",
        "size": 1127
      }
    ],
    "indexes": [
      {
        "link": "&j1jP5cHDeuIKwl9Ocr+nfK5LFJsVo0wrK5PGW5fTnzs=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "d247d2e62f6221a37c1d3cdc9f181b768964af05"
    },
    "commits": [
      {
        "parents": [
          "cd2622bcf7a304119b27c5455aca53d05fb181f7"
        ],
        "title": "Implement directory helper function",
        "sha1": "d247d2e62f6221a37c1d3cdc9f181b768964af05"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "804e23465f68601dbec502734544185149416275",
      "5135d4c3f2d0a16838ced8de384b0745b7c49a5b",
      "e1a226ef5d896e4e1e950a7aaee0af5bf2937499"
    ]
  },
  "signature": "x3aZ4nlJ2MLopzBbzioWeexKftXeVgoMKfrdM6LaD7nEP/61+DCEL4Uq+xrIZt0YnMIpoj4OkrXqZ5MSXRLwBw==.sig.ed25519"
}

{
  "previous": "%JfwZfO9K7C5vSlBe55r8Othem9dR5XI/7L86mJYTktc=.sha256",
  "sequence": 527,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519074977821,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%JfwZfO9K7C5vSlBe55r8Othem9dR5XI/7L86mJYTktc=.sha256"
    ],
    "packs": [
      {
        "link": "&xHGbJHOWM9uIZ2vJCnO937TmpUaBfoDqW9B3ewsJdL4=.sha256",
        "size": 5358
      }
    ],
    "indexes": [
      {
        "link": "&TnHrfjZ/GPEEt359KuaKtXl2RKWG759Y7Uni5t9HjNY=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "0a3896ea58c91391779bdcba64fc16b425227b81"
    },
    "commits": [
      {
        "parents": [
          "d247d2e62f6221a37c1d3cdc9f181b768964af05"
        ],
        "title": "Rename key encodings",
        "sha1": "0a3896ea58c91391779bdcba64fc16b425227b81"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "07eaa790493a5f6d3c9459270c4040f4669513c7",
      "7bc73f5555351dd8a041d41643a5eeed365b84d5",
      "39dc26683e9292efd0fc4712f941c3754e5cf5cc"
    ]
  },
  "signature": "s90eRJ5r0HRAxMfegOdi6ohTG4fghfDRsfkWfygh3bIv9nEuIwxwynFe9AUGZQXkxjiq297T6wz8/JRQZgERDQ==.sig.ed25519"
}

{
  "previous": "%vZcANaL716dM6euQGMOZbUot4z2o1V75NRS6GL5S0cI=.sha256",
  "sequence": 528,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519075561092,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "ssb-keyfile-rs"
  },
  "signature": "tuMxxKTJthJNl64yUQVOemlrMkzeg8tOaxSWZnOFKJ0lPgmbCAwMt0rGTqs5oYS8N4MoBtewF1hoqgUrQalxDw==.sig.ed25519"
}

{
  "previous": "%k3FNpf3/1oBHP3fwbsHqyWh+qkhLnO48OJyrcXJSTRU=.sha256",
  "sequence": 529,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519075567821,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%k3FNpf3/1oBHP3fwbsHqyWh+qkhLnO48OJyrcXJSTRU=.sha256",
    "refsBranch": [
      "%k3FNpf3/1oBHP3fwbsHqyWh+qkhLnO48OJyrcXJSTRU=.sha256"
    ],
    "packs": [
      {
        "link": "&nYJ8+to90RBzslF1Uxsr3PA2YwcRSDskIp1tJ31KRZU=.sha256",
        "size": 12814
      }
    ],
    "indexes": [
      {
        "link": "&mdRndTnid5IuCko9lPyWrj2loJuWzi/51JlL9y3mf20=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "bc359e4a464d255de9aa4442a9298a1fba2ce219"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "bc359e4a464d255de9aa4442a9298a1fba2ce219"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "d0844a939d9e3bd493d9823f23ebc7b8c9cb973f",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "64ba83c1462cb8818dcf46ffd9fed4b254d319b2",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "c60ccbb97f611f18c761625b443a6bec1c812c21",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "2CXDGB1d7Kims67x1kkYOP5VGLOlpDNASV4DiZ9alJQE+NOwonAjXj7eKAm9eYnWy5mverj4L0sZNQv9Ji+OBw==.sig.ed25519"
}

{
  "previous": "%DP1jV7nphfgu7fFREAkcFhYLNoMAGYsLyx3tAySRRkQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 530,
  "timestamp": 1519079456747,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "35c3",
    "subscribed": true
  },
  "signature": "9vY0DSeBuOK1xhHGiHZjjrjOLo7NVRMtgP+PduYGRp+1qKspnhLAqwFlrEpd8jPQ2FCoqZaOOljQzmB7D+5RDg==.sig.ed25519"
}

{
  "previous": "%59VTybatPcu+hA7ebAwktBqcn7sBNWY+o4eRDVIcTmI=.sha256",
  "sequence": 531,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519127287349,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%vZcANaL716dM6euQGMOZbUot4z2o1V75NRS6GL5S0cI=.sha256"
    ],
    "packs": [
      {
        "link": "&lFxiCMwPjXHohRg63P+mfR4BULj1uRQMoWPgcSPSkFc=.sha256",
        "size": 5839
      }
    ],
    "indexes": [
      {
        "link": "&SZKKreoKePNtfX/DubwBCjg8eiqdPf8GNDI+bEFRMG0=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "77d011c7cb14bd6c39ff9b1e062253ae7d168236"
    },
    "commits": [
      {
        "parents": [
          "31fde2758e093306313a6be1c81b0bfcd9f49782"
        ],
        "title": "Unhide PublicKeyEncBuf::new()",
        "sha1": "77d011c7cb14bd6c39ff9b1e062253ae7d168236"
      },
      {
        "parents": [
          "0a3896ea58c91391779bdcba64fc16b425227b81"
        ],
        "title": "Add crate metadata",
        "sha1": "31fde2758e093306313a6be1c81b0bfcd9f49782"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "348ccf9f87886be2db3d37a1d5b510cfe64d5551",
      "d227bdf0504302605189c5e7858b20c5a5eec24d",
      "f45b4a6c290accdc023900f0285d1d3d1d002114",
      "890c9025fb541ad0b176ddeae2582ee8b11ac699",
      "7ddb7d016f6e5f11747097424cf152198a1a568e"
    ]
  },
  "signature": "zFFqcSzIYdCJtdSrQp3Ld/OCjF1KMYQRJcseAXJwMtsL0WhaPa+4tN6BS8rWj/xRK9Y1DPTJTNfCg3EiRdB2AQ==.sig.ed25519"
}

{
  "previous": "%M/kn8tJ+O+UqFkFcbXbV0nGFICUTMyKps2MH9FZqrbc=.sha256",
  "sequence": 532,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519131181180,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%k3FNpf3/1oBHP3fwbsHqyWh+qkhLnO48OJyrcXJSTRU=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%DP1jV7nphfgu7fFREAkcFhYLNoMAGYsLyx3tAySRRkQ=.sha256"
    ],
    "packs": [
      {
        "link": "&Wjh7X2sdbNEKJCz58Ov48Gbh4W3SdjpEaZflUKVxb3U=.sha256",
        "size": 3208
      }
    ],
    "indexes": [
      {
        "link": "&8/cvwGsJzd7Rx0j42B4eiIDJRuKgXAaJQf27xiKjdH8=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "28df893a50c033c4081f37ff95e4322d3818cde9"
    },
    "commits": [
      {
        "parents": [
          "bc359e4a464d255de9aa4442a9298a1fba2ce219"
        ],
        "title": "Implement keyfile operations",
        "sha1": "28df893a50c033c4081f37ff95e4322d3818cde9"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "bb234d24799c8ebdf30aa33b309c37ba087179a1",
      "1c9ff8181ba1e9dc4f419de8f9546ca8daa07b11",
      "9860221d87bedac9a22ba822b50c82bebe77a24f",
      "2f43f9db5c36c537c7e7f702890ae32f447e0f5f"
    ]
  },
  "signature": "rH3XDuBNJeqzp1qjWXawBPG9ghw7mv1QeAeIdJ2IQt1fkXdYG72Djh2Ci/BEAb43M/7DE53WutWQm2mOr96WDw==.sig.ed25519"
}

{
  "previous": "%iVD0w56C8AtaIslmzJRq4GVsquD+kShFRCZn3tfa1UE=.sha256",
  "sequence": 533,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519131827849,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%k3FNpf3/1oBHP3fwbsHqyWh+qkhLnO48OJyrcXJSTRU=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%iVD0w56C8AtaIslmzJRq4GVsquD+kShFRCZn3tfa1UE=.sha256"
    ],
    "packs": [
      {
        "link": "&p1ueTcGBP4IxnhCJf3HS2ISnfMahgXXLAQWDQVdhUJ0=.sha256",
        "size": 613
      }
    ],
    "indexes": [
      {
        "link": "&L6/6fIv17vBTDPwNN6W54f90rzOmUZ0HrRvKSO4AqLw=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "6933ac556e681180d779fe4f94a2ab384bbc042d"
    },
    "commits": [
      {
        "parents": [
          "28df893a50c033c4081f37ff95e4322d3818cde9"
        ],
        "title": "Depend on ssb-common from crates.io",
        "sha1": "6933ac556e681180d779fe4f94a2ab384bbc042d"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "2f292877b837056d6db154a16dd5748755cee559",
      "4716caec64c810d23298ac02c913c179be666ab2"
    ]
  },
  "signature": "901IPBL3LxTn3/8mxQPX/oB9mhIq3eITLBZbNvHnxUKDYJWqO+xeFYF8uu8tcpPXqanGr2FjsGS7S50JEW1iAQ==.sig.ed25519"
}

{
  "previous": "%VtGpWG6yhTjf9Ugg1qJjKofRyHDESIEdhsTFpWMT0dQ=.sha256",
  "sequence": 534,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519132480884,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ku4+59/HuWxzbp7GO5DQl1DeQpxsaltT1x53/nFYp+I=.sha256"
    ],
    "packs": [
      {
        "link": "&Im14LYTxNzZ2qTBn6zKrpJrUUCzxzl+WtfjVqfYm8a0=.sha256",
        "size": 1104
      }
    ],
    "indexes": [
      {
        "link": "&z0JUdh6Enco5sUpgNZz9RiIGWn68nFXZfZkdiqFazic=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "c2c0786b99e349df06b10b1aa370f21ef6ba7a2e"
    },
    "commits": [
      {
        "parents": [
          "65919944d71186a92b8a10bb27c21e32d1c260b6"
        ],
        "title": "Update sodiumoxide to 0.0.16",
        "sha1": "c2c0786b99e349df06b10b1aa370f21ef6ba7a2e"
      },
      {
        "parents": [
          "f348e07315bb8eee17f393d7bab13eceae05e86e"
        ],
        "title": "Rename from _ to -",
        "sha1": "65919944d71186a92b8a10bb27c21e32d1c260b6"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "9f270628bbcfeec09b895dac8ef6549a4f996741",
      "405f0353183faff6fd8b75fca584e51e2bce21dc",
      "093b84587f6f98d210741282a000e410cd9667c4",
      "68657709080f192ef46eacea341e0fe5704b6d3b"
    ]
  },
  "signature": "nzqnaF3YhMmRi5prxVHMqc//GqVaT30biieYPaeUfnS7tme7sd6m6/69ClNzQwo2BIuzlg8HHOOro5q/M2c2DA==.sig.ed25519"
}

{
  "previous": "%W+BrDYLGWZC+voy9G6/AsUKDPE5VKUcEvx2S7//bheg=.sha256",
  "sequence": 535,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519132565262,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%W+BrDYLGWZC+voy9G6/AsUKDPE5VKUcEvx2S7//bheg=.sha256"
    ],
    "packs": [
      {
        "link": "&LvpGfTrJeUk98bmf7Zsolq7ejzEfd2GVa/Zje5BSUdw=.sha256",
        "size": 838
      }
    ],
    "indexes": [
      {
        "link": "&VkMZkOfe0lKhcMsI5Dj2jdmKW9lgf8tz7rBP2ylguT8=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "08aa6f8cdf63cee53ec1d80370f0716e9c029897"
    },
    "commits": [
      {
        "parents": [
          "c2c0786b99e349df06b10b1aa370f21ef6ba7a2e"
        ],
        "title": "Really update sodiumoxide to 0.0.16",
        "sha1": "08aa6f8cdf63cee53ec1d80370f0716e9c029897"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "7f9130e6eecab07c6aaf3798806d0f67c654c8f5",
      "82abceb7fb59533598e0a5982db3ba4d1b7157fe"
    ]
  },
  "signature": "jQSK6BOH4qu8vlUag5fu3Ui9Kd+EXFi1e6n7V4u9h6Qy7iHpTLT+Mf6n0FBmZRMnAhT/zD24yTbg4ULJKZ/vCw==.sig.ed25519"
}

{
  "previous": "%olikeXmadVgswYrbHFzyK3X1++BP8BPPuRPhTx1ZGSc=.sha256",
  "sequence": 536,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519132951341,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%olikeXmadVgswYrbHFzyK3X1++BP8BPPuRPhTx1ZGSc=.sha256"
    ],
    "packs": [
      {
        "link": "&Wt9nikcPbcJqZoaosgmuUNmOZkD3WsCTOr90BeoHxQ0=.sha256",
        "size": 829
      }
    ],
    "indexes": [
      {
        "link": "&5EQ+vvh7+szWRbSGXPRyWf0tvWNbsWHLWCmcP8Ba+9I=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "67afba28838a05987bc6abf75cbd28b3a14d4ef5"
    },
    "commits": [
      {
        "parents": [
          "08aa6f8cdf63cee53ec1d80370f0716e9c029897"
        ],
        "title": "Give up on renaming",
        "sha1": "67afba28838a05987bc6abf75cbd28b3a14d4ef5"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "cfca23282f5d70f798b55f7f78fedb2fa718aa73",
      "99f126f9372ecc18e0e7d7f35218a5eeb7813a3d"
    ]
  },
  "signature": "G7Q4cmyiJ2RHU4ErRBe5GvAFoN8ukotRDEdCmty09g3iSDQuE2VY9S2nKmlGR2oRa2G4tS4K6dmV1uJ68iEIAw==.sig.ed25519"
}

{
  "previous": "%jTSx9RZt5dczcW9xSyv/ll3d5bA/QS5PbOszAvD/xtk=.sha256",
  "sequence": 537,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519133099256,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%HDxRgjLghtu0VujhefMS3qy5LCF34ot5jb0c3VYxnZU=.sha256"
    ],
    "packs": [
      {
        "link": "&Ex1RYiBrMBfUhgJoTMZ0wdMnbjdjjGOV215gRClg33E=.sha256",
        "size": 858
      }
    ],
    "indexes": [
      {
        "link": "&iVdnBq/PKTor5r5VxicCDB8C6fSvw0vroDYXDtMVYxI=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "bd3e3c3eae59256f9cc642d488b9225b39175d60"
    },
    "commits": [
      {
        "parents": [
          "c4aa35611b691654454d5f37715249c90a784b8a"
        ],
        "title": "Update sodiumoxide to 0.0.16",
        "sha1": "bd3e3c3eae59256f9cc642d488b9225b39175d60"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "bed30d6ff0a58e154a73317f83c6155da7ce5678",
      "5cf90884269248cd609dc03998a91d3869a7841b"
    ]
  },
  "signature": "PPku0+hEeL1LGGgfu3bkrhGtnGwle5nkNpk6cynLsGFPCBNZrHRMcS6puvLARjxtCkdoehZ71R9HSD4ZNFDsBg==.sig.ed25519"
}

{
  "previous": "%UvEUIbkpUYqR8sToQVDrR5Y1CCHwfxBGwBaf+9R8KPo=.sha256",
  "sequence": 538,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519133204376,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%lCWZ+lRKmfPcbtbhuEyp6z2HPt5y7ulLA41LtLHQ/ek=.sha256"
    ],
    "packs": [
      {
        "link": "&gCzJ1N55PE6VfSlfrpN9MU6+/Bw2kiwdVOysBK3eIzE=.sha256",
        "size": 651
      }
    ],
    "indexes": [
      {
        "link": "&wVWMi9Dr/zPfCSQ29/9ulSycSRvrzEe2iEqUfyNmmCY=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "3b16bfce926a4b7af598790428ffd10c7f8ae0c8"
    },
    "commits": [
      {
        "parents": [
          "2bf6878d6bf7ff720b8a4baed2212fa85208453f"
        ],
        "title": "Update sodiumoxide to 0.0.16",
        "sha1": "3b16bfce926a4b7af598790428ffd10c7f8ae0c8"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "9088fd81f5b29a3ae52d26295163a4812c98ef58",
      "84215a39e97c3bf8070a00736a704b46739814c4"
    ]
  },
  "signature": "J9GEfw8k31hj4sTS3WU5iewBakDX+nYAp76ZUe/Bi6f1IKmehGfeVffU4x7lq7mPytJdWC9Q0P2UR88pHJJXAQ==.sig.ed25519"
}

{
  "previous": "%j3NbwSUhjfdpFg2zM41oS4AU4nUFBXefU5h+m2M1T4E=.sha256",
  "sequence": 539,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519133272507,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%M/kn8tJ+O+UqFkFcbXbV0nGFICUTMyKps2MH9FZqrbc=.sha256"
    ],
    "packs": [
      {
        "link": "&8mvpNypGV5l+ySRvFh5JSVhc4gn9xD3TUKUaruw6118=.sha256",
        "size": 635
      }
    ],
    "indexes": [
      {
        "link": "&iJHBCzvIBdYAmk5RaFbXWL1FSVxiu2yIt1Wi7hE7BEg=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "8be7b159b46aa79fe88629446b63be75b3d9a094"
    },
    "commits": [
      {
        "parents": [
          "77d011c7cb14bd6c39ff9b1e062253ae7d168236"
        ],
        "title": "Update sodiumoxide to 0.0.16",
        "sha1": "8be7b159b46aa79fe88629446b63be75b3d9a094"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "df68dd545d8a81e2e7d097269f7cf058226fc5f9",
      "705d072fe563bbd3da01c374cad403507ad49eed"
    ]
  },
  "signature": "Z5xPHT3A3tBGprPuRi17/e9+8JBYFiUri05rrmFF8oSzRdSGwDHHJr/ZJXoTNEVcLTxpaRPBFLKJsg951M8lDA==.sig.ed25519"
}

{
  "previous": "%cslb9JsVifX7FWeIr+voYwM3pJel4XYNVZaFIH1IS6I=.sha256",
  "sequence": 540,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519133334494,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%k3FNpf3/1oBHP3fwbsHqyWh+qkhLnO48OJyrcXJSTRU=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%VtGpWG6yhTjf9Ugg1qJjKofRyHDESIEdhsTFpWMT0dQ=.sha256"
    ],
    "packs": [
      {
        "link": "&ifciFtHrzoBZPxHqEWVFgkVnX1GKIGCiLJUsrkp0SzI=.sha256",
        "size": 608
      }
    ],
    "indexes": [
      {
        "link": "&trRMClnO+cY2/uw+yQFffwWYED4AIL/afkQ8iTz9raE=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "47a2e3588bff14a020d9ffbf771370bbe69ede59"
    },
    "commits": [
      {
        "parents": [
          "6933ac556e681180d779fe4f94a2ab384bbc042d"
        ],
        "title": "Update sodiumoxide to 0.0.16",
        "sha1": "47a2e3588bff14a020d9ffbf771370bbe69ede59"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "de26114bafa4639049455551fbb7b869e5fcaa79",
      "c6243effd44129da7563ad42f4053558ba4f41d1"
    ]
  },
  "signature": "FeOwLfxCRyd5nGQBltEgLKQjSvOaSq7U+hZUxaXV47nOTs5tGcR+C1r34ksyjWfYt23CdzNRTul7vZHbEigFBw==.sig.ed25519"
}

{
  "previous": "%Zyz8ToQ2v0wHgbnvlOfWC4mOusJgJ/mLK0XhVPD2cnE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 541,
  "timestamp": 1519135804830,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%/Ndd+7DxIxcF8wJdaXHk8HsA7RRTXURQFG2S+XbvvtQ=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Here's an example of using the raw packet-stream module to talk to a local ssb server. [Syntax highlighting](https://gist.github.com/AljoschaMeyer/b9f15886a00892887c904442f6ca1c4c)\n\n```rust\n#![feature(try_from)]\n#![feature(ip_constructors)]\n\nextern crate futures;\nextern crate tokio;\nextern crate tokio_io;\nextern crate sodiumoxide;\nextern crate secret_stream;\nextern crate ssb_common;\nextern crate ssb_keyfile;\nextern crate packet_stream;\n\nuse std::net::{SocketAddr, Ipv6Addr};\nuse std::convert::TryInto;\n\nuse tokio::net::TcpStream;\nuse secret_stream::Client;\nuse sodiumoxide::crypto::box_;\nuse futures::prelude::*;\nuse futures::future::{ok, poll_fn};\nuse tokio_io::AsyncRead;\nuse packet_stream::*;\nuse ssb_common::*;\nuse ssb_keyfile::load_or_create_keys;\n\nfn main() {\n    // Should always be called before using any of the crypto stuff: It makes\n    // things threadsafe and faster.\n    sodiumoxide::init();\n\n    // Read keys from the secret file from the ssb directory. Takes the\n    // `ssb_appname` environment variable into account.\n    let (pk, sk) = load_or_create_keys().unwrap();\n    let pk = pk.try_into().unwrap();\n    let sk = sk.try_into().unwrap();\n    let (ephemeral_pk, ephemeral_sk) = box_::gen_keypair();\n\n    let addr = SocketAddr::new(Ipv6Addr::localhost().into(), DEFAULT_TCP_PORT);\n    TcpStream::connect(&addr)\n        .and_then(|tcp| {\n            // Performs a secret-handshake and yields an encrypted duplex connection.\n            Client::new(tcp,\n                        &MAINNET_IDENTIFIER,\n                        &pk,\n                        &sk,\n                        &ephemeral_pk,\n                        &ephemeral_sk,\n                        &pk)\n                    .map_err(|(err, _)| err)\n        })\n        .and_then(|connection| {\n            // Split the connection into its halves and create a packet-stream.\n            let (read, write) = connection.unwrap().split();\n            let (ps_in, mut ps_out) = packet_stream(read, write);\n\n            let (send_request, response) = ps_out\n                .request(&b\"{\\\"name\\\":[\\\"whoami\\\"],\\\"type\\\":\\\"sync\\\",\\\"args\\\":[]}\"[..],\n                         PsPacketType::Json);\n\n            let use_response = response.map(|res| {\n                                                println!(\"{:?}\",\n                                                         String::from_utf8(res.into_data()));\n                                                ()\n                                            });\n\n            // execute the `whoami` rpc\n            send_request\n                // while dealing with the response in parallel\n                .join(use_response)\n                // close this end of the packet-stream afterwards\n                .and_then(|_| poll_fn(move || ps_out.close()))\n                // meanwhile consume the incoming packets and stop execution\n                // if the server closes the connection\n                .select(ps_in.for_each(|_| ok(())))\n                // keep the typechecker happy\n                .map(|(item, _)| item)\n                .map_err(|(err, _)| err)\n        })\n        // Actually run the computations.\n        .wait()\n        .unwrap();\n}\n```\n\n```toml\n[dependencies]\nfutures = \"0.1.17\"\ntokio = \"0.1.1\"\ntokio-io = \"0.1.5\"\npacket-stream = \"0.1.0\"\nsecret_stream = \"0.1.1\"\nssb-common = \"0.1.1\"\nssb-keyfile = \"0.1.1\"\nsodiumoxide = \"0.0.16\"\natm-async-utils = \"0.1.1\"\n```\n\nThe final API of ssb-client will become more convenient than this, but it is a good start.",
    "mentions": []
  },
  "signature": "s22GRgFxkQ6utNssWVvUzlmZNKWGt176MM+4BwnDaMC4ipAzui/z/WnSP6KjbUM37UfppXRVVaxkRl2EPYQLCA==.sig.ed25519"
}

{
  "previous": "%ThiUZ6Lw65W3izm9lzJvt4DimGv8cv4wkd87q/48feA=.sha256",
  "sequence": 542,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519137470715,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "muxrpc-rs"
  },
  "signature": "iZA9t2aCTNG8Te1a8Cn3gDWpdEPixl9SO5knWZ8H7Q+Anl7ur0Zn970T3izLEq7P/YiN9dqvoY7rnvZQJVbGDg==.sig.ed25519"
}

{
  "previous": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
  "sequence": 543,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519137526505,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [
      "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256"
    ],
    "packs": [
      {
        "link": "&m8xXvXKtLSBZIz0pX9tZzQss6IpbGuZYTJmqpG3nXoM=.sha256",
        "size": 12821
      }
    ],
    "indexes": [
      {
        "link": "&C6O7BzXWAa+OVlC5aiJE+kd0b1wYaFupSjTPIeZXlkE=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "6d1ed0019d249c44ed9fb9fea1741f573144a02d"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "6d1ed0019d249c44ed9fb9fea1741f573144a02d"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "314876a74cb54e40d186383bcf8fbcd45fd3359e",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "e8a0b292e15a7ba73e0fac832609481f64e05565",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "e2ff1775663dcb523b1a38dcd5934747ca8d2d9e",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "T0COcHzjcxIrwvmgfnL5Gl0SgUUqSvjCpUHOgru7pd2WwwlG9fd+97TAyQs0XZsozKB1PGXYilrHAz/HHRZ/CQ==.sig.ed25519"
}

{
  "previous": "%w1T/H+gCwmiZL4UXekVNGxfMeY2sZrQ9aBnw1eBbKYI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 544,
  "timestamp": 1519210481898,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%c6cclEyULva5N/CDwJk5ZLYEyCNATtHESzTD2OXqrIg=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Since I didn't link to them from here yet: I started [ssb-common](https://docs.rs/ssb-common/0.1.1/ssb_common/), which currently implements types for public and secret keys that abstract over ssb's ability to use different cryptographic primitives. The module also provides a few constants for default ports, file paths etc.\n\nThe ssb-common module is then used by [ssb-keyfile](https://docs.rs/ssb-keyfile/0.1.1/ssb_keyfile/) to read and create keys from the ssb directory.\n\nAlso, as a reminder for myself: I'll probably add a `Future` to `packet-stream` that is notified once the write-half of the packet stream has been closed. This could be used to e.g. start a timeout for limiting how long to wait for the peer to close its half of the connection.\n\nIn the example above, all futures need to be combined into a single future, by `join`ing all rpc calls and `selecting` on the peer closing the connection. With the change, you could directly run the smaller futures without having to combine them. That opens up the possibility of running them on a thread pool instead of executing one big task on a single thread.\n\nAnd finally, [serde_json](https://docs.serde.rs/serde_json/index.html) looks fantastic. Implementing muxrpc on top of packet-stream might actually turn out to be enjoyable.",
    "mentions": []
  },
  "signature": "ScwWWlA8IREsGv4PndspRzkCI2gx2oQ9n3FhYzbPwH/lYN/zDuCHbhQq6Kr+d7ssV7+Ba/8n3hDr1c2tSMb5BQ==.sig.ed25519"
}

{
  "previous": "%bNQj9Mkidzbc0OHCT5yMWc4dWQUwugTzrxsAWfzNTdI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 545,
  "timestamp": 1519216548994,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%bNQj9Mkidzbc0OHCT5yMWc4dWQUwugTzrxsAWfzNTdI=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Somehow I keep running into [limits of the type system](https://internals.rust-lang.org/t/improving-self-referential-structs/4808)... I really want to allocate the data decoded via packet-stream on the heap once and then expose more convenient types via references into this allocation. But there's no way of statically encoding that the heap allocation outlives all these references. I'll look into the [owning_ref](http://kimundi.github.io/owning-ref-rs/owning_ref/index.html) crate which seems to provide what I need with low runtime overhead...\nOn the plus side, serde should play very well with borrows during deserialization.\n\n- - -\n\nThe final ssb-in-rust stack might end up looking like this:\n\n- [tokio_io](https://docs.rs/tokio-io/0.1.5/tokio_io/) providing the abstraction around asynchronously reading and writing bytes\n- [secret_stream](https://docs.rs/secret_stream/0.1.1/secret_stream/) implementing handshake and encryption\n- [packet-stream](https://docs.rs/packet-stream/0.1.0/packet_stream/) providing multiplexing and going from a byte-offset and reference-based interface to a [futures/sink/stream](https://crates.io/crates/futures) interface, yielding owned data (but staying efficient via [owning_ref](http://kimundi.github.io/owning-ref-rs/owning_ref/index.html))\n- [muxrpc](https://github.com/AljoschaMeyer/muxrpc-rs) going from owned bytes to owned json data (internally via [serde_json](https://docs.serde.rs/serde_json/)\n- ssb-common implementing things like keys, cypherlinks, messages and how to (de)serialize them via serde\n- ssb-client going from owned json data to statically typed data (again internally via serde)\n\nAt some point, it might make sense to refactor the static typing for well-known rpc methods out of ssb-client, so that a server implementation could reuse it.\n\nAlso, I expect helper modules to pop up that take json-messages of certain types and decode them into structs with the fields that these messages usually contain. These modules would live outside of ssb-client, but would be an essential part of writing clients, and might even wrap it to provide fully statically typed APIs.\n\n- - -\n\nA consumer of `ssb-client` would only need to know how to use the `futures` crate (which is the de facto standard for asynchronous programming in rust).\n\nContributors to `ssb-client` and `ssb-common` would additionally need to learn a bit about serde.\n\nContributing to the lower levels of the stack requires solid knowledge of the futures-model, the tokio_io traits, and good understanding of the borrow checker. And of course the ssb protocols.",
    "mentions": []
  },
  "signature": "D0l7RtuQ/Z8mII6zsmeeKNJbQt06G88r7/SGPDKufE2E9Sq7faAuxg4LFaB/SC6mCbMSL3je16CPrru3GJbFBA==.sig.ed25519"
}

{
  "previous": "%4bOvWuIypL/UPbm6DWPXevnUkaJIxh1XV9pJgmsHs64=.sha256",
  "sequence": 546,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519218862931,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%8nBk04ewR7oMpgZPEHiK27CPOgm4DmHvR7BjXhGJIoA=.sha256"
    ],
    "packs": [
      {
        "link": "&kle01V9E5YcjTMYBW5bcZAwGqiSlt7dd0fSOQVhaKvA=.sha256",
        "size": 10522
      }
    ],
    "indexes": [
      {
        "link": "&7+qmqPJpAkwUtyI1R4//Sw7qShl6dR65mkCprqqwR/w=.sha256",
        "size": 1352
      }
    ],
    "refs": {
      "refs/heads/master": "247c404f51c6df0760963684725fab0eb3f4d6d9"
    },
    "commits": [
      {
        "parents": [
          "fffd40f94a916ae81c66dc20027bba0d62e8b848"
        ],
        "title": "Update tests",
        "sha1": "247c404f51c6df0760963684725fab0eb3f4d6d9"
      },
      {
        "parents": [
          "1825a7b59ca2ab997d2bf2440b1d6fad46dcc0aa"
        ],
        "title": "Change decoded bytes into a Box<[u8]>",
        "sha1": "fffd40f94a916ae81c66dc20027bba0d62e8b848"
      }
    ],
    "tags": [],
    "num_objects": 10,
    "object_ids": [
      "abed454d6feeda6ab4cc512a198742645641d0bb",
      "cbdfda2720d79f2a5f1f04ef4dbb3b3ffe9a26d1",
      "0afa79c8cb84bac83960924ad382f8878d622e83",
      "9ef373b378b6751cc719433a068acc2f31a73cfe",
      "1dac732db3f0f14ecfcfa66b62745ca4efa452bd",
      "9ba9e28b755684a93009a1181145673ed168d814",
      "46538b754f3428ac750dd57841c871ad4ce0589b",
      "c9752c9d3e50c0b1399e90a4a3b2eb8063065203"
    ]
  },
  "signature": "whzvgF/B+levgRR0K2YsEhllwWOfYLrYguVV0184zkJO6/s/82bWbiU2krUbZOAY7XdcdhfPAe2LBMzcp7I9Bw==.sig.ed25519"
}

{
  "previous": "%n2dSZpd2Rera/6lE5jaDd3KPKXruWfFuteQ5vrmGT9I=.sha256",
  "sequence": 547,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519224654464,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%n2dSZpd2Rera/6lE5jaDd3KPKXruWfFuteQ5vrmGT9I=.sha256"
    ],
    "packs": [
      {
        "link": "&iNI3g3psxc4Ms5+KDlkwPStk0nB/vzZk+Ou1Igkw6Ls=.sha256",
        "size": 5720
      }
    ],
    "indexes": [
      {
        "link": "&oGSRG2r8O2dVvuXn9RdlZuCHPUGEc93Un58J8StF9uA=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "743ba6415552281aed47bf42dd7a5a1f56ea9a53"
    },
    "commits": [
      {
        "parents": [
          "1bfca0ae84fe02728427590861b1106eac138152"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "743ba6415552281aed47bf42dd7a5a1f56ea9a53"
      },
      {
        "parents": [
          "247c404f51c6df0760963684725fab0eb3f4d6d9"
        ],
        "title": "Include creating packet with InDuplex",
        "sha1": "1bfca0ae84fe02728427590861b1106eac138152"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "0373743940a4e982ac19249358d2ef69ffb1b71e",
      "2456f726a005e9f7064dce628ae0d91acaa589ad",
      "8df3bb8e15f53977dabc3886497ef066f82080dd",
      "18bed52502158b067798dcaddef92ac6bc95a95a",
      "a8249a35d61c4e983ecb1685deea4d3a4d716b34"
    ]
  },
  "signature": "4uAn/doPzFMiXNQu2kEQQsswMVPMTbByRfOPPTVkkV0qYYeYdHSnGiQwZuZM2Ln0TOHjpeuQEWGjmMEBhAzFAg==.sig.ed25519"
}

{
  "previous": "%t3Zc/pIn3gwUIywKUarntZIME4ZGqru1vkhMRVzcaUw=.sha256",
  "sequence": 548,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519231539535,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%w1T/H+gCwmiZL4UXekVNGxfMeY2sZrQ9aBnw1eBbKYI=.sha256"
    ],
    "packs": [
      {
        "link": "&+qPuvQ9MZUHH27ehaHRkFwEy2HmdK0lBc7RI8VzP7L0=.sha256",
        "size": 3976
      }
    ],
    "indexes": [
      {
        "link": "&HCDV6FtxpAHFWy+wM5i+4K8hMHbcyCVSidkRQR1T0jQ=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "41f89a751035690156c27b36987d01d3d6697b51"
    },
    "commits": [
      {
        "parents": [
          "b5cf88a02149cb087e33fd6c7ebc76963df3b8a8"
        ],
        "title": "Sketch RpcIn",
        "sha1": "41f89a751035690156c27b36987d01d3d6697b51"
      },
      {
        "parents": [
          "8280c32e68d3e3b0261734a90ac06f680294567a"
        ],
        "title": "Update to packet-stream 0.2.0",
        "sha1": "b5cf88a02149cb087e33fd6c7ebc76963df3b8a8"
      },
      {
        "parents": [
          "6d1ed0019d249c44ed9fb9fea1741f573144a02d"
        ],
        "title": "Sketch basic types",
        "sha1": "8280c32e68d3e3b0261734a90ac06f680294567a"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "6389900957bf12c11c7d8ac51cb7d22df19d268d",
      "9210c10eac3829e4674d9ba2a3158c0b01286729",
      "32d3b28ed3d736d5573ee1987d9d82d391c50467",
      "5201e19297e75a402e1e424f7f3a76c00800b328",
      "8e65d5517dc0883f8cb43334b37aec14b922ae0d",
      "eb7f58a9526583a3811e6dea0a02f9cbd958d371",
      "652bb1c23b8fb0e75066f9bfd2cce65376c95567",
      "6ef420299331e05a56dda02e22dc14aa22427714",
      "51b07b0ff184942e366b4d0a40c652f81836e1fc",
      "90f6b65bc3e4c12fec6f318b46aba9d36add4ae2"
    ]
  },
  "signature": "L/akd1i9tJh3ZrdCyhxJEAYqmL3vprqCxRdkcmiEx04DjqmoJjtv4J5kpb87Anv4zUiqFeB/HYFQjFEq429LCA==.sig.ed25519"
}

{
  "previous": "%ru9GurSE69M5aCwdUX1SaAJCOWMOd6WZMaALr9pzmIg=.sha256",
  "sequence": 549,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519294423384,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "packet-stream-codec-rs"
  },
  "signature": "y0Hw6JfAJT9vWuyYCkGRTmdf0YxaK6tDAqECMfbKhO1I/Qn0vGX+7QF02ct4lm+LTBLqVolizwHxxOHKpSJTAQ==.sig.ed25519"
}

{
  "previous": "%XQ7XmsjfXT6uiSvocl6pWcN+rXgDLp1Wnz6aZx01Kdg=.sha256",
  "sequence": 550,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519294492827,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%XQ7XmsjfXT6uiSvocl6pWcN+rXgDLp1Wnz6aZx01Kdg=.sha256",
    "refsBranch": [
      "%XQ7XmsjfXT6uiSvocl6pWcN+rXgDLp1Wnz6aZx01Kdg=.sha256"
    ],
    "packs": [
      {
        "link": "&YT8jiqkMemqrjV8JY87b6ovsxMzoXkPjSq9Mmzo2Sgw=.sha256",
        "size": 12782
      }
    ],
    "indexes": [
      {
        "link": "&HisYSy/HFaXFMeTAd+Lc7UpA3MctYCTzYVwIYBULnYk=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "fc4354d5430e406c52dc5cf92e3a37c59a8ebb4f"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "fc4354d5430e406c52dc5cf92e3a37c59a8ebb4f"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "286485357be4b9446cf0d471babd9b4fcf3119a7",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "2cfc1412e55f00991677e8c6f725f8a43c48bd3e",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "77e98a59e190ce51ab7ec86deb24492d1434247e",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "cjxzDEBK48fYlBUPWjVGCLn8CKpdRgjHw/JVCoXrT0tcMBOSLyIpu9eFGYwMOREHktVNtOIqG20T1c2rZj3TAQ==.sig.ed25519"
}

{
  "previous": "%fRv2EB6M5ufZUOyAqF6TCdGukUpW6/U5GGZJwRadebM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 551,
  "timestamp": 1519320814806,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%G4DxdPjR7tks1ChMxINz8j3gd3e//lVrte+pOn1XQnE=.sha256",
    "branch": "%iRQdJrm1ew7hVZzTWXXNPVy/gnXyu54tTA/QJ8O+M9I=.sha256",
    "reply": {
      "%G4DxdPjR7tks1ChMxINz8j3gd3e//lVrte+pOn1XQnE=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Is there a concise explanation of plugins someone could link to? Are they a general part of ssb, or are they an implementation detail of sbot? Do they run in-process of the database or do they communicate via ipc (or even muxrpcs)? Can they be written in any language or only in javascript?\n\nAnd also: What do they do, why do they exist? They seem to cause most of the pain when trying to run applications without an embedded sbot. Does scuttle-shell fix these problems? Is scuttle-shell language-agnostic or tied to js? If scuttle-shell fixes those problems, why is it tied to a graphical desktop via the system-tray? Or is it just a gui for plugin management?",
    "mentions": []
  },
  "signature": "/IN5ZDmttic6CsttQh8ZRSrdCt025FxYtOdbEFcOHr8ZejCnyYoeUVYdJbD2+0NY3yu1WVvznO9ZVEQhQxPIDQ==.sig.ed25519"
}

{
  "previous": "%DClhTbY6L/I9F7rnGkRjxr9uYgK6R7PfJwgbVA56+Pw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 552,
  "timestamp": 1519331043146,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%G4DxdPjR7tks1ChMxINz8j3gd3e//lVrte+pOn1XQnE=.sha256",
    "branch": "%+q9ymSptvC5K3woJHnLayrBRI9rujbrbak3IZWzVtLY=.sha256",
    "reply": {
      "%+q9ymSptvC5K3woJHnLayrBRI9rujbrbak3IZWzVtLY=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) Does that mean that none of the clients relying on plugins (i.e. all of them) will work with a non-js ssb-server implementation?",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "aVxeAht8Owkx6s5TvAF3SEe/+suXtDjmm6eUl12vEvkdTEosKJ89T3MJQOXr4Fe5MQTpaC+LlPBHbZGhOAPjCg==.sig.ed25519"
}

{
  "previous": "%NtHSri4LbtRD153IXfDUJ2q7y6JPgZuHI/chqPMM6vA=.sha256",
  "sequence": 553,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519339872119,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%XQ7XmsjfXT6uiSvocl6pWcN+rXgDLp1Wnz6aZx01Kdg=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%fRv2EB6M5ufZUOyAqF6TCdGukUpW6/U5GGZJwRadebM=.sha256"
    ],
    "packs": [
      {
        "link": "&bLC5oqGD+dUwfkLzy/GhpDasEL17Hm/kIPWZ/5ZDlOQ=.sha256",
        "size": 4893
      }
    ],
    "indexes": [
      {
        "link": "&0Yo8WEEWo0dpo1TujdLIEGZtMdbLqu+6a9IZ1eW6MHc=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "299b6a20c60bcef2e6aa8294d0fd7115d673d05b"
    },
    "commits": [
      {
        "parents": [
          "fc4354d5430e406c52dc5cf92e3a37c59a8ebb4f"
        ],
        "title": "Implement everything",
        "sha1": "299b6a20c60bcef2e6aa8294d0fd7115d673d05b"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "9688da81a03943aa336ba8ba43b2c19a0ff7e102",
      "825d3d8c116e2b615db3851475fc94a83928b1ca",
      "1806d3b19856198a1ceed0bbae00973742eace8b",
      "65fe2099be654ee9bb418028f5b9a7cbe07f4436",
      "99476adf49b7cc443e6840028df14356172a2ea5"
    ]
  },
  "signature": "IvPeuNXQhEZ6tfwgGPdyWtOPaZhCwPRreNwnYjZ4ZZIf7F4aNJCxJy/R3bNJZFxL+kgnCkkZYgxguB1HnYklCw==.sig.ed25519"
}

{
  "previous": "%Lm/USWktEAN1DSz9gG/uo7ttPNk7U858M9Zfp3BYCt0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 554,
  "timestamp": 1519340996873,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%4bOvWuIypL/UPbm6DWPXevnUkaJIxh1XV9pJgmsHs64=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Since starting work on muxrpc, I recognized a few improvements I should do to the packet-stream implementation. The packet-stream module turns out to be more opinionated in its API then I expected, so I spent today extracting the packet-stream-codec into [its own module](https://github.com/AljoschaMeyer/packet-stream-codec-rs). And by extracting, I mean a complete rewrite. The old code was rather ugly: I started out writing futures for encoding/decoding single values, and then composed them into streams/sinks. I won't rant any more about the composability of the traits from the `futures` crate, but the result was not pretty. The new implementation directly provides a sink and a stream implementations, both of which turned out surprisingly readable.\n\nNext up is a partial rewrite of packet stream, and then it's time to finish up muxrpc. It looks like the type system does not allow a safe interface using a zero-copying approach as outlined in the previous post. So I'm going to provide a convenient and safe API based on serde types. But it would be possible to write an unsafe zero-copy muxrpc module, e.g. if embedded ssb ever becomes a thing.\n\nI also decided I'll put statically typed APIs for well-known rpcs into a dedicated `ssb-rpc` module. But that will need to wait until muxrpc is done. Next week will be rather busy for me, so I probably won't finish muxrpc by then. But I'll do my best to put my current excitement to good use.",
    "mentions": []
  },
  "signature": "xt3PQkUv+VUtUxJmJz5RxrDY6NHXt6kS5D1wS7abaLyriLaLDAvcIsT9FIcBCV+6GOvGpiKVn33zeFJejOUrAQ==.sig.ed25519"
}

{
  "previous": "%qxHwiaj6ddPUD31QDt9rCufYOz7k6y/GUan5Ii3EDfc=.sha256",
  "sequence": 555,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519389684868,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%AfExRNUanmLs2sUKc/Ut3YGlr5Xfl38qVou66M3sC3E=.sha256"
    ],
    "packs": [
      {
        "link": "&UNBvMaHWjCr0q+iNGSpy3jXiVnA384XzM2Cy0ocbpk0=.sha256",
        "size": 5527
      }
    ],
    "indexes": [
      {
        "link": "&yi+5uB1sObmQ8iS+gWXDN7P+8ktXh2P4KRdIdywBbdQ=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "e69fd70f2903d3d17d9ed7cc2ac4df2429c91c20"
    },
    "commits": [
      {
        "parents": [
          "8d24970a55b3972647a8bc149086ed214d74e2de"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "e69fd70f2903d3d17d9ed7cc2ac4df2429c91c20"
      },
      {
        "parents": [
          "9122953f90ac23675084086e6778ee44e8a050d6"
        ],
        "title": "Add future emitting the wrapped sink to rc",
        "sha1": "8d24970a55b3972647a8bc149086ed214d74e2de"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "1e15efde5633c118710eeba78e886714600bdd58",
      "dbd7b0a528b081e8ced51f6aabc7585c0e7d9ad8",
      "45483eb579ce37da874b8ee374932a1800cd725a",
      "715eec4f39e036b4a45a7e6899c34ebad8396191",
      "1945dd11933325d1174435db45bf3ae26660983e"
    ]
  },
  "signature": "tsPgdaNAUCbWBNXB6loz1/oQa9Ptr9bx4LbW9d2JDpGWgDZzdZGfuCiLIjwD/0MeetO8R2PL2xLwybSihmn9Dw==.sig.ed25519"
}

{
  "previous": "%Qp4G5MbC0mrx+ccNEOngpUr+zARdenrkDKciqLMvOjY=.sha256",
  "sequence": 556,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519402743124,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Qp4G5MbC0mrx+ccNEOngpUr+zARdenrkDKciqLMvOjY=.sha256"
    ],
    "packs": [
      {
        "link": "&osynXBTOBGvu5m2BDO8VwHA7O6BqoxH2dxANN4erBI0=.sha256",
        "size": 5187
      }
    ],
    "indexes": [
      {
        "link": "&b8QbUW6q+2xIGq4+KIWA0RmCvV7k2BLXeniPYKhy7tY=.sha256",
        "size": 1352
      }
    ],
    "refs": {
      "refs/heads/master": "469b5358fbef1f8878a1e461f443aaf3a2cbc49c"
    },
    "commits": [
      {
        "parents": [
          "37a253a4bb1a5d0df3a5ccfd15b9061a9ed44d2f"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "469b5358fbef1f8878a1e461f443aaf3a2cbc49c"
      },
      {
        "parents": [
          "b54694d05e2504f8a544f0842ff835070d8ff7be"
        ],
        "title": "Remove borrow-mps from readme",
        "sha1": "37a253a4bb1a5d0df3a5ccfd15b9061a9ed44d2f"
      },
      {
        "parents": [
          "e69fd70f2903d3d17d9ed7cc2ac4df2429c91c20"
        ],
        "title": "Rework rc mps, remove borrow mps",
        "sha1": "b54694d05e2504f8a544f0842ff835070d8ff7be"
      }
    ],
    "tags": [],
    "num_objects": 10,
    "object_ids": [
      "3d772ef6aca6d88cae7c8180bc64127c81071126",
      "d4327ba23225ac6ce49bd4e7f3bb414a3a97971f",
      "aa03a9852da21d5c44c3737b33638dd2a087c82f",
      "2f8b901b6ed5590cdff17bf9ae8c3e814c11732b",
      "c5d4baa25e8ffae297ca523e74bd303e09a52f10",
      "85ed737be01362b18f8092bd2e2cdeae1e3c8b92",
      "76f04a0bf0afccf45407b0c91eb7466435f35e47"
    ]
  },
  "signature": "nos+OlkYPfVOlkWpfi14MiTG8OqsXo4IMPw7gXGDKun2c2i/l1rxPZZvj0LSSA0ipbH5SJmQWhsKvFM82TvuAA==.sig.ed25519"
}

{
  "previous": "%O4yB6HXnZsM3YebQBnkm8kYxJiY6pf2FeFqHIx2w2TQ=.sha256",
  "sequence": 557,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519480175139,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%xmaiCBaEKCXPo2yJbqsoeK8Re3tp67cjOSd6IOS847E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%W+cLjlDKrIQMIQFIQlK9g3atAC6V/Yyy3rUkitWmxLI=.sha256"
    ],
    "packs": [
      {
        "link": "&tGw/sNQks4KagWZjSFY3DdK9j6kDva6Ya3h3We0Fg0Q=.sha256",
        "size": 4427
      }
    ],
    "indexes": [
      {
        "link": "&IWjJJbMOXLbipMRW8qRVP+pPjeXesoGwVSUJa8LPA5c=.sha256",
        "size": 1324
      }
    ],
    "refs": {
      "refs/heads/master": "32b861c1bee9e3e70a7f62da939e3693f3d09256"
    },
    "commits": [
      {
        "parents": [
          "16ed29ee5de33354e11b633199b726afb49d170b"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "32b861c1bee9e3e70a7f62da939e3693f3d09256"
      },
      {
        "parents": [
          "39003f27390a44ea335f8ec58a89df3c77ec8df3"
        ],
        "title": "Rework api",
        "sha1": "16ed29ee5de33354e11b633199b726afb49d170b"
      }
    ],
    "tags": [],
    "num_objects": 9,
    "object_ids": [
      "bb36825ea1ad85f2a75d0a16a89badc25544a0a2",
      "4228c47ef1ab347653a5156a6264aaacfb38e81c",
      "3344a5867f101b1fe2f8229f8fa97e58b0d14b44",
      "897e19345d2624a2995ca49d319f008496f9c23d",
      "e9c1dda4cc1e9825175f78387affe18f1486d472",
      "5fe0fb1d54ad611f99301c1401c9d7747b764dd4",
      "7d45b2d477a77d58118764c923cc380fa93f0875"
    ]
  },
  "signature": "3Z+5dT/6fvjgiVfjUpRs+eVTWY17jNrGAUFOaX9qFFgRz8xelCp8tRxn+2+xAhHCnAjotcq/k9MWT9aohAC/Bg==.sig.ed25519"
}

{
  "previous": "%3AG95To7lN+jbO4i4U8EzY5h+aLH5lyx4JtseKfMNzU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 558,
  "timestamp": 1519504134213,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%oCQ2CeuYlT8/rj1mOPmQ9LNjeeQqc4QgZe5zNVbnIQ8=.sha256",
    "branch": "%oCQ2CeuYlT8/rj1mOPmQ9LNjeeQqc4QgZe5zNVbnIQ8=.sha256",
    "reply": {
      "%oCQ2CeuYlT8/rj1mOPmQ9LNjeeQqc4QgZe5zNVbnIQ8=.sha256": "@3a/8VgfLqnmmqO3mf0al1piEbKqvg1LqRoNd2pcsLLo=.ed25519"
    },
    "channel": "talenet",
    "recps": null,
    "text": "> Look how *programming* and *playing games* are related to each other right now:\n\nTo me this looks more like \"go\" the programming language and \"go\" the game not being properly disambiguated.",
    "mentions": []
  },
  "signature": "7ne5C1rvF9VMwB/oUBcj/cSm6np471ajDj2WoOG1P4GdH+Pfy52LU9q0xUiHgv5h+yCp2iTVgxJr+qUK+mslDw==.sig.ed25519"
}

{
  "previous": "%AQuLUmwCQz8Q/4jE53XY1GMDfVOdHGivXjaGIToC5WE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 559,
  "timestamp": 1519504215089,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "solarpunk",
    "vote": {
      "link": "%S/9jlB97Z8q871/7/2xbPlY3nBEHTJMQBz1BP+DzeW8=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "+sqP4CFFA1fhHls5bNeQZ1SanYOADFjtRpTY4AeYucYvRRYuWFVCv+YyILwD6fnUvbGfBZzixkRxCa0eEuwTCw==.sig.ed25519"
}

{
  "previous": "%W0ke04aTGppQgp0gws3wF1Sq6MHLRCKdEpVR5K3tzHo=.sha256",
  "sequence": 560,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519554488932,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%t3Zc/pIn3gwUIywKUarntZIME4ZGqru1vkhMRVzcaUw=.sha256"
    ],
    "packs": [
      {
        "link": "&tAHdQpcL/dld2rt66bo7aiD8ydBQ4Ql78b6HuYS+b0A=.sha256",
        "size": 10952
      }
    ],
    "indexes": [
      {
        "link": "&ZKxrsSRyVVDwxTlQ+SXJ+xGRNGY072rmABHZL14PGpE=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "bd8b2fb8ea76cc7f920e532ea02df57708668c38"
    },
    "commits": [
      {
        "parents": [
          "743ba6415552281aed47bf42dd7a5a1f56ea9a53"
        ],
        "title": "Backup",
        "sha1": "bd8b2fb8ea76cc7f920e532ea02df57708668c38"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "c43fa5fa4f1ad764fb9babc268153821c8e3ca82",
      "db7839ae3217e02da49b4a1b0991435127a17a4a",
      "70782c9edc3540a2b9ae1dda4a5971d4ab69c2b7",
      "0a2d7b3f836a74dbfa8fda42bdcc201390279cc0",
      "27f7524cbf6e34a518cc0af44a241e7c6021de77",
      "b0b110f2005fda143972f6fdbc398ba9ea3ace56"
    ]
  },
  "signature": "2bObwkjyYM2BjpIUQwPntUoTtrYev+okaMgYgsFjSudWQ3NZKxdEZWNkffv6dNIkKtJoS4vypXTnQgFTg/cIAQ==.sig.ed25519"
}

{
  "previous": "%Chm/lfMu2pIWWpLg3+ZjHf1kLcCvf6jxzCYUDmLVSYk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 561,
  "timestamp": 1519573853050,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%/IjGTzNNnHVtJr7Momb3np+yWFYp7hJbnXWUcTcCAkA=.sha256",
    "branch": "%hRDwsnguRP8KrmvKh6zwfX1/675IeMqxcVfOVqtPwvs=.sha256",
    "reply": {
      "%/IjGTzNNnHVtJr7Momb3np+yWFYp7hJbnXWUcTcCAkA=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "art~hack",
    "recps": null,
    "text": "[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) In case you need some inspiration (or a feeling of crippling insignificance): https://www.youtube.com/watch?v=zTfZ6jClO3w",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "WdaEGfMyv0+98e7zi9xXoSICBH8HvLUmC+Nzxpk6UtIOXZmcRtAdTiiWuJ02GLZDpXmMh4mBjP52P4vyF2moDg==.sig.ed25519"
}

{
  "previous": "%OzlWP1vmWUMKl5asY7bOKxbZnaa3K0YOa8ryYAmcu7k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 562,
  "timestamp": 1519577993040,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "rust",
    "text": "I wanted to share one of the helpful error message the rust compiler gives when working with the [futures](https://docs.rs/futures/0.1.18/futures/) crate. Unfortunately it doesn't fit into the size limit of ssb messages, so here's a blob.\n\n[rustc-error.md](&TraS1pzBl5HZwe4ZJb/TQaEE1FUYfWfObL5qFyGAS00=.sha256)\n\nrust <3",
    "mentions": [
      {
        "link": "&TraS1pzBl5HZwe4ZJb/TQaEE1FUYfWfObL5qFyGAS00=.sha256",
        "name": "rustc-error.md",
        "type": "text/x-markdown",
        "size": 10140
      }
    ]
  },
  "signature": "gXNIi5s5Gb41W663qoiPT3ft2ta7rtYlg95TpzlI8UB0J/4k3B0qRPNhsLWzyjAdweYH7fGQz+QtBQPpUxi9Cw==.sig.ed25519"
}

{
  "previous": "%KUUSY/2oodH5zjDu3pxydMbTytbxAvAJJZmsmb8yaTo=.sha256",
  "sequence": 563,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519581148723,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Chm/lfMu2pIWWpLg3+ZjHf1kLcCvf6jxzCYUDmLVSYk=.sha256"
    ],
    "packs": [
      {
        "link": "&sK9pYfaOY+kQqa+ES0X4dpeMiDyHEpd4J9aqzEQrLtY=.sha256",
        "size": 6305
      }
    ],
    "indexes": [
      {
        "link": "&G5my+i+KVbrTi1/bW1Q7BYZfTVX4IWmG3p5di12e02U=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "f4077e68303273a7b221303b5c0a35abfd72e6a3"
    },
    "commits": [
      {
        "parents": [
          "e1e743af60f364cc68270e3331e6291e0d521c16"
        ],
        "title": "Bump version to 0.4.0",
        "sha1": "f4077e68303273a7b221303b5c0a35abfd72e6a3"
      },
      {
        "parents": [
          "bd8b2fb8ea76cc7f920e532ea02df57708668c38"
        ],
        "title": "Clean up and make tests run",
        "sha1": "e1e743af60f364cc68270e3331e6291e0d521c16"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "c230c3a5b4842926fbe8ad7d2a04468226003c85",
      "b03ff5c5b9574d01b45460cc5e654ea6dc5e870c",
      "3574d16d05c623158e21821e9799ff2bb62d2a16",
      "8e88cf7c2d9274983e247d67b01fd9a2ae5d7f8e",
      "6e038c7dd7a3f9ad7989dfb2c77c0245d5530bd2"
    ]
  },
  "signature": "SJ6MeTDh4AxzzDQURicIggQKJt5iZG4M4+sy2ZA480utRkv345ImMOZakoHQO1Ox5+VJXilGkyAuDixTXLWTCA==.sig.ed25519"
}

{
  "previous": "%IiPe/31Y7vlZeW8bHtOr41xD4cR0NsGqe1aMvKetAp0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 564,
  "timestamp": 1519587794956,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%qxHwiaj6ddPUD31QDt9rCufYOz7k6y/GUan5Ii3EDfc=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Spent the last three days refactoring [multi-consumer-stream](https://crates.io/crates/multi-consumer-stream), [multi-producer-sink](https://crates.io/crates/multi-producer-sink) and [packet-stream](https://crates.io/crates/packet-stream). I'm really happy with the packet-stream API now. Building muxrpc on top of it shouldn't be a lot of work.\n\nThe next update will contain a link to a working version of muxrpc. Then I'll update ssb-common to use serde for (de)serialization of keys and update ssb-keyfile to use the new version (and actually do full json parsing rather than the current regex). Afterwards, it's time to create `ssb-rpc`. It will eventually contain static typing for all core ssb rpcs, though it will simply start out with the `whoami` rpc. This will be exposed by `ssb-client`, and at that point I'll declare the grant done.\n\nThere'll still be a lot of work I intend to tackle, hopefully less solitary than the protocol stuff:\n\n- `ssb-common` should support all of the core data types of ssb (keys, cypherlinks, messages, blobs, private messages)\n- `ssb-rpc` should provide all core rpcs, `ssb-client` should expose them\n- `ssb-rpc-pluginname` modules for the most common plugins\n- expose plugin rpcs in `ssb-rpc` and `ssb-client`, but behind a `#[cfg(feature = \"plugin_pluginname\")]` feature gate, so that it is always explicit when you are relying on plugins\n\nI'll prepare a `Contributing.md` explaining how to add new rpc methods to the client library, so that it will be extended collaboratively (and also so that nobody needs to get stuck just because the client library does not support an rpc yet).\n\nI'd also like to do a call where I give a tour of the code: Starting with how to use the client library, then showing how it can be extended, and then digging as deep into the protocol stuff as people care about. Are there enough people who'd be interested in that? In any case, organizing that can wait until all of the code I've been talking about in this post actually exists.",
    "mentions": []
  },
  "signature": "4BIwmN8hQLpPSiq1EqZzKfbfwe/YA0yAQNzIjRdgk2lLmmdt1tpUjtAzmj2Nst5P0PVfyxGRYNVEsyyl4AYWAw==.sig.ed25519"
}

{
  "previous": "%mCWZ964LlVaEVpGKEv37H0hx3qCcQTdOnB+lJjTWch0=.sha256",
  "sequence": 565,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519590716066,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%IiPe/31Y7vlZeW8bHtOr41xD4cR0NsGqe1aMvKetAp0=.sha256"
    ],
    "packs": [
      {
        "link": "&tt9ya+Tf8Rz5gRZDiEmZsus5pBa7+WMszpg/3eYiHjg=.sha256",
        "size": 6485
      }
    ],
    "indexes": [
      {
        "link": "&IIQSyez3S4omR4kIvbujX++UTidn2iFCYv0idHjIA9c=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "813207691b83333ba27b0c1c29507d1a20123015"
    },
    "commits": [
      {
        "parents": [
          "75151e09bf86009ecf2291f4b99cc8bed606bd8a"
        ],
        "title": "Bump version to 0.4.1",
        "sha1": "813207691b83333ba27b0c1c29507d1a20123015"
      },
      {
        "parents": [
          "f4077e68303273a7b221303b5c0a35abfd72e6a3"
        ],
        "title": "Implement error for ConnectionError",
        "sha1": "75151e09bf86009ecf2291f4b99cc8bed606bd8a"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "3b8e8dc22cbd6edbd3c4ced9f1a03c5b7d4e91f6",
      "64c44dd0674de689f6d9c421afe112ed26d06734",
      "8077a5a28ad372bb7f77347bb01123f2fcd18a8c",
      "0e1d35ee591142be4f7999da13a59380bb58a6dd",
      "4b25fc5da97fa3e3fce248124e3ab375abdb1056"
    ]
  },
  "signature": "9sUKckx0rw/SG6VxKjF44JD91rOMoK86/vJ+2/VycctWPFzsm9k+zmBTGLg/f1tdR9BTlKKWvPs5WLy57vZfCQ==.sig.ed25519"
}

{
  "previous": "%UH7kxbOPeswP69h3VmndE0V7ZUZtgDmjTNE1U2ymf48=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 566,
  "timestamp": 1519596702218,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%mCWZ964LlVaEVpGKEv37H0hx3qCcQTdOnB+lJjTWch0=.sha256",
    "reply": {
      "%mCWZ964LlVaEVpGKEv37H0hx3qCcQTdOnB+lJjTWch0=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "> Building muxrpc on top of it shouldn't be a lot of work.\n\nI should not have written that. I really should not have written that.\n\nI just hit a [major blocker](https://github.com/rust-lang-nursery/futures-rs/issues/623) with an oversight in the definition of the `Sink` trait that prevents me from writing typesafe muxrpc. Basically the kind of item that can be written into a sink has to be specified once and for all when coding the sink. But for muxrpc we need different sinks to accept different types, depending on which rpc they handle. The type system has facilities for expressing this, but the `Sink` trait does not use them.\n\nEspecially frustrating about this: I had just realized that the muxrpc-rs module would have turned out nearly completely json-agnostic. By changing a single `extern crate serde_json;` into `extern crate rmp_json;`, we could have gotten [MessagePack](https://msgpack.org/) rpcs for free. Or any format on [this list](https://serde.rs/#data-formats). Ok, actually we'd also need to provide custom serializers/deserializers for the types in `ssb-common`, but that would only be a few hours of work.\n\nBecause of this, I'm honestly considering defining the corrected `Sink` trait myself and using it until `futures` updates to `0.2.0`... But that would mean that the whole ecosystem around the sink trait would be unusable with ssb-client.\n\nThe alternative is to keep the muxrpc interface byte-based and provide the static typing in the ssb-rpc module(s). But that's a very leaky abstraction. I'm pretty sure *the right thing* would be a custom sink trait.\n\nGah, this is so frustrating!\nAnyways, I'm off to sleep now, and I probably won't get to code a lot for a week. But I'm curious how (or whether) the `futures` crate maintainers will react.",
    "mentions": []
  },
  "signature": "qY3AsmXT1azO1ind8nVKLihqcFZhrTdvagKamiWrrb1IN+JUfVHFMhX7x/tNI7SkGvnpGcNTFSCtBfTI63NnAQ==.sig.ed25519"
}

{
  "previous": "%0G+gpDZJTNPCsviYqtbvmWvUh1M13rJUDwbk1pLgkSM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 567,
  "timestamp": 1519596726435,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-implementations",
    "vote": {
      "link": "%LZHr2I1OnpU8l1LZRNO1u+jxHOs0UOg4baEf1RyYak4=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "L2PIJXupAq3JuWNl1JpJ0YR+brtkDQ3yqVSlpuUNT7gGGSxPLbFjIPBmsxXfYTaIwNBdNQk/bG0p+tomljz2DA==.sig.ed25519"
}

{
  "previous": "%yvawHb2uQqska24Xhg7TD58g8rlqORQhFg2YdgUcHkc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 568,
  "timestamp": 1519686026048,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": [
      "%0G+gpDZJTNPCsviYqtbvmWvUh1M13rJUDwbk1pLgkSM=.sha256",
      "%LZHr2I1OnpU8l1LZRNO1u+jxHOs0UOg4baEf1RyYak4=.sha256"
    ],
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "In this post I'll describe some design decisions for the muxrpc module. Note that none of this influences the API of `ssb-client`, all these details will be encapsulated by it. But these are some fascinating trade-offs to explore, between static typing, ease of use, ease of development, performance, extendability and so on. For simplicity, I'm going to pretend that everything is synchronous and error-free. That's very much not true, but these issues are fairly orthogonal to the stuff I want to talk about here.\n\nThe (de)serialization framework [serde](https://serde.rs/) works via four traits. If a type implements `Serialize`, it can be serialized. If it implements `Deserialize`, it can be deserialized (who would have thought). The implementations of these traits are not tied to a specific data format (like e.g. json or msgpack), instead you (de)serialize from/to a serde-internal data model. Which is a simplifiction because this only happens at the type level, but that's not important here. The actual data formats are provided via implementations of the `Serializer` and `Deserializer` traits. We don't need to implement those ourselves, unless we want to use some obscure/new data format.\n\nLet's think about the API for muxrpc `async` rpcs. These are your basic request/response format: You send one piece of data to the peer, and you receive one piece of data in return. Mapping a response to a request is done by lower layers of the protocol stack (packet-stream), so we don't need to concern ourselves with that. When we want to send a request, we need to give two pieces of data to our api: The name(s) of the request (a list of strings), and the arguments (a list of arbitrary json values). As a response, we expect \n\nThe [`serde_json`](https://docs.serde.rs/serde_json/index.html) crate provides an enum for json values, appropriately named [`Value`](https://docs.serde.rs/serde_json/value/enum.Value.html). So a very simple API for `async rpcs` could look like this:\n\n```rust\nfn async(names: Vec<String>, args: Vec<Value>) -> Value {...}\n```\n\nThis is basically the least amount of typing information we can get away with. We can send arbitrary json values (and an arbitrary number of them), and we might receive arbitrary json. The function would take care of converting these `Values` into raw bytes (actual strings of json) to send to the peer. Fortunately we don't need to directly work with these values. `Serde_json` provides functions for creating `Value`s from any value of a type that implements `Serialize`, and for creating values of types that implement `Deserialize` from `Value`s (also providing solid error handling). Even better, there's (usually) no need to implement `(De)Serialize` by hand, because serde provides [procedural macros](https://serde.rs/derive.html) for automatically deriving them.\n\nWith this API, the `ssb-rpc` create would simply define types describing the arguments and the return type, derive `(De)Serialize`, and `ssb-client` would provide functions that take these static types, serialize them into `Value`s, passed them to the `async` function, and deserializes the returned `Value` into the correct type before returning it. Everything works, the consumer of ssb-client gets a statically typed interface, life is good. Actually, we can do somewhat better by statically encoding the number of arguments, but we can ignore that in this post.\n\nBut there's a problem with this approach: The `Value`s need to be allocated and created at runtime (and since `Values` can form arbitrary trees, there might even be heap allocations). That's not very cool. `Serialize` and `Deserialize` can allow us to directly work with the raw bytes we send/receive to/from the peer. So we don't want to have any `Value`s in between. The solution is to parameterize over the argument and return types:\n\n*continued in the next post*",
    "mentions": []
  },
  "signature": "vEpAcyCP2np2zGsO3tJe9PplEhY5HK44PMaGOCqfqzaHu1UXId2CDQL20DGQh04F+Wuz8ronIWRUcjEUVtQGCw==.sig.ed25519"
}

{
  "previous": "%IMeATKNQR/2acgfG7KQo3qLz/j7Qg1000q77wBplovI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 569,
  "timestamp": 1519686066458,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%IMeATKNQR/2acgfG7KQo3qLz/j7Qg1000q77wBplovI=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "*continuation of the previous post*\n\n```rust\nfn async<Arg: Serialize, Ret: Deserialize>(names: Vec<String>, args: Vec<Arg>) -> Ret {...}\n```\n\nNow the implementation can directly convert the `args` into bytes, and directly deserialize the response into a `Ret`. So we get a performance improvement. But there's more: Previously, ssb-client needed to invoke serialization/deserialization to/from `Values`, but now that is encapsulated in the `async` function. Ssb-client simply supplies the type arguments, but it does not need to implement any logic at all. There's one more benefit to this api: We don't have any json-specific code anymore. So the muxrpc implementation can be parameterized over `Serializer` and `Deserializer` implementations. We get any of the [supported data formats](https://serde.rs/#data-formats) for free.\n\nThis approach also works for the other kinds of rpc methods (which involve sinks and streams). Or at least it would, if the issue from the previous post didn't exist. But that will be fixed eventually, so let's just pretend everything works perfectly.\n\nSo for sending, we have an api that is ergonomic to use, efficient to use, and data-format agnostic. But here's a problem: We can't get the same for receiving incoming rpcs. Since ssb-client doesn't need to receive any, that's fine. But I do want to fully implement muxrpc. So where do things go wrong with receiving rpcs?\n\nRpcs are received as a single json object with a `name` field (array of strings), a `type` field (the kind of rpc method) and a `args` field (array of arbitrary json values). When we want to deserialize this object, we don't yet know the `name`s, so we have no idea what type to deserialize the `args` into. If the protocol first sent the metadata (name, type) and then the args, we could probably work around that. But with the current protocol, that's not possible. And even if the protocol worked that way, it would still be difficult to return things of different types depending on the value of a previously received item.\n\nThere's also a problem with providing the correct handles for communicating with the peer: An rpc of type `async` produces different handles than a `duplex`. I have the nagging suspicion that a fully generic solution would require [generalized algebraic data types](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type), which rust doesn't support. I may be wrong about that though (needing gadts, not about rust not having them).\n\nSo we basically have to deserialize the args into an unspecific type: `Value`. But at that point, we are tied to the json format again (serde provide an abstract for these catch-all types, and there are good reasons for that, for example not every data format is self-describing, so it's impossible to provide such a type for some formats). And we get the intermediate allocations as well.\n\nIf I was writing this in #haskell, I'd probably try to solve this on the type level. But for now (and in rust), I think I'm going to be pragmatic and emit incoming rpcs as `Values`, and have the corresponding communication handles also work over `Value`s. It ties us to json, and it does stuff at runtime, but it will work. And for the end consumer, these details should be wrapped behind a statically typed API anyways, so at least the convenience and type-safety won't suffer.\n\nSo to summarize: Outgoing rpcs will be parameterized over `(De)Serialize` types, which is awesome. Incoming rpcs need to do stuff at runtime, but that's ok. Ssb-client will explicitly ignore all incoming rpcs (without parsing them), so it will only use the awsome parts of muxrpc-rs. Ok, the last thing is a lie: Because of the [problem](https://github.com/rust-lang-nursery/futures-rs/issues/623) with the sink trait, there will be `Value`s involved anyways, until `futures 0.2.0` is released. Because since the whole thing is hidden behind the ssb-clien api anyways, I'm going to chose the pragmatic route here as well.\n\nThank you for your attention, I really need to get to sleep now.",
    "mentions": [
      {
        "link": "#haskell"
      }
    ]
  },
  "signature": "2yVd0WZvaVTfK7Dp2WLD6ix33gViqOK2vFtF5y2JwdtkvXWhcnwoSSVHEI7w3UwR9PlBmRuddH1i3hlpjrkmCw==.sig.ed25519"
}

{
  "previous": "%MQk6J0cnA0VpPT4+ZDbLivHaSMV5nphUymFqDpV9WcU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 570,
  "timestamp": 1519850733558,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%wD21N8VTJCScfaccdes/Yjqqj/oOL1c1brh+bg+mT28=.sha256",
    "branch": "%Z8ndrEjaP17QuuCxDQqju1nRPtxoCrjkSlQrGXjmEYE=.sha256",
    "reply": {
      "%wD21N8VTJCScfaccdes/Yjqqj/oOL1c1brh+bg+mT28=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Yes please!\n\nThis sounds like a lot (!) of work. I would already support a proposal for nothing but a language-agnostic, ipc-based redesign of the plugin system. Getting this right is a really important step for getting more diverse implementations.\n\nI also agree that this does not conflict with the rust stuff. The languages are different enough that having implementations in both of them is a good thing. And in general, the less js-centric everything becomes, the happier I am.",
    "mentions": []
  },
  "signature": "6x2ClpebYIGLpvZfGgaxl4Dm8BIzN5UObtb4oskdyKZY7HYR5+X0+qH+AIp0XadjfLxXGZ0kLq6Y/kq93GJVDQ==.sig.ed25519"
}

{
  "previous": "%v0qvvF1CnEDQNwYpsMDq+yNkiQnPsx3bWgwnKzNh+RY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 571,
  "timestamp": 1519850744053,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%wD21N8VTJCScfaccdes/Yjqqj/oOL1c1brh+bg+mT28=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "4K6CovfuPl47ZQa5xUZa91EfdgLNmVPAq78VeCnObxnGwYz4lu3UAigDvbAYfLl7uN6QmGjuHL9SL/Ay2mZ6CA==.sig.ed25519"
}

{
  "previous": "%krI5LMLwfzX/s3A6yhCSr7Ue1R8mfQf1Rm4sjevg+TM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 572,
  "timestamp": 1519851101889,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%wD21N8VTJCScfaccdes/Yjqqj/oOL1c1brh+bg+mT28=.sha256",
    "branch": "%v0qvvF1CnEDQNwYpsMDq+yNkiQnPsx3bWgwnKzNh+RY=.sha256",
    "reply": {
      "%wD21N8VTJCScfaccdes/Yjqqj/oOL1c1brh+bg+mT28=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I'll also use this space to say that I'd love to see a second round of [@vtduncan](@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519)-docs: Muxrpc-7, replication with ebt, common plugins, multiserver, flumedb, general server architecture, etc. would all be extremely valuable to have and significantly enable proposals like this one.",
    "mentions": [
      {
        "link": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519",
        "name": "vtduncan"
      }
    ]
  },
  "signature": "Y6XE4DmnSy1U4kuWsarWExQtuBTWIKXYvEoVVAvUB6apbZKy2T909lyP7GwlWgfnLXVrNJSzlHAwR2OWxXzmDg==.sig.ed25519"
}

{
  "previous": "%lmnNtz8ISiDe0vcn4UTI4VXpdST8X9X1Ud4NiEdppnc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 573,
  "timestamp": 1519903553310,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc-grants",
    "vote": {
      "link": "%pNYTZLQB2AijbErEV3XmFIwxtltP5PyDRul4Rp2CTSc=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "pYxMOCWLNbKVhx6OB8OW5q1eQmWlzYyOu8EMicP+hJXUYJKZczFmqmR6Ji4fm+YtN+KztkLCHe0par7sTtVuBA==.sig.ed25519"
}

{
  "previous": "%3dIK/7jhGSfq9OfZa3NLRxZGdd0FcuJngdRxaqLNrB0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 574,
  "timestamp": 1519904693853,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%wD21N8VTJCScfaccdes/Yjqqj/oOL1c1brh+bg+mT28=.sha256",
    "branch": "%D8hccS4QcnwFjUAvmzgXGGySCntRHeLUSeIyDa4mnYE=.sha256",
    "reply": {
      "%D8hccS4QcnwFjUAvmzgXGGySCntRHeLUSeIyDa4mnYE=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> > This sounds like a lot (!) of work. I would already support a proposal for nothing but a language-agnostic, ipc-based redesign of the plugin system. Getting this right is a really important step for getting more diverse implementations. \n>\n> Interesting. This only came up recently in our discussions and we didn't perceive it as a core part of the proposal. We can definitely prioritize it and make sure that this part turns out super clean and we then start building things (e.g. replication etc.) around it.\n\nAs I view it, this is the part that has the biggest impact on ssb as a whole, not just a particular implementation. Having the choice between a monolithic js server and a monolithic go server is nice, but image a set of plugins, each with a well-defined interface that hides all implementation details. Users could mix and match specific implementations of these. Instead of having to \"rewrite all of ssb in XYZ\", you could start by \"rewriting ssb-backlinks in XYZ\". And then see whether XYZ is a good fit, what performance/portability/safety/etc concerns need to be addressed, and iterate on it. This will also nudge devs towards a modular approach.\n\nMost importantly though, an app that needs a custom plugin does not tie itself to one specific implementation (or alternatively, does not have to implement the plugin in multiple languages). The current system simply does not scale in respect to the number of different ssb implementations.\n\nThere are some interesting questions about such a plugin system:\n- ipc or networked?\n- plugin versioning?\n- muxrpc or custom format?\n- encrypted?\n\nMy current preferences are a multiserver, muxrpc based system without versioning. Plugin management (installation, dependencies, versioning etc) should be solved on a higher level in my opinion. Being transparent about whether a plugin runs on the same machine or on a dedicated server would be cool. For example, you could have a dedicated server for full-text search, without needing all the indices on your own machine. As for encryption and more efficient channels (e.g. unix domain sockets rather than tcp), I think multiserver should provide support for that. This isn't only plugin-specific: Why does patchwork talk to the locally running database via an encrypted connection with error-correction heuristics? But that issue is a separate one, so I'll stop hijacking your grant proposal now.",
    "mentions": []
  },
  "signature": "HAOQBt+IcXEFhZjvTL0u8MhYdqp1mEEruTUx8zQ7s5JdOZ17LC9LMkmNT0W3BHn/e3mgiA0YNVF16F7wtoAwAQ==.sig.ed25519"
}

{
  "previous": "%77auvJLC3N6iRnpVXO5RUl3/YcGmeS5Gfd6BkONXJK8=.sha256",
  "sequence": 575,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519920005435,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ru9GurSE69M5aCwdUX1SaAJCOWMOd6WZMaALr9pzmIg=.sha256"
    ],
    "packs": [
      {
        "link": "&TXjbyYpcH20QgnWp3Ss7Fosfq/2PacDhQMKqt+KfmY8=.sha256",
        "size": 5963
      }
    ],
    "indexes": [
      {
        "link": "&36jDzK5cEBw7stFqJW015EWaAzg3J+c0yoY46Uf67/8=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "896a08ab94762e65ba4ebd111f5870498ca9ef0b"
    },
    "commits": [
      {
        "parents": [
          "41f89a751035690156c27b36987d01d3d6697b51"
        ],
        "title": "Implement asyncy",
        "sha1": "896a08ab94762e65ba4ebd111f5870498ca9ef0b"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "8a1821fba5b42f30c5f5118e7bb74646d3c23c38",
      "4eed50d699888a48799328813017e944547c1b4c",
      "8ca607b796e6489f0af6bff8faa98153ccddf398",
      "dbd1889d12dc12e160455c51eae8e50fcf14009a"
    ]
  },
  "signature": "2x/fRzsrqWMoTGNEaqATDez754QRZXiin7yQnerHJF37kLXMKtpmy5OiwlzEcLnw9IjRBZ56H0styAAQs0J2Bw==.sig.ed25519"
}

{
  "previous": "%f212VrBTYaAjSUuh5X2mX9God+tTFuPx5jSiu87DCUo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 576,
  "timestamp": 1519932412270,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
    "following": true
  },
  "signature": "NwrhI/NkISTe1gMAnv4/UGP8rlFOIWRyNGWVcBLu/W4WyHdDbHnhmBsoxLGNyGua4aeJN4h5W4vphwZp2CEWCw==.sig.ed25519"
}

{
  "previous": "%4OVMa4lQ+dZCfJ4obUWPC/AqKVTMrSxOL/6M5RoPs4I=.sha256",
  "sequence": 577,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1519938323854,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%f212VrBTYaAjSUuh5X2mX9God+tTFuPx5jSiu87DCUo=.sha256"
    ],
    "packs": [
      {
        "link": "&N7Hfq/GsYh2C8KM0ul7Mg7BiRB6dJXNprgYYyTRDtKY=.sha256",
        "size": 6196
      }
    ],
    "indexes": [
      {
        "link": "&WgPflRcKlGtyOrJytXSkQwTMsMKVjQw24CwJcCb7By4=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "cad86a3e30086fe1b7818181a9287457cd0517ab"
    },
    "commits": [
      {
        "parents": [
          "896a08ab94762e65ba4ebd111f5870498ca9ef0b"
        ],
        "title": "Clean up async",
        "sha1": "cad86a3e30086fe1b7818181a9287457cd0517ab"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "55f02a265b193108e869facfa8af84468fc626f4",
      "5217ab6cb577d041e682d669117d7e4666bd9c86",
      "cffe883134e3f1c97da32c789f68ef2261010882",
      "b2622f07d1089e1779371638d395f792f861c3cc"
    ]
  },
  "signature": "PwoV9E9A/yLsnmw59+4hqUYvAa7WTCryJV7WM6Y7GJ3vhb/w9wFdl+wlIfN53HV8Z/KMfXVNFzwjt7OoS/ElBA==.sig.ed25519"
}

{
  "previous": "%Hl2R2grWnfduXDHof637Th0xs9NuqNhN5tC09welhCM=.sha256",
  "sequence": 578,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520013192351,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Hl2R2grWnfduXDHof637Th0xs9NuqNhN5tC09welhCM=.sha256"
    ],
    "packs": [
      {
        "link": "&R9uK1vgbGEmUKxFRdLwUvLEIf65sx9iwEq85ZsBSBew=.sha256",
        "size": 7292
      }
    ],
    "indexes": [
      {
        "link": "&/PXG7KQswwW2OQ1QtLDbbQq7fJ7agaiOwGyg/3qEG4M=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "1c44b56e45c6ddf3337ed0cc4fbe818707db4165"
    },
    "commits": [
      {
        "parents": [
          "d9f87c5a81a2c97db71a2c2b5cc744b5823f6248"
        ],
        "title": "Add PeerError",
        "sha1": "1c44b56e45c6ddf3337ed0cc4fbe818707db4165"
      },
      {
        "parents": [
          "cad86a3e30086fe1b7818181a9287457cd0517ab"
        ],
        "title": "Move errors to separate file",
        "sha1": "d9f87c5a81a2c97db71a2c2b5cc744b5823f6248"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "216ff1695fae0d0f2b6000d3796422befce50d75",
      "b6454597deddec5ddbf42f715157abc4a84828aa",
      "4b0fc646606208f21c39c6d6f28024de4fd10335",
      "656c7130df724cc595446ebc7c95f00fd6a23037",
      "86912dab45ff581177411663644bf2b36be0f2f9",
      "1582dc95f0d9c303ab74c6a8d0654f0b71535bb7",
      "d9968ac9f81dedb6b5b0921858d8cd59515ced3c",
      "0158b7ca2a715ab1baed9d998a207c1c86042320",
      "0fa07636b44969df750d2c25130373bb0e534932"
    ]
  },
  "signature": "4V7SotO+nXjoHLPv2U2XR4nCaUbKpUQrYsbmAXafhGcBgCmssPUDVkRl4ZvtXR9RImOeP24ocX2+2Xxab0FHCw==.sig.ed25519"
}

{
  "previous": "%mE9MJ8bO8aFCGGaqWBXeBhWCE/kTqJvxBwcIb7/VOog=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 579,
  "timestamp": 1520068033546,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%RJO0l//xSSPGOi93i5i7Q49NhB+p5wgLqoNXMHlxmGs=.sha256",
    "branch": "%VbWxxyfmxJAOG3BbhzjZmlgP5aW+heIKkbtDxBo3SAU=.sha256",
    "reply": {
      "%RJO0l//xSSPGOi93i5i7Q49NhB+p5wgLqoNXMHlxmGs=.sha256": "@MZ02s9Z2iR8VtKY27ZiQzopGZzzyD3DxfFPuLBRG1IQ=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "The short answer: We don't use merkle trees, we use a merkle list per identity. Instead of deltas, there's only the length of the list.",
    "mentions": []
  },
  "signature": "TRqjiQmGgNGQ4FznBvN3gKYT4aOdhS1yA8gqmEDyZuvBJVIBVoYlYv3UbC29a71V+q3jke+oqJZosVAc5+1+DQ==.sig.ed25519"
}

{
  "previous": "%ZU6bCJNUC+XCryGGvX3vmxMHAgvLhX2oXXtmfdIINlQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 580,
  "timestamp": 1520068674324,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%CYa3IvNudZnsmGbMm57wUZNt8qH7vLv/VJGmWBqRX9s=.sha256",
    "branch": "%7RggrrVPr/mJKCnCcUmYqYB2jOJS8t7Pcf3EudqLkLA=.sha256",
    "reply": {
      "%CYa3IvNudZnsmGbMm57wUZNt8qH7vLv/VJGmWBqRX9s=.sha256": "@ZjbRQS4Cqli5cvYRem4eGt2uCKuPqT35Cq9IIMwnG4U=.ed25519"
    },
    "channel": "ssbc-grants",
    "recps": null,
    "text": "#### Go Node\nHaving a compiled server that does not periodically run out of memory and crashes seems like a good thing to have in the short term. And the technical plugin stuff discussed in the grants thread is very important in the long term (a very explanation of the situation: Many clients use plugins to augment the functionality of the database/replication server they connect to. The mechanism to do this only works with the js reference implementation (sbot), but is fundamentally incompatible with servers written in other programming languages).\n\n#### [@Angelica](@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519) as artist in residence\nWe are trying to build the future we want to live in, right? I want to live in a future with artists in residences. I won't even try to frame this in an objective way, because this is just my subjective opinion.",
    "mentions": [
      {
        "link": "@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519",
        "name": "Angelica"
      }
    ]
  },
  "signature": "k42kzS82s1xt9+Foio+N7gIZOJKiQjmhFZxR2fxPNqpb2lDqMwgtf3xK+8nxxCDJRQZ3ulOpRa3TjFN0D6wHCg==.sig.ed25519"
}

{
  "previous": "%dbwKVl/jtwCIsyjSoZk50YYb0BSZ2AIAepQXjTIO4us=.sha256",
  "sequence": 581,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520080165782,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%bpVfVHm3eOu1qALEYT6rhBPRY9tVmIU7P2SNVjIkuCs=.sha256"
    ],
    "packs": [
      {
        "link": "&bEgm/ZCTyq+hEswnKitV+YIiSqriraBKGj5/+VBkvX4=.sha256",
        "size": 1703
      }
    ],
    "indexes": [
      {
        "link": "&m0206OEFD4hEESw8kUERXKEyDtdLrsL9NQMS7WLdcIw=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "b1dbe72fdc5d8937ee58a52a48c2e926f73e7da0"
    },
    "commits": [
      {
        "parents": [
          "e2a9d98e7e7b3c3883d5fc11760eee44336ce294"
        ],
        "title": "Bump version to 0.1.2",
        "sha1": "b1dbe72fdc5d8937ee58a52a48c2e926f73e7da0"
      },
      {
        "parents": [
          "a993170e7a1281704827adbdeecea6c69e49ec34"
        ],
        "title": "Add SendClose future",
        "sha1": "e2a9d98e7e7b3c3883d5fc11760eee44336ce294"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "1c4c388989140b130007280d7932b7a3c56f67f0",
      "bfad34a5fb03c176bceb8e6081b504f908501fed",
      "105d438accf5dda5835ff9165999e51723b3cbc3",
      "1161fe5ec7096b220500df784617dbf46a05abf1",
      "0ad037fb74fd1f46a4a33734ee25b0c65bd0e772"
    ]
  },
  "signature": "1rBriE4AuUBOdF9GKzOy84O+RhvGbW1NAF8QTWt9LiTCOJc9gvPLlHknTKlmYD3i/lTh2nw4lXRHX65cwiwXDA==.sig.ed25519"
}

{
  "previous": "%gjhLq5b26TyUjeQkhLgnHSu/Xak30zgfw4SMIV9y/kM=.sha256",
  "sequence": 582,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520080830289,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%UH7kxbOPeswP69h3VmndE0V7ZUZtgDmjTNE1U2ymf48=.sha256"
    ],
    "packs": [
      {
        "link": "&WtiCLUWYFBfZkHFPux5DYNoSWou+MZiVK9plKFL+W6o=.sha256",
        "size": 6195
      }
    ],
    "indexes": [
      {
        "link": "&u2RJEQLcGOabMsWLWvVEANc9AyaSR4tGyS7H/5uFNK0=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "56e0feeba4fafc202e7b0b08249104b51a0d7b6c"
    },
    "commits": [
      {
        "parents": [
          "813207691b83333ba27b0c1c29507d1a20123015"
        ],
        "title": "Use SendClose util",
        "sha1": "56e0feeba4fafc202e7b0b08249104b51a0d7b6c"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "c9e039c7de2a8e5b10d38d58194faee7e981753d",
      "be006e84deb33b11c086687aa2e4f4e421b10619",
      "e7f578a49ccbd89b1eb9aa59656a4203fde49d9c",
      "a004ffdf5c462a99ad8c69245deaba42039157a6"
    ]
  },
  "signature": "UVyGATErQgflxyBRniswlUv0wdy1IudpvN6ZlowWXquqJ79IlUJCEPpv2xb3nF9wYg+7Yyv7clgsiefsxZ9SDQ==.sig.ed25519"
}

{
  "previous": "%mfmCn9rb/Nou+y++ZBkrdvEgCzbevLkDwyXZl/NK9Po=.sha256",
  "sequence": 583,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520093206842,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%mE9MJ8bO8aFCGGaqWBXeBhWCE/kTqJvxBwcIb7/VOog=.sha256"
    ],
    "packs": [
      {
        "link": "&9D50HYTAk+G3ZIxhYjtBOKuN0DL+Kr5RMbkffjH/euc=.sha256",
        "size": 7777
      }
    ],
    "indexes": [
      {
        "link": "&vlLOJdVtCCwByy21B36BvwoUz4hJPeGj5pUCBJ0CDKM=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "68a931b014aef7555618cc273721a4e0dc407a57"
    },
    "commits": [
      {
        "parents": [
          "1c44b56e45c6ddf3337ed0cc4fbe818707db4165"
        ],
        "title": "Implement RpcStream",
        "sha1": "68a931b014aef7555618cc273721a4e0dc407a57"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "edd52e2ed998eb70e28830c268c024daf8134dee",
      "5f5dcd55e94465ac162b593bc622085576f0125b",
      "1969b2fe7007b6ecb220c5b42a83abf3eac71adb",
      "798b26e12626194469521f10c53e631add2543dc",
      "72629a84b7d359eefcacaf4a705c034738d60014",
      "a4045724c40219c1a2b54313b3d59cecee5d5353",
      "8fff5bfc1fd78a2578b05916770a3c807b9e3eb5"
    ]
  },
  "signature": "PVLAoQcv+dTg1z365lhxAKlX+w89vZ65ZYxvo18mzbnall90JhhVdbsNZb3KlVDQGHNfUlcW2vePf+DrrTdYAw==.sig.ed25519"
}

{
  "previous": "%8xrO7lAIatO7Chz5k8u1YWIxvzSZ8fMyRoTIr5vP/j0=.sha256",
  "sequence": 584,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520110296716,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%8xrO7lAIatO7Chz5k8u1YWIxvzSZ8fMyRoTIr5vP/j0=.sha256"
    ],
    "packs": [
      {
        "link": "&f5+X0vstI1vssOcL0Ksf6FtbpjMuV3e0mzcZyeKo05s=.sha256",
        "size": 7428
      }
    ],
    "indexes": [
      {
        "link": "&67JuEVmUf8IxEbBzrtTEjKUzr4OiCVboq92ZzQ4j5b8=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "7801c55001eed888dbb8b62960054a8469943f63"
    },
    "commits": [
      {
        "parents": [
          "68a931b014aef7555618cc273721a4e0dc407a57"
        ],
        "title": "Implement and test RpcSink",
        "sha1": "7801c55001eed888dbb8b62960054a8469943f63"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "3cab75c0dcda8bc8438528e50e44f91e647520fd",
      "355e8c02de012302da553b2601cd50ffb644b24a",
      "9c20e967a300a95b2d9caf4b177c6cc68642d917",
      "0bcc0d5ff18a01203aa6398c12b9f62f16561546",
      "bc337ac08f4ea672e59833f64ca518541fae48f2"
    ]
  },
  "signature": "LLUamTps642P8lOrm1E6nsybexw9U+Dz9FVgCCSbP1UDhja8qFNhN/LzfDJ8jZvmXATh+LuqAIEjU2WD8hKVBQ==.sig.ed25519"
}

{
  "previous": "%jR4BZjpdI5N0KDBk01OONFS9UWSHmTOug04eamH0kIc=.sha256",
  "sequence": 585,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520112986901,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%jR4BZjpdI5N0KDBk01OONFS9UWSHmTOug04eamH0kIc=.sha256"
    ],
    "packs": [
      {
        "link": "&Dphef1rcFIIAEoA7RJM9+0U1JfZSDQIrwFoBzpF8kKM=.sha256",
        "size": 5526
      }
    ],
    "indexes": [
      {
        "link": "&VrAlDl9KroWDlr84/8bloiYNBdZf5uvKTG0cY6Hmn9E=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "622197f180125284b96db56927f2e784482005cd"
    },
    "commits": [
      {
        "parents": [
          "7801c55001eed888dbb8b62960054a8469943f63"
        ],
        "title": "Test RpcStream",
        "sha1": "622197f180125284b96db56927f2e784482005cd"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "93a79d6c1a297f780f0845a6be53b529e01525a5",
      "41a1e2cee5a1cf46581eae3c669719164cd38d5d",
      "51510bc35299f8911902fee104171235ea9faa31"
    ]
  },
  "signature": "UdkvXvYxBUMl6pHJkK/AA6gFiOhGxXhCGyY5X16njuc5hbaollv1c3ScHD8zKZ4tCDwO45OgvJow/JCONoOcAQ==.sig.ed25519"
}

{
  "previous": "%D0faV9ZVfAX3KFdJ9UNWpeaZ6sgAQEo+j5v0Ib2BA3M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 586,
  "timestamp": 1520113422500,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%w1wPSI8UiOtadwp/e+t7+aXoumNOjzBo8PxOF3walWE=.sha256",
    "branch": "%AulN3TgX7LedicbeTPsEvgdJnx1ndxwmTGruQj0fL5Y=.sha256",
    "reply": {
      "%w1wPSI8UiOtadwp/e+t7+aXoumNOjzBo8PxOF3walWE=.sha256": "@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519"
    },
    "channel": "ssbc-grants",
    "recps": null,
    "text": "Some clients have support for custom emoji, as introduced [here](%RfQ2qb/wqQ/CfiwogMLFfNYJDwOFBe0+pZIP7yh6ANM=.sha256).",
    "mentions": [
      {
        "link": "%RfQ2qb/wqQ/CfiwogMLFfNYJDwOFBe0+pZIP7yh6ANM=.sha256",
        "name": "here"
      }
    ]
  },
  "signature": "aCgQ86TI8O9ICLUkC9eui15daU67q38HG3gLnqnytCZljhyf8GElV9ZrVAuBJ9cM2FYZk/hS+MdXRJGgEhmAAg==.sig.ed25519"
}

{
  "previous": "%DFhyvL2pXFjXMFriswpQnmpzlTT2Q94HH+pJNw+fnkA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 587,
  "timestamp": 1520113674223,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc-grants",
    "vote": {
      "link": "%w1wPSI8UiOtadwp/e+t7+aXoumNOjzBo8PxOF3walWE=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "Qjml3wSxH0GMl6ETsZfxGCviqVpkjjjf9TDRX42D2Nr5bi34Qh/pzDwNRiVkHjj+yH4Ew2RfB1o8/2sy1Q4HAQ==.sig.ed25519"
}

{
  "previous": "%GqkQrJeBzBZBiKfWqgrz+6CYppqaun5cC2Wiy4dFSZM=.sha256",
  "sequence": 588,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520161135356,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%mfmCn9rb/Nou+y++ZBkrdvEgCzbevLkDwyXZl/NK9Po=.sha256"
    ],
    "packs": [
      {
        "link": "&YiZhg4oZ8IfI/YnQcSOCZHUuKAM2WL7DBwNQtq3oiH4=.sha256",
        "size": 6484
      }
    ],
    "indexes": [
      {
        "link": "&OMZa/5R55Zxl+p9iqMPJ8LH8UPrI8zJREMA3E2PdD1U=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "015b3eff7193f8cec802ced8b82b5190fc78aa8d"
    },
    "commits": [
      {
        "parents": [
          "b102bc88b845cbfd425aebfd2d15a72eb58033f7"
        ],
        "title": "Bump version to 0.5.0",
        "sha1": "015b3eff7193f8cec802ced8b82b5190fc78aa8d"
      },
      {
        "parents": [
          "56e0feeba4fafc202e7b0b08249104b51a0d7b6c"
        ],
        "title": "Make close return a future",
        "sha1": "b102bc88b845cbfd425aebfd2d15a72eb58033f7"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "4b245e7949163b638e7fd3ddd4beec3c1837a171",
      "65e7819de71975f5f7cc3b41bd42f3272c356c82",
      "624510a13952a689f5a1b239f9a777d0c05dfa74",
      "74572cd37d575d27476780b76ad03a200fc304ca",
      "5725df705b69cbb6d87d1194a93ba424a58c6f2b",
      "bc23f38c1ea5e3b26b6a30b4685f89a4197666b1"
    ]
  },
  "signature": "116CopsIgftpmWEBtkC/diWplkL4sW1mLowBJSMvplGgUoC32rlJxWLLmsQ8Lvkw30Xf50ujyqdlNDHWOcNwCg==.sig.ed25519"
}

{
  "previous": "%gyBRZn7ZxZ7oE6h2eYN/ZpX/L27uwjkwd7JPMIKPf9Q=.sha256",
  "sequence": 589,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520161765264,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%D0faV9ZVfAX3KFdJ9UNWpeaZ6sgAQEo+j5v0Ib2BA3M=.sha256"
    ],
    "packs": [
      {
        "link": "&tLZ8uIqY5I27i7g7Cv7K4Qe7ACksjjUP7iGdun/crK8=.sha256",
        "size": 13194
      }
    ],
    "indexes": [
      {
        "link": "&+MprHHN9COoZeLqugHgOX6thuimepN6PyHj9HUPcAp4=.sha256",
        "size": 1716
      }
    ],
    "refs": {
      "refs/heads/master": "d8140bc6d550742b2e21a27de1c22a74a10864f3"
    },
    "commits": [
      {
        "parents": [
          "6340b4356121e67f88b6bbdea2b7615806ddb777"
        ],
        "title": "Clean up",
        "sha1": "d8140bc6d550742b2e21a27de1c22a74a10864f3"
      },
      {
        "parents": [
          "4cacbeef18249088c401e90a9a82ae4c2cf5684a"
        ],
        "title": "Implement sync requests",
        "sha1": "6340b4356121e67f88b6bbdea2b7615806ddb777"
      },
      {
        "parents": [
          "622197f180125284b96db56927f2e784482005cd"
        ],
        "title": "Implement duplexes",
        "sha1": "4cacbeef18249088c401e90a9a82ae4c2cf5684a"
      }
    ],
    "tags": [],
    "num_objects": 23,
    "object_ids": [
      "97639772bc344e8f459ed0a619d504de1b508617",
      "3359d0310219a214b80eef69ccff1b6fc1d96bcf",
      "8f947038e5cf909ff23ef89c999beb71b8d23c87",
      "6fcf1270af548226721ed824837805673cb68971",
      "550b8f9415bce3fd74fc89d4f25f603cf086def6",
      "4504a8b04d8f69ddeaaff54bcb228c24ff5c5f41",
      "e6cb9415385f5609cf7ebac1b6e4b9efba7fbb8e",
      "63ea7cfb5e481100c4cb0f737d300843ffb52f4b",
      "d675ad0e6b60ecbf6842aaeb19c142ff650430b9",
      "9425663bfe9fc0be44a4eba89a41d2949663c4b6",
      "04d4d6d4bfce312133a1035e933f299d39b218b8",
      "59d06542d6990b2c31eaaf0351efcece5292fa57",
      "421787789a2936832f698b7d582f903bdb29876a",
      "4f447ff442989d0eae6b6868ac1ca39f0ea01300",
      "9250829e5732999976a59d574a56b058da834cd9",
      "50c996eb151467e6c834c61b08e76cda97867e25",
      "f7058caf6cef84f08ea704b0a6abfe6bc7095403",
      "b4fd997d23c7d55c90aab185c9f6c2f7f8d63396",
      "3237a4fe309e555e2ffc92e8c65b7a9ff53ccd25",
      "8d7e7dc5b6724793d88110c324ef38884af570ab"
    ]
  },
  "signature": "ezt1Q5PD8AqrhAF9UMAiAwzm+diEHvjUkYqu1lP0+sjyTiC1EaMf5YIvBfq1eOVBYGZo3fxSi8Wxbkqvsxx1Bg==.sig.ed25519"
}

{
  "previous": "%BPRBiTiX8die6iy1psoGudkJGvpKi4A8zOViAz9a2so=.sha256",
  "sequence": 590,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520164218302,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%BPRBiTiX8die6iy1psoGudkJGvpKi4A8zOViAz9a2so=.sha256"
    ],
    "packs": [
      {
        "link": "&p5lvK60jBkxGx+CTvehJhOoElPiS8XkEUkOHuyUPSH0=.sha256",
        "size": 8741
      }
    ],
    "indexes": [
      {
        "link": "&JOLVZ4xLWj/Lq3JzKg4TxH8hmSDBwJGg2MagfTpIcEg=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "5feab3d73be88b9f2e0bd8510f686015ebd4d3e7"
    },
    "commits": [
      {
        "parents": [
          "d8140bc6d550742b2e21a27de1c22a74a10864f3"
        ],
        "title": "Give more informative errors",
        "sha1": "5feab3d73be88b9f2e0bd8510f686015ebd4d3e7"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "66ea7dcaa16e8885a1edb3044b33a98eae08ad77",
      "5cfb786bf44a5598fbd4fdd667e4ab13d49a612c",
      "348e6abb6209595642a5579b7b249663b0174630",
      "d4221576b2b6303646726a3eccf847c0b4dafdcc",
      "c9f1d8530fcd41ad5c3110d484de7459c43a1c72",
      "be4d19cee05ef039ac2d599851000b80a100a6ab",
      "f72c5315ee7ca31324bec6cbb22c8bfd2b6ecf84"
    ]
  },
  "signature": "A4tUeAWSG93f0lAMbEZ8MPfEC0h9u920lHlC3ut9oLwsOTo1PYrD6LFp0U2Pouu6jPinXyGg+h8WQOvUn/09BA==.sig.ed25519"
}

{
  "previous": "%1q1wgBT55tGBrWIdiEe/9f5B79InJ3qRq3DV3NFwbsQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 591,
  "timestamp": 1520168263661,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%MQk6J0cnA0VpPT4+ZDbLivHaSMV5nphUymFqDpV9WcU=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "And here we go: [muxrpc-rs 0.1.0](https://crates.io/crates/muxrpc).\n\n[Here is](https://gist.github.com/AljoschaMeyer/1bbca333a5482790bdcf8f803f6707f7) an ugly but working example.\n\nNext up:\n\n- There's a lifetimes issue with secret_stream. I can't rewrite the above example with an actual event loop, because the compiler complains the closures might outlive the crypto keys. So I may have to make some breaking changes to the secret_stream API.\n- Implement custom serde Serializer/Deserializers for the key types in ssb-common-rs, then update ssb-keyfile-rs to use these rather than my handwritten string serialization\n- Add types for cypherlinks to ssb-common-rs, including Serializer/Deserializer implementations\n- Create ssb-rpc-rs with a type for the whoami rpc\n- Create ssb-client-rs with the whoami rpc\n- Organise a call for going through the codebase and showing how to extend the modules. [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), can we use one of your mumble servers for that?\n\nCould someone add [me](https://github.com/AljoschaMeyer) to the [ssbc](%7aaCd6xV8EOfDMZYfy30fCLpUEkTKMSWQs1vtC2Ralg=.sha256) github group, so I can publish ssb-common-rs (and later ssb-rpc-rs and ssb-client-rs) there? Don't want to ping mix again, he's already doing so many of these community-gardening things. ",
    "mentions": [
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "%7aaCd6xV8EOfDMZYfy30fCLpUEkTKMSWQs1vtC2Ralg=.sha256",
        "name": "ssbc"
      }
    ]
  },
  "signature": "wZStEpQvEh0PmYYDxisM+c5P5oJIYZCvCdID3jY0uVqKC+FQutMwbt3m9CHTpzFUM2z5UX2XSDiIa1bQErP4AA==.sig.ed25519"
}

{
  "previous": "%0Nl5JUTAhTR+3Jf1blAKabOy6R9ScwX0WL0GPnok/7Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 592,
  "timestamp": 1520183564081,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%0Nl5JUTAhTR+3Jf1blAKabOy6R9ScwX0WL0GPnok/7Q=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Here's more details on the lifetimes issue: The future for performing the handshake takes references to the keys, but [`current_thread::spawn`](https://docs.rs/tokio/0.1.1/tokio/executor/current_thread/fn.spawn.html) only accepts `'static` futures. The following code should be safe, but is still rejected:\n\n```rust\nfn main() {\n    sodiumoxide::init();\n\n    let (pk, sk) = load_or_create_keys().unwrap();\n    let pk = pk.try_into().unwrap();\n    let sk = sk.try_into().unwrap();\n    let (ephemeral_pk, ephemeral_sk) = box_::gen_keypair();\n\n    let addr = SocketAddr::new(Ipv6Addr::localhost().into(), DEFAULT_TCP_PORT);\n\n    let do_stuff = TcpStream::connect(&addr)\n        .and_then(|tcp| {\n            // Performs a secret-handshake and yields an encrypted duplex connection.\n            Client::new(tcp,\n                        &MAINNET_IDENTIFIER,\n                        &pk,\n                        &sk,\n                        &ephemeral_pk,\n                        &ephemeral_sk,\n                        &pk)\n                    .map_err(|(err, _)| err)\n        })\n        .map_err(|_| unimplemented!())\n        .and_then(|connection| {\n                      println!(\"hi!\");\n                      ok(())\n                  })\n        .map_err(|_| unimplemented!());\n\n    current_thread::run(|_| current_thread::spawn(do_stuff));\n}\n```\n\n```\nerror[E0373]: closure may outlive the current function, but it borrows `pk`, which is owned by the current function\n  --> src/main.rs:60:19\n   |\n60 |         .and_then(|tcp| {\n   |                   ^^^^^ may outlive borrowed value `pk`\n...\n64 |                         &pk,\n   |                          -- `pk` is borrowed here\nhelp: to force the closure to take ownership of `pk` (and any other referenced variables), use the `move` keyword\n   |\n60 |         .and_then(move |tcp| {\n   |                   ^^^^^^^^^^\n```\n\nBut when using a `move` closure, the moved keys don't live long enough.\n\nI'm pretty sure the only way to satisfy the type checker (while providing a safe API) is to have the handshake future take ownership of the keys, which means copying them. I hope I can at least do that without having to rewrite the C implementation, because taking pointers to the keys just seems much more sensible than taking them by value. But since the future itself can be moved around, I'll probably have to copy the keys to the heap...\n\nThese times when rust forces you to sacrifice performance *and* clarity are really, really annoying.",
    "mentions": []
  },
  "signature": "NFPvIM+UWdbElCKSYEhZKA/g6bqwGmJpgk3apAetvqyzVNQKkOJrVrpWr7qh77+ECMdZ5a2CBkAQZTJ5uiOtDA==.sig.ed25519"
}

{
  "previous": "%UGgHRGRslLJLBpthJNzdUCwAUwJCx/cPZWTQ8f0qUG0=.sha256",
  "sequence": 593,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520199909755,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%UvEUIbkpUYqR8sToQVDrR5Y1CCHwfxBGwBaf+9R8KPo=.sha256"
    ],
    "packs": [
      {
        "link": "&64sAmAoGDO45J23ykxOT4EUWvm6zi8OPl7eMB94gDm8=.sha256",
        "size": 5242
      }
    ],
    "indexes": [
      {
        "link": "&+DsZnBf0JRVVHZMhuFhVHGrheorK6o0bzp3Zgbq1kA0=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "88520e1a2522f7b8737c49f2799057cbbf93c8ae"
    },
    "commits": [
      {
        "parents": [
          "bd3e3c3eae59256f9cc642d488b9225b39175d60"
        ],
        "title": "Add OwningClientHandshaker",
        "sha1": "88520e1a2522f7b8737c49f2799057cbbf93c8ae"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "6e1bea57aa1e0c65f41dee9667b02d738552c835",
      "4b1cbb21771c75fe8ef609b9d8367a930c1eceef",
      "f38b5818e50c5fd51c0038b9bdf6b03e6f0461ed",
      "a4788a3dd453e45fd73028f81eec941c6ecde733",
      "c751053fbb05c33ff936ab9af8c821d0b5e4cb24"
    ]
  },
  "signature": "rP/lz4wAAEHaq7/eEWvdNTfq6UZitSTZuAWKO1LHICx+zNsKP72r8sIOfbuqLl5dP+5tzPK+eqgEBX6Kv/WnCg==.sig.ed25519"
}

{
  "previous": "%0aWHan2+yhoHRcvVzN4shla3PqJONwbILJQrNDEO/VU=.sha256",
  "sequence": 594,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520200311385,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%j3NbwSUhjfdpFg2zM41oS4AU4nUFBXefU5h+m2M1T4E=.sha256"
    ],
    "packs": [
      {
        "link": "&kRiiociWUNPrBjNRxqnSWhXQl182VQi423BalINSA7w=.sha256",
        "size": 2278
      }
    ],
    "indexes": [
      {
        "link": "&PStBtGUrjnqCxJswA83cNZDuzXjDEqipeytKA6n7zJE=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "aa0cd68f81211148f04cc88c1b717956da978dff"
    },
    "commits": [
      {
        "parents": [
          "3b16bfce926a4b7af598790428ffd10c7f8ae0c8"
        ],
        "title": "Add OwningClient",
        "sha1": "aa0cd68f81211148f04cc88c1b717956da978dff"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "1a526dd31e3ac5ccab188c9a60509c47a1718f3a",
      "da71b020d2737f4ee3c9f43f544e93d33b339705",
      "654111bf400b4544472a9c4cac0a2b05c4a86b17",
      "4650100ed1406e6499d26e95bf8d2b1e1fd124bc"
    ]
  },
  "signature": "EZOQxgBn3c6kyQQcNSW0uqgDyGC8YQhZxNOPijzP32bHKOiYAdFjfUjzcuuhzQ8gE6Erf6GxwjXgOXFeQUGkDg==.sig.ed25519"
}

{
  "previous": "%gPb4vWpgFVRMNM1D//3skvuZFFOP7qxhns7f2qRUtec=.sha256",
  "sequence": 595,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520203504792,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%0aWHan2+yhoHRcvVzN4shla3PqJONwbILJQrNDEO/VU=.sha256"
    ],
    "packs": [
      {
        "link": "&pB6m0WEy/vvfksT44UV+HSHlmDcvELnYa4bYd/DpBC0=.sha256",
        "size": 8586
      }
    ],
    "indexes": [
      {
        "link": "&n087/GiOwptgEdQd0tjdN+S7yNaO8e1+qPDuj/HCS6s=.sha256",
        "size": 1324
      }
    ],
    "refs": {
      "refs/heads/master": "bd4b046384f08a11e954b75be40aaf6b16dd4ec5"
    },
    "commits": [
      {
        "parents": [
          "4811f151120749b564ca72c016629dc32c77f29a"
        ],
        "title": "Bump version to 3.0.2",
        "sha1": "bd4b046384f08a11e954b75be40aaf6b16dd4ec5"
      },
      {
        "parents": [
          "88520e1a2522f7b8737c49f2799057cbbf93c8ae"
        ],
        "title": "Add owning server handshakers",
        "sha1": "4811f151120749b564ca72c016629dc32c77f29a"
      }
    ],
    "tags": [],
    "num_objects": 9,
    "object_ids": [
      "cde8588e13a872c6ce81b2e5bd64f6ff53b09532",
      "76b8806367057b1cd013e03319105f58db20812b",
      "abfe8c94c67fcba7f3ed3c6f82d5f5bc4fe2a4f4",
      "64298b9faecada3053b6370ae1e4957863cf7394",
      "bc2f39dc43efb6d6f45ee6eb64b1082657f2e485",
      "3aa0fddfe278cac95b67078d0501074f067b5bb5",
      "a8d4f7cf3a46da6512c5b6738c8a65375f95e862"
    ]
  },
  "signature": "ckBRCVubs4ZCBYU0dUYqIvAWQ7adt7k1IOdt7XPLGHEtC/+h40RLEUWDQWQK6rmtHl7MVcxIrY3sLeR1U9zgBw==.sig.ed25519"
}

{
  "previous": "%x8kt1Xbvdh6Ypneri2UJ+83x3nPBh12kPg4YK6g607I=.sha256",
  "sequence": 596,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520203951456,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%gPb4vWpgFVRMNM1D//3skvuZFFOP7qxhns7f2qRUtec=.sha256"
    ],
    "packs": [
      {
        "link": "&fK1FTXabIcqOQbCSeX0Z3cfJ130KF8Ze0I/NPvWRuuo=.sha256",
        "size": 2727
      }
    ],
    "indexes": [
      {
        "link": "&218DYvzIMv5ppEUxc4AleBPMkeaNFOom+8+0HV5Ye+I=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "39d61d57bef9157fbceb141df9622d4d76db4669"
    },
    "commits": [
      {
        "parents": [
          "a348a03da20775afa6b838114a2db58a6e7045e4"
        ],
        "title": "Bump version to 0.1.2",
        "sha1": "39d61d57bef9157fbceb141df9622d4d76db4669"
      },
      {
        "parents": [
          "aa0cd68f81211148f04cc88c1b717956da978dff"
        ],
        "title": "Add owning servers",
        "sha1": "a348a03da20775afa6b838114a2db58a6e7045e4"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "2d59325e4da9a6ce8980e244804421273ee4c35e",
      "eda0645f8b35d91a8d21dfee5449ac5e518d00f6",
      "39a72617d6877da19ea27e53f58ecfac0d2af676",
      "9b09a62441dff590b7f30602ae6d2531a9c12728",
      "eb268c542675834c78dc5033ecf1f7f40d6072de",
      "02155941f4e903afc1d72fe263d8ab04ce1dee88"
    ]
  },
  "signature": "JTfhH7RqtejKaIqhE1kCxI5AO0/+xCthB7HAIv4D/Zq6eVIfiTi7pWMK7k1RygFXOungLNGQKUulSn34+JzCDQ==.sig.ed25519"
}

{
  "previous": "%2sUVacAsBn6hTFea8wW432HJp6WM7rd7hgwzn5yzRT0=.sha256",
  "sequence": 597,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520248465312,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%cslb9JsVifX7FWeIr+voYwM3pJel4XYNVZaFIH1IS6I=.sha256"
    ],
    "packs": [
      {
        "link": "&H20tJw2oZZKAGDgCzR5Nvqu6H6DmBIliYwvqbTD0QKs=.sha256",
        "size": 7809
      }
    ],
    "indexes": [
      {
        "link": "&0+A/6PVJDpCwy5T75DbSa3b02tBQT7fAu3Z5QZaxUhs=.sha256",
        "size": 1604
      }
    ],
    "refs": {
      "refs/heads/master": "e1c4518343532b68fc377872f9526f8fe66f7179"
    },
    "commits": [
      {
        "parents": [
          "b01637a37baa3e6c4ed72573c7a8b6b12a868987"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "e1c4518343532b68fc377872f9526f8fe66f7179"
      },
      {
        "parents": [
          "3f06a2fe9ade45af04dd30bd1784882ebb75bcbf"
        ],
        "title": "Test serde impls",
        "sha1": "b01637a37baa3e6c4ed72573c7a8b6b12a868987"
      },
      {
        "parents": [
          "76e6886c00381b3a17bda6ddb0fd585bb53bf5f5"
        ],
        "title": "Implement serialize/deserialize for sks and remove encodings",
        "sha1": "3f06a2fe9ade45af04dd30bd1784882ebb75bcbf"
      },
      {
        "parents": [
          "8be7b159b46aa79fe88629446b63be75b3d9a094"
        ],
        "title": "Implement serialize/deserialize for pks and remove encodings",
        "sha1": "76e6886c00381b3a17bda6ddb0fd585bb53bf5f5"
      }
    ],
    "tags": [],
    "num_objects": 19,
    "object_ids": [
      "62e0a73b29956112aa9143346565c52fe65b0c2f",
      "825e270dd3f005ed61bbb2a8f0591631e075e7a8",
      "2c8172c75dc24d1160f89e507599860b2cdaa532",
      "ad885c6dab1f86dde875e2471f743cb63d311ae3",
      "e73d36f402dd19d04aaee22e2e63b5ca4b50a80a",
      "0908d954506826a7b8381ad50bc64c5de0aac1ba",
      "77f8fb3192b24b188ffe23f48c05f4c53de4ba12",
      "23b79c236a7f8c5a9e5f291ebed4f9e92986228d",
      "101ba5e87317a3eeac28baba742307dfa08d9be0",
      "c81144ddd88dd7993d7460cfbd8ef01a4c161a2a",
      "6f9e5b5f6b243962328c7b46a0c2ce644d6d1113",
      "ff87dd6a4f5e08d36efbf53b5a877a4d596682c7",
      "12eb9d0b196af83190d8bcff24b5dcb79fbd7834",
      "284760dc3d71751a3364f361a64ab30a1db02924",
      "8a22c71360632f01ff35915a7aa94683112c3760"
    ]
  },
  "signature": "ncYYRmELQmhJo3+gU905bmkn4V1riA2WwVeTHki20QHSpjGrXRvMU0/bMktL/xrEHaHNQR4UW6TmUrlfxDf8DA==.sig.ed25519"
}

{
  "previous": "%tKTM9ANol+dBzz6g3eKgPnU+6bybm8+/8AOtfO3wJi8=.sha256",
  "sequence": 598,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520264054947,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%k3FNpf3/1oBHP3fwbsHqyWh+qkhLnO48OJyrcXJSTRU=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Zyz8ToQ2v0wHgbnvlOfWC4mOusJgJ/mLK0XhVPD2cnE=.sha256"
    ],
    "packs": [
      {
        "link": "&5NPdVXn83rKWGx9mr7XUFFUs4W5p0yk1OTw2t8v4tRg=.sha256",
        "size": 3095
      }
    ],
    "indexes": [
      {
        "link": "&Kgxocjx3o8wBelzTqIUEJbC8Cw+yDuAo/Jtlf8ODkmQ=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "88aa6808c6526b72d70ddbb98426076851c418e7"
    },
    "commits": [
      {
        "parents": [
          "47a2e3588bff14a020d9ffbf771370bbe69ede59"
        ],
        "title": "Use serde",
        "sha1": "88aa6808c6526b72d70ddbb98426076851c418e7"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "20ff1a8b933f4ad52bd0b3359d61b89ba1180d3f",
      "5c47390875ce4b5f8a2948fe17b2ef59a499442d",
      "341d33c05b955ab24df11f7a1e8e23e6a78a181f",
      "1766eb44d77bda3722cc4538fa7f8215092deeb4"
    ]
  },
  "signature": "di9Y0abTcXAF0eOWGy4NRUGLmka6VySlY38BkNGEfy5dZQlK3ctRKi0BMzEmO0Audu78M+Hc+pA0swgdB3BEBA==.sig.ed25519"
}

{
  "previous": "%OK2O6flwlWFrJJ+6LvvQTFKxKbOoaD4N0P6Nzg21pY0=.sha256",
  "sequence": 599,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520270967905,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%tKTM9ANol+dBzz6g3eKgPnU+6bybm8+/8AOtfO3wJi8=.sha256"
    ],
    "packs": [
      {
        "link": "&4j/BQ4t8cnNBumByidaPGNiu91rcDOmAFIsj2ye9Iu8=.sha256",
        "size": 7114
      }
    ],
    "indexes": [
      {
        "link": "&HST6vhpmxmb2fNsJMm8zQjZzEYJjWzozY95kQs/Rj1U=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "02fe308edef3b4079d53f0657debdaa26264a80f"
    },
    "commits": [
      {
        "parents": [
          "7538d9435a37221fbc3590636db7beeb7080c786"
        ],
        "title": "Implement FeedIds",
        "sha1": "02fe308edef3b4079d53f0657debdaa26264a80f"
      },
      {
        "parents": [
          "932efd8f7a631c420ef17281f1b00d127c05cbda"
        ],
        "title": "Bump version to 0.2.1",
        "sha1": "7538d9435a37221fbc3590636db7beeb7080c786"
      },
      {
        "parents": [
          "e1c4518343532b68fc377872f9526f8fe66f7179"
        ],
        "title": "Remove docs for encoding buffers",
        "sha1": "932efd8f7a631c420ef17281f1b00d127c05cbda"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "210433fcc98aa043baeb69a5072db847d12b22cb",
      "2d61ed69dc23464f29677e29230d7c2333390cc3",
      "22f78ad3cae00e3ec6f531c33d7df3c8dc23e02d",
      "b45a05da2ea43b3c4ed68d7615fab2dc2e32bf95",
      "fa67955b1d41fcdefd79964603081b33321a4553",
      "f5f1c793a7863f4b3223c288eb9792258e6add92",
      "b45693a8613de8e7451ddc15e951cc37c99b1994",
      "aa878c709af821a2c754c85c6b7445d4175769e3",
      "15b49c63016e2029089e1be4e68419374772ccd5",
      "cfcb313d6250e36bacccddb8b2ccff467e3c2073"
    ]
  },
  "signature": "VEuUd8MZ6KaEv3TLtlszZ20FTMOcXKvXRbXlHc+wfkA36kx2I9jeE+/zbzDtPWmPNON+KjP9hUQkR0xLSR7sDg==.sig.ed25519"
}

{
  "previous": "%WjivyhMw9rkK8YQnkPtNgQwdf6PV5gJatJ7tQtN6oC8=.sha256",
  "sequence": 600,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520271290362,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%WjivyhMw9rkK8YQnkPtNgQwdf6PV5gJatJ7tQtN6oC8=.sha256"
    ],
    "packs": [
      {
        "link": "&jEn+7pvQuZNBWM9/Oc8MS9EjJfhcjAv4uIHmZq+EwpY=.sha256",
        "size": 655
      }
    ],
    "indexes": [
      {
        "link": "&ILsm6RLUjVKbMr1+ctxMZmhKLfIbrluuuHoGiGdXpKE=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "54d5489c85df2f83c3eb88d80d0067dd158d9436"
    },
    "commits": [
      {
        "parents": [
          "02fe308edef3b4079d53f0657debdaa26264a80f"
        ],
        "title": "Bump version to 0.2.2",
        "sha1": "54d5489c85df2f83c3eb88d80d0067dd158d9436"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "03088561a0ae541e43078ebdcb4dd490f3486502",
      "a44d19a71f565a7eaceac461e21f7818dd8af99e"
    ]
  },
  "signature": "UnkFLQxgnL35BJhAJiaFok0Fwde2H/UnyDXgjHAgTDZVo82TLv2at/u0xQU9R7KAAgqXAtRiyAd1mBKC/kS1Bg==.sig.ed25519"
}

{
  "previous": "%t00zlFnjkVo94vwSqjm5VtlhUkt3Gohx2w7pKsnNz/E=.sha256",
  "sequence": 601,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520271660013,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%t00zlFnjkVo94vwSqjm5VtlhUkt3Gohx2w7pKsnNz/E=.sha256"
    ],
    "packs": [
      {
        "link": "&2iYfQX3s2AykcuhaQPVe0R70MAi8TRC+bc1zsUaGTUk=.sha256",
        "size": 1760
      }
    ],
    "indexes": [
      {
        "link": "&zPw8i46FsfLOa9PBJmg1HJnx9yvVlqxJoAxeXsOwI0o=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "2f092b750c27b664e3069829f8b3d4ccbbd4a094"
    },
    "commits": [
      {
        "parents": [
          "54d5489c85df2f83c3eb88d80d0067dd158d9436"
        ],
        "title": "Add FeedIdRef",
        "sha1": "2f092b750c27b664e3069829f8b3d4ccbbd4a094"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "66f90a4b9f7d181abfa99444360ef7df8aa37e6d",
      "998182d26db77e95d253765b3afb72a5c76a6874",
      "191fa565d5ad583304cd338405fa3d7f7f34b6f0"
    ]
  },
  "signature": "9ebDaMhKL4pxs3ndQZAEwbSag8B0jlAWrzHnqPrz+GoDMXxrmRdiKuPA89TwTd8W0JgANlA62BJ5fKTNDb3mCg==.sig.ed25519"
}

{
  "previous": "%Io19QsL2omaGFagKma4dxuEFgkEATBQ3ig5muK2lMd0=.sha256",
  "sequence": 602,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520272506652,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Io19QsL2omaGFagKma4dxuEFgkEATBQ3ig5muK2lMd0=.sha256"
    ],
    "packs": [
      {
        "link": "&xNwIEJOfggTsSJ7VQnydyEJAkMl3NcnrG7aJU+4umLI=.sha256",
        "size": 656
      }
    ],
    "indexes": [
      {
        "link": "&Dkhn2HyrAOg0BRAk1zLof/aG5Qow/TU4tiY7noRu+i4=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "8c7bd7be723d9a7e24979fc22d8d601ed33d4248"
    },
    "commits": [
      {
        "parents": [
          "2f092b750c27b664e3069829f8b3d4ccbbd4a094"
        ],
        "title": "Bump version to 0.2.3",
        "sha1": "8c7bd7be723d9a7e24979fc22d8d601ed33d4248"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "2f3d19c37b716f0b4bb3539d4355e99437d3ab6d",
      "bc587ef54ab44b9416e99e21fb91dcb6efc44b5f"
    ]
  },
  "signature": "Ca72JB1Tj1RQZf362lByOXJIZqxYVKmesM+mXJO8JaNundvStQWNgkvySNypF4X07nXgvinoAFYELckRScRRAg==.sig.ed25519"
}

{
  "previous": "%nOlmgnj5a5+Rf1qz4YTIgWs+wWPbTRstncy59PiBDW8=.sha256",
  "sequence": 603,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520272552145,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%k3FNpf3/1oBHP3fwbsHqyWh+qkhLnO48OJyrcXJSTRU=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%OK2O6flwlWFrJJ+6LvvQTFKxKbOoaD4N0P6Nzg21pY0=.sha256"
    ],
    "packs": [
      {
        "link": "&4UAuVnS/25Zx/AIYPlHVQ6J67LQRPBCKWDI0fN0G52Q=.sha256",
        "size": 3665
      }
    ],
    "indexes": [
      {
        "link": "&IWAwrNzKmocO1Pjv1TSiy0VnToCRZUNcXQJLwco2cGo=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "4bc289556ad3b3596f688fad0e4097cd13520356"
    },
    "commits": [
      {
        "parents": [
          "315844cc3c1e0b0a65414dc346ad01697540fed6"
        ],
        "title": "Bump version to 0.1.2",
        "sha1": "4bc289556ad3b3596f688fad0e4097cd13520356"
      },
      {
        "parents": [
          "ac10097a97bc1409c3ffc3956d1d15fc6673b2e7"
        ],
        "title": "Update ssb-common",
        "sha1": "315844cc3c1e0b0a65414dc346ad01697540fed6"
      },
      {
        "parents": [
          "88aa6808c6526b72d70ddbb98426076851c418e7"
        ],
        "title": "Complete secret text",
        "sha1": "ac10097a97bc1409c3ffc3956d1d15fc6673b2e7"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "27a4fee98750a4244eb9d2f8133744df7077a753",
      "f2ba8139538ac851ee5e1ac5a725894aedb1b2de",
      "2cbcdc39bd5ab4973e35ef67fde4f333c870dbef",
      "cb561937bc12b44d110947cd89e0d5934d79a552",
      "b746c9273d98d74557786a482cb352fbe793689f",
      "be49a9b2e0e3b3b25e66cbf7987e5a2b4ef4d19e",
      "0947e6642c08357e2d8b2b3fc47ec431c4612b9a",
      "9ceacae8e30d40e1b84b895ad52cbaf71259746a"
    ]
  },
  "signature": "JDJG8w9Sw7pK8akEE80GpV251sh0KbyEckJhwV8mu/JYNicEeMB3OoRoRdVwlc6F5DXX0nx3X6HsLiV6rQ7iCw==.sig.ed25519"
}

{
  "previous": "%rCYDHiLYSMiNa7lY+eiMxUMp/p4zLXV3P1jnURc/4Mw=.sha256",
  "sequence": 604,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520276497035,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%nOlmgnj5a5+Rf1qz4YTIgWs+wWPbTRstncy59PiBDW8=.sha256"
    ],
    "packs": [
      {
        "link": "&Tra1uOhQibuFix+vOd9wYWEcQ/36KXu+KAa1vvkHpPA=.sha256",
        "size": 6949
      }
    ],
    "indexes": [
      {
        "link": "&6Jk2uflVJzUBOnqAaxC1loqk7vdM4pSGB3Sa7DC3KNI=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "56f99f6f341a953684d3eed13940b70860f79024"
    },
    "commits": [
      {
        "parents": [
          "c0b750fbd4677650aa1ed7cef63b1f98c104b5d0"
        ],
        "title": "Clean up",
        "sha1": "56f99f6f341a953684d3eed13940b70860f79024"
      },
      {
        "parents": [
          "8c7bd7be723d9a7e24979fc22d8d601ed33d4248"
        ],
        "title": "Implement Hash",
        "sha1": "c0b750fbd4677650aa1ed7cef63b1f98c104b5d0"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "e8b722314f197a51b27b905e02fea51905a7e638",
      "ae315c6433bfa97f67bb8c82d0119fe206fa7c2c",
      "cabf487552f7bf1efaf12600dd31e30cad22f1c2",
      "c817dda6b77427c47e896d4347cdb78ad58db837",
      "dac974e11ee5bd4346fe38182d17949644926ac5",
      "9233abbf570554dd948c7dcf2049ea8ad3a7b2cb",
      "f0a2114dcaf638c3c599ba9f4869076c018365bd",
      "8e423562b809395d49efab368e94856e21f17073",
      "2a676ef70dba182ffe54291feef3d7794d8eb8d0"
    ]
  },
  "signature": "rII3P5/D2IW57nUonn0JkvondWb1zFpqPciSj2AzcGFN0zCGMb1xCv3G2LzXOEn8UpiNowDcwuNZF0GFPErUBw==.sig.ed25519"
}

{
  "previous": "%pMe9Xmo91xXN9h4MrPOTBbFN5EobFDYYRlfuCVfl/c0=.sha256",
  "sequence": 605,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520282597467,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%pMe9Xmo91xXN9h4MrPOTBbFN5EobFDYYRlfuCVfl/c0=.sha256"
    ],
    "packs": [
      {
        "link": "&LyCpIvvVra75W/3VkaFN1DeXb/VCL9/v62wKO8Fu3Ck=.sha256",
        "size": 2196
      }
    ],
    "indexes": [
      {
        "link": "&Uy7WhbXZ5ycd1sKHrP2OsdRnD4c/FZaQ7nb/n0F/GL0=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "ed933d1e28dced77ccc635d076642ecc9b5204ce"
    },
    "commits": [
      {
        "parents": [
          "56f99f6f341a953684d3eed13940b70860f79024"
        ],
        "title": "Implement MessageId",
        "sha1": "ed933d1e28dced77ccc635d076642ecc9b5204ce"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "95c08c7eb29e0112ca1c624de147a71fb13b7f1b",
      "749e8f93e428538023447f46673496dc950e4495",
      "7db74561320c6ce471a65b51637100fe6c2878fd"
    ]
  },
  "signature": "xuAGODdG550CcvJrSKOxSD5JPTrwdIsXLej17HJj4L5sZg/00GMeVQ/kTyWqTFXR/70ZCi/Xt0lFP42B/ST6DA==.sig.ed25519"
}

{
  "previous": "%b+/gHlVH2PrdVepyWZ8kHzXPqfw/8iahb0xiu4tsfz4=.sha256",
  "sequence": 606,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520284097800,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%b+/gHlVH2PrdVepyWZ8kHzXPqfw/8iahb0xiu4tsfz4=.sha256"
    ],
    "packs": [
      {
        "link": "&nMuh6fVdPFjce1XNlyGWr7ldXk+mXnRmcnpnhhfvpsU=.sha256",
        "size": 2444
      }
    ],
    "indexes": [
      {
        "link": "&f6XV6GPgj3UkJdge8xZYKY6kf/PtN8bdpi7ZP8QLfEw=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "f7989d8bd26f07ab3fe9ffe4c510e6c754a1092b"
    },
    "commits": [
      {
        "parents": [
          "ed933d1e28dced77ccc635d076642ecc9b5204ce"
        ],
        "title": "Implement BlobId",
        "sha1": "f7989d8bd26f07ab3fe9ffe4c510e6c754a1092b"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "a10b96a2fd5b9068113026af9c804b46b038f3ab",
      "bd8f7037eed9063796f5dbebbe93fa93b95850a9",
      "40334dcbcde3df1dbdc37bc78479241545df65af"
    ]
  },
  "signature": "btXMxVEpGZlZZa6vsdlYDWuwun9Ipw8KmX4KU8YsI6aEOj0XEn7BY0zmHxFkjbGWAoPWdnO9m7D/tqDpSNhGDw==.sig.ed25519"
}

{
  "previous": "%jLBFdV1ycxU/t+zHHcWy/1Yj0tS1P8Z0HxzftyQD8u8=.sha256",
  "sequence": 607,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520286147942,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%jLBFdV1ycxU/t+zHHcWy/1Yj0tS1P8Z0HxzftyQD8u8=.sha256"
    ],
    "packs": [
      {
        "link": "&2gbfFjyDigaMrsumxyJeF1380t+/bsJ5NvcDJ8RE+60=.sha256",
        "size": 3754
      }
    ],
    "indexes": [
      {
        "link": "&2qXJmGkd8WDhdSbfJjfER0mqZa34qnysKxE79AszcZM=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "99a12ba7ef35499b4aba51a780ef801f810fc2eb"
    },
    "commits": [
      {
        "parents": [
          "692d641b314a59b117d75c6e0a63038daf971c0b"
        ],
        "title": "Bump version to 0.2.4",
        "sha1": "99a12ba7ef35499b4aba51a780ef801f810fc2eb"
      },
      {
        "parents": [
          "f7989d8bd26f07ab3fe9ffe4c510e6c754a1092b"
        ],
        "title": "Implement Links",
        "sha1": "692d641b314a59b117d75c6e0a63038daf971c0b"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "fbfd8b49f84160b37945415013124ef6411a31d8",
      "e887f4d7f93c71f50b0ef0d71ad6363cae5a25c8",
      "fc1e7443420771ebadd630e705910330ea3dd16c",
      "d03a60d8a1f4ae12a32adadee8597d804579b179",
      "3e984d23650a987ddba7542b706a661c2775436e"
    ]
  },
  "signature": "eMZf8UIKHirrMeg5undjm/yD878k+kCgdg/jZWExnq5tob4rDjdtjO3CvQ/fxhhU6WRktTr/ImmI10LwhC2GDA==.sig.ed25519"
}

{
  "previous": "%GKJaVlrgftSbSWN1Y/t7/c4IeahhInGurKCXPE38aP4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 608,
  "timestamp": 1520286814926,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%UGgHRGRslLJLBpthJNzdUCwAUwJCx/cPZWTQ8f0qUG0=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Everything is ready for ssb-rpc and ssb-client:\n\n- [secret_stream](https://crates.io/crates/secret_stream) now has futures which take ownership of the crypto keys, so that they can be used with a [real event loop](https://gist.github.com/AljoschaMeyer/e2ca433b2857acd085feb4ee80d9fd23).\n- [ssb-common](https://crates.io/crates/ssb-common) now supports hashes and cypherlinks. The last major missing component are messages.\n- [ssb-keyfile](https://crates.io/crates/ssb-keyfile) uses serde internally.\n\nTomorrow I'll probably wrap up the grant, by:\n\n- creating the ssb-rpc module and implementing the whoami rpc\n- creating the ssb-client module, exposing the whoami rpc\n- providing convenience functions in ssb-client that handle setting up the connection for the client, using the ssb default ports/protocols/keyfiles etc",
    "mentions": []
  },
  "signature": "vNMseHFH0JnXVxH/jINwRDuSSTR3sPJ6/Z6mBAqBIUyx+80wp1ucVQ6EPVjZ735uT5nLLlkNa+947Eb4bc/tAg==.sig.ed25519"
}

{
  "previous": "%h3YE9N4FVO3TVHltZocv5g7S4f9vog4ANretEuXqZi4=.sha256",
  "sequence": 609,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520326532516,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "ssb-rpc-rs"
  },
  "signature": "IzOvmbK4cX/aaq8gnkApEqXrJMadMOkYRBrQ/8ddJfcahhGnhhikkWaf6oVGQbQNik4nYT1hxkQHBvo3MaI7Aw==.sig.ed25519"
}

{
  "previous": "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256",
  "sequence": 610,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520326536356,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256",
    "refsBranch": [
      "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256"
    ],
    "packs": [
      {
        "link": "&K/4HXYicJunRvQG1wBNxVyIP5hrGZn/PutO/m5vQ4mk=.sha256",
        "size": 13179
      }
    ],
    "indexes": [
      {
        "link": "&5bsirQ6c3kDwZwBPmL7bIOu599WdqADDkBd7hCYBugo=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "18d1262bfc343292e08266783e7f5b9635333dc4"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "18d1262bfc343292e08266783e7f5b9635333dc4"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "05b1623ea3ea0fcfd7387d2322b794c4d5a9c97a",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "a86b1ffb09cf52faa65db984944faf6c7fe75e56",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "952f1b52705ae2f4024bfbd525bd4345a02c181d",
      "871cd2446a12aff80dc582cccb488ae8fd2bba46",
      "9124fc3dc281c5fd2fbe8ac9bc58f02deddfca2b"
    ]
  },
  "signature": "Yt3vyBCODziWJS7MjBsssoqA9mB5Xn6vXyJ46ViyKU/sWu5LDpsPxBajlEqXMn92kBMNkcnoOqA7yVVkktCIBA==.sig.ed25519"
}

{
  "previous": "%9Izkg9RrM0bXGXi73ylHl7pYwdtYJyYw5MH78onzdeU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 611,
  "timestamp": 1520326672979,
  "hash": "sha256",
  "content": "NWCOMFujGn+lQoKHig+O/sXH+y1ePu3Zcq7ybx3AE+297KBriWL2O5qqMRUGttqdbBMuREEFSF4Q4p65IZcbtgJoJHS1uw8b0V61SjUKdlaFz5aCz6ucggqACkAVT3YCnjE1/3Pc/0BMgqyvEmVYv6zT0EC1EoIDa315NyQ8vP8ySTq0dfi8o61dLePQTft9rW3isFzhqna8gc2AOXNEnnPl59TqJnjSEL5lUKP7lBVGAVACbAp/8xB0l4gn/DXYJjjfQbp/kSDNtnv2i9uCumT++f3ALrmHhMibGKMf4KKexfIByuv6rlF49p/3JdD1wF4hSS//sQTlEXpaf1J/AowqzoBhLG0gmKyaRrZS8O5XdeejXY6ykOXFSHZzW7HYcF0qlCikVOQUDTk9AA1DdmS64h6LOyLhXMwdBYY8SlANZDa/yrZsAgPTwGIdwnuTs449VmKy9giubtT9Frz/jP8M03deGQyEUpzWD0fCnfUgwjvC2d5D6SyoXajIgy1ZgE2mfXDOOswc24GNs6WSaei3SLA7W5tX5HsEqsoZQN663TausyQjZ4YRkB49JtK0xGTYDf0+bVWqx3tApittEtOAGiK9d6v2S/NhEy5jopUiSEGD/BmT7HGmiDFGNRf5loqGdbedDqymGUa2Z0Up2wL954W39drpUxrsGUj5jg5Utg7WMreIFEB44xlpUA7tyXPpJerNLrPu1TXcFuMdkUh2ysYsOKNm5z+oE73+hRaPwslfk+jlXe5Q+//6QrH8fFTJwT2omQpjkZVRuFkk+ONRFBBUaN5L5MtPO8I8DqFX6hQKmrkKJ+Hq4z34R0Yx/nUREmU8peausqG4/2ZcvszZQe4WQ5Wc48oLgNRxuHJS6Ht09NY7CxCqab4sXcwDcYa/N6FCt+VxN/g/x+SpURz1ioSO.box",
  "signature": "EuV5ZeL9ZE6fSFY97lwen+pn2xnZF8BjiZ5sZborlA33oq2tl9zAtD43SQ/IMeOOdK2O6tDFjPICjmQIhJxoCA==.sig.ed25519"
}

{
  "previous": "%OPIfRosEmZPbLTWJAWFbsaesxCqdx00GxSYSDw5e+/M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 612,
  "timestamp": 1520333943504,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "sbot",
    "text": "Can I get information on the plugins shipping with sbot by default? [Scuttlebot.io](http://scuttlebot.io/apis/scuttlebot/ssb.html) lists the following:\n\n- ssb: The core rpcs. As far as I understand it, a program can call itself an ssb server implementation if it provides all of these rpcs.\n- blobs, block, friends, gossip, invite, private, replicate\n\nThe sbot [source code](https://github.com/ssbc/scuttlebot/tree/master/plugins) lacks the blobs plugin but includes a plugins plugin.\n\nMy questions are the following:\n- Where does the blobs plugin come from? Does it ship with sbot by default?\n- Did I miss any plugins?\n- Which of these plugins can be considered so essential that every client can assume they are there?\n  - since the plugins plugin is js-specific I'd like to exclude it, but everything else seems to be pretty fundamental.\n\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519) #ssb #ssb-implementations ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      },
      {
        "link": "#ssb"
      },
      {
        "link": "#ssb-implementations"
      }
    ]
  },
  "signature": "+CiLiKAir4yLJ8uKJ8qwtNT/OKRzLPL+tT5/x+3LHk00tIPmicW7j7A4iin4Fn9urxb4vjRYkXU2TJhqhs+8Cw==.sig.ed25519"
}

{
  "previous": "%YEPJB3pdhk19Y0ftfdVjCGi19nA7pJoUY0wR/OJSYWs=.sha256",
  "sequence": 613,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520340071492,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%9Izkg9RrM0bXGXi73ylHl7pYwdtYJyYw5MH78onzdeU=.sha256"
    ],
    "packs": [
      {
        "link": "&59R0Z5Xd3lSd0GVh2ikJVuqKWL1p00Vm0jnZJ55wONA=.sha256",
        "size": 2878
      }
    ],
    "indexes": [
      {
        "link": "&G7whoKTiYEpiSpYkDIZPHNYk6Sba5ZZS4daoTI/N7uQ=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "1b21a6b0bca3a6c070c5ab5e7377b10735b1e2f5"
    },
    "commits": [
      {
        "parents": [
          "18d1262bfc343292e08266783e7f5b9635333dc4"
        ],
        "title": "Add whoami rpc",
        "sha1": "1b21a6b0bca3a6c070c5ab5e7377b10735b1e2f5"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "67b735a47d0d8a60f6f898424fabe65009ca229d",
      "9f0e0c24d6c2e4fd68fa5c4401d82d64919962ae",
      "398759ab0695eed46abbabd59349ff89bc0b0bfc",
      "f7382f12daa269cd4c85781d58d7b1fc781b028b",
      "45b617294db5ac09ba821c9887ab1c5f5ae29c26",
      "389028136abbab7bcd215c166e9d6a0e82bbbca3"
    ]
  },
  "signature": "bmS9KBEXvbi+7sNg2EpxnY2NJizq6LCCJMT9yDhKq6C7KDWtDaGTi5knA2BqrDNp9Tbn8jx7gRxwE6xylX2jDQ==.sig.ed25519"
}

{
  "previous": "%5Y4F74d5wiyKQBtamQgKxUMIMWzXZKayFcizrEuxX60=.sha256",
  "sequence": 614,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520340529439,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "ssb-client-rs"
  },
  "signature": "y4DM46swdvSXSF4i0r3domCMaNh9Wk1WCeVIvHl2dfcaK750/DFt1DABYyUNTsT9cdZNRuECxA06etvkPgWsBg==.sig.ed25519"
}

{
  "previous": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
  "sequence": 615,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520340532458,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
    "refsBranch": [
      "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256"
    ],
    "packs": [
      {
        "link": "&AMMqKhdIw6O2Q2oOzcIVaDfIW2dikJzURRGLZ+HvIdA=.sha256",
        "size": 12902
      }
    ],
    "indexes": [
      {
        "link": "&02l1uqeV71oWW/L6K/Qxs+KXIl8MO+OXUSNvW8fokTk=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "bd33eaa67269c6a1b224fede075e83cc08209d3a"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "bd33eaa67269c6a1b224fede075e83cc08209d3a"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "6d78a38d0498ff0045fe516f92e9708c4695b4b4",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "4690dc6bbca79957968d5b7c4aab314f8994e3e3",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "2b92b0e0bced39f78c993a292cdf07f196bec65f",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "hMDk9tjn/BWck8EUjJjLQBI8e70cZYJ941axE8XiENoBdE8TNlVp9grgyh+0w5YL9i98rLHoinIdXO0tftE9Cw==.sig.ed25519"
}

{
  "previous": "%ReYuX8giZzqnmzn/VnlEepiA5UDJZ1PipwPm+YStqMs=.sha256",
  "sequence": 616,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520340983009,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ReYuX8giZzqnmzn/VnlEepiA5UDJZ1PipwPm+YStqMs=.sha256"
    ],
    "packs": [
      {
        "link": "&Nj1tdEfgO1hRhgOcF9zxj1DXBFazFB3HW3A0pwOrR9o=.sha256",
        "size": 473
      }
    ],
    "indexes": [
      {
        "link": "&uornqA3EQMIwLRFYPjI8n3kT9tXgJWtXFCwoz81A4sQ=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "d80fa3053647b090153f344fd7efdc01df437b02"
    },
    "commits": [
      {
        "parents": [
          "bd33eaa67269c6a1b224fede075e83cc08209d3a"
        ],
        "title": "Fix typo",
        "sha1": "d80fa3053647b090153f344fd7efdc01df437b02"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "b4a36e15564816a87d39195f2502cb10603f2840",
      "fe268549b28706e20a446fb7d9d31f308da5796d"
    ]
  },
  "signature": "M5dYSvlg12iKWDcLZkYrcEt9F3/vOEvErhu+xl+HqzHK35BZUBjQfc5kkIJ58L0bMHyDVTA+zLJbCUXnWpt+Dg==.sig.ed25519"
}

{
  "previous": "%TtyNEK/5am8t6Cw2Zqm5osJQMCfx1ORcI8IPln2n5uk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 617,
  "timestamp": 1520371558252,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%WDEEoMQn66kKdZrzjFOXZvNTbyDz9ffZkzcZwW8Tvuo=.sha256",
    "branch": "%xhqOtJkW28IP9x2ML+8B4gufda0dDKpVt7wwmdNInMk=.sha256",
    "reply": {
      "%WDEEoMQn66kKdZrzjFOXZvNTbyDz9ffZkzcZwW8Tvuo=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519) Related question: %YEPJB3pdhk19Y0ftfdVjCGi19nA7pJoUY0wR/OJSYWs=.sha256",
    "mentions": [
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "%YEPJB3pdhk19Y0ftfdVjCGi19nA7pJoUY0wR/OJSYWs=.sha256"
      }
    ]
  },
  "signature": "40uoXUCtwTAqSN7nvKsE5sitto1ypmnzOU9H5uE3mOlB300+Uxepy/TkGNhEr9NfodycHIzDJd4R7jN+JQzSBw==.sig.ed25519"
}

{
  "previous": "%7xhaOr6kv0SQZ8hkVagszuaJl909nhSqdg7vaOw2D18=.sha256",
  "sequence": 618,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520371951326,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%TtyNEK/5am8t6Cw2Zqm5osJQMCfx1ORcI8IPln2n5uk=.sha256"
    ],
    "packs": [
      {
        "link": "&f0RnTMisqcI5nXkbfsH75eGY+9AAua7Yy3MSLrlKOpo=.sha256",
        "size": 2478
      }
    ],
    "indexes": [
      {
        "link": "&PY2cNl69Dk8/57MxZ0jRv5BkFtDXtjKplMadr8MzqMI=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "127448b3b7126cfe9cef9f4956e556a7a398652c"
    },
    "commits": [
      {
        "parents": [
          "d80fa3053647b090153f344fd7efdc01df437b02"
        ],
        "title": "Implement whoami",
        "sha1": "127448b3b7126cfe9cef9f4956e556a7a398652c"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "255a720ae83bea4495363373a07d5a766cea1e7a",
      "c9d48ab0577cb1c42d8a3fd978f48f639b1755b9",
      "49fc28bac77904488ab5e6094221abb525022351",
      "edd76fa4c4987dab90db8a3bb72cdb84e72aad2d",
      "1fe704da1fb617c3602a969dc33c2e59fd417785"
    ]
  },
  "signature": "tPRJPwrWY8KWXZyRPboM8SdnUlatiaBvFLNZbAaAD7UDzypbSoOTzSo0XgvEyatkWMyUpJIb0qssHYiX3hOxBg==.sig.ed25519"
}

{
  "previous": "%7tNKoxGJxvNhx7+wvoDMVZqyduH4mby7v08zD9hp20c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 619,
  "timestamp": 1520377833882,
  "hash": "sha256",
  "content": "8w2G42D0uOudTGVpkcONVMLE7APV3TLKr7EVwLjMCqf2znSAM7/Oozg/ARDxsbV6peDyn8fH0Rv6ysWXqd70wmOOBPDw3cxWQ5RJ3K/5WHcj/TfUPRXDJLUYnaE3YjPEFNVV/BItHkMA4kNpBhpwS8rQ+7ebhFfjq6+8AIrvm7amY4OOh33sfDH/EzNuOAm6JR3ds9bQwBm9RD+LfqnJy+Xek5HhY5n6znlR5CxF7Zj3GC71091PnM3zKcLwvRUvjkwLg4R/FwJETw+JGfnTnRTbuEtaUqIuRi6a7AWboEeCDj53nmD2oYJ5IzksF5uh5gysNApTabujNHFAUSQx09iWNEm8lo06pvGIj4ClNMkt4j1DthsbGOo5mUsWzuWCRYT7i3YbsprUztWdTDS2TLGorSP4eCZG7CdzzN3hyJ65Z5jYUJm1V0q57FaUC81WA73GFRNWA3Gm5mPOF2dUlbvhRC4vXct3OWty+//VBasF04DG6O06+aU/yUd5z52xbC601J7MPRNzeIKlky+mlJCjL9IMRn/SmauchGM59TBjr+CLGMZkzsBBdJoCLZIiViUGnA7r7rS8T+AhkboA4lkT57U+EQymlOajZKO8Xzn8XI0Y4L+eDNKEOZZojIHlfdNiir7xZyxNSgjo8vi0mg6sFx96WNc+Fp97c85D05HG/XA4uRAEA7zEhOneyKt8wSueUGr5Q/+nF9QvhfYNU16VrmxV3183qyBcsWTLYQ+JQAkzOsQh6vCvqvRppGg9r2hshVnaBt2tc5ts5NE7m9XZjWLgMYkkaoWzdRe1jdHKMJVsA0GlcOUHCKBOeZgT7dPM6cY+NYajjO+LzfgTz11EcYoTcEqByt5TL/ux5b4UTvADadhcBesS.box",
  "signature": "b4WvPHrRb8Jl2KljK83+9Td6mYbSg6+HC9tvF9ODfU/QNzVXmGtFCPabDeGB3gWMhh/KPEJlXXITsPiQthuECg==.sig.ed25519"
}

{
  "previous": "%tQBXUSJTs9Ll67PGpMRfmavZ16SRT/abcAq32pX0RJ8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 620,
  "timestamp": 1520378184328,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%h3YE9N4FVO3TVHltZocv5g7S4f9vog4ANretEuXqZi4=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "Didn't get to polish things enough for a release today, but I got everything working.\n\n```rust\nsodiumoxide::init();\nlet addr = SocketAddr::new(Ipv6Addr::localhost().into(), DEFAULT_TCP_PORT);\n\ncurrent_thread::run(|_| {\n    current_thread::spawn(TcpStream::connect(&addr)\n    .and_then(|tcp| easy_ssb(tcp).unwrap().map_err(|err| panic!(\"{:?}\", err)))\n    .map_err(|err| panic!(\"{:?}\", err))\n    .map(|(mut client, receive, _)| {\n        current_thread::spawn(receive.map_err(|err| panic!(\"{:?}\", err)));\n\n        let (send_request, response) = client.whoami();\n\n        current_thread::spawn(send_request.map_err(|_| unimplemented!()));\n            current_thread::spawn(response\n                                  .map(|res| println!(\"{:?}\", res))\n                                  .map_err(|err| panic!(\"{:?}\", err))\n                                  .and_then(|_| {\n                                                client.close().map_err(|err| panic!(\"{:?}\", err))\n                                            }));\n    }))\n});\n```",
    "mentions": []
  },
  "signature": "X5iuusBWcf89CEInhgEM8p2/fQFwoigQ8mk+Nk7xFmnZWFVsnZPvR0GTRb4qaVSMfbaisfd4EHUAMoReYpwKAA==.sig.ed25519"
}

{
  "previous": "%TGLnZooL5pW/IWmVijW1AOydi9b71VJ0104EclfNC6g=.sha256",
  "sequence": 621,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520414259811,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%7tNKoxGJxvNhx7+wvoDMVZqyduH4mby7v08zD9hp20c=.sha256"
    ],
    "packs": [
      {
        "link": "&/RRpWcvgxTzcx5cneslzj2832ren0UkiaAF4oGYzlPU=.sha256",
        "size": 4664
      }
    ],
    "indexes": [
      {
        "link": "&iDv0F+blvoxTHAqB0xkdeGAK1DOYo9T2kr0zW/vA7us=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "66d937ce2e2afd88849bbb39334d2e93368d17ce"
    },
    "commits": [
      {
        "parents": [
          "4db9840c94bc45740ace114fc2daba0ac36aea82"
        ],
        "title": "Add easy_ssb, doc examples and a test",
        "sha1": "66d937ce2e2afd88849bbb39334d2e93368d17ce"
      },
      {
        "parents": [
          "49a46f39958a5d66878ffeb351b7e400719eef99"
        ],
        "title": "Make close public",
        "sha1": "4db9840c94bc45740ace114fc2daba0ac36aea82"
      },
      {
        "parents": [
          "127448b3b7126cfe9cef9f4956e556a7a398652c"
        ],
        "title": "Make whoami public",
        "sha1": "49a46f39958a5d66878ffeb351b7e400719eef99"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "37295453dd33ae33b4e899f7e411a356b0231862",
      "f09ce59ce8f6208ace78e7b706cd3bbcc954efa4",
      "a571fd480464f32dc87451f01c03f10bd4b68c2e",
      "450461f6d977b670a927650b07781a713afe149b",
      "f3a77748e8dec2c9753fba99eee3e27554848c5b",
      "cc2f769f03f4970159ee344f5c301ebdafd22923",
      "db48c9f2c62812c7dddfbfc41e26aebbe0cd7d3c",
      "84ac47269f96e2ed7be23a38a4d2821e71f120d1",
      "1ead3e95b8f9528855e35e7875bf5dcd1b3ecdd6",
      "73dec47f0c3d6164c10b702831ea05f952e7c3cf"
    ]
  },
  "signature": "lY0fY3u/3PWMFfx7yXTljrtJ1WuXqdvCCq1UHqZZZltK4k0B4JTWNVk+j28lAEyhjCPvkoHZxO24wSCFCZCiAA==.sig.ed25519"
}

{
  "previous": "%d+lK6zQcx9KR9DiXAxYdX2D+Dm2WuBDRo+vsAlXpA4M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 622,
  "timestamp": 1520428477490,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%TGLnZooL5pW/IWmVijW1AOydi9b71VJ0104EclfNC6g=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "# Wrapping up the Grant\n\nI just pushed the first version of [ssb-client-rs](https://crates.io/crates/ssb-client). While it is (very) far from providing the whole ssb API, I'm going to declare the [grant](%pYNveoqk1n1YobhscETnI/EE8aZd0itL0bnPqXIASzw=.sha256) to be completed.\n\nI'll start organizing a mumble call for a tour of the codebase in a different thread. Right here, I'd like to give an overview of everything I did as part of the grant, and list some things that can now be built upon it. So here we go!\n\n#ssbc-grants #rust\n\n## What has been done\nAll communication with an ssb server is encrypted. So the first step in building the client library was implementing the encryption. I had already done the crypto code in C: [shs-1-c](https://github.com/AljoschaMeyer/shs1-c) for the [handshake](https://github.com/auditdrivencrypto/secret-handshake) and [box-stream-c](https://github.com/AljoschaMeyer/box-stream-c) for the [encryption](https://github.com/dominictarr/pull-box-stream).\n\nThese C libraries then got wrappers in rust: [secret-handshake-rs](https://github.com/AljoschaMeyer/secret-handshake-rs) and [box-stream-rs](https://github.com/AljoschaMeyer/box-stream-rs), as well as their convenient combination in [secret-stream-rs](https://github.com/AljoschaMeyer/secret-stream-rs). The main difficulty here was to correctly fulfil the contract of the abstractions used for byte-based, asynchronous io rust: [`AsyncRead`](https://docs.rs/tokio-io/0.1.5/tokio_io/trait.AsyncRead.html) and [`AsyncWrite`](https://docs.rs/tokio-io/0.1.5/tokio_io/trait.AsyncWrite.html). Thankfully, the [partial-io](https://github.com/facebookincubator/rust-partial-io) provides excellent testing utilities for checking whether you correctly deal with the non-fatal `WouldBlock` and `Interrupted` io errors.\n\nI also wrote some more utiliy code in this stage. While it is completely invisible to the APIs of the ssb modules (and a lot of these utilities are only used for testing), these modules saved me a lot of time. The [async-ringbuffer](https://github.com/AljoschaMeyer/async-ringbuffer) provides the async readers and writers in all my tests. There are also two helper modules containing testing utilities and useful macros for working with nonblocking code: [atm-io-utils](https://github.com/AljoschaMeyer/atm-io-utils) for the byte-level, and [atm-async-utils](https://github.com/AljoschaMeyer/atm-async-utils) for the abstractions provided by the [futures](https://crates.io/crates/futures) crate.\n\nWith the byte-level encryption done, the next part of talking to an ssb server is the rpc protocol. It is based on [packet-stream](https://github.com/ssbc/packet-stream), upon which [muxrpc](https://github.com/ssbc/muxrpc) is layered. In rust land, the fundamental module for this stage is [packet-stream-codec-rs](https://github.com/AljoschaMeyer/packet-stream-codec-rs), which bridges the gap from byte-based io to the traits of the `futures` crate. The most difficult part of the whole grant was figuring out how to provide multiplexing via these abstractions.\n\nThe rust compiler disallows multiple mutable references to a value. But in order to transmit/receive items via a [`Sink`](https://docs.rs/futures/0.1.18/futures/sink/trait.Sink.html)/[`Stream`](https://docs.rs/futures/0.1.18/futures/stream/trait.Stream.html) you need mutable access. So how do you build multiple, independent subsinks/substreams that all write to/read from the same underlying sink/stream? The answer involves [cells](https://doc.rust-lang.org/std/cell/), and, to keep the API usable, reference counting. Figuring that stuff out took a lot of time (and energy), but the results are neatly encapsulated in [multi-producer-sink](https://github.com/AljoschaMeyer/multi-producer-sink) and [multi-consumer-stream](https://github.com/AljoschaMeyer/multi-consumer-stream). I honestly expected that modules like these would have existed already, but no luck there.\n\nUpon these modules, I built [packet-stream](https://github.com/AljoschaMeyer/packet-stream-rs), which provides multiplexing access to the packet-stream-codec via these multi-producer-sinks and multi-consumer-streams. At this level of abstraction, you can write code using the convenient `futures` traits, but the transferred `Item`s are are raw bytes. The next level of abstraction is provided by [muxrpc-rs](https://github.com/AljoschaMeyer/muxrpc-rs).\n\n*continued in the next post*",
    "mentions": [
      {
        "link": "%pYNveoqk1n1YobhscETnI/EE8aZd0itL0bnPqXIASzw=.sha256",
        "name": "grant"
      },
      {
        "link": "#ssbc-grants"
      },
      {
        "link": "#rust"
      }
    ]
  },
  "signature": "cJM7QOgyMDJZuU1T+sNp1+PlOrxX7RQ3aTy/we0a5Gr4pzZcaFcbujS1OwHYnck36tuo52i6umH+p6NS6MO0Ag==.sig.ed25519"
}

{
  "previous": "%T5h5TKyiN8a4YsbWlAsYfkvc91vL36stV6fs+1YhPsY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 623,
  "timestamp": 1520428516842,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%T5h5TKyiN8a4YsbWlAsYfkvc91vL36stV6fs+1YhPsY=.sha256",
    "reply": {
      "%T5h5TKyiN8a4YsbWlAsYfkvc91vL36stV6fs+1YhPsY=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "*continuation of the previous post*\n\nThe muxrpc module has two important jobs: Besides requests/responses (implemented as [`Future`s](https://docs.rs/futures/0.1.18/futures/future/trait.Future.html)), it provides pure `Sink`s and `Stream`s, whereas packet-stream only supports duplexes. More importantly though it enables a statically typed interface rather than a byte-based one. This is done via the impressively well-designed [serde](https://serde.rs/) crate. Muxrpc rpc calls are ([mostly](%0G+gpDZJTNPCsviYqtbvmWvUh1M13rJUDwbk1pLgkSM=.sha256)) parameterized over some type implementing serde's [`Serialize`](https://docs.serde.rs/serde/trait.Serialize.html) and [`Deserialize`](https://docs.serde.rs/serde/trait.Deserialize.html) traits, and they automatically perform the conversions (and error handling). A nice bonus about this: Serde provides procedural macros for deriving these traits, so you usually don't need to implement these by hand.\n\nNone of the code I discussed up until this point has been ssb specific. But building the ssb code upon these foundations has been pretty enjoyable. The module containing ssb-related data types is [ssb-common-rs](https://github.com/ssbc/ssb-common-rs). It contains types for ssb's keys, multihashes, cypherlinks, etc, as well as hand-coded `Serialize` and `Deserialize` implementations. So while the ssb rpcs represent e.g. a feed id as a json string in a certain format (`\"@base64hashhere=.ed25519\"`), we can internally use an enum. The conversion between these formats is automatically done by muxrpc. The same holds for the other data types. This is something where rust really shines.\n\nRpcs are provided in the [ssb-rpc-rs](https://github.com/ssbc/ssb-rpc-rs) module. These are simply types with getters and setters, deriving `Serialize` (for rpcs) and `Deserialize` (for responses). Internals are encapsulated so that additional rpc parameters don't result in breaking changes to the API. For rpcs, there are always two versions: One that takes ownership of its contents, and a more efficient one which works via references. Ssb has a plugin system for adding support for new rpcs. The ssb-rpc-rs module uses feature flags to keep track of this: By default, only the core rpcs are enabled. Usage of a plugin always needs to be made explicit by enabling the feature for this plugin.\n\nThe last module is [ssb-client-rs](https://github.com/ssbc/ssb-client-rs). It simply wraps muxrpc and provides methods that send/receive the `ssb-rpc-rs` types. It also provides a function for easy setup that reads keys from the default location (via [ssb-keyfile-rs](https://github.com/AljoschaMeyer/ssb-keyfile-rs)) and performs the handshake.\n\nSo yeah, this is basically what the 5000$ turned into. As well as me learning a *lot* of things.\n\n*continued in the next post*",
    "mentions": [
      {
        "link": "%0G+gpDZJTNPCsviYqtbvmWvUh1M13rJUDwbk1pLgkSM=.sha256",
        "name": "mostly"
      }
    ]
  },
  "signature": "77mbem7/MUDcFDjSqzNZvEuHJaKdIL+xks2C0ZkIT6zdlE9ky5EISman3LDSNzc/hSquWOKh5MsSHPA2R/nqDQ==.sig.ed25519"
}

{
  "previous": "%ffcvscmT2bdLW4JuydSVPRL6RQtkOTP2yy+g9/4Io/o=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 624,
  "timestamp": 1520428545114,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%ffcvscmT2bdLW4JuydSVPRL6RQtkOTP2yy+g9/4Io/o=.sha256",
    "reply": {
      "%ffcvscmT2bdLW4JuydSVPRL6RQtkOTP2yy+g9/4Io/o=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "*continuation of the previous post*\n\n## What can be done now\nApparently, somebody wrote a bunch of code. Now what?\n\nWhile I implemented all of the necessary protocols and the scaffolding, we still don't have a full client library. This is the part where contributing is both extremely useful and extremely easy. There are two main things to be done: Finishing ssb-common and providing more rpcs.\n\nSsb-common does not yet provide all ssb data types. The most important one still missing is a type for messages. This should be a struct that provides all metadata and is parameterized over a type for the actual content. I'd love to see someone else giving this a shot. There's also the issue of [hashing](https://github.com/ssbc/ssb-feed/issues/11) them, but that's not at all required to be implemented right away.\n\nRpcs can simply be added to ssb-rpc. There's a list of rpc methods [here](http://scuttlebot.io/apis/scuttlebot/ssb.html), and these candirectly be translated to rust. Once they are done in ssb-rpc, corresponding functions can be added ssb-client. At some point, I'd like to write some macros for making that even easier.\n\nThere is of course no point in extending the client library if there are no clients. While the gui situation in rust is far from perfect, there is already a [variety of options](https://github.com/rust-unofficial/awesome-rust#gui) to chose from. Or you could build a terminal client, e.g. with [termion](https://docs.rs/termion/1.5.1/termion/).\n\nThere's also more to be done on the internals of ssb-client and the rust ssb stack. This is what I will start putting more work into. The futures crate just released an alpha for `0.2.0`, bringing a set of (breaking) API improvements. Bringing these to ssb-client requires breaking changes throughout the whole stack. I'll use this as an opportunity to experiment with different APIs for multi-producer-sink and multi-consumer-sink. Their APIs directly influence the interface of packet-stream, muxrpc and ssb-client, and there's a few things I want to improve upon. I'll also try to build thread-safe versions of these, so that ssb-client can be run on an event loop backed by a thread pool.\n\nThe muxrpc implementation does not support backpressure yet, that's another point I'd like to tackle. Getting this right will probably involve defining traits for backpressure-aware sinks and streams. This may involve [reactive-streams](http://www.reactive-streams.org/) in some way.\n\nOnce the API changes have been done, I'd love to see developer docs for writing ssb applications in rust.\n\nAnd then, there's of course the most obvious project of all: Implementing an ssb server in rust. But I personally thing now is not the right time yet, I'd rather wait for both the rust APIs and the ssb APIs to settle.",
    "mentions": []
  },
  "signature": "Hu1tcah/cSYY+2B11kP4LW0LrX3WuwYAClPa8SyK/wFHNjI5ePLABkRfw3yNDJ8HRosyNP1m7n11G208aIYKCw==.sig.ed25519"
}

{
  "previous": "%dilkjmUBMrGsvhjikJg+ruIH5a8KZ6m+fRc8G1x/H5U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 625,
  "timestamp": 1520434403462,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%tsvAIG8xRp26wc5ltpUHdk1ygcinmDjGqDQCbBfgKdQ=.sha256",
    "reply": {
      "%tsvAIG8xRp26wc5ltpUHdk1ygcinmDjGqDQCbBfgKdQ=.sha256": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "[@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519) I actually started the crypto in rust, because I thought keeping everything in rust would be easier (and also because I've never written C before). But rust cares a lot about type safety, which made this kind of code pretty painful to write. The clean way of writing it means using array types à la `[u8; 32]`, which encode the length of the data. But the crypto involves things like splitting arrays. The [sodiumoxide](https://github.com/dnaq/sodiumoxide) crate (the libsodium bindings I use in rust) also has different types for different keys/hashes, even if they are the same underlying type of array. The rust code became completely littered with type casts, [`transmute`s](https://doc.rust-lang.org/std/mem/fn.transmute.html) and `unsafe` blocks, making it hard to read and work with.\n\nIn C, everything is just a pointer to bytes, that's it. And Working directly with libsodium in this style of code was both efficient and more readable/clear (although I did completely sacrifice clarity for space-efficiency in the shs implementation).\n\nAnd finally, there was the consideration of bindings. While it is possible to use rust code from any language that has an FFI for C, it's obviously easier to use C code from a language that has an FFI for C. ",
    "mentions": [
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      }
    ]
  },
  "signature": "47tM01Jy0XP475/abuh6CeN1CtmmVYloz0vtB2NKBwQSAr5gAaBlyLYi8CwEIKWnzX9lsf+Jpj8fzORUyGGdCA==.sig.ed25519"
}

{
  "previous": "%wB9DJ0UDPSiGJRSgnOBia7tYchqfB1/+iXwECRKVe3I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 626,
  "timestamp": 1520437468396,
  "hash": "sha256",
  "content": {
    "type": "post",
    "text": "# ssb-in-rust call: finding a timeslot\n\nI've been funded to implement parts of the ssb protocols [in rust](%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256). Today, I [wrapped up](%T5h5TKyiN8a4YsbWlAsYfkvc91vL36stV6fs+1YhPsY=.sha256) the grant. And now, there is a large codebase, but I'm the only one familiar with it. That should absolutely change. So I'd like to do a mumble call where I give a guided tour of the code for everyone interested.\n\nHere's a [doodle](https://doodle.com/poll/nm3bezg9a7a3rrsh) with a bunch of time slots. Let's hope we can find a time where everyone who is interested can participate.\n\nThis call will be interesting for anyone who wants to learn more about the internals of ssb, or anyone who'd like to write ssb-related code in rust. I'll start out showing how to use the [`ssb-client-rs`](https://crates.io/crates/ssb-client), then how to contribute to it, and afterwards I can go into any of the implementation details people care about.\n\nIt might be helpful (but is in no way required) to know about:\n\n- the [`futures` crate](https://docs.rs/futures/0.1.18/futures/) for nonblocking, asynchronous programming in rust\n- the [ssb protocol](https://ssbc.github.io/scuttlebutt-protocol-guide/)\n- the [`serde` crate](https://serde.rs/) that handles the serialization and deserialization of rpcs\n- the [`AsyncRead`](https://docs.rs/tokio-io/0.1.5/tokio_io/trait.AsyncRead.html) and [`AsyncWrite`](https://docs.rs/tokio-io/0.1.5/tokio_io/trait.AsyncWrite.html) traits, should we get to the low-level byte-based stuff\n\nI'd be grateful if someone who is not me could do whatever setup is necessary for the mumble server. Also, do you have any recommendations for screen-sharing?\n\n[@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519), [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519), [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519), [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), #ssbc-grants, #rust, #ssb-implementations",
    "mentions": [
      {
        "link": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
        "name": "in rust"
      },
      {
        "link": "%T5h5TKyiN8a4YsbWlAsYfkvc91vL36stV6fs+1YhPsY=.sha256",
        "name": "wrapped up"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "#ssbc-grants"
      },
      {
        "link": "#rust"
      },
      {
        "link": "#ssb-implementations"
      }
    ]
  },
  "signature": "rD1So9iVb3rICVJJKg3r+gpKZZKVjeMP+aMj0i/sLzOND0qX+mur7ym3S+SYfrDYjEel82ihX7hOl8BdqvxnCg==.sig.ed25519"
}

{
  "previous": "%4duCfFNxut1s8yQJfypnDTaPPUGba8p8vX6z4BxYlqM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 627,
  "timestamp": 1520437570820,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%wB9DJ0UDPSiGJRSgnOBia7tYchqfB1/+iXwECRKVe3I=.sha256",
    "reply": {
      "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "[Here's the post](%4duCfFNxut1s8yQJfypnDTaPPUGba8p8vX6z4BxYlqM=.sha256) for finding the time for a call where I give an introduction to the whole codebase. I'll create a gathering once a time slot has been found.",
    "mentions": [
      {
        "link": "%4duCfFNxut1s8yQJfypnDTaPPUGba8p8vX6z4BxYlqM=.sha256",
        "name": "Here&#39;s the post"
      }
    ]
  },
  "signature": "MbEXpO7S0f1AU6pxRyLpY98vEsEZQaxFzWhdGSQHU6TgWZqV754iHJVnM+LwVMpVPFhD7SUiFwHUmfJpqH8iDg==.sig.ed25519"
}

{
  "previous": "%fHy49G2cUqCHTeowFBnz3ILvdcTvTnM5natksURBV5M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 628,
  "timestamp": 1520500551088,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%4duCfFNxut1s8yQJfypnDTaPPUGba8p8vX6z4BxYlqM=.sha256",
    "branch": [
      "%3nGqoLJoeRuh7g8OElVP7I5nHOCRx22hhgw3rL2jErE=.sha256",
      "%L+GNuDk9ZxZ/sPgsPXknp+6j9vO5XC+uRiSRAjxNQ4M=.sha256"
    ],
    "reply": {
      "%4duCfFNxut1s8yQJfypnDTaPPUGba8p8vX6z4BxYlqM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "The 2-hour slots are just a byproduct of getting to a reasonable granularity of starting times. I'll try to be available for as long as there is still stuff to share, but I have no idea whether that's going to be one hour or four.\n\nIt currently looks like it'll be the first timeslot on monday the 12th (in Europe/Berlin). I'm going to wait one more day, and then I'll create a gathering and mention everyone from the doodle.",
    "mentions": []
  },
  "signature": "pwtKfHXUznkG1/KNQZdLui55Olk2f8pYn51EREL/nykICh41QiW3Lw1fh0+tXAA1eMcToHox6noH0lr05GXSBg==.sig.ed25519"
}

{
  "previous": "%SUcFfh2JxkDi21b4zYxut0IK0JuZOf3AI6t+IKdf4Ds=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 629,
  "timestamp": 1520501313926,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y2WlAvRUzXdbCRW0k+tghADVA2y80KF83zRxuE54sGI=.sha256",
    "branch": "%dqw75JPaB68VWJf/DpOP8F+sOGDfMkYOIGcyHPWo9kU=.sha256",
    "reply": {
      "%dqw75JPaB68VWJf/DpOP8F+sOGDfMkYOIGcyHPWo9kU=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) Yup, both are possible. But there's not static typing for these things yet, so you need to manipulate json trees. The only method you can currently call without having to manually deal with json is `whoami`. But that - among other things - is what the upcoming call is for: Getting a lot of people to the point where they can contribute these wrappers around the raw json protocol. Also, the whole codebase was built in a way that makes it easy to provide static typing for rpcs.\n\nWhile I could simply set aside an hour per day to implement the wrappers myself, I'd rather provide a good opportunity for new contributors, and spend the time helping people with that. I already did the whole grant on my own, no need to further keep this tied to one person.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "xhqh0+aLglodmXv3ulVqj3Qv8URDvUF4hA/W5NcdqnRPTZCtRJg144bPWuueVn3somMzgfozk65fysmFdQe4Dg==.sig.ed25519"
}

{
  "previous": "%2RyYHG8kpi0MRAfhMCyw8TafmsNhe3XSbXfuIoMPo2c=.sha256",
  "sequence": 630,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520506977894,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%1q1wgBT55tGBrWIdiEe/9f5B79InJ3qRq3DV3NFwbsQ=.sha256"
    ],
    "packs": [
      {
        "link": "&pep2hHCFTktMZ38Ogsx16HC4D99LWQ8sLs7YFwnkNNU=.sha256",
        "size": 5698
      }
    ],
    "indexes": [
      {
        "link": "&EBogJtyoa6R7wgyf7p6bicIHQ2CPde8E8VLZQPxIIXc=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "62dfcdea98ebe35679db379063d20d7cb231b71d"
    },
    "commits": [
      {
        "parents": [
          "e87013f958a6b541d8dc248bc189dc1d8b42106a"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "62dfcdea98ebe35679db379063d20d7cb231b71d"
      },
      {
        "parents": [
          "5feab3d73be88b9f2e0bd8510f686015ebd4d3e7"
        ],
        "title": "Change RPC names to slices",
        "sha1": "e87013f958a6b541d8dc248bc189dc1d8b42106a"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "ba73856a155b2087e6f85261b7b9d80600b1cf6c",
      "f968588d25b3967106bbcb1e78d11e6532b7f554",
      "eac3fb235e6737573c965108135d6bf2bed5b335",
      "05d50925ee74a3e9b4667aaa6df8498faff80771",
      "26a9ef0b7d57eadecd629252d8f39f70a3db1558"
    ]
  },
  "signature": "pPM5tUwR/TMmAylfyH/uEB/PTcQCbEvQM5qkibeNhPtwbngHN3nOA9O5ToByp5ny62uf44Bq3Ily7AizSNt3BQ==.sig.ed25519"
}

{
  "previous": "%GTGeGap8Qs/Um5ndadmurrzFwLoAaRVOzjlvVp4xzZ0=.sha256",
  "sequence": 631,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520507168016,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%5Y4F74d5wiyKQBtamQgKxUMIMWzXZKayFcizrEuxX60=.sha256"
    ],
    "packs": [
      {
        "link": "&mbluBLBj+puz5QLnYhPS59K/TQvJJyLMW7uwLartMTc=.sha256",
        "size": 1425
      }
    ],
    "indexes": [
      {
        "link": "&nuocrpLKP4iGEcNLID6ERZf/SihB2sGxYzkW7zGBuvI=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "e0a1b902a8d048e83ce5a3a14e32633fa9ec9999"
    },
    "commits": [
      {
        "parents": [
          "1b21a6b0bca3a6c070c5ab5e7377b10735b1e2f5"
        ],
        "title": "Update muxrpc to 0.2.0",
        "sha1": "e0a1b902a8d048e83ce5a3a14e32633fa9ec9999"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "052376dca2b88f9fdf5f2e8539da7bcb84078cf7",
      "72b74d83b74359abadc92096d0a38eca29af8dee",
      "ba7c0ed6344f11cce9133226bc38276a90a5a70e",
      "d9b3c21b52e97174811d033dd55ed0cbd19b88cb"
    ]
  },
  "signature": "jtKOPbtBv7RquI35imEcXnPqaltUjKx9HRJVW7ZxKvBGmZYY17w/k0TIDkNqB66mDfKtot3BXlofvPGoPGNXBA==.sig.ed25519"
}

{
  "previous": "%fxFq5ysIKXPXvyznZtAYdNMzAhi9nbDJlZxic/xJOyI=.sha256",
  "sequence": 632,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520507290023,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%d+lK6zQcx9KR9DiXAxYdX2D+Dm2WuBDRo+vsAlXpA4M=.sha256"
    ],
    "packs": [
      {
        "link": "&HkvKSalLdGP9kvJn72DBoXXWbGppkYabebzmgG34uAw=.sha256",
        "size": 759
      }
    ],
    "indexes": [
      {
        "link": "&WqQoaF7FFZiAZpRnYgV+Mg7al/b4+gT32uQVAhU7XkM=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "4d952b3996a682066322accde8e59075de95de4b"
    },
    "commits": [
      {
        "parents": [
          "66d937ce2e2afd88849bbb39334d2e93368d17ce"
        ],
        "title": "Update muxrpc to 0.2.0",
        "sha1": "4d952b3996a682066322accde8e59075de95de4b"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "f77f3f689950d6025f3f037fa9f009bff42ab43a",
      "64623451e52f00c166af7921daf13ea9d6ed3c93"
    ]
  },
  "signature": "8pAkmEWXkySwQdv+uJ7HRxEFZrvX8bd708kLi6nKm/7ZY/CGaShth7ww5izhOCf7qRwYntsDz0WX35FzDei8Cw==.sig.ed25519"
}

{
  "previous": "%oRGDqQuWeUYyV7SZou+346GnzF7OnMaBno4enMiQjh0=.sha256",
  "sequence": 633,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520507960122,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%x8kt1Xbvdh6Ypneri2UJ+83x3nPBh12kPg4YK6g607I=.sha256"
    ],
    "packs": [
      {
        "link": "&HLxJ36VK4lHG4vvBByasMVWywCjNVuVQ3tVib3wx/Xw=.sha256",
        "size": 6165
      }
    ],
    "indexes": [
      {
        "link": "&G5/ww0SPt+aPesEzAixOKMwi3IX9bgLCri2zeTQgFoc=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "af7262d9c287893002107741831fd066f9ebf167"
    },
    "commits": [
      {
        "parents": [
          "bd4b046384f08a11e954b75be40aaf6b16dd4ec5"
        ],
        "title": "Pass by value when creating new OwningHandshakers",
        "sha1": "af7262d9c287893002107741831fd066f9ebf167"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "7a8adc16bdd755e12147f536a8318b02b1dfa3df",
      "836a7d0b647bcedc8f57a0a1a15807244fa8df94",
      "702b7976328d2c5a18f81c49392cb40f4a85c187",
      "4f1fa7d038a846fb9888caa43055a087c363954f"
    ]
  },
  "signature": "ZeyYmrxoqOrNpO09oJtD79RNEe+mPOX1q5OhP4ViB6hSuIOrTPYd+uZjZuISt99naLvslAznj7viybg/ek20Cg==.sig.ed25519"
}

{
  "previous": "%5fFy6DxvyJ06Lbj0lUtT6fQSz2K+Hpiqcv5b4VkMiRc=.sha256",
  "sequence": 634,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520508165971,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%2sUVacAsBn6hTFea8wW432HJp6WM7rd7hgwzn5yzRT0=.sha256"
    ],
    "packs": [
      {
        "link": "&FGOO1Ku8Bwjl6Kt9O2mHz6zMQ/h3qD36KlPdVEPt3G4=.sha256",
        "size": 2497
      }
    ],
    "indexes": [
      {
        "link": "&b64z2dAUg3v8OXtofvtdAgE56TkmNlbyRScJeyvg9pg=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "8d787231f27cb3bda77d3a8ff608601ec95caca1"
    },
    "commits": [
      {
        "parents": [
          "39d61d57bef9157fbceb141df9622d4d76db4669"
        ],
        "title": "Pass by value when creating new OwningHandshakers",
        "sha1": "8d787231f27cb3bda77d3a8ff608601ec95caca1"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "b6fd936e26e8e2bd0dac5d42255e4a59a0bc21c1",
      "1a1c7d322ed33cae7edd3ce9b4e8046c1445067a",
      "b2ff878ac935a3193cc6ccdd385c809c2384dce7",
      "5db5bd7a251fde8d72fa0f815f60ad390ace56ea"
    ]
  },
  "signature": "uGHtk/j3WYBkFE18mqEFAPyJrRdB3u9xvAZ8lLikBUQIQ9DqxGSvtHeymxJo1LEhMpOZSS612siJA0oM6mjPBQ==.sig.ed25519"
}

{
  "previous": "%lBQI+TzCuhNxUGNMUeR2gEZMOEbJ4X4zKKg6biYf8oQ=.sha256",
  "sequence": 635,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520508321072,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%5fFy6DxvyJ06Lbj0lUtT6fQSz2K+Hpiqcv5b4VkMiRc=.sha256"
    ],
    "packs": [
      {
        "link": "&946QZT5WSq8FTQyU3RZLZ0TFJG4X993K1dZxWtsip/s=.sha256",
        "size": 856
      }
    ],
    "indexes": [
      {
        "link": "&eDp0HPy7qfK5ur0LdE9Zh8u84+WtQs7HnZZDWOuz1Cs=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "28b2e1654b598d268f966ee3244800d4b40a3104"
    },
    "commits": [
      {
        "parents": [
          "af7262d9c287893002107741831fd066f9ebf167"
        ],
        "title": "Bump version to 4.0.0",
        "sha1": "28b2e1654b598d268f966ee3244800d4b40a3104"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "a4d426cdbc6090a77c9add0ae3b995668f546acc",
      "3e3f1a2beab9d830708541b5e942817d28b82825"
    ]
  },
  "signature": "ielSqKwaQUtg4Db1x5YjTyVewMnfHQoZbDbEyZxtsWZgSDxI47zoVa6liQyowFV9J1T0xdMWe4Gie8/mA7rWAw==.sig.ed25519"
}

{
  "previous": "%KVlQFqH7gVu+bHOE5hXKFjtsH4/AUIO6jHYAenWl7ns=.sha256",
  "sequence": 636,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520508395749,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%lBQI+TzCuhNxUGNMUeR2gEZMOEbJ4X4zKKg6biYf8oQ=.sha256"
    ],
    "packs": [
      {
        "link": "&SH4ERPri8PNGk//pfGfN3hZseWju59AD/KgZvXPYaio=.sha256",
        "size": 649
      }
    ],
    "indexes": [
      {
        "link": "&2UyhWG+zfNxPRj/9HSWOoFAz1Exmko3EVbkHY4IcgIM=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "093f7d5a98d7559746887a3a0aa338a86850cd59"
    },
    "commits": [
      {
        "parents": [
          "8d787231f27cb3bda77d3a8ff608601ec95caca1"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "093f7d5a98d7559746887a3a0aa338a86850cd59"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "62da6761257b739288e958092f7b97aa65e8f977",
      "15326ad7e5e22db6a74583f0c1af0a0dbe7eb050"
    ]
  },
  "signature": "iCQZ5/eLAEzGqwb3FKnjOqpJ7OuJ7q/y+wNmBHJdkf7J/5BLusymGDjylmQC9X8gbBlbNI/B6qTR0DJ8lCIRAA==.sig.ed25519"
}

{
  "previous": "%Hz5PBxc11x46h8m+VIjp5PO8NYT+vmnKvTJtihwsA9k=.sha256",
  "sequence": 637,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520508467511,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%fxFq5ysIKXPXvyznZtAYdNMzAhi9nbDJlZxic/xJOyI=.sha256"
    ],
    "packs": [
      {
        "link": "&/pBlNdnoCXGs4Q1X0+tjZuF4SJtwIqZ9drZzIg02qE0=.sha256",
        "size": 1873
      }
    ],
    "indexes": [
      {
        "link": "&a+Ao0VQMdvEkjpb9zirdHubOQUNwk+MQ3bvMJ1YWjqk=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "ef0b3969c85e744481f9a4bb66f6467a859d4dc7"
    },
    "commits": [
      {
        "parents": [
          "e0a1b902a8d048e83ce5a3a14e32633fa9ec9999"
        ],
        "title": "Update secret_stream to 0.2.0",
        "sha1": "ef0b3969c85e744481f9a4bb66f6467a859d4dc7"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "927502ff8667d662f118951d0077a519ed019361",
      "6e0be82d66c2fa3b491c1e2fd6a05f2b415291d3",
      "b6a6a4bb3ab4857c0396a4dfdbd53acbb9ae041b",
      "9dd4de640eb4eafa91a7c5aa4a5e4131efef674d"
    ]
  },
  "signature": "c/RkaiuDBU+1AbIzurLW0MthqCkRW8x0z0Doy7npmnuhtaUDmknl/kS+vIlnHyYuWnabwnUFjpwsx/uQl1rwAg==.sig.ed25519"
}

{
  "previous": "%IkMPbmQ/ZvwK6J5eARHLLPoD5weTuTj2lInkpEYKfew=.sha256",
  "sequence": 638,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520508619934,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%oRGDqQuWeUYyV7SZou+346GnzF7OnMaBno4enMiQjh0=.sha256"
    ],
    "packs": [
      {
        "link": "&Mh4enTp3x8/j4NrKNYuWPHAF36K22AG6NI4J6lNauvk=.sha256",
        "size": 3894
      }
    ],
    "indexes": [
      {
        "link": "&KElcSlEiWurw3WCMag/PseGAUx/m2nNCnFowXCGox5g=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "62333634d933d49cecedcd4f534a5920e0430c47"
    },
    "commits": [
      {
        "parents": [
          "4d952b3996a682066322accde8e59075de95de4b"
        ],
        "title": "Update secret_handshake to 0.2.0",
        "sha1": "62333634d933d49cecedcd4f534a5920e0430c47"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "9e4a2db9a537f9320d50a1aac5608ee18facd48a",
      "be1371499fba90d42ccdce8fecee47259631ecfe",
      "e0c5f0a5f2b034ee7e560392e8e0c76dc9be4cfc",
      "e25275cccf0eee6072ed97798459be4069e43bad"
    ]
  },
  "signature": "Z/pzoMBr+elfh+shhJXN9P4gHBTFHgOGFO/ZprNKa5W3kMK3T8/b9lVhXCHlDRG6YBhHaUQNdUAYDx3AjPFWBw==.sig.ed25519"
}

{
  "previous": "%fmroeBlO4J/ujUjWS3p+L4UuJyOmS/kM48H3eTOg600=.sha256",
  "sequence": 639,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520508890886,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%GKJaVlrgftSbSWN1Y/t7/c4IeahhInGurKCXPE38aP4=.sha256"
    ],
    "packs": [
      {
        "link": "&8bLm5gqKd0F7i/DHQndWnxxAeqhIshttfLTziulWoSI=.sha256",
        "size": 1343
      }
    ],
    "indexes": [
      {
        "link": "&kzR+rpU/wjKiyGYQOoQM5F1s9jx2ZBYWJZPf/XSj7Eg=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "40fe8d851e90faddd86ad00bcc5fcb0816f8831d"
    },
    "commits": [
      {
        "parents": [
          "99a12ba7ef35499b4aba51a780ef801f810fc2eb"
        ],
        "title": "Use proper constant for the length of the mainnet identifier",
        "sha1": "40fe8d851e90faddd86ad00bcc5fcb0816f8831d"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "ed37527a54e880861b783957979a3758d698628d",
      "3d911c41d748373f6a48d2150786bf355d360121",
      "02c7add1ff7e4aafcb38b5a9c9fdf268f3e58b6a",
      "09f9013edd6365a3b8d0eb10022a53fc82ac0914"
    ]
  },
  "signature": "hh6J1CY6qULLguG1egs2alqMCw5aa+1gt9PbYKV7Uy0MZ+G3hnvgNjJjvszMyJ9tvg5Ml14I3q/xeXKkofENBw==.sig.ed25519"
}

{
  "previous": "%882mlNGVBaUtg4E0WgRBoss1XicF4VJn6gHNvvzR1Ts=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 640,
  "timestamp": 1520515001285,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519",
    "following": true
  },
  "signature": "YqPg7RRQLN4FxVYQgWGbgt+Jw+5LmaJ18crRzKcsMyZdUZRolraeghNadwmqkGoNoEix04YIf6dmQaBotivmAg==.sig.ed25519"
}

{
  "previous": "%hl0ROE4U+m/WNVOdS3VMMG0WbeEArCqYQ2RD3Y5Xfg4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 641,
  "timestamp": 1520593959026,
  "hash": "sha256",
  "content": {
    "type": "gathering"
  },
  "signature": "0u8Wr4QcLp9Foy6PMFvcuX8AGVXym816yM9yYLk2gSBw+e2PL0wl5Cn4GHVbNgJUZD20EUKCgaf/8Pji8W9iBw==.sig.ed25519"
}

{
  "previous": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 642,
  "timestamp": 1520593959522,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
    "startDateTime": {
      "tz": "Europe/Berlin",
      "valid": true,
      "bias": -60,
      "epoch": 1520845200000
    },
    "title": "SSB in Rust - Introduction",
    "description": "An introduction to using ssb from rust via [ssb-client-rs](https://crates.io/crates/ssb-client), as well as how to contribute to the ssb-in-rust stack.\n\nLocation: Mumble."
  },
  "signature": "la1vtZ8zkEqx748bGoYb3/PPUxkYEB6lB1o8gidz+o0qTO8qjav0jJYZlw/UDqJVFG+t0b2NHmO+pezMo9NiAQ==.sig.ed25519"
}

{
  "previous": "%FyHV0Oyw3z5KV+DAlSUo6dFjbW695reEZnqcJKmr5rc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 643,
  "timestamp": 1520593970603,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
    "attendee": {
      "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    }
  },
  "signature": "A4HuPkoiwEW6wjXcDCtlX0GynOctu/wF0AAJvAM27RX9DTOK/xKPNCbEhS4aGAXy6bTx4Pyfpfg/pzhzuZw9Bw==.sig.ed25519"
}

{
  "previous": "%yfcAotGZwfj0zhzZxKBCCB+6+78nHvYIiI0m5RWTDU4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 644,
  "timestamp": 1520594024410,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
    "branch": "%yfcAotGZwfj0zhzZxKBCCB+6+78nHvYIiI0m5RWTDU4=.sha256",
    "reply": {
      "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@corlock](@sHFNLAao6phQ5AN17ecYNUbszDa4Qf6DhyQsjtQfdmY=.ed25519), [@SoapDog](@gaQw6z30GpfsW9k8V5ED4pHrg8zmrqku24zTSAINhRg=.ed25519), [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519), [@Matt](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519), [@Powersource](@Vz6v3xKpzViiTM/GAe+hKkACZSqrErQQZgv4iqQxEn8=.ed25519), [@glyph](@HEqy940T6uB+T+d9Jaa58aNfRzLx9eRWqkZljBmnkmk=.ed25519), [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) ",
    "mentions": [
      {
        "link": "@sHFNLAao6phQ5AN17ecYNUbszDa4Qf6DhyQsjtQfdmY=.ed25519",
        "name": "corlock"
      },
      {
        "link": "@gaQw6z30GpfsW9k8V5ED4pHrg8zmrqku24zTSAINhRg=.ed25519",
        "name": "SoapDog"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt"
      },
      {
        "link": "@Vz6v3xKpzViiTM/GAe+hKkACZSqrErQQZgv4iqQxEn8=.ed25519",
        "name": "Powersource"
      },
      {
        "link": "@HEqy940T6uB+T+d9Jaa58aNfRzLx9eRWqkZljBmnkmk=.ed25519",
        "name": "glyph"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "kjses6I7tOySIJ7GHDK/EM01Qx6S9fIeKo7GYuuMgeeM5LE5ekrptRre53ef+Xkb/Zrk9ucqPnMau1Q0Td03CQ==.sig.ed25519"
}

{
  "previous": "%MZ02gF5Yj5G8yx2O8jgkJ2RgaM/oP3kyJprfxr8uUyg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 645,
  "timestamp": 1520594158402,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%4duCfFNxut1s8yQJfypnDTaPPUGba8p8vX6z4BxYlqM=.sha256",
    "branch": "%rZDkXn+CPuOvFAAjMFc4LEweYNjNfm4LXrM/nQj88bA=.sha256",
    "reply": {
      "%rZDkXn+CPuOvFAAjMFc4LEweYNjNfm4LXrM/nQj88bA=.sha256": "@C6fAmdXgqTDbmZGAohUaYuyKdz3m6GBoLLtml3fUn+o=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Here is [the gathering](%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256) for the call.",
    "mentions": [
      {
        "link": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
        "name": "the gathering"
      }
    ]
  },
  "signature": "+MdSeulOZzgjY5N9uT0qBm/Aqr6mJbUzIbnHxh4IW2TEK5qn+4T3T8RAeEnE3bdTrQ1rVXkPcTVlItPjl1p+AQ==.sig.ed25519"
}

{
  "previous": "%c47d7MfylbbT2iNueVSpqxnJMg9HyvI+U0VNT2AmzPQ=.sha256",
  "sequence": 646,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520612267575,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%gjhLq5b26TyUjeQkhLgnHSu/Xak30zgfw4SMIV9y/kM=.sha256"
    ],
    "packs": [
      {
        "link": "&GfuY0wiUOMhC+l2qX2mUlZ2I2al0yQSA00zjazoNTLs=.sha256",
        "size": 14936
      }
    ],
    "indexes": [
      {
        "link": "&qt8IWfryDLKmACvfn6b5JFUSRXl61bOBhYw0bPpIvZA=.sha256",
        "size": 1660
      }
    ],
    "refs": {
      "refs/heads/master": "65f04a1b50d6fc6697f86276a804f4c82ee46fe2"
    },
    "commits": [
      {
        "parents": [
          "513a882cd06baed4ffb13545fcc17549aa3dd996"
        ],
        "title": "Remove quickcheck dependency",
        "sha1": "65f04a1b50d6fc6697f86276a804f4c82ee46fe2"
      },
      {
        "parents": [
          "1373d8dec43ed46e79e13d52dc80cb4fde9f4940"
        ],
        "title": "Test TestChannel",
        "sha1": "513a882cd06baed4ffb13545fcc17549aa3dd996"
      },
      {
        "parents": [
          "76174dd255d88653b9bd71a4c1790455c181086a"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "1373d8dec43ed46e79e13d52dc80cb4fde9f4940"
      },
      {
        "parents": [
          "b1dbe72fdc5d8937ee58a52a48c2e926f73e7da0"
        ],
        "title": "Update to futures 0.2.0",
        "sha1": "76174dd255d88653b9bd71a4c1790455c181086a"
      }
    ],
    "tags": [],
    "num_objects": 21,
    "object_ids": [
      "c8b9a3aacb90d160a1336dcf8bfeee050253b03c",
      "b21d7d4d528878509eee73f618a35ac924d54ec0",
      "b5ca3b7e8f1aa0ff743cc17989815860ccadbaec",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "4b732d9c1419ece230df609d14aa591242bc807b",
      "e876ab9819adb0d2a0d7fafc0f4ddbb774734bdf",
      "3dc65e0a425647988349104c7d7e3716fb21aade",
      "8756a0b0a0794c2df2c59337dda507802556bbe0",
      "82617363868f52c89861c3992127c58e16f93de5",
      "e0a080438d461449893360ef8a3fffdf21992505",
      "d381872d4e44674bc68d31c8d8124bc535da9433",
      "9ea1b2b26bd95327ef905f0cc546fb9b7bff78ae",
      "737560faec84a67861ee02cbdb3a0bccdd8067d3",
      "fa695ac555d6a5c19b9275e8498c50e31f92b310",
      "2fb945f7d5132c1258fdea83d7d310223cf53947",
      "d085190f0a099c6a48b98d5534d4a096dceaa7da",
      "795e0166bbbb808117817db110060c34a8f97d72"
    ]
  },
  "signature": "75OnC87ktPAuE1AtdlYsA9dr+tr+2zxIyLetdOU0j6lahTdENVCraEK4weVgCN54jXvMwHbXekGqxdxDGLYRBw==.sig.ed25519"
}

{
  "previous": "%J/nKMceldQda1KyiYCV+NRMox9TedeWkZGsDL7BLMwc=.sha256",
  "sequence": 647,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520623132678,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%xmaiCBaEKCXPo2yJbqsoeK8Re3tp67cjOSd6IOS847E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%3AG95To7lN+jbO4i4U8EzY5h+aLH5lyx4JtseKfMNzU=.sha256"
    ],
    "packs": [
      {
        "link": "&0aS0pNZ3s66qekKwEG/4KjIfWFgFldOXkXuOoxlQyAU=.sha256",
        "size": 21003
      }
    ],
    "indexes": [
      {
        "link": "&sZyNw95stX/qP7J6ZTa8O7w/Lwdn6VlO+XsbmpeM8tA=.sha256",
        "size": 2276
      }
    ],
    "refs": {
      "refs/heads/master": "739706a84798cfe833acfc05914dc575a566287e"
    },
    "commits": [
      {
        "parents": [
          "675ce56960b67d97ee4a4163ed12e6e27f88aca1"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "739706a84798cfe833acfc05914dc575a566287e"
      },
      {
        "parents": [
          "322ddcd1d5f348e450ee2d89bc0bbd55167c19ea"
        ],
        "title": "Give up on the sync version for now",
        "sha1": "675ce56960b67d97ee4a4163ed12e6e27f88aca1"
      },
      {
        "parents": [
          "d6493ab61010b20013192fb348638bb0a23d5133"
        ],
        "title": "Test unsync",
        "sha1": "322ddcd1d5f348e450ee2d89bc0bbd55167c19ea"
      },
      {
        "parents": [
          "27d451066aa8aa958525c8347bd0e449c6bc6332"
        ],
        "title": "Implement unsync MCS",
        "sha1": "d6493ab61010b20013192fb348638bb0a23d5133"
      },
      {
        "parents": [
          "8307e0d9f1b9fd452c939aacdf89e4be56db923d"
        ],
        "title": "Implement shared logic",
        "sha1": "27d451066aa8aa958525c8347bd0e449c6bc6332"
      },
      {
        "parents": [
          "7b280c62d79cf437470382502f3fbc6ac96b363d"
        ],
        "title": "Sketch api",
        "sha1": "8307e0d9f1b9fd452c939aacdf89e4be56db923d"
      },
      {
        "parents": [
          "32b861c1bee9e3e70a7f62da939e3693f3d09256"
        ],
        "title": "Tabula rasa for futures 0.2.0 rewrite",
        "sha1": "7b280c62d79cf437470382502f3fbc6ac96b363d"
      }
    ],
    "tags": [],
    "num_objects": 43,
    "object_ids": [
      "b9c5f2422057666d2b3b10c28ebc51f21a2266fc",
      "18b4f439d53559a6edd0fe5e02d5191f8de92b20",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "9099d4888b1f2c0f5491fc4d4a71244c2903f7f0",
      "34af908dc9cbba0c5dbc1ff5c7c483c739c7f799",
      "36eac0c4b7791edb4479defaa68ad4e208739e63",
      "8bc27cb5ed37e7d2c0879f2cf55572ee2f5c1acc",
      "9e5832e1b4ce37313219c91697982b284a4adb77",
      "394e88270374feb1dff7871551a6276fbb63b0e8",
      "33c57902f657cf35d0781282f7f5f33eb3df2525",
      "bd4b73e0dc6a19faf9d8e198f85048fa2445349f",
      "6d532f9e23997a1bdb82111d671ca62efc4c7835",
      "f52fde8c1d07a4a47925bb53d78de2531e6b807f",
      "c25f29d5c4382c2bb29b264e25bcd5ef8b2cb4ae",
      "33b4856f3376bc904920fea335642233518432a9",
      "ce9b337825e1387e66a231b3b801348e8c381839",
      "0c72893384b1ef6e59c4db19a13855c0b1421fdf",
      "4dde425404d43e01c2d11eb287580b5928b5f809",
      "2f121f3db8d38db0a4ddc6a6636869db74969c57",
      "70728ca32266c7e12a6e6763de570ffbf0d941b3",
      "3eb624f13edd58a309ed1d90e95755ddf11f7cf0",
      "2c27637bdd04924e0e0373066e088e71fe17a925",
      "168f5520826faeec5c79389e3afb96c9d2f5d68b",
      "eb60307029051a870cb86c0e851e39ca42dcca3d",
      "9212de2a3f4d7e735c5dd3cf99adcbdad9dc3d03",
      "8d92d2b9a192f669b400ed4e1018f17609b94141",
      "86305b07e0c4e39ca3fd61bda3abd5157131910a",
      "a03964d1ee84d21de6454d988432ee0e85af9464",
      "915ba57413a479fb28946f2b00c2cf40f32e7d8f",
      "c9cc5bc1c3d9c1260e17e5e40e987a5514b58965",
      "1a8c8ee9570263955df39b668653f5d7055e982a",
      "b40f3376ef90f9709e11f5f5de8278e04ab041a9",
      "93aa407165a3b0b48a250bbde94d54d1ef1f9813",
      "3f033cb882984ed48971b7cdf44ccca212706404",
      "8346ca036a9c67238ee5093c0af08a6a589bee5a",
      "f65a71c15d397d21e2ec4b6cacb58ef96746ea63"
    ]
  },
  "signature": "526iS5RsOzQOEEhh6GV69b+ew43BTMxV8ZF8O2IKszccEZTbMReLB36Di1WsdRkVO+W6bCH/sT4oQi/piDMSAw==.sig.ed25519"
}

{
  "previous": "%dF4ycJkHCk/3FsC10FkoyWky3ynXQs6y8m2eWXJSP40=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 648,
  "timestamp": 1520623231061,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%nVMeWGsdtHIbiA/p7JSvuyzhbLazfnGi1liy/GWjkfQ=.sha256",
    "branch": "%gTzY3+T4+S/vgDSdmyj7qnW1H/Tsr201eBavvXG8YJQ=.sha256",
    "reply": {
      "%nVMeWGsdtHIbiA/p7JSvuyzhbLazfnGi1liy/GWjkfQ=.sha256": "@ZqH7Mctu/7DNInxuwl12ECjfrAKUX2tBLq1rOldNhg0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> Power Grid // The greatest game of all time.\n\nI knew I couldn't be the only one!",
    "mentions": []
  },
  "signature": "TYENHamQOipLO5Fdx+pUr960J7R/j/r5pYfhcxkCXk+LKJs3kXu9RulpRa3KNvOyfZXQyQ603jvBamOV21QPDQ==.sig.ed25519"
}

{
  "previous": "%XVNxeRIttfFG/sxYp6+a+a9v/UU/PAZnOrWSYfusmdQ=.sha256",
  "sequence": 649,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520636552629,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%O4yB6HXnZsM3YebQBnkm8kYxJiY6pf2FeFqHIx2w2TQ=.sha256"
    ],
    "packs": [
      {
        "link": "&VMKpBAS9jjQBwLjBlwSRhQpYI1SMXQpiUZWrsb4vyb8=.sha256",
        "size": 17564
      }
    ],
    "indexes": [
      {
        "link": "&5WpfN28eBZMNdGjVQWstGaKB62Yzi5rJf4irvZe2Hcw=.sha256",
        "size": 1660
      }
    ],
    "refs": {
      "refs/heads/master": "91d409d7149694f7f46e9273c0372b7fc3ff92d9"
    },
    "commits": [
      {
        "parents": [
          "f002364c7feda4cf568f5b117cf023ec68183d12"
        ],
        "title": "Bump version to 0.4.0",
        "sha1": "91d409d7149694f7f46e9273c0372b7fc3ff92d9"
      },
      {
        "parents": [
          "697361c154e8a1928cef77b29548f9c740e5dc90"
        ],
        "title": "Implement mps with futures 0.2.0",
        "sha1": "f002364c7feda4cf568f5b117cf023ec68183d12"
      },
      {
        "parents": [
          "dd1ec9e20dd9855564d4861c6857b5f4cf340b00"
        ],
        "title": "Prepare update to futures 0.2.0",
        "sha1": "697361c154e8a1928cef77b29548f9c740e5dc90"
      },
      {
        "parents": [
          "469b5358fbef1f8878a1e461f443aaf3a2cbc49c"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "dd1ec9e20dd9855564d4861c6857b5f4cf340b00"
      }
    ],
    "tags": [],
    "num_objects": 21,
    "object_ids": [
      "5bd36c1c73cf4f09976b6e07354a7a83a5b564f4",
      "c5241e10ffe762cce5c5f9a22abac2fad09cbce4",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "8e3464229a2065a9db6f9bfadc718d5c3a8d5094",
      "4b6d5e1ccfde83613f7adbb6dc176d1bcb84b214",
      "84705c1b06a664184d1e4751c798b6ae0fa27f58",
      "a7a780b2c97cc49f9baffdec97b28ab6869e202c",
      "d17e39fd7149197841342ce284970dc97bbaebb5",
      "3f6662235d46b465a8d1bf0ca7c412573325b6aa",
      "3138511cb94fec71decfd5a1ef2d6c233eb5bbf3",
      "5083e2cadb196a6a7a2795feef00110bb59bd180",
      "76e362dd86ea0116617815b4395badfae98559c5",
      "3f63a7227a6c81caaf0bbcc5be894c19bb54ec09",
      "8b137891791fe96927ad78e64b0aad7bded08bdc",
      "e3deaf393a1ff9d2261abf2379d734154ad26cc5",
      "fa8c4fe58f180b8f00c829e409f1a16b5f12fa9f",
      "0c9627746b4905b9e38de6904c5e33087952b513"
    ]
  },
  "signature": "NqPuQ3cBnfhyOZ8iW1vxgwycc1zSBG1gCBHqcVSAcD9nh8CXaD9T42BYWhxhDln5NiBvNTWjUFCt4qkoNK+ABw==.sig.ed25519"
}

{
  "previous": "%+rLT78hjYLWqiV4sM+OIu29Nu0Kqh/zHSEYChKDO5x0=.sha256",
  "sequence": 650,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520670848231,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%fDjtH40oENJrx8gvG0CxgDvAD4eY8QmCzLvordfUDSE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%f40inmXIzFJzWqqHYsV8lArq5FjlG22CFHLzNoA0eNk=.sha256"
    ],
    "packs": [
      {
        "link": "&u1WZ0RpPCWa+7/os9sncV6W6L1StA0TqKkJo/b8dV/0=.sha256",
        "size": 18920
      }
    ],
    "indexes": [
      {
        "link": "&MvjM1gXCmS7wnubMvhp+mRGg9Ia2n0VpH5+UjWvgBrk=.sha256",
        "size": 1464
      }
    ],
    "refs": {
      "refs/heads/master": "3462488701fe1ac5901381da54b996372a6170d5"
    },
    "commits": [
      {
        "parents": [
          "9c1263e9b4fbe6958f27f5aab27af2dfb1557850"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "3462488701fe1ac5901381da54b996372a6170d5"
      },
      {
        "parents": [
          "85c8bf526e61a270564d1460359dd2f64d10bf0d"
        ],
        "title": "Update to futures 0.2.0",
        "sha1": "9c1263e9b4fbe6958f27f5aab27af2dfb1557850"
      },
      {
        "parents": [
          "4798d59c26a3ba76a6ffe6f31871cba256493fa3"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "85c8bf526e61a270564d1460359dd2f64d10bf0d"
      }
    ],
    "tags": [],
    "num_objects": 14,
    "object_ids": [
      "5a6278752e429e3325dd55a4fc48482d21345753",
      "4e20e8541b3c1f45b242f117f03080283a1449e1",
      "112e9248f05a4505f1b95d9c6b9c043c2960acc8",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "5005e622fce7e0112782fb4614e7616c1ea508fe",
      "7f86d1de9466ea195189b29351c19b0267a7174b",
      "750e2f34fa096efa5659bb6773c85ed250a00249",
      "43dbdf311627912cf0ca1aedd988011e18c3ef43",
      "8510280a15cb2ca6f654fd57e9f41c51c40f1249",
      "62c96f9d091e4435c3b0b3983d0e2d82fc84a054",
      "b68f9260354181540ffbab23a9c0e1b1095ed399"
    ]
  },
  "signature": "BHfEbQs9fQX/6579tTpIW2ibKkiYb9iN1SwsnmM16RXw2mN2pwjX1sCK94YFzKwnxfzklijwsUeDr5s2HWCsDA==.sig.ed25519"
}

{
  "previous": "%rdghhycts0ONTO3Q5B0qDoozo/u1KXuhy7Lo0v4wP7A=.sha256",
  "sequence": 651,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520674747844,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%XQ7XmsjfXT6uiSvocl6pWcN+rXgDLp1Wnz6aZx01Kdg=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Lm/USWktEAN1DSz9gG/uo7ttPNk7U858M9Zfp3BYCt0=.sha256"
    ],
    "packs": [
      {
        "link": "&RxfA7M84uXA1JGcaXWe5/4rs47RcBsBlsOwDF+iWMU4=.sha256",
        "size": 16853
      }
    ],
    "indexes": [
      {
        "link": "&Ubx3/EGkViz12RFTr6kGjpJmndZPwhOQOnF8WbUmxmc=.sha256",
        "size": 1408
      }
    ],
    "refs": {
      "refs/heads/master": "a56d4aab32e74722442f2a0e9ef37bc850cfd1cf"
    },
    "commits": [
      {
        "parents": [
          "a0c4da7f51c7092a2fba289d37c66d8fe2a6f791"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "a56d4aab32e74722442f2a0e9ef37bc850cfd1cf"
      },
      {
        "parents": [
          "4d20c1d1c6f4a02d6b2e3f84a16956fb2670540f"
        ],
        "title": "Update to futures 0.2.0",
        "sha1": "a0c4da7f51c7092a2fba289d37c66d8fe2a6f791"
      },
      {
        "parents": [
          "299b6a20c60bcef2e6aa8294d0fd7115d673d05b"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "4d20c1d1c6f4a02d6b2e3f84a16956fb2670540f"
      }
    ],
    "tags": [],
    "num_objects": 12,
    "object_ids": [
      "c9e7a39a774c98d86533d3fb113d6aa249e27947",
      "1ebd74a518ecd115603d9e55686c044c185589c2",
      "e1e8eff9c188a61fdec7e92d5fa92a56100f45a0",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "0b93a9cdbb930c8ae4394367276e3c9ffecef92a",
      "978948f7d1c4b6d2d8b7d820f8739d19d3bc006e",
      "7a7e039c4c46466bbdb8e9654f2ba80ccab49665",
      "96f62a8ca7b89a2105b05b040360c240e31f2e4a",
      "7dce0bde1086114b61a8ff6c67afadfb23c60e28"
    ]
  },
  "signature": "z78FXbDhbZAKbiExv9QK87AaCaq2AStbZW3CG4Se5pEj39Dm/2Ws5feRXpK2waW0rQDYQ9yVdhOGGhGatVZbDg==.sig.ed25519"
}

{
  "previous": "%1FRWPGmA422xVni5mWf/eO9skzKGguE1IARS113/ItI=.sha256",
  "sequence": 652,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520680416047,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%7NbvDJeDCknlhTcgBmj1RqtV5AowDH2fB5pZm1ol8XM=.sha256"
    ],
    "packs": [
      {
        "link": "&XWk70To5oY3kK7pkVe5pKSnNHVckmc+TQ5UOSj/+E/o=.sha256",
        "size": 13858
      }
    ],
    "indexes": [
      {
        "link": "&bDh4O1c9cbM1mxcOU49a7a+77/mv6KqgSomScxiVQ08=.sha256",
        "size": 1464
      }
    ],
    "refs": {
      "refs/heads/master": "58a058fb6e9fa5bfe33c66771b56a9dcc50f856c"
    },
    "commits": [
      {
        "parents": [
          "ce2a5f588ea3b6a516211da5ee97383380d4a551"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "58a058fb6e9fa5bfe33c66771b56a9dcc50f856c"
      },
      {
        "parents": [
          "0ff0addecfbe60195c5fd57f42039883c2d63c2a"
        ],
        "title": "Update to futures 0.2.0",
        "sha1": "ce2a5f588ea3b6a516211da5ee97383380d4a551"
      },
      {
        "parents": [
          "dff3b5613269b03c2a8ed58ff13c75d2aee34027"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "0ff0addecfbe60195c5fd57f42039883c2d63c2a"
      }
    ],
    "tags": [],
    "num_objects": 14,
    "object_ids": [
      "ecaa62542b20e388698b406fdb00ac78746d0338",
      "a2602a96c2c552276923db189f11c6fd5053c830",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "45bcb75a7ff0e5699f5f16ca9d80832977c22223",
      "c16b843151c777012d65937e94495e48ea66b68d",
      "f16d3a9cac3db49a5b53cca069b945d5a482cff8",
      "a18d1ec29984268a7c4450b15974b59bd7a5db54",
      "dca458436b4a9782321b3d3ff0e5891644312bb9",
      "e35c9dc85d5ccf2b7be56a4d11006bf785753cb9",
      "f8311e25ed8c04434f41db15d07380aaeb5f4fc7",
      "6d0aad7443d7f1ec1845e3c3d7946392218072f2"
    ]
  },
  "signature": "O5/2TdufLewhU87oZqszDXPrR8Ha3WDw8PkFo1NvKVIWUkenVlLj0fGJVt4tSHQCii67BaA2/W9hfdSHDCLIDQ==.sig.ed25519"
}

{
  "previous": "%1QZDLm7xgsq87qTf5eKTpJe3/HVOPIzYGA3zDyEncso=.sha256",
  "sequence": 653,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520680770247,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%M/jqbgMZ3Uk3WJG58FlvM7nMiHUq+hVQ8Mk9fmYtH7s=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%KVlQFqH7gVu+bHOE5hXKFjtsH4/AUIO6jHYAenWl7ns=.sha256"
    ],
    "packs": [
      {
        "link": "&svaxvOoYInpOmmPzTk3wTSHDxn5PSUXDvrdbxXyfgiw=.sha256",
        "size": 23303
      }
    ],
    "indexes": [
      {
        "link": "&Yd/3gfplGb7zUd4vdlgYmZAnbkPtKhSHYJSablP/RgE=.sha256",
        "size": 1520
      }
    ],
    "refs": {
      "refs/heads/master": "5191b5d9b6ace31997ef2eeb3a436cea786972cb"
    },
    "commits": [
      {
        "parents": [
          "96661050c18f517a9411ce96163feb8750154fc8"
        ],
        "title": "Bump version to 5.0.0",
        "sha1": "5191b5d9b6ace31997ef2eeb3a436cea786972cb"
      },
      {
        "parents": [
          "57bcf64cfbc89642ad5e17844806a20b75f9a3ed"
        ],
        "title": "Update to futures 0.2.0",
        "sha1": "96661050c18f517a9411ce96163feb8750154fc8"
      },
      {
        "parents": [
          "28b2e1654b598d268f966ee3244800d4b40a3104"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "57bcf64cfbc89642ad5e17844806a20b75f9a3ed"
      }
    ],
    "tags": [],
    "num_objects": 16,
    "object_ids": [
      "7b95dd8ab7549e2c41c40cddcd0ea5b7335a9202",
      "5639ff02379bc2aab56122433d6f0195251bc0bc",
      "1c0311b389b0045f2eb9ac7ed9203b3f6a69df0c",
      "cb27693d4f641e4e807ddca652e4c6c31006ccec",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "c28d50b5475c5f47b51d7bf48faadaa4ee2281fc",
      "dcedf92460103359e404de5cb52e1804820dca19",
      "0b940dd83ee350a71dc72d363dac23d4981c3c4f",
      "43093d500e899fd79ef3c3e7cbe1ef88bcb61fcb",
      "52df7e1fba14d1580a3fdf03706fa55e98f7ef2d",
      "713d18570b65767ef7f3113c83a32340cce238eb",
      "64bdecd3360c47079a13bc19911cebd346dfe973",
      "757c0e7fc153fa298e8dd4a5bf70f5468772b5a1"
    ]
  },
  "signature": "GuqPLp6eQGHCz8qXMJ7xcNYCF9o01lp0KeZtBIrZYbgDI0SpOPgRKrcwlaESmZQ3Xy0/C4zAKjiZyeF6+yVnCw==.sig.ed25519"
}

{
  "previous": "%RLJc2k/s3EkKd03ePdbSVB6E8zpGQVUkbmw6QXSYyR4=.sha256",
  "sequence": 654,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520684545312,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%aaa8p7x7PZQA+Rf9YniiXky15VfPU5vSWWnjdktjZ2M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%jTSx9RZt5dczcW9xSyv/ll3d5bA/QS5PbOszAvD/xtk=.sha256"
    ],
    "packs": [
      {
        "link": "&eyNam2MszNABxL4vz2DblFB4jpObXOQa3WV0egG9dv4=.sha256",
        "size": 20740
      }
    ],
    "indexes": [
      {
        "link": "&wKcPI2aADrfX1KGpy/tuiRv70JUKFvXCLymfqD7NofU=.sha256",
        "size": 1576
      }
    ],
    "refs": {
      "refs/heads/master": "8cdf9d641fbbd85b6c17869278c7192832cf91bb"
    },
    "commits": [
      {
        "parents": [
          "138adf229d55899ffbfddcd19a8ba7a374eab01d"
        ],
        "title": "Bump version to 0.5.0",
        "sha1": "8cdf9d641fbbd85b6c17869278c7192832cf91bb"
      },
      {
        "parents": [
          "4777dffddd6dde8863e0cb38b5b57fac4d84db0e"
        ],
        "title": "Update to futures 0.2.0",
        "sha1": "138adf229d55899ffbfddcd19a8ba7a374eab01d"
      },
      {
        "parents": [
          "67afba28838a05987bc6abf75cbd28b3a14d4ef5"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "4777dffddd6dde8863e0cb38b5b57fac4d84db0e"
      }
    ],
    "tags": [],
    "num_objects": 18,
    "object_ids": [
      "ac207185641232a6ba0988c2bbf4c79447d8c8bb",
      "1f345fd1ccffa90fcbb9e074b34289ea0fcb70f8",
      "55ddf9157d1fb8182b68da65f76c92aa96cbdadf",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "2df0785b8fda881b42148d35c6dccc9e2b7765e3",
      "510467bd601cc4091d22f8e2a124d220cd925cbb",
      "3c51bc2173edf0c4d7c66d9387f3b1af262a0d94",
      "40db2273190cc297b7810f0e3bafb4fe00e7edad",
      "dcb66efde634a637a08c1afe6d75187f2b66b5aa",
      "33ffc237c68afaf58013c44eafc7d2216b9a546f",
      "f953543ebd07ea61591629d391d7378656f1df85",
      "af41969bb5ae5e33ce34f1c071fdd15719633b53",
      "ee798b1126d40a1cfa686138d688f45291a6c02a",
      "67d4ec23ac074d68e074617726d80f5f19413e08",
      "f70f832bc032b154e2c0480d0006da8509357269"
    ]
  },
  "signature": "VUF0PSrvW9avD3qcBE5xY24h2N+DveFXN/p37mBNcpaQa/n3GfN4FHWEfeb7XqvPs2ILlBHskA7yFy/VehWSCA==.sig.ed25519"
}

{
  "previous": "%E7UKxps5wde35POlmJH8LHShVRMN6awOT4/Y4CsC7E0=.sha256",
  "sequence": 655,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520685595672,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%YO/K2lseKIoXy+IU3RQvNZHBEuejxtruqkKsNKmEwik=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Hz5PBxc11x46h8m+VIjp5PO8NYT+vmnKvTJtihwsA9k=.sha256"
    ],
    "packs": [
      {
        "link": "&AA8IHQi6IkTaTRQayAfR7X+2ShIWDuT+02KpdXMBQa8=.sha256",
        "size": 14694
      }
    ],
    "indexes": [
      {
        "link": "&zx1u6dYAi04KctwLc4RzahUjVmVAYVbo5NFkApjqX8Q=.sha256",
        "size": 1408
      }
    ],
    "refs": {
      "refs/heads/master": "e9ec81ad67b3d38f2c5701b975d9080513e16c28"
    },
    "commits": [
      {
        "parents": [
          "a246f23af15a7546f1be6cc782488d3bbe206ff5"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "e9ec81ad67b3d38f2c5701b975d9080513e16c28"
      },
      {
        "parents": [
          "344faa4e6a66707ae18ce68277a2a8686d3ecfd3"
        ],
        "title": "Update to futures 0.2.0",
        "sha1": "a246f23af15a7546f1be6cc782488d3bbe206ff5"
      },
      {
        "parents": [
          "093f7d5a98d7559746887a3a0aa338a86850cd59"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "344faa4e6a66707ae18ce68277a2a8686d3ecfd3"
      }
    ],
    "tags": [],
    "num_objects": 12,
    "object_ids": [
      "190a55d7e0fc91de4c3958e20f5e9daf0ebcab1a",
      "605f3661fa7273504665418a9beda18ce728dc5a",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "80b7225cac6b72ce9c91ec48e8bfe38120c8ff53",
      "efa6ad70048ad7af2fbbf112612ae154739aa59f",
      "2e087f53169d91560271599621a0e288a692baeb",
      "7db3b0debc0430d01c7c6a46477c29b4309314a5",
      "052779f1f6da54ad7e80c6e340e8cb1f5a1ff38a",
      "54c8606fe3863037d787d98389bbe93ceeb8ab7c"
    ]
  },
  "signature": "3Oj17cXw+VKf/OVY1TIEEFrpNupLYHKGl/BznibDg6nx4rSI8es+OLehe/APMi9O+DcUxHuAuS+O2ym1SF3dBA==.sig.ed25519"
}

{
  "previous": "%kyuz8b57nb1ZUOxIsy7iQscv08FgEE54uBV0h1yJfJE=.sha256",
  "sequence": 656,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520695369668,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%h5DmAVxRGNOmWbXGOsvVCcqDFl8xpCdb/lcHVCasBlA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%J/nKMceldQda1KyiYCV+NRMox9TedeWkZGsDL7BLMwc=.sha256"
    ],
    "packs": [
      {
        "link": "&C2ykHRoxLG9EPWhu31GD8pn/f4nxjuw8PF0F6+3pAZ0=.sha256",
        "size": 1576
      }
    ],
    "indexes": [
      {
        "link": "&5kii5t50KPjft7die8YRdCc1rWviRoqV3aDoqZO93vA=.sha256",
        "size": 1324
      }
    ],
    "refs": {
      "refs/heads/master": "264fe25d909fcde724187de13c296c7d0d7311a1"
    },
    "commits": [
      {
        "parents": [
          "072dcc184f69104f55e9c3191a70e3e216b4d513"
        ],
        "title": "Bump version to 0.2.1",
        "sha1": "264fe25d909fcde724187de13c296c7d0d7311a1"
      },
      {
        "parents": [
          "65f04a1b50d6fc6697f86276a804f4c82ee46fe2"
        ],
        "title": "Add SendClose future",
        "sha1": "072dcc184f69104f55e9c3191a70e3e216b4d513"
      }
    ],
    "tags": [],
    "num_objects": 9,
    "object_ids": [
      "239647271bfe79408acd397c0d967b4ed4ec3afa",
      "ea84328130793b1ed0979d79729fc4613bcb529d",
      "6dbf62f9efbec648675724a9efcae6d6934bee12",
      "cbc8490dc851578135cd4de6d4bae3e3ec357f71",
      "62bbfa8a03c095e9bbf46b51989b1b0d6c68230b",
      "cd6fff54a5d7c8f942df231ad7df426730e73719",
      "9b8b5da807ba007c174c4d739558ffb8743119b3"
    ]
  },
  "signature": "g/gFVT050fvIYnKzAG2Hb4p7LVFhFIZa4PRhwr35/xC/VdEqr8gCrq1WIvILljF6pDIqi/t5GZ+aIaP1Ad51AQ==.sig.ed25519"
}

{
  "previous": "%TAjt8XkIo0pBXJv+ENLihYQrrEuyqhuzuMjmFaNfeEo=.sha256",
  "sequence": 657,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520701035198,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%gyBRZn7ZxZ7oE6h2eYN/ZpX/L27uwjkwd7JPMIKPf9Q=.sha256"
    ],
    "packs": [
      {
        "link": "&i5rnRWtiGSYJQWdxeB/q6B9VNaBxsscJPkksYKFtExU=.sha256",
        "size": 18283
      }
    ],
    "indexes": [
      {
        "link": "&d9d5O3CA9/9EyXpzni4KYZv1an0PL8l75jf08VI3pmk=.sha256",
        "size": 1408
      }
    ],
    "refs": {
      "refs/heads/master": "54ffb9a47b32b9f37c71a49aeefb42339eff13fd"
    },
    "commits": [
      {
        "parents": [
          "589ad27eeeb71c47757ea2abc5e4dac668beeecb"
        ],
        "title": "Bump version to 0.6.0",
        "sha1": "54ffb9a47b32b9f37c71a49aeefb42339eff13fd"
      },
      {
        "parents": [
          "226e1235a2c6bc6fc70d293035386ccf05b0d360"
        ],
        "title": "Update to futures 0.2.0",
        "sha1": "589ad27eeeb71c47757ea2abc5e4dac668beeecb"
      },
      {
        "parents": [
          "015b3eff7193f8cec802ced8b82b5190fc78aa8d"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "226e1235a2c6bc6fc70d293035386ccf05b0d360"
      }
    ],
    "tags": [],
    "num_objects": 12,
    "object_ids": [
      "c84c484e5dae2d8fc86045227d0e768b2a8b8857",
      "f5a997d95c281bac6f4ec92a3ec905e1c5960ed2",
      "82023f8e20ba1d50ce9f9589099b286d4620b73a",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "3ddf9231a11fc69dea0f8c9e6b77d599c3b2d333",
      "fa0795dc6c698cff29892a59dc1844a6f9e07775",
      "21c98b2217b9740b62cbadd503f37a2ef5ee6795",
      "7bbce4a5d487668f3f17fb284b4b61ac4b4b3244",
      "9f35b0fabfacd2f5df55cee59817fe317d8a50e2"
    ]
  },
  "signature": "ew9kElqiYxHmb1P1cT4x8ILmF8viuhIbOEl4x84J20pmtjXRHmJrykPr0DZF7IhtDH7qQjHixTUJBE2c4OKWCg==.sig.ed25519"
}

{
  "previous": "%/0TJQsalQsfRW29dNzSpQmXfNzdM3PIVWWvWYpRPUjY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 658,
  "timestamp": 1520701224414,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%r+fF2yd0tKUyhgOD/+lGb3Ko/yrLyox7nuwQQIZpCo4=.sha256",
    "branch": "%r+fF2yd0tKUyhgOD/+lGb3Ko/yrLyox7nuwQQIZpCo4=.sha256",
    "reply": {
      "%r+fF2yd0tKUyhgOD/+lGb3Ko/yrLyox7nuwQQIZpCo4=.sha256": "@Yzh747g/jUGxXLPVb14oCPtvCu7Vzw9t1IWtOhQyDpk=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "No native clients yet, but the rust modules are close to reaching the point where clients in rust become feasible. If you are interested, there's going to be a [call on Monday](%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256) where I give an introduction to the code base and how to use it.",
    "mentions": [
      {
        "link": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
        "name": "call on Monday"
      }
    ]
  },
  "signature": "3ZfK0six3OI2xpu2MQDv4g+NzsUngmJnQ3RxMikAVly4xaZUutHMnwbJKUvMdb9JCkCJNdu2vaUEuqMtsPmRAg==.sig.ed25519"
}

{
  "previous": "%2HiHbPuW+TgjKEjEZHyK9KEHvk6bdZO9Kweg7ct3NoU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 659,
  "timestamp": 1520702172197,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
    "branch": "%eQRcl8ZCj5qpQjxOfGfAbzBLxnxKXKoYm5kVLnBO8vs=.sha256",
    "reply": {
      "%eQRcl8ZCj5qpQjxOfGfAbzBLxnxKXKoYm5kVLnBO8vs=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) \n\nRegarding the skill level, I don't think you need to know a lot about rust in specific to follow along. The code makes heavy use of both parametric polymorphism (aka generics) and ad-hoc polymorphism (aka traits aka interfaces aka type classes) though. Some experience with somewhat expressive type systems will certainly be helpful in following along.\n\nThere's no demo repo yet, the API is not stable enough for this to make sense (I spent the whole day frantically upgrading to a newer version of the library for asynchronous programming. This will completely break the API, so I hope to be able to finish this before the call).\n\nAs for audio, screen sharing and recording: I'll use my laptop for the coding, but I can't use it for the call. So I'm going to run mumble on my housemate's (is that really the English word?) computer (Windows...) and use her headset. So I'll be happy if nothing breaks during the call, but I certainly won't be able to record it.\n\nI'm not opposed to it being recorded in principle though. So if someone with more experience and a less horrible hardware setup could record it, that would be great. [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519), didn't you already record a community call?\n\nDoes anyone have recommendations for broadcasting my screen (I'm using archlinux)?\n\nAnd also, how does the mumble setup work? Cel didn't react to my mentions. Does the server just run and we can connect to it, or is there some special setup?",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "uriIdsKYKrBhNiGdKsFO3zM5l1y6tL/9mqjGx0Uj2F6zdTXtXTDi+nSjfQFhDTkf1WHjPgv03+N/+NBECiDODg==.sig.ed25519"
}

{
  "previous": "%a24a5QGOwHJ/Osf9CVg1OMuMRYReeMZKLB52qTFs4gk=.sha256",
  "sequence": 660,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520710339090,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%/0TJQsalQsfRW29dNzSpQmXfNzdM3PIVWWvWYpRPUjY=.sha256"
    ],
    "packs": [
      {
        "link": "&TSre+ZMFUVn/g1IHHMUB8CDLiMwmDw4Fd42qoCfeFtk=.sha256",
        "size": 5843
      }
    ],
    "indexes": [
      {
        "link": "&JdZZaX16DEpJ7HlOelvHIKgbUodlZ2N7DW3RRQk6xi8=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "675fae0c77ee30a39792997e7c393e6ff74c9631"
    },
    "commits": [
      {
        "parents": [
          "54ffb9a47b32b9f37c71a49aeefb42339eff13fd"
        ],
        "title": "Remove futures_executor dependency",
        "sha1": "675fae0c77ee30a39792997e7c393e6ff74c9631"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "29965e3f60c900a38f8d90d91c8d4ed0a1cbc727",
      "a61951ecf20529c971aa082e0d3941bbcfb3b490",
      "f30ce3c49145ad41bc93cd94d4abe0ea0742b64a",
      "38f40b5466c9a0b484c50a251778b75a643b2ce5"
    ]
  },
  "signature": "GEAHFmuc5OoHclpleJJOeMVI9EJN1OxLT0zYeDjd4povQYNurvrQAykHk1GSgwP7IT4WOYwyFN4qQOCUhKY8CA==.sig.ed25519"
}

{
  "previous": "%GpcsxBMTBi/x/aPw9BRQ1jqjIMJ3hoCtwGcPuiz4mw0=.sha256",
  "sequence": 661,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520711185040,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%7uBN8kaUcuoJys7PtamDqda7WONrbnTvIF8rjlX8Hsk=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%GpcsxBMTBi/x/aPw9BRQ1jqjIMJ3hoCtwGcPuiz4mw0=.sha256"
    ],
    "packs": [
      {
        "link": "&lt3BNx3yW1x7CHZFCYMV6kmtYCLhxaT8gDFSLIFy1cg=.sha256",
        "size": 6055
      }
    ],
    "indexes": [
      {
        "link": "&BapC0elHC/3Zik5VW7eWMvLTj53cDoGhtSWjuKdoG5M=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "9e0c4d1aace61fbbf6badfb1c64b776ba86dfa3c"
    },
    "commits": [
      {
        "parents": [
          "12fd4f8fe348608835a7332d543550c05637e861"
        ],
        "title": "Bump version to 0.7.0",
        "sha1": "9e0c4d1aace61fbbf6badfb1c64b776ba86dfa3c"
      },
      {
        "parents": [
          "675fae0c77ee30a39792997e7c393e6ff74c9631"
        ],
        "title": "Rename peer stuff",
        "sha1": "12fd4f8fe348608835a7332d543550c05637e861"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "05eb8bf0fe15f009f88a6b14f226eac86a609639",
      "7a17cbc3347abab84bf282134be3901ee8024594",
      "90787233be8eae93db538b20a52d41a5f85f7ec1",
      "ee3ab4264abbb5f285f577e68784ec37739191d2",
      "903d432eb0b480b015cb5319bd585ca094ab6b92"
    ]
  },
  "signature": "RV+8GJv4gKoS2nZVuEDEzAaYb8eoXZ3MTRsBXXCMWdLKfPdeg7D5vkvu/zkLBJqpbThQTryoWyLUXk9haawgAw==.sig.ed25519"
}

{
  "previous": "%qwldqfqlo5Ey3FYGrO4IEX54U88uds58R6j+tpcqnMY=.sha256",
  "sequence": 662,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520757689395,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%HnJq2Jquqx+JkMzV8+twITfW/IMMmg4eKF3iHI/vHD4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%GTGeGap8Qs/Um5ndadmurrzFwLoAaRVOzjlvVp4xzZ0=.sha256"
    ],
    "packs": [
      {
        "link": "&gXrNb3j/g3AZhXThWH2HiCxj/R0qzbOGHIzsXq6VU54=.sha256",
        "size": 21853
      }
    ],
    "indexes": [
      {
        "link": "&A1nPMUqAfBbXYV7vSzfDdJC0RRxUusSoooTYZyYK1Jw=.sha256",
        "size": 1548
      }
    ],
    "refs": {
      "refs/heads/master": "041cfb8c3dfda37fd1076edcc4388157532d1f18"
    },
    "commits": [
      {
        "parents": [
          "7c21dccab36e233e79bfba0d24d6cad4bd9fb8f7"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "041cfb8c3dfda37fd1076edcc4388157532d1f18"
      },
      {
        "parents": [
          "5d5bd16067c592c8baca1c45e62ba6f42add2728"
        ],
        "title": "Update to futures 0.2.0",
        "sha1": "7c21dccab36e233e79bfba0d24d6cad4bd9fb8f7"
      },
      {
        "parents": [
          "62dfcdea98ebe35679db379063d20d7cb231b71d"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "5d5bd16067c592c8baca1c45e62ba6f42add2728"
      }
    ],
    "tags": [],
    "num_objects": 17,
    "object_ids": [
      "967ae10b7e4684a72e2a809f63c0c8d28089716e",
      "5a24f08e07562d146407057080d2087d42488250",
      "b35621f3dc98d0699bf43a4377af4a9d8fd51a55",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "4f554bf2cf2487f264c8ae8ef0aaf13261abb563",
      "30bd4b863dfdbf708831b0bff43c1999d4fb6b6d",
      "4a0d731f9e06595b3289c53663af37763713fc6c",
      "61a4989ae13f7c6f88df5ab5ac1dfdf49997a0b2",
      "552a7005aef802533691c2c16d325b608a8282fe",
      "4d1cd31c95738b8b14d0baa001d3b66dd83c70a3",
      "6f43a089d444ca021a58fe40a28f342d5400314c",
      "50dccc7158b75eeb6016e5aa7c6625e14d73d307",
      "54df0a94179213fa9a2a690a4787826a769df7d5",
      "99be671cf695e27aef515127b72231a8c2ba8215"
    ]
  },
  "signature": "Zic3REGxe7fnt+kqD3Z/PS/+HZf5YamqtsZvtMc9rDDb193GlZqpp4KuDAtsD9opTnRi/4vqZFJy+Bh4NnymDw==.sig.ed25519"
}

{
  "previous": "%syAAfttziPKDXANiCxHPPXvPP8emZTkc99CHlBbU/8Y=.sha256",
  "sequence": 663,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520772314974,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%882mlNGVBaUtg4E0WgRBoss1XicF4VJn6gHNvvzR1Ts=.sha256"
    ],
    "packs": [
      {
        "link": "&CAuf9Lowz2IWJI38or2fOtZPZHmjpHqbVgXXcM7E560=.sha256",
        "size": 14824
      }
    ],
    "indexes": [
      {
        "link": "&wQ0q1WxtnBuiG2ql3EMQep+WYAL7pq9T44P4ZTn439s=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "81bff2fbda16a14030ad201d97ebbe998088f5af"
    },
    "commits": [
      {
        "parents": [
          "888aba340e3099464bd1481e4be328a0a2a88f0d"
        ],
        "title": "Bump version to 0.2.5",
        "sha1": "81bff2fbda16a14030ad201d97ebbe998088f5af"
      },
      {
        "parents": [
          "7c74d14d315286787218be6ec0faa01efcba2f11"
        ],
        "title": "Add partial implementation of messages",
        "sha1": "888aba340e3099464bd1481e4be328a0a2a88f0d"
      },
      {
        "parents": [
          "40fe8d851e90faddd86ad00bcc5fcb0816f8831d"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "7c74d14d315286787218be6ec0faa01efcba2f11"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "2cc5f42e9956eaee2386ef1a69e5ebbb329f782f",
      "39267bc8f51010bf2829618e90d45d744bd93360",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "48564a75ad36a70f5538f3e3f69c309eb6882ef8",
      "2ddd0fa1a10d4ecf5dd08e2535767befa1bdb7c0",
      "3398f098cc948c0b4cd95e70b4ae6c1d619e0041",
      "ea0a5e924ba388bf1a0cb9ab2c72d71f1d64cbe8",
      "df9c08b6262ea8e3e7081e3eb8dd104d0ebaa94a",
      "c9fa5f8b3cd7d3486d93f4b141798bb5cc470513",
      "fe14f82346ca312001bddbbcb495d053e035999d"
    ]
  },
  "signature": "NjIypGi03l7nn7sLtSZiLqIfTeOy7a7/l+I+Z3JoozLq9rVdFBOvC8h0B1xs8rVoJNoH1cbsBuGKbVkQKwKPDw==.sig.ed25519"
}

{
  "previous": "%lNUZycdfNa8Ctf8X/ZXh29JBm/Q+vfvV+dct0Ipb0JY=.sha256",
  "sequence": 664,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520781458293,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%lNUZycdfNa8Ctf8X/ZXh29JBm/Q+vfvV+dct0Ipb0JY=.sha256"
    ],
    "packs": [
      {
        "link": "&ELVHJES0U/gt4vWLKeNoLPH6fErZfnGXH7iLjcHHtps=.sha256",
        "size": 2930
      }
    ],
    "indexes": [
      {
        "link": "&NnmD3O1W+EFH/yC782sSNMs11ldBSemNTh3wwyloEQQ=.sha256",
        "size": 1324
      }
    ],
    "refs": {
      "refs/heads/master": "d41d3dab79790cfa0b62abb48dfc02718c318408"
    },
    "commits": [
      {
        "parents": [
          "f5dca9a6d87de60e8dc3352575a088343d9ea6b2"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "d41d3dab79790cfa0b62abb48dfc02718c318408"
      },
      {
        "parents": [
          "81bff2fbda16a14030ad201d97ebbe998088f5af"
        ],
        "title": "Use opaque types for sequence numbers and timestamps",
        "sha1": "f5dca9a6d87de60e8dc3352575a088343d9ea6b2"
      }
    ],
    "tags": [],
    "num_objects": 9,
    "object_ids": [
      "c04b8693b6f5134ad009ffc68d76d20ad670fcb4",
      "cf09f78f3a15464f71ec82f31e7d767aa61b7edc",
      "aa49014f269e100aa117dcae961b2bbcee125313",
      "2d21af8eec15a1e9331a417bf3683aa19619e56f",
      "3df4a33b4b1b4eba9021265a23b525256349bf25",
      "ff04f1513d5b34832ac98d037deded0ef7b445e5",
      "5a609c6a51873793678e9632e2b0ed3ddf3a53f7"
    ]
  },
  "signature": "GwZN+jEJdgEeIHuBdLjBpcmgJnMNWu1ES/wt5wyP7gv1De/aIyVH8m4hgUT2O4lZVbn4xW0hXXdE2tG4yonnDg==.sig.ed25519"
}

{
  "previous": "%xJuaUxomv/WLZY7wLgOJaXCqkQxeO0rdEGDOXRHEgBQ=.sha256",
  "sequence": 665,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520781914257,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%IkMPbmQ/ZvwK6J5eARHLLPoD5weTuTj2lInkpEYKfew=.sha256"
    ],
    "packs": [
      {
        "link": "&ZQpx3qRYVqDRhFl0upRWqihAx+UHvzZZcH4XwW1ntRw=.sha256",
        "size": 15596
      }
    ],
    "indexes": [
      {
        "link": "&8rFmRsXmUWusRJyXTQvjCTomhu1rpEw6JUqdDroiAKg=.sha256",
        "size": 1548
      }
    ],
    "refs": {
      "refs/heads/master": "86c90bfca7ce3ddeaa46fb141ccd04cbe5568fd4"
    },
    "commits": [
      {
        "parents": [
          "7d33be95d0092bfa4ebfd83f45ffa2ae1d453bf2"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "86c90bfca7ce3ddeaa46fb141ccd04cbe5568fd4"
      },
      {
        "parents": [
          "f472aed8cac3b7ac9c82c72bf3f0b79fb258f31c"
        ],
        "title": "Fix WhoamiResponse FeedId getter",
        "sha1": "7d33be95d0092bfa4ebfd83f45ffa2ae1d453bf2"
      },
      {
        "parents": [
          "dacc4dcedc6efc0e8b8dfcde5c0f8c5211ce034f"
        ],
        "title": "Add Latest rpc",
        "sha1": "f472aed8cac3b7ac9c82c72bf3f0b79fb258f31c"
      },
      {
        "parents": [
          "ef0b3969c85e744481f9a4bb66f6467a859d4dc7"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "dacc4dcedc6efc0e8b8dfcde5c0f8c5211ce034f"
      }
    ],
    "tags": [],
    "num_objects": 17,
    "object_ids": [
      "b597e89b5f69b63a6860efa4bb80f74e34b7e80a",
      "87b0259c5d2550939b4c3f589efc4afc58cd027b",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "0071428a12db7324a3751350ab16e2e3cf278e2a",
      "a26b0615be33134e94dcac8eeffb9ec2631f57b4",
      "ce906d9e846e960ed7e23895bfde405ba96a8115",
      "5ebb3171db02408108e0d9958f28d935e76a868d",
      "a3db3117b67b81f68ea47ed6b872aaf5a3d73428",
      "104bf8c7c895fe6676c2bbf69e444a8f0ccb4f0e",
      "4264ae49f190f13b17066ca8e8d68ee9f73d4dcf",
      "30a7e4fe66b0a7035ef2d7f3893ac894e32f8c02",
      "e6c68a1144e34eeb62cd7037f39e150d8dcbef48",
      "653e06e702a0f288265065f87dd1263abce9fbe3"
    ]
  },
  "signature": "jnnRSved2438t2rKQNy76F7ZqIOn9W2AAUBCo7Qnh12dhgIG/1z9PUirbq8Ae8Hoa9NdHYpTfmR3FSBLzFNnCw==.sig.ed25519"
}

{
  "previous": "%zW1GTrKNRUYmxyoc8E0yziiAUeQIdLLsH/wyHP/onqM=.sha256",
  "sequence": 666,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520781978993,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%zW1GTrKNRUYmxyoc8E0yziiAUeQIdLLsH/wyHP/onqM=.sha256"
    ],
    "packs": [
      {
        "link": "&2ImZ59MDOmAuIGpghkxAZAUBwEjwe1NofbYU6MMG3CQ=.sha256",
        "size": 747
      }
    ],
    "indexes": [
      {
        "link": "&onOCi8X46s4BAp5vcuSr5P79F3bJtKToiNoo/Guvn8c=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "cb580698b014de0610134b98b283c7c5d6e78aff"
    },
    "commits": [
      {
        "parents": [
          "86c90bfca7ce3ddeaa46fb141ccd04cbe5568fd4"
        ],
        "title": "Update to ssb-common 0.3.0",
        "sha1": "cb580698b014de0610134b98b283c7c5d6e78aff"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "60f869399f0058c21a5315ee4e7c1679c64ce2bb",
      "5659cd62902e984b84a98f13bdff4b7b4b94f5d7"
    ]
  },
  "signature": "A9TLrD9HJVIjk9GpFH+QPEB4uIMLUy3vKliFqq+/+ZLvnxfpyBhJjbOM9UHBIZ5KiJvs/nPoLfr4MYh3bEJ/Cg==.sig.ed25519"
}

{
  "previous": "%vRfIRLiWuT5KPIoC6oS7lbjNQur33nAVQnraY1ZLhnc=.sha256",
  "sequence": 667,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520797015368,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%vRfIRLiWuT5KPIoC6oS7lbjNQur33nAVQnraY1ZLhnc=.sha256"
    ],
    "packs": [
      {
        "link": "&CTWO6V5+77DbDG+yX/SZcysl/FWKQRwFycNVEoKqC1E=.sha256",
        "size": 2297
      }
    ],
    "indexes": [
      {
        "link": "&q27X2mWACuIniCUF98J9xiLWj54BVdrgfcHeB9Ju44s=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "6c87656f45c9f8a10d279d5928f15961653a2071"
    },
    "commits": [
      {
        "parents": [
          "1276e42a2743ff4478adcece1586f000695b4743"
        ],
        "title": "Bump version to 0.3.1",
        "sha1": "6c87656f45c9f8a10d279d5928f15961653a2071"
      },
      {
        "parents": [
          "cb580698b014de0610134b98b283c7c5d6e78aff"
        ],
        "title": "Reorganize code and add Get rpc",
        "sha1": "1276e42a2743ff4478adcece1586f000695b4743"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "6cf42fdee2ca55b38194d309f48db98491e1299e",
      "b9fb74a8e47fd70c3bfeeacd0392049dcc2a27e4",
      "577bcd8554a2652e80a55c820176bf2c11398e8a",
      "ac9fdc7a7b8803d70bd43375a6d8cf94f90f41ee",
      "e34af285be6967ce7339460ee4ac4bdd6b658cdc"
    ]
  },
  "signature": "J3IpkH8DB6m9evqzw7AMKGwpewg4706mx+CkUdxCW3sFAVsHV9F/55YHT0WTvn6q9YiG/rL3Gx8pYqxjEBv4Bg==.sig.ed25519"
}

{
  "previous": "%AZhgNTeS6RsK+KqCTCKxOe10n8SBYhzhWkXTue0eJ3M=.sha256",
  "sequence": 668,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520797066683,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%pxGWLArs+Z8HEySSbJH6IkPPIZCuoQ1m0vKEUt0Zb+U=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%AZhgNTeS6RsK+KqCTCKxOe10n8SBYhzhWkXTue0eJ3M=.sha256"
    ],
    "packs": [
      {
        "link": "&kfmxi/HHx9BNH7lMmam15JxzBv0InS0L0Pcw5DqCBq8=.sha256",
        "size": 2278
      }
    ],
    "indexes": [
      {
        "link": "&SEE09CD/K6KZ43ghYKCgeBb5WYDn0sKYVXZ/tBAR1TM=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "d08da0ad20c59cb373a196920785d011d0e01fb1"
    },
    "commits": [
      {
        "parents": [
          "6c87656f45c9f8a10d279d5928f15961653a2071"
        ],
        "title": "Fix git derp",
        "sha1": "d08da0ad20c59cb373a196920785d011d0e01fb1"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "fc339eb29ad946a56685b4168128cd5f85f4f03d",
      "62a641b5766ed3d1445ef9d43a82d498081b75b2",
      "12d10388fa0ef889906889acaa75ecc33e35d591",
      "41b71ce438fd3292deb097bcb7aba831f2ad77b1",
      "f7a9e02de4ddb9561654b90c22a85af377d730dc",
      "c12ceb4ad27d46bd385adf6cb70d851688fdac61",
      "9418669e74a88100761e82836c0db7ac191d6719"
    ]
  },
  "signature": "Iv8zkTcwdnITZJNa34oPyqRH48xfMRVU8b91wm+docQRITJbrY9odAZPjofFCCGMSNChhRfOszbtbyiL2IvnCg==.sig.ed25519"
}

{
  "previous": "%g2b3m9jIiUnuZaCx5MTUvOfchKAhqrldXrW1bFlPDtU=.sha256",
  "sequence": 669,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520800310015,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%fmroeBlO4J/ujUjWS3p+L4UuJyOmS/kM48H3eTOg600=.sha256"
    ],
    "packs": [
      {
        "link": "&w+ZAUbc7ePcuz7DPZg+b5604+/Z6bTiCYP+CDUCrUNI=.sha256",
        "size": 17000
      }
    ],
    "indexes": [
      {
        "link": "&tK7ZaIlr/qtWQRnYSO4baSxTZP7ae+uwIxVVEUu2EXo=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "0248bda7e12d28612237f5dddad96208192d067c"
    },
    "commits": [
      {
        "parents": [
          "d622ef8059bc5f901828bf156c64875f9c170305"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "0248bda7e12d28612237f5dddad96208192d067c"
      },
      {
        "parents": [
          "9ef2c4209dcd162dc64689cfaf6b3b6af7a9c711"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "d622ef8059bc5f901828bf156c64875f9c170305"
      },
      {
        "parents": [
          "62333634d933d49cecedcd4f534a5920e0430c47"
        ],
        "title": "Break whoami response and add Get request",
        "sha1": "9ef2c4209dcd162dc64689cfaf6b3b6af7a9c711"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "1409c4745667521d4b7963b5863bf9722e8a7428",
      "b59b086f8a2f3b1457c13a85fdac3303dab665e4",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "7b461b66f5e5bf6398ba0b43c6cd82be9ac1873e",
      "4f752502f44197373e610f7a7434b3164ea3ba7b",
      "a3acc15ed8382c93d0c79ea0fcf36cd22fda7773",
      "55a0fd3d4ff47f225bf6739a18edaa6e409d48d9",
      "1cdac75778a4f0a5285166b25d93285f7221970a",
      "6fe97168d8022744f1505538a54412e3b70987bb",
      "6edbeee719df29adffafc06a4d3051971904dddd"
    ]
  },
  "signature": "SEW3JyW/244jj3EMZJrm/2YRABvM+KbNRLQInbiS3ePnBZPLMl4ZkuMaSO/bXxvybFBBDuHpRYguEKaFQX+zCw==.sig.ed25519"
}

{
  "previous": "%VIhDNnfa6WPwvhCYhREeeC+HetWmNAdUruT9h6HMIFA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 670,
  "timestamp": 1520800920950,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
    "branch": [
      "%bH3TDg50fQZvNKoE46RDLz+H0eps0Totexy91gtyI5Y=.sha256",
      "%lu8LIcDBVw0/W0ON2itfYylf2TIIYGIgyPDCaYn2O9c=.sha256"
    ],
    "reply": {
      "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Ok, we'll use the mumble server at `west.celehner.com`, and talky.io for screen sharing. I'll post the talky link here when we start. Let's hope it doesn't randomly break.",
    "mentions": []
  },
  "signature": "06kMj3L6Rv43M/TP3iTHsBTxwZWMgoOtFzXHmmbg7+lVN+iwqm2+0cJFuVPSUnLT1gOP+ltX4O4966jGZe17AA==.sig.ed25519"
}

{
  "previous": "%lZWH+uFtxNLaX7oL0frJC946gaJlegFzr61NsBli4og=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 671,
  "timestamp": 1520844858308,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
    "branch": "%eCgQpiUCw0AFu56pyarsLhHujmc4qmdCDX7IICN1h/U=.sha256",
    "reply": {
      "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Here's the [screen sharing](https://talky.io/ssb-rust-introduction).\n\nI'm connected to the mumble server (`west.celehner.com`, port 64738), but having trouble getting audio to work. Let's hope I can fix this quickly.",
    "mentions": []
  },
  "signature": "+rl/mlupABYnO6I/Vll4rsyd7ywPqfQn3telVROerolzTKT4NwTkL/GXkAo58a314ktdsHnZxzYSMIj0ablbDw==.sig.ed25519"
}

{
  "previous": "%tMRuus4xaiMbs+tAPqnmhH+CQTewcme4sX2RmMyIC4g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 672,
  "timestamp": 1520852249097,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
    "branch": "%tMRuus4xaiMbs+tAPqnmhH+CQTewcme4sX2RmMyIC4g=.sha256",
    "reply": {
      "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I couldn't get the microphone to work, so I explained everything in text. Here's the full chat log: [mumblelog.txt](&bomxNV1C41YtLt5hSUMxPJ0tiAnImxc0wf+jRm8mixc=.sha256) ",
    "mentions": [
      {
        "link": "&bomxNV1C41YtLt5hSUMxPJ0tiAnImxc0wf+jRm8mixc=.sha256",
        "name": "mumblelog.txt",
        "type": "text/plain",
        "size": 28417
      }
    ]
  },
  "signature": "t1Su+Vb5DOz5/IAnrPlOnyBBVvUwn7at4jKHZYrDg4//bjkRpKO5dnH9BcjWVB+Qmdq6OvPdE7RV+X3VF2WeDw==.sig.ed25519"
}

{
  "previous": "%8E2ROYZzE4EeqDpLc0CejJGzAOqNmFJQsUdd4vYRGZc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 673,
  "timestamp": 1520860947294,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%Jdj3WCKuPGwtSrIiyjVYesx9/WPBYFbXjukHqMnZ7PU=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "x+Fj4WobGnGuhwTdK3WBcbJuMwi/z7FmAIQ9W+ZhBk0KIFZHzyMW0AjvAI1y40wKiYGxcZp1yEieqKbWjXPvAw==.sig.ed25519"
}

{
  "previous": "%bFVs4tIq1Q9DSEBW4QYeRc3f8qxI7quW2FftF7VQBFo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 674,
  "timestamp": 1520861145766,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
    "following": true
  },
  "signature": "jGI+qpr7rYZaAuG/i7TpEZo6co9iDFNtPJifC23MojJN7Exh2J0DuXbGwVp0PayszuyaZF3GlFBaJ1mfgJYMDQ==.sig.ed25519"
}

{
  "previous": "%jt17mqKULtst+rdPhPi8cdl0t4+2jWBmEyXYvtGES4o=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 675,
  "timestamp": 1520862592986,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "go-ssb",
    "subscribed": true
  },
  "signature": "GHbpNns9V1CXAhCj/kH/NVJyU+yIV/uePzmbDDlnqqgyKn6XtbuCZz4jWI+8bX6uMMnsHiZDOZrFAcyewRY8Bw==.sig.ed25519"
}

{
  "previous": "%mg+a3cqf7qu3SNLsVhGbzdFYGwDjhdFuuD9SPhbypPI=.sha256",
  "sequence": 676,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520873075324,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%VIhDNnfa6WPwvhCYhREeeC+HetWmNAdUruT9h6HMIFA=.sha256"
    ],
    "packs": [
      {
        "link": "&vC6Lp6mEAi9fFKI27jwjsaNyEJXBXGW5YQDennWdYZc=.sha256",
        "size": 1095
      }
    ],
    "indexes": [
      {
        "link": "&uoz5ruGV4qf3lH8cn7ZYqW/q4YxcdXomk2aesw/nDlo=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "88602eea67fb3e7eb05b60a3bc7f48c16f90e2b8"
    },
    "commits": [
      {
        "parents": [
          "0248bda7e12d28612237f5dddad96208192d067c"
        ],
        "title": "Fix get to correctly return messages",
        "sha1": "88602eea67fb3e7eb05b60a3bc7f48c16f90e2b8"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "a79e8a49b185ef5d1721b3a65057d2cbb278b94d",
      "6a8df1f51016a363efa824fa0cacc006f3fd2882",
      "b443e287386beb78bd41654111d7e3a3735b50bd"
    ]
  },
  "signature": "R8F/Ev2ykMp5W2jHFCJdA+uTEgHFy88geXiR/04RdCa1sBgun026qhuRhOF0kgBMiiGoipheoTn/7Yms6IwbDA==.sig.ed25519"
}

{
  "previous": "%OjeZJOev7P1kTVuJ4T6ii4v9tdoaq636DUapB6BA78A=.sha256",
  "sequence": 677,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520873368859,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%iGtSxT4becIQW5QkVqDDTm6mzpWTCX9Y6CizMxJk76E=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%OjeZJOev7P1kTVuJ4T6ii4v9tdoaq636DUapB6BA78A=.sha256"
    ],
    "packs": [
      {
        "link": "&JdqGb/4qIGT4d97ayexoF64uOg9YLs1uA80L2o4bS+8=.sha256",
        "size": 767
      }
    ],
    "indexes": [
      {
        "link": "&AybAlEvaddQec/3Jw2pfAkl0XOMk99Jb7+1qkem8NbI=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "dae2252a70e6c0ae2266f789dc072f59746721e7"
    },
    "commits": [
      {
        "parents": [
          "88602eea67fb3e7eb05b60a3bc7f48c16f90e2b8"
        ],
        "title": "Bump version to 0.3.1",
        "sha1": "dae2252a70e6c0ae2266f789dc072f59746721e7"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "6d87832ef1961c3fa3c0f0e21d7c913a742cb7a9",
      "a9cc8e8c1ef29266332052c9505b0888f40eb21a"
    ]
  },
  "signature": "oDt0XyG3Ti8W108i3G9GHMiCEgtANQxTI/3RORb8M3bbUgCPJtAR8sCIrL7vxR4PKLzw3mSdy8C1Ecbjda6NCA==.sig.ed25519"
}

{
  "previous": "%p71geWPF2XkqqY5R/MU4k5wALW55yOEc9PEp9HaPrms=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 678,
  "timestamp": 1520873679774,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256",
    "branch": [
      "%8E2ROYZzE4EeqDpLc0CejJGzAOqNmFJQsUdd4vYRGZc=.sha256",
      "%FobJZt4d1Pmquv+W6cfti32Ifcgx7+HsOobn6Tvt5Lc=.sha256"
    ],
    "reply": {
      "%EjlbdkKdtE2m6bmcAoHY0CDfOH8cQhZ58i/OaTkmnTM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[Here is](https://gist.github.com/AljoschaMeyer/7d0589dbf9fd1f6e9d5955f5fe84d708) a working example of using static typing for messages. Note that ssb-client-rs need to use version 0.3.1 or newer (the previous examples use 0.3.0).\n\nAt lines 40 and 41 there are comments describing how the struct can be changed and how it changes the behavior of the program. This alone is already a good reason for using rust. The performance gains are just a nice bonus.",
    "mentions": []
  },
  "signature": "FZQuDQPGYkONWifvCVI5woyvZ7V/Io2D4M1XBcBc/5nNstabXRDDIAC/2p4ssN1HpQfe5oVRg/W4PbSpLKopCQ==.sig.ed25519"
}

{
  "previous": "%YhQ3M/F0ohLk4mSZl/id5hMBBsB1LbyTSOVXRUjstq4=.sha256",
  "sequence": 679,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520880959138,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "bpmux"
  },
  "signature": "REYFLtbufr8xOiR1hEgYS5TKcXE6Lsf2r7j6hnqR/WZdxxpKLaZigJMBOk+7QH+wlkXMM20lCJD+VkU5JNgRDg==.sig.ed25519"
}

{
  "previous": "%uaUZsGvgLEc/EYPrHufpgm1Dccn+SYWkjNwOB+zzMwY=.sha256",
  "sequence": 680,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520880963391,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%uaUZsGvgLEc/EYPrHufpgm1Dccn+SYWkjNwOB+zzMwY=.sha256",
    "refsBranch": [
      "%uaUZsGvgLEc/EYPrHufpgm1Dccn+SYWkjNwOB+zzMwY=.sha256"
    ],
    "packs": [
      {
        "link": "&KxJLPBlsYoaqCRvyCxUGctzcQu21Elf3x0tI70qdogM=.sha256",
        "size": 1616
      }
    ],
    "indexes": [
      {
        "link": "&pn4vfWJI9KJHIcZrdU1Fe1MnuHousyHjBjfABJR9iuk=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "8cf934eba312ecd6f2d91e0f0921f2ea85c21530"
    },
    "commits": [
      {
        "parents": [],
        "title": "Initial information dump",
        "sha1": "8cf934eba312ecd6f2d91e0f0921f2ea85c21530"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "9a168ab2d1784e384ff757705ebe220ea247fa35",
      "58d54de1b8991e4db24f7d3c643a5b413594f5db"
    ]
  },
  "signature": "PW7DVrS5FxUJU/7UO4/IJgR8a4V5oiU1i9cv4gR/9RxCVq9XqtlRROqPIPXP5EvDt4LfN6uBQvqiL/NXeAxdDA==.sig.ed25519"
}

{
  "previous": "%0WgohnKYdEapuoMb4wSeYSlq0hqUAlGmxvdfsIcmr0g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 681,
  "timestamp": 1520886937197,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GIIo0J7KLebsOSYc54YyuZJmtxOYpleS6xpfrjPDjr0=.sha256",
    "branch": "%dj3YEL0VXGufmla2+Ho8DtYyopRrWP7IxhBeBxiKPfg=.sha256",
    "reply": {
      "%GIIo0J7KLebsOSYc54YyuZJmtxOYpleS6xpfrjPDjr0=.sha256": "@JIgHECRt/HZuCI22snwTjfzph8HRFAQueagp1azC8wg=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Yup. Distributing data is easy. Making distributed things communicate is hard, which is what ssb does for you. Put a git repo somewhere, and nobody will notice. Git-ssb will automatically share it with your friends, and you will automatically get update to their repos. And everything stays decentralized.",
    "mentions": []
  },
  "signature": "0BKKaBkmu8bvgJUgfuv5n1fmlC2xMlH6H0mynbAX2QUNxyZ4E3TUQXiv8UlVszdjG+kvo/F7vrsmhYR4NKwrCw==.sig.ed25519"
}

{
  "previous": "%nIWf5O3sGdPN8xZ6egdUWQI/DMjoGJ4hEI40H4YklsI=.sha256",
  "sequence": 682,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520891653904,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%+rLT78hjYLWqiV4sM+OIu29Nu0Kqh/zHSEYChKDO5x0=.sha256"
    ],
    "packs": [
      {
        "link": "&bwVSfN3fBJ8vT1H+3OPeijnWPdVyB01YpdMiRbl708M=.sha256",
        "size": 5942
      }
    ],
    "indexes": [
      {
        "link": "&jwazDg7jXOZdO87HA8D9kA4AlDULJ0qwlbzNkfRJ+sY=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "be42b35bc048d4c074ab9d3ee62bf1bc739d8a8b"
    },
    "commits": [
      {
        "parents": [
          "6e81726cc12bfa90bc17657b1a8dcfcbdd90ca19"
        ],
        "title": "Bump version to 0.5.0",
        "sha1": "be42b35bc048d4c074ab9d3ee62bf1bc739d8a8b"
      },
      {
        "parents": [
          "498b1eaa1b78aa550f4cfb04bbdf76f7317db751"
        ],
        "title": "Create MPS trait, rename implementation",
        "sha1": "6e81726cc12bfa90bc17657b1a8dcfcbdd90ca19"
      },
      {
        "parents": [
          "91d409d7149694f7f46e9273c0372b7fc3ff92d9"
        ],
        "title": "Centralize error handling",
        "sha1": "498b1eaa1b78aa550f4cfb04bbdf76f7317db751"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "f992fd7aeb3d350d5f3272c95eb5a3f667089885",
      "334ce1e3077ab921c47e9ada6c74ce98b0e98500",
      "28bbe107a4427743849efd47e97c77acac472a65",
      "d87f688a40e3495a99460817b328318fc0af186d",
      "aa28071efdd75daad0f03b2826a98fababb84058",
      "313f7d636aa0ecb98c5395a68a5e9fd922d3cda8",
      "639bb9bc6ac054f871b4398797cfe6287a5ecfae",
      "b62b25f624428575452dc35151bd46fa551d3fdf",
      "8d4f4ca246a359165fdf59fd01cbebddf3ee0857",
      "b6999fe09e93dca73fb68c90a3ace0d763dac828"
    ]
  },
  "signature": "MpT/QLrcFF8+0tiL8LSb8DyhGfdCYBuGSq9jaJ+yv6qlKlYJcMzeAH2TcEfL45V5YxU1yOBRquSRNe9h6KpGCg==.sig.ed25519"
}

{
  "previous": "%S0A7wrCw6zEEN39qGpUtoobSQuw3TYt6PMNgHGL7OhM=.sha256",
  "sequence": 683,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520894484908,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%S0A7wrCw6zEEN39qGpUtoobSQuw3TYt6PMNgHGL7OhM=.sha256"
    ],
    "packs": [
      {
        "link": "&xoafxwGF6jBi3y37AqMu9/Vkw3k5vdxSAw2eFvjKHnE=.sha256",
        "size": 4218
      }
    ],
    "indexes": [
      {
        "link": "&U92S0VjU6IynQ+Kp8m8+sxPqg07hL6izAxJHM8YIMRY=.sha256",
        "size": 1324
      }
    ],
    "refs": {
      "refs/heads/master": "75fb135e5b6794b64db381c0dbfdb6a1df64a55d"
    },
    "commits": [
      {
        "parents": [
          "459ba6c214c8a40b504768d71de4ad6fed6e567a"
        ],
        "title": "Bump version to 0.5.1",
        "sha1": "75fb135e5b6794b64db381c0dbfdb6a1df64a55d"
      },
      {
        "parents": [
          "be42b35bc048d4c074ab9d3ee62bf1bc739d8a8b"
        ],
        "title": "Add threadsafe mps",
        "sha1": "459ba6c214c8a40b504768d71de4ad6fed6e567a"
      }
    ],
    "tags": [],
    "num_objects": 9,
    "object_ids": [
      "fa36bd48ed0c245a6a768ccc1fd5ab1090156d64",
      "0b064a9f9ac408cf11cd0d8756c344b927bf2c8c",
      "296e5fa106d9ee9bb8b3072183767307ea5a3b0e",
      "06df248ce0e9f3bc4d252b074921a7b9c22eda27",
      "2937055ddddc44a0d3f84e6045c4dd213b69ec5b",
      "9bd72ff3560429cc48e720d1dc2b50a051d8a10c",
      "4692cd5521aed361fcf361d9c12a20edd6d0b343"
    ]
  },
  "signature": "Xsu/WkBCJAO2INb+ioCoXgrcHTRwEbiL0GUSomcsTwF2h7aE+B6peIUUsfniXamzbHI0g6IG/zUWPHsPpdb8BA==.sig.ed25519"
}

{
  "previous": "%EMkPdJpnmm3rCTTtouN6eMaEdpwvw9W8PkJ+2NeAkbI=.sha256",
  "sequence": 684,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520931065878,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%MgbdvzAbJzQ3Cyesk8aZ6KYj3TS8mu9p53oZ4krwIJY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%EMkPdJpnmm3rCTTtouN6eMaEdpwvw9W8PkJ+2NeAkbI=.sha256"
    ],
    "packs": [
      {
        "link": "&ZMZm5atPaDxVAdk7D0B/9q0bz3+lfisyQ/AWhX4gJ8E=.sha256",
        "size": 3169
      }
    ],
    "indexes": [
      {
        "link": "&jUgfggHxzaXgvhEjdnnnfU2EIldrDdlEn1goVqsjWZs=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "d840090335625356ed809f4ed85ed87951f147f4"
    },
    "commits": [
      {
        "parents": [
          "40400a3e2a6fe15669675ab9e74320304e0565f9"
        ],
        "title": "Bump version to 0.5.2",
        "sha1": "d840090335625356ed809f4ed85ed87951f147f4"
      },
      {
        "parents": [
          "75fb135e5b6794b64db381c0dbfdb6a1df64a55d"
        ],
        "title": "Remove unnecessary atomics",
        "sha1": "40400a3e2a6fe15669675ab9e74320304e0565f9"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "1f7bcf6aed986e64e959fd7f63df06e01e01773e",
      "78b18de0025309e8f1a142c1b5504e061c9a8958",
      "d03b702f37e7a0e4e5bd2ab9edcaa320fc0c285f",
      "738f69c914a273ad941d2c3d70554299060af524",
      "a9dbf3b14485c45bd014e50e841d77d7fae333e5"
    ]
  },
  "signature": "E3+ndlmUKlxjonPKifBUk0FicUaR04ROZpRBxdpNUhW//bAOhYkoQzV1w7j5CyOXLzRlH17pAgzGYghGI0TNAw==.sig.ed25519"
}

{
  "previous": "%fW1RDGk1kYpQjwAVqc8dgLiKs3g1+hQ68Kc5S81VcWA=.sha256",
  "sequence": 685,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520943598802,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "varu64-rs"
  },
  "signature": "HP6DYwoPj6YUbNbRN5SKSzM+tIkVrwnnsCz/IuDV6CuCqPZZYRHRI7AMOwFIlidt9iZssdHohvKD7M4VaQ+wAw==.sig.ed25519"
}

{
  "previous": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
  "sequence": 686,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520943602645,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
    "refsBranch": [
      "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256"
    ],
    "packs": [
      {
        "link": "&VIJoMykCqIJV3fS5IgRSUGGFfJPl5BAdLLXDqY9gk2E=.sha256",
        "size": 14046
      }
    ],
    "indexes": [
      {
        "link": "&rBXNSpnGfKUY7NkIOscw9loAgRGhX31fZsHfSG9Vt+o=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "396acdb54f3b84faad88e47cb5216e163c9fa417"
    },
    "commits": [
      {
        "parents": [],
        "title": "Sketch API",
        "sha1": "396acdb54f3b84faad88e47cb5216e163c9fa417"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "b9038912a217decf9eaa83872ae4387db478533f",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "2bdd4cbdb2a509d12ff27996fdb10fe6a2644bdc",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "6e34d3d4455dbf28a18eb095f7d656ff22aeaffa",
      "29384f306dd9c44f66d8c2e4f25aed827e506f4b",
      "3480cbeeeeb3cfca450edc242e27661ccebf889d"
    ]
  },
  "signature": "o55oaOV1hmUXXmblNtTAs/S+jhUc2eJhk0wQXfNJPb1hxmoMm6zjhV3jIWk2mjyUvBzI3M3dU8wKZ9VNqHvnCg==.sig.ed25519"
}

{
  "previous": "%D+XWjkILAwTSSsmtck/P4eqs2Cxt0el6uv9IKn3TXwc=.sha256",
  "sequence": 687,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520944026457,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "bpmux-codec-rs"
  },
  "signature": "fslCneWLx+tAs36Qrkhop3OiDzO/riRcLzI9VMEARdjk+4SxdrVCy95bF4YV9+dkS4jIp0iYhiwD83TnwItKCw==.sig.ed25519"
}

{
  "previous": "%G0pg6GdgWyD9D15YYuknBkV2+Cn/+GrZ12cB7JOiTMQ=.sha256",
  "sequence": 688,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520944031501,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%G0pg6GdgWyD9D15YYuknBkV2+Cn/+GrZ12cB7JOiTMQ=.sha256",
    "refsBranch": [
      "%G0pg6GdgWyD9D15YYuknBkV2+Cn/+GrZ12cB7JOiTMQ=.sha256"
    ],
    "packs": [
      {
        "link": "&r1o1obBBL2QnJtqz3IY/DphIw2dmKJ1Bi4XWsMuZnQ0=.sha256",
        "size": 12512
      }
    ],
    "indexes": [
      {
        "link": "&W32k+0XpBSDYswCWhoLub+QRm5tS3Mafw+ChdmCyzdg=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "19ecd0af972a3c74a5f5c126a9df0b07ed78e368"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "19ecd0af972a3c74a5f5c126a9df0b07ed78e368"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "9382e75c3928383f98cb7177b783f01462f4d888",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "f78cb363681a587138f93950ee057c19c542424a",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "764ee6fb1a0a5474e858f895c064d3d888770c9b",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "+xofWhiWnEQRfNoVfQj8NW5oX3o4hR3ifQOUP7GA1xvt6KvETfce2VRRDa4Xz2MfKK8QWpL58bD2PHFIQpWtAw==.sig.ed25519"
}

{
  "previous": "%ZuVEquFI492BFy7WBuL8C23Lp7nnlIS7ZOwMmiCqoY4=.sha256",
  "sequence": 689,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520949889847,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%D+XWjkILAwTSSsmtck/P4eqs2Cxt0el6uv9IKn3TXwc=.sha256"
    ],
    "packs": [
      {
        "link": "&9TOzWX0k3Y+vTfRaYaVPoVd1cMhDD4fghUqjrZZUhwU=.sha256",
        "size": 2542
      }
    ],
    "indexes": [
      {
        "link": "&+8ruZnwPlrjM2JZTxKneRduy16odPjHWHHjGPOGC4GE=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "0aaa5096758aa18dd94b4961aa80008c406d395f"
    },
    "commits": [
      {
        "parents": [
          "396acdb54f3b84faad88e47cb5216e163c9fa417"
        ],
        "title": "Implement decode_bytes",
        "sha1": "0aaa5096758aa18dd94b4961aa80008c406d395f"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "f4ba834aa5c8ed9adde121e7f1d3d77a0dc31f92",
      "52d33cb8d1a1d69a7bb0f4c9bcb27735e05fe211",
      "d56144b454810777545d896a40b8d14d3e6f4a3a"
    ]
  },
  "signature": "D/BFTMWwXUm0V/Wy1u08nlBDIlRFAXaUnqkE+ZvuSyLQsYQNiA9bsIGnkO0b5WjKJaI7RZpY4H1LtC/i806XBA==.sig.ed25519"
}

{
  "previous": "%d9IJxy90M0/4ETmlXlmbzU3RYj02fwQFxal33587q7o=.sha256",
  "sequence": 690,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520956476770,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%d9IJxy90M0/4ETmlXlmbzU3RYj02fwQFxal33587q7o=.sha256"
    ],
    "packs": [
      {
        "link": "&BQbBgpJFoHdCh/mlpLr2ZqLtvQc1CceGUnqBcZONhmg=.sha256",
        "size": 3703
      }
    ],
    "indexes": [
      {
        "link": "&BT3U3bO7KZosoWhK0mEsEZJfaonZhlVN30Hmuy1Vkt4=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "c5d664855be38bca6e49de05a0e3a9604b4a72de"
    },
    "commits": [
      {
        "parents": [
          "24447d97ad54c2fee2bb8594450e2cbb4d6c808e"
        ],
        "title": "Implement decode_reader",
        "sha1": "c5d664855be38bca6e49de05a0e3a9604b4a72de"
      },
      {
        "parents": [
          "0aaa5096758aa18dd94b4961aa80008c406d395f"
        ],
        "title": "Implement encode_bytes",
        "sha1": "24447d97ad54c2fee2bb8594450e2cbb4d6c808e"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "95ba14961fb6203747d1ca2122a313ff71d809eb",
      "a944cb62bd8b43fca0c949a6f57d7a1caf5bf8a2",
      "a614b649fc2205ac5229d9fd819d391936b20f5b",
      "04b2ef55836e640c9bf34c8776f9e5ccc6eef6f5",
      "87eabbd3fb2de1a680ffe13dd7f27a149a0364cc",
      "083efd347984adf1e66856002a4e8c552640697e"
    ]
  },
  "signature": "UPSNTgQyXq6rKgkCp6iDtyXnvBPtj2SQmeRA/hzOWziAh7wStRBEO03LMmdPP8+v/Z00km1Z4Rl7S7MgKNNZCQ==.sig.ed25519"
}

{
  "previous": "%Fc2kWJZHQuYJXY7CyNpoQ2QMI/r8WPS0098PdHG+M0c=.sha256",
  "sequence": 691,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520957515396,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%1QZDLm7xgsq87qTf5eKTpJe3/HVOPIzYGA3zDyEncso=.sha256"
    ],
    "packs": [
      {
        "link": "&1QZuY76g9l+fOawSBdbz/dQHFOv7vQQ0MHS39PVdmhU=.sha256",
        "size": 1412
      }
    ],
    "indexes": [
      {
        "link": "&5JZ5stac4OKewAbP6sEx4+v66Jr90E9RLkYqNBYxgPI=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "216287e67023808cbb1a0859d39a649e42a0df8d"
    },
    "commits": [
      {
        "parents": [
          "24ef840e311df97b187bb98c2400ab8a3a9ca1aa"
        ],
        "title": "Bump version to 0.2.1",
        "sha1": "216287e67023808cbb1a0859d39a649e42a0df8d"
      },
      {
        "parents": [
          "58a058fb6e9fa5bfe33c66771b56a9dcc50f856c"
        ],
        "title": "Add retry macro again",
        "sha1": "24ef840e311df97b187bb98c2400ab8a3a9ca1aa"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "24ca36cb770087155a125850d5356f2d16dd09b4",
      "07cd170d14fac56c401b037888f95ce0e9171a61",
      "0cdd8586c6fc427b8f12cf3a8beb5ebebc2c7a76",
      "7e58cfd2b8bd914015ca509b446281dccd661e0a",
      "89755e4a429caf1d9a4ea7b7349d6306f86425a4",
      "54a69f79564730e55d0c8e4229d4d36ef8bf3dcc"
    ]
  },
  "signature": "LAQ6iYX0748KrRx9v34MFaBVzdNa+UqwXST3IorhJD3pDOe1KGBVHE0h+hMY5vmJQfckrz5jJFtT2uYsrWPyCg==.sig.ed25519"
}

{
  "previous": "%AkMZxf6s5kUeDmFQD8xRS6CwwF5ltfvS/M2oovUbZyA=.sha256",
  "sequence": 692,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520958069043,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Fc2kWJZHQuYJXY7CyNpoQ2QMI/r8WPS0098PdHG+M0c=.sha256"
    ],
    "packs": [
      {
        "link": "&aiICWqcfuA7qfDMXLXldfmU26+4fQn2O/k3XJZi8Qvc=.sha256",
        "size": 3766
      }
    ],
    "indexes": [
      {
        "link": "&tDYT/+vDpsdb/AKomRfoMsCG1WmDF2lpGV+nLfsyVqA=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "b498d0bea10ae941b6490707fe04b2936a76ab62"
    },
    "commits": [
      {
        "parents": [
          "c5d664855be38bca6e49de05a0e3a9604b4a72de"
        ],
        "title": "Implement encode_writer",
        "sha1": "b498d0bea10ae941b6490707fe04b2936a76ab62"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "e6c7e207d564f7cbdf023bf2480a09099b18bb24",
      "493ff8b1184125181b6a4085b150155dbc83054f",
      "a5d0c6f035d35dceaea67497fe4d756a0e969061",
      "ba577a8326dac94144264e3d82d258e60f485e55"
    ]
  },
  "signature": "PQvoxDrXAXSyG1fwWAiHXuzYCgNnQKyDlAp2gnPrPacMglvWj1MLImrXUyPwCOWxlXAN5WuUqpUt8cn0THGWDw==.sig.ed25519"
}

{
  "previous": "%WD0dg7+/YOxQkF2dAy+RO3M/40DqY0+rYU9VKsJwd4A=.sha256",
  "sequence": 693,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520972471604,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%WD0dg7+/YOxQkF2dAy+RO3M/40DqY0+rYU9VKsJwd4A=.sha256"
    ],
    "packs": [
      {
        "link": "&/5p3fu3LMoSdFuwzNYM5gda8eTBHNPFWE8098obaYNw=.sha256",
        "size": 5559
      }
    ],
    "indexes": [
      {
        "link": "&rKrAMrdC/lyn1NFAJnuKbqCE6dyx9G7fuqanlI5fQGI=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "0eeefaf61db8fa71fdeb93784d69f5b4b2851c21"
    },
    "commits": [
      {
        "parents": [
          "c7247c2196c42dc2c20d69b212a23524c2361ebc"
        ],
        "title": "Implement Decode Future",
        "sha1": "0eeefaf61db8fa71fdeb93784d69f5b4b2851c21"
      },
      {
        "parents": [
          "d684e6752dabf7412535171f41a23f9349932144"
        ],
        "title": "Implement Encode Future",
        "sha1": "c7247c2196c42dc2c20d69b212a23524c2361ebc"
      },
      {
        "parents": [
          "b498d0bea10ae941b6490707fe04b2936a76ab62"
        ],
        "title": "Refactor tests",
        "sha1": "d684e6752dabf7412535171f41a23f9349932144"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "8d54117f996b24ef95d1ba226dea297d3dab0a3c",
      "55664fdca086585dc4c8af82798ea0892d090d95",
      "4e5e941d0ad2bbd4cc45601e6588d02be05ddca6",
      "e2f9db59744142e0e93812648559c9c8db9883b1",
      "e678a0ec1491da3eddff95db80094b2dc18dd0f1",
      "b9c7ca1fe877d89b129b46f6682c86a88d2501db",
      "c557ae42f61c1e2446389a54b89f9d12db7eaa0d",
      "1eda040de8061e880d4f14952f72be303bb1757a",
      "8ac6ce462bd565f620e3af4331526b40a610fbb4",
      "25fb2baf55b76f0bd9b01d70d511c0ac522b87cc"
    ]
  },
  "signature": "F9RJzYuRRLIfTS/MeZqkjqBFnfZNgtxitfF1YK93VgRPCqt1mjz0lKot6b2odBqHSySS/2vtWOvmwean8C+TCA==.sig.ed25519"
}

{
  "previous": "%ckpztkeo0SSY6BwtcorRkod0+vpX0CXrPFfwhLStZFg=.sha256",
  "sequence": 694,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520975969014,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%uaUZsGvgLEc/EYPrHufpgm1Dccn+SYWkjNwOB+zzMwY=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%0WgohnKYdEapuoMb4wSeYSlq0hqUAlGmxvdfsIcmr0g=.sha256"
    ],
    "packs": [
      {
        "link": "&LqLppMl+I56bUIzr/5L0FYU1wkPflv9/AYnJzlIlkI4=.sha256",
        "size": 1608
      }
    ],
    "indexes": [
      {
        "link": "&1yY715UHFBSjZY3oD8ZVEGeXPtCa59bI7uzj2Y2BVRw=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "d8739e294843f5d5da6d10c9ad366739f1d75890"
    },
    "commits": [
      {
        "parents": [
          "8cf934eba312ecd6f2d91e0f0921f2ea85c21530"
        ],
        "title": "Link to VarU64",
        "sha1": "d8739e294843f5d5da6d10c9ad366739f1d75890"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "e2de3cbf0a6dc7a429c5a3cbf6f1e6076e78cd2d",
      "3539bf0ba55c28cc56beb21d855c8feccd837441"
    ]
  },
  "signature": "2ZQ0ttqRY9xdyQIHbmloCWDdsTt8fNT2A7K5fAsKISwJnwSaxhopYxf2u3qVbuNVSZj09t1al8u8s4p4x8tRDw==.sig.ed25519"
}

{
  "previous": "%kGLHcXPhIHL85MVRIBJpvW0ISJvfRBCECYkqTzyymSo=.sha256",
  "sequence": 695,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1520976084780,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%G0pg6GdgWyD9D15YYuknBkV2+Cn/+GrZ12cB7JOiTMQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ZuVEquFI492BFy7WBuL8C23Lp7nnlIS7ZOwMmiCqoY4=.sha256"
    ],
    "packs": [
      {
        "link": "&e4ZOZiwHcbvWbdT9hDiIKf5lDs62BUo8mw683eFSQxU=.sha256",
        "size": 1151
      }
    ],
    "indexes": [
      {
        "link": "&z6jZDJQaEah8qKZuNPueZYtL2DyZDly8lQMtcwgHPY0=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "c6a40f000e3042850e443f43cd70ca7d7746ab88"
    },
    "commits": [
      {
        "parents": [
          "19ecd0af972a3c74a5f5c126a9df0b07ed78e368"
        ],
        "title": "Add tag constants",
        "sha1": "c6a40f000e3042850e443f43cd70ca7d7746ab88"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "c73f2171ccffac96f1f1960394546cda81dbe155",
      "3132012b85275b57c872745d42e4866ea5e40404",
      "2bb59cd84f04b76691886139e00f73e42b61831b",
      "006854a03e22de40da6e0066afbfe32a3d93bcc8"
    ]
  },
  "signature": "qTcB8Kzdm8XM4vK7ZQLIaO4gI3kpCCwvuOk2u5aGM8dvZODUeFTkswnagNEK0pRNf96uIT6MNGyLy0UYWiC0Cw==.sig.ed25519"
}

{
  "previous": "%okZ18NAu8UjZS//xT+Q0apriMvuncz1lfylP5urW/zA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 696,
  "timestamp": 1521018160496,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%hsnjYblkC/Acn2a10QCbjaSBZOxFsXquqqX9HlSsBSo=.sha256",
    "branch": "%6RLe/cNqmVzMjllOwxGfXgNzQbdI0vgyYEJjpBQZsik=.sha256",
    "reply": {
      "%hsnjYblkC/Acn2a10QCbjaSBZOxFsXquqqX9HlSsBSo=.sha256": "@d2vneic0a0Y7OoRYvhXf+nCOBIV/lFQXHmOcHNr/3/I=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> This means that important services like indexing and full-text will have to be in the core spec - to be able to make meaningful apps.\n\nI completely disagree with this. Why not keep the basic functionality to a minimum and have clients specify what plugins they want (to throw a buzzword out there, clients could be built with progressive enhancement principles in mind).\n\n- - -\nIn my opinion, the system would profit from a clear separation between the replication rpcs and the client rpcs.\n\nReplication rpcs are those that do all the awesome p2p stuff. They run automatically, in the background, and assume an untrusted peer.\n\nClient rpcs are initiated by a (usually) trusted client, often on the same physical device. Among the obvious stuff like adding and retrieving messages, the currently most important ones of these are those giving more fine-grained control over the database (creating indices, flumeviews, etc).\n\nThe client rpcs are necessary to build apps on ssb. But the \"core set of rpcs [that] is considered an ssb server\" only includes the replication rpcs. If my program implements those, it becomes an addition to the scuttleverse. The scuttleverse doesn't care whether it stores its messages in a flumedb, in memory, or in an aws s3 bucket, and the scuttleverse also doesn't care whether there are any clients using the data, and how they access it.\n\ncc [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519), our little discussion triggered these thoughts for me.",
    "mentions": [
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      }
    ]
  },
  "signature": "dM3FAKf74z6T2yrFJxFDuoY6oPeGx+KmIdnGRkdz45CKUc0en39N95EpALztbdQop2po60vCXHNPdsMchuZjAA==.sig.ed25519"
}

{
  "previous": "%wGjW6iCPpbLIUkh5y32CHt2aPYVblKhw+g60V6Yl9rI=.sha256",
  "sequence": 697,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521027759857,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "async-serialization"
  },
  "signature": "1KUr00Tfmle5ucWQ1a/sX8+O/Y8kGiHDr7R6hVIa0F47/QGPNXZnEVDlmfdFHD9m/nyX/W3ZwfQMjiaUzFzJAg==.sig.ed25519"
}

{
  "previous": "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256",
  "sequence": 698,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521027767030,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256",
    "refsBranch": [
      "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256"
    ],
    "packs": [
      {
        "link": "&+52HNcqZiFJlJQt3hQW0+JNf9OltMbcnhNNSp5yh9zw=.sha256",
        "size": 2921
      }
    ],
    "indexes": [
      {
        "link": "&D0OxHXaScP2V8gWL7n12HJcfF5PuPwUEG5GmiHaRc9I=.sha256",
        "size": 1548
      }
    ],
    "refs": {
      "refs/heads/master": "b9959bdebf4fdecd6262f9141f15bc5d802bb1cd"
    },
    "commits": [
      {
        "parents": [
          "3c17b1e41f6b18dbe2051c49feb156bee8f3e4cf"
        ],
        "title": "Fix typos",
        "sha1": "b9959bdebf4fdecd6262f9141f15bc5d802bb1cd"
      },
      {
        "parents": [
          "6958335a78702a3908530dd36c0c9c24b0c16330"
        ],
        "title": "Add traits",
        "sha1": "3c17b1e41f6b18dbe2051c49feb156bee8f3e4cf"
      },
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "6958335a78702a3908530dd36c0c9c24b0c16330"
      }
    ],
    "tags": [],
    "num_objects": 17,
    "object_ids": [
      "3adf171520b4091f66f672f14f110f974d08f3e5",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "23bd76a0627e9fea213d6b27f6a1d43f0fef104f",
      "6cd7b7924ef912ad8804e18ab2efd0c08b64d2e1",
      "fe6521ecaaede398b3283673203b358da5ab16a7",
      "8d47ab569d6c89e9d08a819df042dd495ad59420",
      "fa7d38c70bedc7d7cdfc1a8af472bc165a6ddaf7",
      "ea67f142152d067f9a69bf6065cb9dee93705877",
      "b6cebe6149ea58bd937e8ebef4d022a1ce856491",
      "dd414d5d59b551b3af396f6c20c432efd0a3d659",
      "542f9e1062c5fb45bf11da068439034fd60efb64",
      "c3d110e77907862279b472e1789657e1e1e93711",
      "f9941aa018434ac52fc68a29d540ca0c76b4ccfb",
      "0f5f42e501935a0428c61811ee4daeed3b62309d"
    ]
  },
  "signature": "tYY2tCHoIEjnyXq8uNC8jOZjFqO3vw/7U/d8HTusrPqVYdlv/QHavubYDI3WSD7GZsz02S5Ms1TI1lh2D5XyAg==.sig.ed25519"
}

{
  "previous": "%bMR0AYz1Zqmv/rjjnIk9aaV5NolbnAJsf8pXLqycR5A=.sha256",
  "sequence": 699,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521028436862,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%bMR0AYz1Zqmv/rjjnIk9aaV5NolbnAJsf8pXLqycR5A=.sha256"
    ],
    "packs": [
      {
        "link": "&PDvs2vxnSRAzXzDwZ0oiISwFaa+ZLgi/Yg9KuWRK1QQ=.sha256",
        "size": 1109
      }
    ],
    "indexes": [
      {
        "link": "&DiJSGvWzHAfYlDX8a+Isu3GZIrcDUb6xZ9tPHuD20O0=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "98e405d2373acb2f7db692b0fc3ccc77ef46e067"
    },
    "commits": [
      {
        "parents": [
          "da0cf9e28de855b3c76ebd134976893ee6e9238e"
        ],
        "title": "Set publish = false",
        "sha1": "98e405d2373acb2f7db692b0fc3ccc77ef46e067"
      },
      {
        "parents": [
          "b9959bdebf4fdecd6262f9141f15bc5d802bb1cd"
        ],
        "title": "List problems",
        "sha1": "da0cf9e28de855b3c76ebd134976893ee6e9238e"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "a815f25e66a291a5cf4f8e6988ff9a7e0cfdc207",
      "e4863bca995b5f1d4eff708bec1216db100518bd",
      "6ec1fd092af7223bc7687b5334c99846f1eef334",
      "53bf4ab377f5a0fd8178166d74afdfc4bdf6dbf9"
    ]
  },
  "signature": "OM5Nu8S6hTN9qCuHrQ4Rkdic9UJ0fnkQzalr2NdzZps/BZ0gDcnvgJxNiQAIe1IrMzkbDFBfyylhQ+CqKNeaAQ==.sig.ed25519"
}

{
  "previous": "%NaTBpZbHNBd3s7AQuRewdB4g2Lmy1cYU20r7mqqW3w0=.sha256",
  "sequence": 700,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521030668557,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%NaTBpZbHNBd3s7AQuRewdB4g2Lmy1cYU20r7mqqW3w0=.sha256"
    ],
    "packs": [
      {
        "link": "&eNQMAwC9sZMO2hgoYjMEL1JRPWvjDZeDCyN7sF0lE2Y=.sha256",
        "size": 1790
      }
    ],
    "indexes": [
      {
        "link": "&MXlec2xv+MOqnXFE2HMe5FXkOdX+8vs5L7Z327/6N4k=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "5614c3ba0859ea84a4328c1b2805ec8204ffcc67"
    },
    "commits": [
      {
        "parents": [
          "98e405d2373acb2f7db692b0fc3ccc77ef46e067"
        ],
        "title": "Fix problems by making this a trait of futures",
        "sha1": "5614c3ba0859ea84a4328c1b2805ec8204ffcc67"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "acd56c5c241417cfeedc2caacf132607e6098bd7",
      "23bd76a0627e9fea213d6b27f6a1d43f0fef104f",
      "828107ddf43ab5b29d7ed5c2183a765fd9fc5ee9",
      "8d47ab569d6c89e9d08a819df042dd495ad59420",
      "8268f0b3bdc370e4d4c9390a5bc575fc31f43efb"
    ]
  },
  "signature": "kFAE3kpsO/mVjLVebftH+Jry/hhpfgIw1WCcjmggc2STO+fVws0nHpWZwbbH1RSsTDAqqeTPxaEXfWOGeyU8CQ==.sig.ed25519"
}

{
  "previous": "%lFyXm8/PIV4JUCZKaConEgmAQJISa2DEsLIIdXK1Ock=.sha256",
  "sequence": 701,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521035428480,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%lFyXm8/PIV4JUCZKaConEgmAQJISa2DEsLIIdXK1Ock=.sha256"
    ],
    "packs": [
      {
        "link": "&UprXdC1vImWBUUNl5Xwqhcpigt8VnXRPEh0iFDjKIL0=.sha256",
        "size": 1839
      }
    ],
    "indexes": [
      {
        "link": "&NxwSXX102VPn+9NdW8OgtVcu5KBfO1g0bxuetslwdo8=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "547353dfd4adee2d9eadbb0c33984853a3564deb"
    },
    "commits": [
      {
        "parents": [
          "5614c3ba0859ea84a4328c1b2805ec8204ffcc67"
        ],
        "title": "Add traits for computing length of Serializeds",
        "sha1": "547353dfd4adee2d9eadbb0c33984853a3564deb"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "e5dce7686a320b03c44f38d8d1fd80c09b523bee",
      "abe844c1137f33e1a363651acf674b15b99ec6e2",
      "c6041ca21ef775af08e8039a8a5d074db432247c",
      "2281ef4eb367b3737df482a9f10591dfa6c908aa"
    ]
  },
  "signature": "38S1GGBxOuwVJ+V/3b8FyCk4x10AV6wSRcUG5v5Xkcj1w22Imj/k9gN8mM/wk70Ox+BMc2QP8HSD2HhMJOwDDg==.sig.ed25519"
}

{
  "previous": "%7qmn1PflXWvkt6u9BpXocW1uRmIcXr+lztJjo4q+Fcc=.sha256",
  "sequence": 702,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521036339489,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%7qmn1PflXWvkt6u9BpXocW1uRmIcXr+lztJjo4q+Fcc=.sha256"
    ],
    "packs": [
      {
        "link": "&hZ0gb4i+zhJ5u8abF9EZ8GdxzKf7tKyHW6Hd2GSn4j0=.sha256",
        "size": 2261
      }
    ],
    "indexes": [
      {
        "link": "&sxfDAbq54Z0M05vOsdlI8EHSTVqpMdTMz/r+C9l4Rsk=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "0240ede7a07fe83417c89d110f7aefd1a4c85f42"
    },
    "commits": [
      {
        "parents": [
          "426026b0686dca4d81a2bbf9fd58d3b8fa0937d9"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "0240ede7a07fe83417c89d110f7aefd1a4c85f42"
      },
      {
        "parents": [
          "393f249d536dbabf480fb3db4712592132bba700"
        ],
        "title": "Rename 'new' methods",
        "sha1": "426026b0686dca4d81a2bbf9fd58d3b8fa0937d9"
      },
      {
        "parents": [
          "547353dfd4adee2d9eadbb0c33984853a3564deb"
        ],
        "title": "Rework AsyncDeserialize",
        "sha1": "393f249d536dbabf480fb3db4712592132bba700"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "f076c02982847e1db12cec472a929451c153f8cd",
      "db16058c04bf768c3761b05076748bd79d94db69",
      "f78de828ae164b3b10815a7c77b0b63d1a188f9e",
      "39bd313aba96513155ed26724552734418404a18",
      "28be7669cb469795fc35353a17da9d89ffac63a8",
      "8055fd4540fc30d1fe4d319c854e9593ed3c7df5",
      "04b3aeafb232b6e8893794a432a17d8f73e78515",
      "004a0ed173e94949735a26c72897200bcb75ed08"
    ]
  },
  "signature": "JXQ0B7fCqVYCgD26Evdm2CGbN4RFY1bdclU+DCgdaOwWQFhbbLZ9q4aQ1FSmH1fAlTfYzTgSNFmqWykxuVSRAQ==.sig.ed25519"
}

{
  "previous": "%sRR5cc14YtSz0tR23U2XnckhSNektvuH6WKcWc+FJos=.sha256",
  "sequence": 703,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521036603756,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%sRR5cc14YtSz0tR23U2XnckhSNektvuH6WKcWc+FJos=.sha256"
    ],
    "packs": [
      {
        "link": "&wMxyeu/AG/9+ytB16frB6SD6F20nfDb4uRacjkxL3sg=.sha256",
        "size": 1439
      }
    ],
    "indexes": [
      {
        "link": "&gpSpuqk4kvnK/rpQGd6hUdTJRqHNxJ2UAjCN9xFT2Ho=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "9329e23c90a39d08d2b29cce2296abafc74118a2"
    },
    "commits": [
      {
        "parents": [
          "0240ede7a07fe83417c89d110f7aefd1a4c85f42"
        ],
        "title": "Add missing argument names",
        "sha1": "9329e23c90a39d08d2b29cce2296abafc74118a2"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "e468e9eeaf635adce6c958fa8ee4de26b81e24f8",
      "776e8fddee1191aa7a6a21292cf043bf2f7354e3",
      "3d267f50e77f64059256e780eba5890e42562c8b"
    ]
  },
  "signature": "8DAMlbfsk7pJ6x28S0V3t1mTAFQwwxWr99SEYZcxfA8U4XvGpx9h78SheIo5S8aJbrhW8O6O7/NXwkpAVJ0aAg==.sig.ed25519"
}

{
  "previous": "%cnPZTONp2hIa+0T7wmWCqlJ+i0yYUDDu1n4oAEGBaIg=.sha256",
  "sequence": 704,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521041389483,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ckpztkeo0SSY6BwtcorRkod0+vpX0CXrPFfwhLStZFg=.sha256"
    ],
    "packs": [
      {
        "link": "&vPlGPfvCyOUbN+Orz5X6usF+g65nacfxdkPujkE7FIg=.sha256",
        "size": 5621
      }
    ],
    "indexes": [
      {
        "link": "&aBO9gwcyrL0h09M0BdlJPUdXItGXUwOJabmBeytIob8=.sha256",
        "size": 1576
      }
    ],
    "refs": {
      "refs/heads/master": "c85b8535a639f578496278b69b1966660e053d6c"
    },
    "commits": [
      {
        "parents": [
          "81e8eee3604e42db612f8f0e9d31a370114a4a1f"
        ],
        "title": "Bump version to 0.2.1",
        "sha1": "c85b8535a639f578496278b69b1966660e053d6c"
      },
      {
        "parents": [
          "76e695700d39b958ae7aa06a7ca105af71121034"
        ],
        "title": "Implement AsyncSerialization traits",
        "sha1": "81e8eee3604e42db612f8f0e9d31a370114a4a1f"
      },
      {
        "parents": [
          "87bf8133ffb66568083ca9647b88f9c4c831717a"
        ],
        "title": "Update tests",
        "sha1": "76e695700d39b958ae7aa06a7ca105af71121034"
      },
      {
        "parents": [
          "0eeefaf61db8fa71fdeb93784d69f5b4b2851c21"
        ],
        "title": "Change returned lengths to usize rather than u8",
        "sha1": "87bf8133ffb66568083ca9647b88f9c4c831717a"
      }
    ],
    "tags": [],
    "num_objects": 18,
    "object_ids": [
      "0358cd300ac6c15ba309a7fc6a79cb37a9d0e3f7",
      "a7c530ab387dd644008428d1d3a7aaacd5239c2e",
      "179694cdc290e1d9d1892a2f338fd82d0954c4a7",
      "9750442465e5628ca9bf4d74f02e866641d14660",
      "3f4b079aa3bb1c3152cba3dc24adbd1a5f4ca9aa",
      "fe40bffe989de1a76b176e209c6d675022b03195",
      "aba0484a5a504a49550d9317b00cb13fbf543ba3",
      "04d17f0f817f784f42a7725684ab8ed1b03a0b32",
      "ace6dfba57f570ac6c9f45687494d095bf13ae9b",
      "31e5e71d16071ccf42197ab0b409380cffc89181",
      "b987eaaf1acc8902f0bc4c45af5e2f2454f66411",
      "78fe1fed13d356f26e667aee80b21873351d89f6",
      "3ad07211b9b688312a84b36302094420c8dd6c2b",
      "ddadd365de5dcb1a45ffdf07354461e029b8bff2"
    ]
  },
  "signature": "/Zm2GLxYzsl/ec+FSk+blNvZj9UWUYOYmrodDHbLF3upeNR3tI0waM5eI8pClvvCuHysfgim+ZNBNUt/kdMmCw==.sig.ed25519"
}

{
  "previous": "%lqCvw5hMRnI2y4udWuOJ1xqgGvsgywBILWyEa6LqgE4=.sha256",
  "sequence": 705,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521042476278,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%cnPZTONp2hIa+0T7wmWCqlJ+i0yYUDDu1n4oAEGBaIg=.sha256"
    ],
    "packs": [
      {
        "link": "&p19FueQxl8chX5jvxnkQ+CHJzLOwaXfrHWw5mukVaNo=.sha256",
        "size": 2545
      }
    ],
    "indexes": [
      {
        "link": "&xRTvJHwo1RHqVTHfsdKo6uayRPFpvWa4OMQZ7MTaTok=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "6137e08e7f8bbb72f44fa2d57a3c68391de5a7db"
    },
    "commits": [
      {
        "parents": [
          "7e281565a338d5d090da8537b9da671311f9df09"
        ],
        "title": "Bump version to 0.2.1",
        "sha1": "6137e08e7f8bbb72f44fa2d57a3c68391de5a7db"
      },
      {
        "parents": [
          "c7eeaf978ef4b41e3f2d0884903057d14e4d6e74"
        ],
        "title": "Implement common traits for DeserializeError",
        "sha1": "7e281565a338d5d090da8537b9da671311f9df09"
      },
      {
        "parents": [
          "9329e23c90a39d08d2b29cce2296abafc74118a2"
        ],
        "title": "Fix AsyncDeserialize doc comment",
        "sha1": "c7eeaf978ef4b41e3f2d0884903057d14e4d6e74"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "ef2c5e02e0457df4975c01be0f44d2a1a8a465d6",
      "8bb72468ba2e680c4a25f73e4c15f73004d6aa1c",
      "feb4c12a7f7abfe8facc3140fa0ec9f5082adcac",
      "843a056f5ad654fe2766a793bced9d75048a7a32",
      "724dd83f3b3598af7d613ec88d6fb8d37ce43707",
      "47fcac7a023929bfdde0ddfcd4c91e5f230419a8",
      "9d24e62372c973d9fd19c74b3a5c7715f596184a",
      "8ab3baff385420144f0fa6b9fedfaa74c9761de6"
    ]
  },
  "signature": "jhmz+zGSLBvaYckn2/g/j15gSUjyB0u/ES/MJ/2PuXkPNC8QCf2ReFHQN88crV49RN03ZLX6UcEhSTfGWs9ECg==.sig.ed25519"
}

{
  "previous": "%4FTd2xcq6zn9omne47qLAUdM5uuZ6FzEGreGJsLJUCc=.sha256",
  "sequence": 706,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521042864307,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%lqCvw5hMRnI2y4udWuOJ1xqgGvsgywBILWyEa6LqgE4=.sha256"
    ],
    "packs": [
      {
        "link": "&IkcU0/XrpFl0SOcY6ZMxD4CrDosTIIEewWNYVGQo5i8=.sha256",
        "size": 4874
      }
    ],
    "indexes": [
      {
        "link": "&+riFQumO1E7CdI5GQlDW8XwmzJeXP34kiPBAnKROD8U=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "41a70a6d4620f3676fe0faa7bb3ec4a88ebce3c5"
    },
    "commits": [
      {
        "parents": [
          "e9654572448d40821a863d462780ce0a275c221a"
        ],
        "title": "Bump version to 0.2.2",
        "sha1": "41a70a6d4620f3676fe0faa7bb3ec4a88ebce3c5"
      },
      {
        "parents": [
          "c85b8535a639f578496278b69b1966660e053d6c"
        ],
        "title": "Implement AsyncDeserialize trait",
        "sha1": "e9654572448d40821a863d462780ce0a275c221a"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "dc66165a20a322b6c98b2b83ba5819b8a18dbcef",
      "b93c56844d924738ba3e8ae35893d8befbb3e764",
      "a6bb54a18b9122a89bad339794410bc421c2f7fc",
      "b05bae057fafcfb7d96fb052c87a27fead2eb6d3",
      "e1da8f970ae68663d5035747c744dbfb7357c82f",
      "73fefcf700ae4074f3828cd1bd7b009aa2178b44"
    ]
  },
  "signature": "Vg3+7f5VUQVe/UEBQtncxFMxHfgz7NOSafPp2m0T0zz2ub4eLYZohQLhl8/zWf4C08pQ7g2/eb1M/GjKCaH1Dw==.sig.ed25519"
}

{
  "previous": "%GivAebTqNR/2zNM5zJYWeADiGDHrfZemmrWg6dLEvc8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 707,
  "timestamp": 1521054991663,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "%YoR67yjn586RydPI0YdYUSFqoGE45972U0nhxd69134=.sha256",
    "attendee": {
      "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    }
  },
  "signature": "jvD0IXcjB+R98DzWrkq7o18MlFaZO599fXjb2zVfl7Me05glvKcbeluiKT6Qw730ON2vq6Kp0BRmz2oNgzhPAA==.sig.ed25519"
}

{
  "previous": "%GAAsqEdjKI0BQd7a3b0Y3QfvYQlfP5olVjB/dcfuCFg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 708,
  "timestamp": 1521102244046,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%YkIPtiAe4VHc4YjeYJ1MPMsdxE2soNyQjzgqj+4iXNo=.sha256",
    "branch": "%tcq0DhloyaWmCiWXZ0PhZF/SB3j1rFtN+S/b8z+yMT0=.sha256",
    "reply": {
      "%YkIPtiAe4VHc4YjeYJ1MPMsdxE2soNyQjzgqj+4iXNo=.sha256": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519"
    },
    "channel": "protocol-docs",
    "recps": null,
    "text": "Is this [this issue](https://github.com/auditdrivencrypto/secret-handshake/issues/11)? To quote Dominic's response from github:\n\n> that is so the application (i.e. pull-box-stream) never knows the internal secrets used in the handshake.\n>\n> secret3 is used to encrypt the serverAccept https://github.com/auditdrivencrypto/secret-handshake/blob/master/crypto.js#L141 so hashing that again means it doesn't get used again.\n>\n>keep in mind that sha256 is at least 60 times faster than 1 asymmerical operation https://github.com/dominictarr/sodiumperf/blob/master/results/bindings.txt since each side does 3 scalar_mult's a sign and a verify, it would take a lot more hashes before we'd actually notice any perf",
    "mentions": []
  },
  "signature": "EFR/YNuro10Vmoh4YHirCoJ08a0kg333W2teAL6zqqD4TrO/3KGtodXidQh7G7qcNErZ0aglolqAlkFDQAWmDg==.sig.ed25519"
}

{
  "previous": "%VnaDxDToX1oa6v2WkXKxSEads/Vh7aIQGl7Z8xXbVto=.sha256",
  "sequence": 709,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521125505830,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%AkMZxf6s5kUeDmFQD8xRS6CwwF5ltfvS/M2oovUbZyA=.sha256"
    ],
    "packs": [
      {
        "link": "&vSBqGxmCQkUtg6ppttEWjMgl/J4+/J82o8xEA126f+4=.sha256",
        "size": 2988
      }
    ],
    "indexes": [
      {
        "link": "&Gb6kOA55ZNOHmdNdghsVHW+Ejz6OrXQwtktxzuQsZgc=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "f8d4386a2f6cce1bb246c68838a93d3bc652ec4b"
    },
    "commits": [
      {
        "parents": [
          "216287e67023808cbb1a0859d39a649e42a0df8d"
        ],
        "title": "Add PartialIo reimplementation",
        "sha1": "f8d4386a2f6cce1bb246c68838a93d3bc652ec4b"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "28dc6788df97568a6cfa26216075690ba5ab841c",
      "758dc80fa2049d31860323f1efb3860665a7348a",
      "9d7a4c5fbabc24d988eaf88113637b75b9de47da",
      "4a19e73f8f6eec3c3f33cb8b3700d9095f29f4ea",
      "ccf5297579270f329bda7041bf7b0bf6fd253b35",
      "571a9b2968d98927ccd80c5537e3b3abd83e5077"
    ]
  },
  "signature": "D8brB3awSS4miA3MEkyEeVUdiGLBeOu8LsrEOq8oQ8I6SJTtOj0UXGujzjfdqDb53Sx0STdXzqxTOJliqqzzAA==.sig.ed25519"
}

{
  "previous": "%C1JR54ltvFgt3I2dBW+8ia/7ePb7ShqNtrfYO9WjvHE=.sha256",
  "sequence": 710,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521127043409,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%C1JR54ltvFgt3I2dBW+8ia/7ePb7ShqNtrfYO9WjvHE=.sha256"
    ],
    "packs": [
      {
        "link": "&7+Q/9tCPbt+HuCyA8Hmgi9QgoOJP1tdXp3jiHNvQvDs=.sha256",
        "size": 2291
      }
    ],
    "indexes": [
      {
        "link": "&/4ECN2rSYkFiYXLP/w9whwG2rgvwagxAOrSsUzEs+a4=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "a5eddde1757969225ef8cd96700450e592354639"
    },
    "commits": [
      {
        "parents": [
          "f8d4386a2f6cce1bb246c68838a93d3bc652ec4b"
        ],
        "title": "Fix quickcheck setup",
        "sha1": "a5eddde1757969225ef8cd96700450e592354639"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "69dee5c2cd924e8aeb5a05141c6719338a8895d4",
      "15c73d87e0dc747ac606df1f72712c1a2ddb0f52",
      "86fab2bcf6555d4d062cdf66cd52e3dd34609313",
      "2f91d896c4226cbb2847b5903b3b2cc6a9da3f4e"
    ]
  },
  "signature": "ba4wSrinZE7IS/zJ7xlciajTgEfhMyqQnCTlK9MncpmT7n3jLgNXDwTSDdSTx1QCG70iWgMV6PBsgyfWvbVHAw==.sig.ed25519"
}

{
  "previous": "%/bhyQa4aCXC4UMEzrx0bRxGpnayZXxc4jcuAonf7PHI=.sha256",
  "sequence": 711,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521127219751,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%/bhyQa4aCXC4UMEzrx0bRxGpnayZXxc4jcuAonf7PHI=.sha256"
    ],
    "packs": [
      {
        "link": "&ssEYPdXcdGmQeA7ZT3FiAr4ZyiNOFyn2GX2bsM7779U=.sha256",
        "size": 706
      }
    ],
    "indexes": [
      {
        "link": "&VIZ+90Q/vy7uJt1YrQET1uK24j2suaqJGLD54p3Orks=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "78606d0641902a73e0c81dd7e73e418f8a4bf792"
    },
    "commits": [
      {
        "parents": [
          "a5eddde1757969225ef8cd96700450e592354639"
        ],
        "title": "Make quickcheck an optional dependency",
        "sha1": "78606d0641902a73e0c81dd7e73e418f8a4bf792"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "a08d3d7d9f169f1320191c2854bd906fc6481ad7",
      "023a8ef9a2f4b4c8ea4f11d3b7d23a6c541e89e7"
    ]
  },
  "signature": "nZcocnvnMHflm1r4ixhHu5UM0eTYBi2MluJrsg30kdPn2+3I+DMvo+f7D1EyoeO5tGBoyWqQLEw6bzgZHnPVAA==.sig.ed25519"
}

{
  "previous": "%Sk+DwKm+C7vZo2knqQ2QUIRV8z3b7srHChH1ZFerUk8=.sha256",
  "sequence": 712,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521127269168,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Sk+DwKm+C7vZo2knqQ2QUIRV8z3b7srHChH1ZFerUk8=.sha256"
    ],
    "packs": [
      {
        "link": "&gqBML/1m3A89EB8aa74MMShugq0vunOW1h/GXLdNuoI=.sha256",
        "size": 675
      }
    ],
    "indexes": [
      {
        "link": "&n4ExbUlY+L2PBEOSRaJhd0wLzU05Y5GQwLNu4E9Fiew=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "3a8a20a31b1faec6f5002cf28874ab0fc5a519f9"
    },
    "commits": [
      {
        "parents": [
          "78606d0641902a73e0c81dd7e73e418f8a4bf792"
        ],
        "title": "Bump version to 0.2.2",
        "sha1": "3a8a20a31b1faec6f5002cf28874ab0fc5a519f9"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "39a04ea1d08efec3fdb493f516797f39ba5167b5",
      "7d4405dc91bfb6f2f4173259e0172ffd9f0ab7c1"
    ]
  },
  "signature": "HQ+6n90vptgyWd2dmjljiiKmmHwOCHr5X/cwDO33zoOGa0tZz+GRJbDP4Gv7syI7rz6USK/ldyInIVwx2qmQCw==.sig.ed25519"
}

{
  "previous": "%c7kkiQdiDiQRitx/wl5e0ExKcszDF1S7bdzeA3553NM=.sha256",
  "sequence": 713,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521127363287,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%c7kkiQdiDiQRitx/wl5e0ExKcszDF1S7bdzeA3553NM=.sha256"
    ],
    "packs": [
      {
        "link": "&civu+VH7ERVwAMNLKPkHOZolrQM6hZxq4rpQyxN3v64=.sha256",
        "size": 1959
      }
    ],
    "indexes": [
      {
        "link": "&wY0kU2FzCA5+/tW65AySuCK1bdudiryze1X8NudiiDE=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "1190e643d2510b02320586968d126eae56a51b43"
    },
    "commits": [
      {
        "parents": [
          "3a8a20a31b1faec6f5002cf28874ab0fc5a519f9"
        ],
        "title": "Remove unused imports",
        "sha1": "1190e643d2510b02320586968d126eae56a51b43"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "e8fd83d57694fbbd9d626de2c80f37f7f44b26ab",
      "317769da66f50c237cd0c2a61e2f35403fca93f7",
      "62494088f6e801e66d39e9218f55e0252dfd475f"
    ]
  },
  "signature": "3B4ZuTbrPdx6BBLmubSGpWmKtj6dYnoKgLyQn1fB1iH/Koyln+ssQEt4F6KtB+8o7vzS//1CF7SOPrx5W0NJAA==.sig.ed25519"
}

{
  "previous": "%iw6+mrC50uxYdAZ1QsvYCtOmxCPs8mh74THQ7A4QN64=.sha256",
  "sequence": 714,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521127724608,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%qAMCRNRrm/xW5inb9cDs3elHrTnw7KkgIUIViZCWn1M=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%4FTd2xcq6zn9omne47qLAUdM5uuZ6FzEGreGJsLJUCc=.sha256"
    ],
    "packs": [
      {
        "link": "&CkNd6BNxqizjY2seUlHsfpPCB8ZEzHdrwyvW07L3aQo=.sha256",
        "size": 2124
      }
    ],
    "indexes": [
      {
        "link": "&5L3YI3EUnAXh3lgv+PG6UNbp80LTZRovTnSiPylmTHQ=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "42de07daacfeb1a6f856207c3f2f93e285787916"
    },
    "commits": [
      {
        "parents": [
          "6137e08e7f8bbb72f44fa2d57a3c68391de5a7db"
        ],
        "title": "Deprecate the crate",
        "sha1": "42de07daacfeb1a6f856207c3f2f93e285787916"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "62aec410d72013cdf4c2966a28f998e529692b97",
      "fd148e05a30b1da5282f9f4d3b2e1ee44c7f1a12",
      "9d00fd1d23357164cb4e9f2c065ea78fa0b83b63",
      "2b24b95a089d75b47ddc8027a5b3656ed1cca1ee",
      "befb7036b69a19b3cf290ba208f7e68a35460a6b"
    ]
  },
  "signature": "zOf4yryrvcqAVO20BP3t7lDPSdZkPMwNVrtbq788b2M0HGYiNDhfzp243PBzr36037M1qbtGn5dtmbHK6m6TAw==.sig.ed25519"
}

{
  "previous": "%v/M0+CXJ3FNE9J2L0MekDLHue1EVlLZFG7+qQlLLVAg=.sha256",
  "sequence": 715,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521128426800,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "async-codec-rs"
  },
  "signature": "8FE1ysPJdWZXXsqPn/gSTW/PehQ74tGUAJfYgjdCy+akGQfmtaYEVwYamK31X9NqIyc8txCdrAcH7QRJHBNbCg==.sig.ed25519"
}

{
  "previous": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
  "sequence": 716,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521128430412,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [
      "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256"
    ],
    "packs": [
      {
        "link": "&otMyh74x/rJIopRfU9haUEwAFWKL1/nEhg6mWG500mg=.sha256",
        "size": 2883
      }
    ],
    "indexes": [
      {
        "link": "&Icizqig+B/PtM/+5ARegx0g5WqmGXq6e97foF7EKvls=.sha256",
        "size": 1408
      }
    ],
    "refs": {
      "refs/heads/master": "f670dfa4822ec9140a691afc9d22e0b367e48566"
    },
    "commits": [
      {
        "parents": [
          "98c7ba51e2331230a8e61c5860cf4ac124f00349"
        ],
        "title": "Add trait definitions",
        "sha1": "f670dfa4822ec9140a691afc9d22e0b367e48566"
      },
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "98c7ba51e2331230a8e61c5860cf4ac124f00349"
      }
    ],
    "tags": [],
    "num_objects": 12,
    "object_ids": [
      "f6d81c6f41865627a094ffd584bbe3a21c440d7f",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "e72fd60ed63f053e22ca28871866549411cfea4c",
      "dacee850bbe3387d09f82ab1e4edd50319612840",
      "dc08de097ee5a4af4dd6bea0c9b40f29996c9987",
      "63f08185ef9955fd373653f212dfb0e9484e4c94",
      "379030db1c16f8cc75965664ecf43351e2e03fc4",
      "cebb4733f5a739c333cbdd0e151a96d78962b057",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "d0kayC+bt2QCQHAPCIJG57C7Fd/nliKLVnq3CBbmMGzfFZIRR5onuU4Rqkhe6IH6l43ab/I30Ld+c6r1BQ8QDQ==.sig.ed25519"
}

{
  "previous": "%n+++3OoNNozkyeZhI4A5waruAnSOt8W9mbwEHv92IC4=.sha256",
  "sequence": 717,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521143262833,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "async-codec-util-rs"
  },
  "signature": "hYCKbQmWBTnXLBtHcbHtDAXhBo+NoukAWQNK2UBzm94SIF3btGrV0zR1kPJW3AxmOuA0OOyFLOFkcinE2YowBQ==.sig.ed25519"
}

{
  "previous": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
  "sequence": 718,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521143725879,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%n+++3OoNNozkyeZhI4A5waruAnSOt8W9mbwEHv92IC4=.sha256"
    ],
    "packs": [
      {
        "link": "&vVqXxfn9E8QDrF+H64Z8l8ZJ0QEi0hkcN/Ba5wYhZko=.sha256",
        "size": 2362
      }
    ],
    "indexes": [
      {
        "link": "&zvp5pSj72KRKz1yswX3H5ULLIdT57NmdMXqDDghaWSE=.sha256",
        "size": 1352
      }
    ],
    "refs": {
      "refs/heads/master": "896a66ef8d938326c0affb44db2f34fa3c6af9cd"
    },
    "commits": [
      {
        "parents": [
          "591c7c07e539a1db10fb0f9b9b6425e9c7f9058d"
        ],
        "title": "Bump version to 0.1.1",
        "sha1": "896a66ef8d938326c0affb44db2f34fa3c6af9cd"
      },
      {
        "parents": [
          "4f24c86c5fd5958222ab4a8ff0d3dbef82a08ce1"
        ],
        "title": "Really remove test rudiments",
        "sha1": "591c7c07e539a1db10fb0f9b9b6425e9c7f9058d"
      },
      {
        "parents": [
          "f670dfa4822ec9140a691afc9d22e0b367e48566"
        ],
        "title": "Remove test rudiments",
        "sha1": "4f24c86c5fd5958222ab4a8ff0d3dbef82a08ce1"
      }
    ],
    "tags": [],
    "num_objects": 10,
    "object_ids": [
      "29be4307de56ff197066672164a260be2efef70c",
      "35981e043f16a55d401baeb796ee2e353c9f0d94",
      "edec066d637d6885abd8581603e5e61792f3be86",
      "5d0b15b57cf3a7ee74922ef60e2ae4aba2c1b56a",
      "f782bc000902f18377cd530cc67cebfe7de80282",
      "870457580f6663bee83fa748f5740aed412fa623",
      "67dde4c6822a0e0621727effc257f3145fb3d570"
    ]
  },
  "signature": "A5v7g7gHzB6EL5b7+gfZMkXkV0DQiUf215hEiFzQ5UCDCikX7e5zpayTn0hD3VrpofggR/PWGrke+gjd9ZKgDw==.sig.ed25519"
}

{
  "previous": "%oAAR1+otxji4JuxYmezCek2S/FqzmAI/aUm5AhJaFlQ=.sha256",
  "sequence": 719,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521153228175,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [
      "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256"
    ],
    "packs": [
      {
        "link": "&qQdP4eiANgz47Mja+TyAgFJ/+fcN9X7hGnNboP6Rx9I=.sha256",
        "size": 15307
      }
    ],
    "indexes": [
      {
        "link": "&sG2pXNmQmG/FTMiR8JGf1Aebe00azw8CJLTRuoEWPOI=.sha256",
        "size": 1660
      }
    ],
    "refs": {
      "refs/heads/master": "d572a8d61dca32d3c440be8fa42d578ec391e195"
    },
    "commits": [
      {
        "parents": [
          "e0973f5e388d69931704fb0c63b03f1d16aa2f22"
        ],
        "title": "Add remaining_bytes to encoder future",
        "sha1": "d572a8d61dca32d3c440be8fa42d578ec391e195"
      },
      {
        "parents": [
          "ec55231d4bb1e0f57c9a43e4f364e60d86b3d1c3"
        ],
        "title": "Add decoder and encoder futures",
        "sha1": "e0973f5e388d69931704fb0c63b03f1d16aa2f22"
      },
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "ec55231d4bb1e0f57c9a43e4f364e60d86b3d1c3"
      }
    ],
    "tags": [],
    "num_objects": 21,
    "object_ids": [
      "da85d28082b3a5485b6b5e2015c23e707b45a2e3",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "cce05c998551f2a90a95dbb9e6de2cd76df311ce",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "5f8281609863bbc49c42390ddb6b3daf5204c85a",
      "612690bba14ef69155f6252cf35d057ba4097166",
      "4aebc7db31253545b81a639e7c2053154c0bfa34",
      "4c74f1cc320daed607412da86e0d5e2228c5dad4",
      "a47926e2e871bd824d2861790fb80c22ba2945b2",
      "4b8363856c208a8e065ad7c6d62c5a7c6cd3137c",
      "6233356dbd6826c3856496a79906750cd34fb204",
      "b0b541f1255a64c9eea5e0f27c4e3df736a29556",
      "52199247a111689ccb611194690b303e8a363aba",
      "21be30bcb0ce05d17c721553a1c90092d184b103",
      "2ba95a4f1f47e21cca15cecf922dd5b822c68572",
      "1afa8df7fa44b59abf9d34db8611d4e21b2c8399",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "vwL1VzVH61p014WuoNNwRpPvpsO+GczcYBYcWiqMSuMr6h4FzRc4WHB5mK48DwYxfz/DBnqYuaBcR30NJaVeCg==.sig.ed25519"
}

{
  "previous": "%pnlx8+LHBgFvoLd9HtyuTVaCTbdnkTaEPAK9CB349Js=.sha256",
  "sequence": 720,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521153737932,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%pnlx8+LHBgFvoLd9HtyuTVaCTbdnkTaEPAK9CB349Js=.sha256"
    ],
    "packs": [
      {
        "link": "&vF2p5pv4seX19b//0b058NetWg4M+IJOtixrl7gW49E=.sha256",
        "size": 1425
      }
    ],
    "indexes": [
      {
        "link": "&YcVo6e7s7rONkqod+hfJ7b9fuVt9I/zKTM3HpCRdEso=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "90115f18f742fb3ac639397495dfb2efadd390a7"
    },
    "commits": [
      {
        "parents": [
          "d572a8d61dca32d3c440be8fa42d578ec391e195"
        ],
        "title": "Make remaining_bytes on encoder future public",
        "sha1": "90115f18f742fb3ac639397495dfb2efadd390a7"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "e7219935a063dd93770f066ddbf0ec12728b0836",
      "0b63c7325d6f47dd0bb01f468b30b411a3a508cf",
      "91353127aab88ec0dff5b8ca2efbc2c05a8abb97",
      "c20ecc95d69788d39187bd939d72bc86d2e2cb31"
    ]
  },
  "signature": "oTsThDffUVUeNKky9OWCbnPPz4BLsSrDscjFWPNG4e56vjxuC1c+0dzwKDQrm1Dgnm6yXLRiJ7OWJHB+dbxiBg==.sig.ed25519"
}

{
  "previous": "%U6kboDMxxjHZHNcT1yZ1uS5Q7Po85c3i/5y+y5kcDxw=.sha256",
  "sequence": 721,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521206111409,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%iw6+mrC50uxYdAZ1QsvYCtOmxCPs8mh74THQ7A4QN64=.sha256"
    ],
    "packs": [
      {
        "link": "&0Fh98xrS5DzOuz14C8Z3mDYSB1TDqMf/ebwt7A9sZJc=.sha256",
        "size": 1537
      }
    ],
    "indexes": [
      {
        "link": "&XisPOHibvL9Sr9YgJ8ZPY4InRY6hyIqnmMe5TZqKLOI=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "a2e4efa4b55ce63a130f4b5f026748fca404993f"
    },
    "commits": [
      {
        "parents": [
          "c29fdf8e6935db87376d2471d5603b6c542fc096"
        ],
        "title": "Bump version to 0.2.3",
        "sha1": "a2e4efa4b55ce63a130f4b5f026748fca404993f"
      },
      {
        "parents": [
          "1190e643d2510b02320586968d126eae56a51b43"
        ],
        "title": "Add read_nz and write_nz macros",
        "sha1": "c29fdf8e6935db87376d2471d5603b6c542fc096"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "e99edafba4eba629d81ed0b30e4c369bd9266ea1",
      "fc7d519d78a2949f2ba1a23027b73bd815b81ba6",
      "dd87a1d1632a6ec8c5446e0736f27d8ca45e040a",
      "3f46cd34fdbbcffb54e8055b61564f0d8f637735",
      "a91b1fdd7b62d9c075bbf10c5cd5f0bcc971a799"
    ]
  },
  "signature": "3APq01ibiG3A1akZazJI3ULaEPISs5AF2VSCzgJ0ULFoLcF3sr3dNjr7+ysf3PpX8nqrWLW3iR/3PONmyUARAA==.sig.ed25519"
}

{
  "previous": "%NUvay8v4DazTwSQnGy8Sxprojx1yA047LqtW4U8YmMc=.sha256",
  "sequence": 722,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521207023331,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%U6kboDMxxjHZHNcT1yZ1uS5Q7Po85c3i/5y+y5kcDxw=.sha256"
    ],
    "packs": [
      {
        "link": "&bkbjcSO+Kn/EFEq0mLN+hfyp4uuWkNiem95mmK6BOU8=.sha256",
        "size": 1857
      }
    ],
    "indexes": [
      {
        "link": "&3v8Zqrzbw2t9CJbCXHaCqDrBT2zjI/58vJ/igB2H5tQ=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "1f8438023aa867bfdcb2ac3be2bcc30488521719"
    },
    "commits": [
      {
        "parents": [
          "c4ce796924c82a73e23645bd91c467d95a34348e"
        ],
        "title": "Bump version to 0.1.2",
        "sha1": "1f8438023aa867bfdcb2ac3be2bcc30488521719"
      },
      {
        "parents": [
          "e41162bbd06edfd2b5a72ea86d2849f6ebc0ef1d"
        ],
        "title": "Remove unused dev-dependencies",
        "sha1": "c4ce796924c82a73e23645bd91c467d95a34348e"
      },
      {
        "parents": [
          "90115f18f742fb3ac639397495dfb2efadd390a7"
        ],
        "title": "Add testing module",
        "sha1": "e41162bbd06edfd2b5a72ea86d2849f6ebc0ef1d"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "559e3b7a8b45e4a756c37e5196e943ed22313695",
      "0dc31dfc9393f55c3020fffbcaca20ea1c1afc73",
      "1a0752f0e86a7f0e2c17c35bb52b2775d10b9d19",
      "b7abe53e8339435e8dcc3507680460b845e2d810",
      "5a1d075dde8c7e25eca3c6675da0b7c8bf9c483f",
      "d7943e8f906f83b3367f4e53f40b391efef459a0",
      "82bc600da993f0b457d928c8f21890eb0b21e296",
      "9bca52d4fb713fce31f3ff82718dc7b2557e3fca",
      "e5b9754355b77a8a2ee111f613d87e29fd9d55c0",
      "ed4b0492ba028b749d72e48d85f9b1dbecdfb231"
    ]
  },
  "signature": "UiLfwbNPn+GUNSQcxFHUG36SCUyXjBtFZeY4/FEPurpBNhxGYh5puD4Gme1grIFI28M7uuyAxkQAD/yM8lWZDw==.sig.ed25519"
}

{
  "previous": "%wShM7J5z5EQAFRFxjOhO4LNf0XXdQg0o9afDakg2pC8=.sha256",
  "sequence": 723,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521207077707,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%wShM7J5z5EQAFRFxjOhO4LNf0XXdQg0o9afDakg2pC8=.sha256"
    ],
    "packs": [
      {
        "link": "&VqQy2qYPUkJlXgmW6pnlURu5vii6QQ9abnO3ZfZ5lSE=.sha256",
        "size": 1428
      }
    ],
    "indexes": [
      {
        "link": "&Mp8Y1eXcJxv+Hfxf68hsB5jjgE+mjob/ezakaGfzaRo=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "579d2e3f9a1ddc8523d200a496be0ca5189f1b23"
    },
    "commits": [
      {
        "parents": [
          "1f8438023aa867bfdcb2ac3be2bcc30488521719"
        ],
        "title": "Actually add testing module",
        "sha1": "579d2e3f9a1ddc8523d200a496be0ca5189f1b23"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "e474d904d8cc4f652d6beaaa2f53edac8a58a724",
      "b9963453b726e33199829939b2d35ab499faceef",
      "c11f996b8b5d74c5d332732ea1495fbfb328936b"
    ]
  },
  "signature": "ZVdco2nNXvAqUgFE7RE8R8hMMyXDUqVkgm/irTXq+CroBzyxD1tOUcireqXij9j3CEko93p2FpqV5+xrLgFxCQ==.sig.ed25519"
}

{
  "previous": "%KF9iX2YCx0BZgQwQ+w7OnFrb46M1Kj+fa3s4o7Zk83o=.sha256",
  "sequence": 724,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521207276395,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%GivAebTqNR/2zNM5zJYWeADiGDHrfZemmrWg6dLEvc8=.sha256"
    ],
    "packs": [
      {
        "link": "&2XJYaVzk2CG4p1P3BztDGIHKtGLLJIaMfJB/rZUXZQI=.sha256",
        "size": 4824
      }
    ],
    "indexes": [
      {
        "link": "&wePOa+E0uGxCjgnDG21RuxMVE6dGSYGx2w7IC/LXQm8=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "3e9ecbbb587589ca8115b7de86ea24249fba1d6a"
    },
    "commits": [
      {
        "parents": [
          "9dfffe248c2f4d86a211a7916f5f823b08414623"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "3e9ecbbb587589ca8115b7de86ea24249fba1d6a"
      },
      {
        "parents": [
          "41a70a6d4620f3676fe0faa7bb3ec4a88ebce3c5"
        ],
        "title": "Switch to async-codec traits",
        "sha1": "9dfffe248c2f4d86a211a7916f5f823b08414623"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "aabd5b928535c59227d33bef47e73edcd1da9870",
      "822026b3780a74c3f05d63a8296ce8c667d13e78",
      "1d6dddeb4ef73f1d7e9dd95fd6090164397a193b",
      "ca8c6533a427a1fe473256483cefac0da295c324",
      "f48a0cb9b3255debee527bcdd88b06022ee34f86",
      "0de208fc92f5a0ddc295d47bd61130e1f35c6116"
    ]
  },
  "signature": "7e3HJbCoHVarq7VEYFjYiGC29YN3KibVoaXvcDpCGcvf5wcYG1tZqcRumI0BNb9lnQrUgNgQkQaLK9QXqVweBw==.sig.ed25519"
}

{
  "previous": "%JcujYuB2TlUO0m1vEgf20EAFsMY0AJZao/mSUNV07T8=.sha256",
  "sequence": 725,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521212739614,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%NUvay8v4DazTwSQnGy8Sxprojx1yA047LqtW4U8YmMc=.sha256"
    ],
    "packs": [
      {
        "link": "&mpEq+9tdgw9aE6XhYjoJglIOMbBnQHRNOyfjABBqNs4=.sha256",
        "size": 700
      }
    ],
    "indexes": [
      {
        "link": "&KB58zdfvXNHKI5rAqV5vsf5YGJcBYFn8Xdfet9GaBlc=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "9bcdaa759aa825c7aacf295e831df7e0ed52fb8b"
    },
    "commits": [
      {
        "parents": [
          "a2e4efa4b55ce63a130f4b5f026748fca404993f"
        ],
        "title": "Use try_ready",
        "sha1": "9bcdaa759aa825c7aacf295e831df7e0ed52fb8b"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "742fda914fab43a583785b4ca2686b8b6b6b5340",
      "d6522308cbee02f0c5ff16bddb9cc939805efd1f",
      "5f922e170eef6aa2114ed487ce39be3737986a46"
    ]
  },
  "signature": "m/jRZL+T2+Otcdca+onX7PabrgQ5AVAwyl4sroU3AnW/c/JASsV42SKV0eWOe40DZQEBzSEQJx8h+rZhQM/NCQ==.sig.ed25519"
}

{
  "previous": "%RNtWv4k1qXA5ZK6lSRrHRfuAJgcYKLBq5qSaqVP3bFQ=.sha256",
  "sequence": 726,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521213031655,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%RNtWv4k1qXA5ZK6lSRrHRfuAJgcYKLBq5qSaqVP3bFQ=.sha256"
    ],
    "packs": [
      {
        "link": "&zm6W6kXu2NY1qZzb+Upkc5dVD7OeFxl4e7BBevx4hsE=.sha256",
        "size": 1069
      }
    ],
    "indexes": [
      {
        "link": "&0jDFzcYP6QWn8Qdy5uRPpTvP65dCrs/p3zHSf8tx/gQ=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "1ed478a2eb9eddf8238f8bb1de4cb0d3ecb4e869"
    },
    "commits": [
      {
        "parents": [
          "9bcdaa759aa825c7aacf295e831df7e0ed52fb8b"
        ],
        "title": "Try pasting try_ready",
        "sha1": "1ed478a2eb9eddf8238f8bb1de4cb0d3ecb4e869"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "00242e36cdc0eb6383ee3fb96650aa49fdb87f73",
      "2f7e97aecdb5f84265fb71f3c2c52442bd13547b",
      "099a666687701ffd079ef653e2c675f5a28e9d5e"
    ]
  },
  "signature": "SKX579Z++rYLn24epVwgGE8UDgzCH70x2roBur2wbvVuJebkqGTo69DONI73dZwrRSlx2Ll82MteV11AufkIDQ==.sig.ed25519"
}

{
  "previous": "%aOaPzMj5lm84QcesOLZfyjOfnTVmlwhh4rT0VWA1hug=.sha256",
  "sequence": 727,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521213393183,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%aOaPzMj5lm84QcesOLZfyjOfnTVmlwhh4rT0VWA1hug=.sha256"
    ],
    "packs": [
      {
        "link": "&rwJXeUk9QMqLwuCF0OkFNbklKvaEUcTYKMB9M+yZQ7c=.sha256",
        "size": 1253
      }
    ],
    "indexes": [
      {
        "link": "&LSLypecEiCXCRwu3t5lX20weEK1mFkqSczjs+E9tZ48=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "ce45506407868ed6551e4a491a9e4e6612d660b3"
    },
    "commits": [
      {
        "parents": [
          "1ed478a2eb9eddf8238f8bb1de4cb0d3ecb4e869"
        ],
        "title": "Inline the try_ready part of read_nz and write-nz",
        "sha1": "ce45506407868ed6551e4a491a9e4e6612d660b3"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "692e8a5b3390e49f2699886f9cd9268db2702453",
      "cf713890fe9b158c23010918171242e397e58a8d",
      "ccf5297579270f329bda7041bf7b0bf6fd253b35",
      "fa779d0fa55f3191c91259b700c5de7886b7c50d"
    ]
  },
  "signature": "YrCE21YffuUWRyx2tvmwK5EGCRlB+fqknBVHcpg+vVTUreyqRNQFzWgFn6xzeeI5dDH5j5KmKCWWNuBCiafzDA==.sig.ed25519"
}

{
  "previous": "%7AAk8fLEapBsyrdbZZ8A8rv7bJ1q54gg14c0ZYUlKF0=.sha256",
  "sequence": 728,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521214269919,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%7AAk8fLEapBsyrdbZZ8A8rv7bJ1q54gg14c0ZYUlKF0=.sha256"
    ],
    "packs": [
      {
        "link": "&mg4vs1P1vK/XcrOru7KU18+U0AktyYp9k/ZRCD3B/VU=.sha256",
        "size": 675
      }
    ],
    "indexes": [
      {
        "link": "&wPt/E4fbXoccxFx+z1bRcj3Nhawo51k4wCFh7lXlPiA=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "89bf1808e70601af25d8d8fa7c3151f05a95ad4a"
    },
    "commits": [
      {
        "parents": [
          "ce45506407868ed6551e4a491a9e4e6612d660b3"
        ],
        "title": "Bump version to 0.2.4",
        "sha1": "89bf1808e70601af25d8d8fa7c3151f05a95ad4a"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "13ccc2c380d7337c8a54018a94c975052a46c5d2",
      "f73e6466c8c1c6cd5eda33b6d6ef99bdee7754f8"
    ]
  },
  "signature": "sKUmdiJr0H0zxlnliPQAz+bdS/XHjokCA1YlOkmOO/NWgVLezBc6ZoW+pLWG0svrD1rDWuXilBAy3uWC7fSzAQ==.sig.ed25519"
}

{
  "previous": "%lTli8wC7PRljOhMd++fVIU8ltImiCyVZHfbhIWUKLYw=.sha256",
  "sequence": 729,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521214630424,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%oAAR1+otxji4JuxYmezCek2S/FqzmAI/aUm5AhJaFlQ=.sha256"
    ],
    "packs": [
      {
        "link": "&VuELU/i3IEWEEIxgOm1UaulMsA0aWT8oKHXsILS1BZQ=.sha256",
        "size": 2048
      }
    ],
    "indexes": [
      {
        "link": "&GaFFECVqfXC76JE7MuN9qNR/LaHO4RpFp1xyOBX50ZY=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "3382be052d208fbe57329612118385a0d7f506e1"
    },
    "commits": [
      {
        "parents": [
          "1ca101cb282260b04a90a376cf47aef93bca453c"
        ],
        "title": "Bump version to 0.1.2",
        "sha1": "3382be052d208fbe57329612118385a0d7f506e1"
      },
      {
        "parents": [
          "896a66ef8d938326c0affb44db2f34fa3c6af9cd"
        ],
        "title": "Clarify docs",
        "sha1": "1ca101cb282260b04a90a376cf47aef93bca453c"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "fe89e3038256045ae7a72ac0face6e91e02c0f88",
      "08a984bc6438d5527275635960158c54eb28f127",
      "d5e66eb934f54a09c55044227d961e0e08f769c5",
      "4db74bbf1cbe9cac93c8da9e9a678947364612d5",
      "0f4b6469b7256e8eaadac169c2c404f885c7beb7"
    ]
  },
  "signature": "re/b8NPXNArcB/8AWGeYjJoSWTfN/jn96qE6awuDds++hsDfAQTFX7HE0LIZR8yPaJUVw9Ul6NbtfB+kvr2YAw==.sig.ed25519"
}

{
  "previous": "%Np3tqT0JSvcCoZy2PNdKWreifUAg2FQqfI9M8kdfUXM=.sha256",
  "sequence": 730,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521241570499,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%KF9iX2YCx0BZgQwQ+w7OnFrb46M1Kj+fa3s4o7Zk83o=.sha256"
    ],
    "packs": [
      {
        "link": "&bQGDV98voPGetrcKKuTj3Bk174fRuv0jB2bhlxaA4BQ=.sha256",
        "size": 3682
      }
    ],
    "indexes": [
      {
        "link": "&ioju4ZLmXbpp/fYw0rJSCDic3s/e98XUq59Lb3tbaUM=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "30daeb582b0affb29a216dbd1a3c70d3053ec192"
    },
    "commits": [
      {
        "parents": [
          "4d56947a042042f0bd71fb1b069b443f88831929"
        ],
        "title": "Bump version to 0.1.3",
        "sha1": "30daeb582b0affb29a216dbd1a3c70d3053ec192"
      },
      {
        "parents": [
          "579d2e3f9a1ddc8523d200a496be0ca5189f1b23"
        ],
        "title": "Add encoder chain and decoder map",
        "sha1": "4d56947a042042f0bd71fb1b069b443f88831929"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "f9f5240d4f52c87220465302bfb84e9a77207345",
      "92dda4b57c256f1e7094f52a1aec649f97c19ec5",
      "e25bb8675bb3d0dfaaf213833ad59a2b01e889e5",
      "86783b0a1d7fecb9e445300901b53f1407d4ec4b",
      "670506170254b34520e15f0d2078fb86ecf96c64",
      "8532ae7716bed608e8e1b16139ab07d01338e4ad",
      "9c302015ac74b99050487e164f461af8955f00b2",
      "30044f65335997a262786217f110050bf8da20f1",
      "184ac52aabdd513bef8e354855fc234021786e0e",
      "add2449a96d4352c6bed7c135740e6b78be6c45e",
      "8a2efa4b0a16805757e007939a65cd46a96daf55"
    ]
  },
  "signature": "LZFAJXtRXhpUtv6iyrGKnrIUzHZ7UxqHmUBUynrRlLSFKamlBDC1TDEP7eHyE7r/l43vkzvYIBO1Df+UPtcPBw==.sig.ed25519"
}

{
  "previous": "%7c9p2aT4mVhlEgKuEkpymAen4qANHugIGtISTf0Fk88=.sha256",
  "sequence": 731,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521241916375,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "async-byteorder"
  },
  "signature": "8bmEZQwj3DaSnPfKSe4TGYVVm6OtdN1owIiXSYej4g7cVDpP/1OQbVU1ImuUEZJaITpd4YnPzLODJSsVSSCFBA==.sig.ed25519"
}

{
  "previous": "%VLqvnWfMWx1Wur4FHCz1B/Gv0n92VmbNeRePwjk8tcA=.sha256",
  "sequence": 732,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521241923547,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%VLqvnWfMWx1Wur4FHCz1B/Gv0n92VmbNeRePwjk8tcA=.sha256",
    "refsBranch": [
      "%VLqvnWfMWx1Wur4FHCz1B/Gv0n92VmbNeRePwjk8tcA=.sha256"
    ],
    "packs": [
      {
        "link": "&p9oI5Zp68vgMQ6ytgn4qHn16ljz95Ut6AwoKPemfeX0=.sha256",
        "size": 25595
      }
    ],
    "indexes": [
      {
        "link": "&SsKIyZJ8JBf3wUaJGB4wMy4JQzI1dj7JFscz55ZExkg=.sha256",
        "size": 2276
      }
    ],
    "refs": {
      "refs/heads/master": "4bb00833e6f643a1a4c15c691f94168d64d85fbb"
    },
    "commits": [
      {
        "parents": [
          "f9e1bbf8210ace81796198e5c857786ed1ac1a87"
        ],
        "title": "Change license to AGPL-3.0",
        "sha1": "4bb00833e6f643a1a4c15c691f94168d64d85fbb"
      },
      {
        "parents": [
          "678bbc747c40f764838a2c0f3a775530a62ba9d3"
        ],
        "title": "Switch to async-codec traits",
        "sha1": "f9e1bbf8210ace81796198e5c857786ed1ac1a87"
      },
      {
        "parents": [
          "64aebbb73384d147b6adb1ed09a3b7d8b762fca9"
        ],
        "title": "Flip argument order for writers",
        "sha1": "678bbc747c40f764838a2c0f3a775530a62ba9d3"
      },
      {
        "parents": [
          "5bc7f14d1e509e9f50951ca9d6699f2591df564e"
        ],
        "title": "Fix typo",
        "sha1": "64aebbb73384d147b6adb1ed09a3b7d8b762fca9"
      },
      {
        "parents": [
          "1d68c70842aa81e7de4cb32ed52b74636c530b0c"
        ],
        "title": "Support more ints, including single bytes",
        "sha1": "5bc7f14d1e509e9f50951ca9d6699f2591df564e"
      },
      {
        "parents": [
          "7a7520209d47d85a448d5d7271b9b43b08340bcb"
        ],
        "title": "Macrofy everything",
        "sha1": "1d68c70842aa81e7de4cb32ed52b74636c530b0c"
      },
      {
        "parents": [
          "02da8d60472b960d4026f5f8949180a18b884d45"
        ],
        "title": "Return ownership of readers/writers",
        "sha1": "7a7520209d47d85a448d5d7271b9b43b08340bcb"
      },
      {
        "parents": [
          "b552d739c74952d5ceea10aa63f944b3e2970ef6"
        ],
        "title": "Implement u32 readers and writers",
        "sha1": "02da8d60472b960d4026f5f8949180a18b884d45"
      },
      {
        "parents": [],
        "title": "Add initial draft",
        "sha1": "b552d739c74952d5ceea10aa63f944b3e2970ef6"
      }
    ],
    "tags": [],
    "num_objects": 43,
    "object_ids": [
      "7329f79ee343f89fbe24fe2dc485d7e4f97a82f4",
      "4308d822046df995d72605f3497d02ae5ae307d8",
      "63adc3ca3ab6c2b0b990c8f5f4092d1e6fa3092f",
      "b743e04edb76e46bc907203fc9df6ccc85e60591",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "58734269cdb85b1c2ca34dc57df01baef4df4a3f",
      "81988a0c193801d988cd14802fb185a8a0d91e24",
      "f89fa50858914f10b65867dd007b68e2da1b6691",
      "af0cfef01f2a91a9067f4a8c8a08d5f9d0579135",
      "7f7d930092bd36d80af8a036f08380ac20945802",
      "12f0d73c827eb478a37844cfa393413baec45433",
      "fc34dbf4cbeb05e55ef66937e6c1042d46cc670b",
      "b2b47652ebe19614a2d6bc40528bcd4d868be930",
      "84e3ece1f5d497c941b49e1ca9d12084a48479b0",
      "6a95d29aeb887830994c1deb3ca89baf30ee334c",
      "3d6f3daa0910275354cb576468ee32c613a20e44",
      "47876c45d1fd418ecbf1f3f7944f6822593b001a",
      "377f2136535e0ac09555bcba23ee42224ba9be4c",
      "615fd0071ca678d11ebc8e7db8cc28f7ad7f0cd6",
      "dc772aba5d7ad2e15981c3c3c98e12dda8b21fbf",
      "e6f949efc2d992f7030ea0740daa59ace87a6f07",
      "4b453f585f24dd89641b9a723ac98911c5b188c1",
      "fc626020d667e2cb7792151ef86afd76f4a01234",
      "3f068795325e1efe5059f19876da62949d5aaee4",
      "0ce771d2ac7ea671513cd086ad194a82c9ed1d5e",
      "671073248f993e555d66d02d8f2e1933b2221934",
      "fc0bf8bbdb7e9492dbeef36ca546d82ee431b012",
      "d625cfd2b0a016f739ac1c7b765bac42217c5991",
      "2fd4c159f4d0f72e57162da436f9d9ca5bb1692b",
      "1d0be6244dddbb9bee51bf218de95e84f5c04db9",
      "b9eced7190c060d2c08538ef010f66e139d36c7d",
      "5ad01b6b829c7b791caa5cf4e79f0f75de55b8f6",
      "e1043cda300409a8c33d4b40015058225bad220b",
      "5c9dd432642648efc359ee40b89ab81b3d696068"
    ]
  },
  "signature": "6Vbx/Mv+KUYsFfGF2NS+dSPIDnv08UrOGl21DZUKIvTZtwQJWM7+AXzYqhdIXcrl8jw8pnxSxc1gpFCD0OvHCA==.sig.ed25519"
}

{
  "previous": "%DZrf3Fi2eXOmO8BoAUq056DmzMeOWtjGLO0muQoDotc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 733,
  "timestamp": 1521273793535,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%d5gv/qcOJiI2ow7VWpZ20LJASksEOtP4asjW28nMyvw=.sha256",
    "branch": "%d5gv/qcOJiI2ow7VWpZ20LJASksEOtP4asjW28nMyvw=.sha256",
    "reply": {
      "%d5gv/qcOJiI2ow7VWpZ20LJASksEOtP4asjW28nMyvw=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": "erlang",
    "recps": null,
    "text": "This might come a bit late, but there's a [test suite](https://github.com/AljoschaMeyer/shs1-testsuite) that runs handshakes over stdin/stdout, both correct ones and faulty ones. There's also a [readable js implementation](https://github.com/AljoschaMeyer/shs1-crypto-js).",
    "mentions": []
  },
  "signature": "zMMPYmrnLVeIWwWeUHhufcQwoAXjyrMUWEeNBZNA9/UZkCsGO7z7cHKCwyDh5ST28XzWvr6EMHoFg/7ddHHYBA==.sig.ed25519"
}

{
  "previous": "%xMcl+D/xLHJZVIyKVC4RFSg7zdD2YEQ/QP0IrVjpFus=.sha256",
  "sequence": 734,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521281931221,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%7c9p2aT4mVhlEgKuEkpymAen4qANHugIGtISTf0Fk88=.sha256"
    ],
    "packs": [
      {
        "link": "&3KwTzzTLy0as+mic05J+LfAQ1LxW5QpjwrN4kNmySYo=.sha256",
        "size": 4209
      }
    ],
    "indexes": [
      {
        "link": "&o7pZuedbg7PUiM4TGW2RyndN4Rtmpl1oil/svCjzFBE=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "fe3d519ae3a750e13056cf705838ca404c799636"
    },
    "commits": [
      {
        "parents": [
          "8db8d5723887df90de1a831c7a0cd58520992e17"
        ],
        "title": "Bump version to 0.1.4",
        "sha1": "fe3d519ae3a750e13056cf705838ca404c799636"
      },
      {
        "parents": [
          "30daeb582b0affb29a216dbd1a3c70d3053ec192"
        ],
        "title": "Add decoder chain",
        "sha1": "8db8d5723887df90de1a831c7a0cd58520992e17"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "93bfbc76c7da07a2407edb2abdc341ec802d48a8",
      "b2109f4e09a0b8cad5772c0ab6cbb566977e96ca",
      "9a2fba44ef8dfb65e8984e4c5a5b2d7f2606a113",
      "1a5924d7558bb2d9a092799521a5a02d1bf8c01b",
      "addc7d58f0a301a8692372d685d5c3a18db54a22",
      "767987ff0e8a69c748c823905f316c1609388ec8",
      "e4618c2454f17ad45d4b8f4d727022684e4f1438",
      "7cc0ade4cd48a84c5c83d128b17aa6cc07cc5aa1",
      "a9857c1bd9a7dfb3ad1e1f963ffebe437929d3e2",
      "b780c9b46a423011b2b2ff31d21c9a895581bcae",
      "bd49798720a3bf7f049bb05fb0020c7793c610e1"
    ]
  },
  "signature": "brymAek7bTJnfynfQvSOkIxDw88RSOiNDe2PuSyQZ/xzYZwy71U16+ZJFDG/cRVSyeMyDkpikBqWjodve3GzDQ==.sig.ed25519"
}

{
  "previous": "%6lpCfYacMYf2YFMEZMQy6WVYTGU8zBjZ6xhyYyIU/A0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 735,
  "timestamp": 1521466425261,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%u79LEOEJdYbs/up15Kn2LVixKw+5a9KqXDkeilv8wc4=.sha256",
    "branch": "%L6uod8cjrlaNQxJ4cmCWsNZoNdjWXeQp6dThg5RtWuY=.sha256",
    "reply": {
      "%u79LEOEJdYbs/up15Kn2LVixKw+5a9KqXDkeilv8wc4=.sha256": "@sHFNLAao6phQ5AN17ecYNUbszDa4Qf6DhyQsjtQfdmY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I disappeared directly after the talks, socializing over shared drinks just doesn't come naturally to me (having been hungry and sad certainly did not help)...\nBut I'd still like to attend more meetups and actually talk to people. I have a pretty good understanding of the technical side of ssb, so that could be interesting for some of you.\n\nSome *key* (sorry) feedback: Identities are referred to by (public) key, not by hash. But despite some of these small details, I really liked the overall vibe you managed to convey.",
    "mentions": []
  },
  "signature": "5pRepp0luEgsZke/9ILZgSTWfPVKUyMtXJajaexHEPHM38429Go8Ra5add6sqRQXc3gawONLQ6eONsz+Q17gBg==.sig.ed25519"
}

{
  "previous": "%hQQL3k3BrPacbL1UiAaOKeCicn80HDDzZ8R/ra0QVjY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 736,
  "timestamp": 1521467587755,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%u79LEOEJdYbs/up15Kn2LVixKw+5a9KqXDkeilv8wc4=.sha256",
    "branch": "%2/ZnGdbQYcjZR1H4QNj6CP4Bnv3oX8JFqEFQLwb0rpU=.sha256",
    "reply": {
      "%u79LEOEJdYbs/up15Kn2LVixKw+5a9KqXDkeilv8wc4=.sha256": "@sHFNLAao6phQ5AN17ecYNUbszDa4Qf6DhyQsjtQfdmY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Yeah, you also started using the correct terms after a while, that mixup just happened in the first portion of the talk.",
    "mentions": []
  },
  "signature": "R945rsysWpvGQXhTTUhM4PmyBPy8VcZPuDce9s5W1Lx4dSp5zlEIUpSgXut1H3yuajJBpW4v0t02xqGU38OiCw==.sig.ed25519"
}

{
  "previous": "%TYQ1rvZfvFvhG5Mk0tceLYujqDUASpJVnEcTBTg20R4=.sha256",
  "sequence": 737,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521468372537,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Np3tqT0JSvcCoZy2PNdKWreifUAg2FQqfI9M8kdfUXM=.sha256"
    ],
    "packs": [
      {
        "link": "&YaKfG2zXppWkfbaS+FMZhB0rGf6/Ov7eftYk0Jbc764=.sha256",
        "size": 1872
      }
    ],
    "indexes": [
      {
        "link": "&s0Ue21HJA/7nzD+VaFyV6gA4dx3QNdkPi9+uGHev5o0=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "a1f86eb703a4ad078f2543f82e1b7a60728e16e1"
    },
    "commits": [
      {
        "parents": [
          "3382be052d208fbe57329612118385a0d7f506e1"
        ],
        "title": "Switch to PollVal",
        "sha1": "a1f86eb703a4ad078f2543f82e1b7a60728e16e1"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "2227070bd712bed64d2d3816a2a01dd85c8e8360",
      "a39c61676da7afc48f319fc7deb16d44bcc6da34",
      "ed1c9087c0352c45eea94e8d5f2acf93a6e856ff"
    ]
  },
  "signature": "GiYZKXyww26XffUtVBbNsCLk2oJe0onpIO7XuUjnf3vbLGR1BdxFuDcvOFOlO5SbPs9OWVvL27ztNOi8JECqCg==.sig.ed25519"
}

{
  "previous": "%/vtSiyKoZ1TW5w6CQj+JQh5a/saIbYFBWdw6qnWgcX8=.sha256",
  "sequence": 738,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521468476922,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%/vtSiyKoZ1TW5w6CQj+JQh5a/saIbYFBWdw6qnWgcX8=.sha256"
    ],
    "packs": [
      {
        "link": "&6U7WtNWd629PVHP4CufXWwUTP3w2N+Lgm1hutUqhQes=.sha256",
        "size": 1882
      }
    ],
    "indexes": [
      {
        "link": "&REZB76KbszjSjQR62tzzBvXx4xzrUZJGWyYRkdJ8ljQ=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "cb93552175db337983f757f3d13aaff70cb6d9ca"
    },
    "commits": [
      {
        "parents": [
          "a1f86eb703a4ad078f2543f82e1b7a60728e16e1"
        ],
        "title": "Add Self: Sized bound",
        "sha1": "cb93552175db337983f757f3d13aaff70cb6d9ca"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "f8a2ff6425a3545f5689e79c91b11a216e56e309",
      "46eb4324aae2ce6bce2bf6f9bd1a66e90c38853f",
      "4654ab561657178a0bf89f58e178ce066c61183d"
    ]
  },
  "signature": "nL8NshSlopy/04btFhTDuiDFe2yht4BkZMnuwQ8VYsprJZ7CEMmXoZ/9UwpU/asPTShth98XNtiiUAWTp33sDQ==.sig.ed25519"
}

{
  "previous": "%sOHRqjDHmBFWz+mOBXBac9tqeuJ+D3uXs6dGgQpS6ZM=.sha256",
  "sequence": 739,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521469520778,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%sOHRqjDHmBFWz+mOBXBac9tqeuJ+D3uXs6dGgQpS6ZM=.sha256"
    ],
    "packs": [
      {
        "link": "&D6dK5ZzNH8ja9mzvaEiC+QBYGAo4nqrQfy6Ru56LWww=.sha256",
        "size": 1673
      }
    ],
    "indexes": [
      {
        "link": "&Z1nWoboO5K51UXLCqi+i+tDW/fEWbecEji/OwsX76Xk=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "6fbb568d4e4e1276c00de8eabeaa30fb3b6c76f9"
    },
    "commits": [
      {
        "parents": [
          "cb93552175db337983f757f3d13aaff70cb6d9ca"
        ],
        "title": "Use custom return types",
        "sha1": "6fbb568d4e4e1276c00de8eabeaa30fb3b6c76f9"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "4dc843db1c058a69e95a2043e031770ca2b57d3b",
      "8a714fc55925bf7cd650fddabf0fca727f194d4c",
      "f72b6fc2948e36e81be1d898d85e91232e1ea827"
    ]
  },
  "signature": "ccUMnrJjskKb7n+toJhAb5gkJ3yqPGNC2+2wAfHno0fj+I3mEbzaokeVpjhSonqe9+qhLGlXisoph0VOozPSCA==.sig.ed25519"
}

{
  "previous": "%8dJoaISxNYhn91v8mbXrRX1T5t5H4cTeZpukOCviYFc=.sha256",
  "sequence": 740,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521473028308,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%6lpCfYacMYf2YFMEZMQy6WVYTGU8zBjZ6xhyYyIU/A0=.sha256"
    ],
    "packs": [
      {
        "link": "&NANkI01nLqdSHWDU1tF4pFEjKi76zc8dJgmtSUqWwWA=.sha256",
        "size": 4353
      }
    ],
    "indexes": [
      {
        "link": "&VFdWx1S+HyZRqbKr+j5AUuhVkaWXxFhISGFO+vrk2pQ=.sha256",
        "size": 1352
      }
    ],
    "refs": {
      "refs/heads/master": "dc59bdc8b52434aa8c1b656877984c9eccda505e"
    },
    "commits": [
      {
        "parents": [
          "fe3d519ae3a750e13056cf705838ca404c799636"
        ],
        "title": "Update to value-based traits",
        "sha1": "dc59bdc8b52434aa8c1b656877984c9eccda505e"
      }
    ],
    "tags": [],
    "num_objects": 10,
    "object_ids": [
      "0050cac927e5c56beff5a8975d0af377e73cabe5",
      "bb271851ed68f540c6ce9b721a4e234140fdef36",
      "c97af31633f5df37c8d971c8997c2e22d49d9654",
      "9d16cf3d9c02834906bbbbc82868305268968897",
      "4d5be18e83e3d838961fdb7402656e77ec1f32b2",
      "fe9a661db3725df23a9e95700c8a6be407cadeff",
      "66db03b1c86425b37fa3c745f82e1ba1d05e6ef5",
      "fabbe0f2f50311a41e0b8fe8551a78a9525843cf",
      "b10afbe91c2e1d6f7e1fc68e7ab5cba25df3079e"
    ]
  },
  "signature": "7P0Rbhw6btGGM6Nn3PkTjbgJTpNo0ox2jkYErEbNX5ofUzgUlPg7sgdK3WmxS9AUs8++fxpC1rVvzZbS6wUnDQ==.sig.ed25519"
}

{
  "previous": "%m+tMaD5UhzxZdX2YAu4lt+p8IZpUxY2iRE3Jsp+8ur4=.sha256",
  "sequence": 741,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521550797219,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%8dJoaISxNYhn91v8mbXrRX1T5t5H4cTeZpukOCviYFc=.sha256"
    ],
    "packs": [
      {
        "link": "&dbjszq47mmd6e4oAzD9HmmcbHqxtuN6IAZp8fSayVjs=.sha256",
        "size": 1683
      }
    ],
    "indexes": [
      {
        "link": "&QUxFSZP8KtDzdawZr0y/9QJJv32Y2EfIM0Ilw53UTbc=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "93bdeaba1daeed126c189efdcbe9cde50c9e80dc"
    },
    "commits": [
      {
        "parents": [
          "6fbb568d4e4e1276c00de8eabeaa30fb3b6c76f9"
        ],
        "title": "Add number of written bytes to PollEnc::Done",
        "sha1": "93bdeaba1daeed126c189efdcbe9cde50c9e80dc"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "599eeb82c756fc9df1ae7685a3fa86dc06a5a144",
      "568208df3445e92f270dd4fabefe5a21732663f5",
      "80dbca764ba535d7f52d95adafe3b2fb8fb36ee1"
    ]
  },
  "signature": "b0kIvOf12/u7tOBOo2LRt0cLAh3duCKZrh0CfNWuEoqkn52CokpPJKPr7TBq6NbYWGxOiXmPKryxHdruNONzAA==.sig.ed25519"
}

{
  "previous": "%+8XFzBU3aaOa/2udA/fMvryfZPpIneHnagb2QwVHZKA=.sha256",
  "sequence": 742,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521551251665,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%m+tMaD5UhzxZdX2YAu4lt+p8IZpUxY2iRE3Jsp+8ur4=.sha256"
    ],
    "packs": [
      {
        "link": "&jAjhqeuZ/xjepfg17N7N5iPpat1LG6KJzsCCMS0b/RI=.sha256",
        "size": 2866
      }
    ],
    "indexes": [
      {
        "link": "&/aAZ/qwG+zgPUxX4IRPnKzqGCKbJ+0B0KPcMl0N705E=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "94195a71aac477c48eff050da9fa51856e7a055f"
    },
    "commits": [
      {
        "parents": [
          "dc59bdc8b52434aa8c1b656877984c9eccda505e"
        ],
        "title": "Add number of written bytes to PollEnc::Done",
        "sha1": "94195a71aac477c48eff050da9fa51856e7a055f"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "004823e0ef33f866766ad25ab56e7e550489cab5",
      "1b9533af0271fb72db2a07e0f6c0ed32e9ff042e",
      "13eb29f29c39f5f19f18fdb7e1a83fd6182a6ce8",
      "fc894d0845ddb8af460c8b38962e235b8f4d98b1",
      "5a3b30005440bb31e0eb388c5c6e98117341b75e"
    ]
  },
  "signature": "3GltJIsaIJXLctKhSOXuIMu06mF/8fDOd/2nXPkNok/En9gZo5luSX5EW1DmWEsodbN/UrEmeoWjssB0Q+XGAQ==.sig.ed25519"
}

{
  "previous": "%ezzFxttCiTcsYX7Jg0xGedE/0WGNVLcQw5rokKyLtg4=.sha256",
  "sequence": 743,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521551589320,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%VLqvnWfMWx1Wur4FHCz1B/Gv0n92VmbNeRePwjk8tcA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%DZrf3Fi2eXOmO8BoAUq056DmzMeOWtjGLO0muQoDotc=.sha256"
    ],
    "packs": [
      {
        "link": "&DYdWQm5ImqAyIU2w/2+ya0rzK9iUyFWqsOh28qFpEuU=.sha256",
        "size": 3675
      }
    ],
    "indexes": [
      {
        "link": "&ympE0d7TDwPggr92gl2AhzYordYF1l/1eyzQxYAoyIg=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "e99c05f16e53b7ac1678c20530497a84fd24943c"
    },
    "commits": [
      {
        "parents": [
          "4bb00833e6f643a1a4c15c691f94168d64d85fbb"
        ],
        "title": "Update to new traits",
        "sha1": "e99c05f16e53b7ac1678c20530497a84fd24943c"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "4163f57b7681a0abf193cba8c543411bbfc62cf9",
      "4f79756415e9a4ba53b531aea318dd40ebbeb461",
      "b3717cea2158a5cf353b74187ba3f0309b7e3a9e",
      "5bcf632f0701d9f60e570667760aed4cd677b797"
    ]
  },
  "signature": "qEoFOY1l/CPTVbgXSUpjVnGb+3zUYTR5Ej2TRBt9aW+MGZ/ZW3PI2EU5BIfEUANggE98BhbpPppB4ur/iMMICA==.sig.ed25519"
}

{
  "previous": "%ufukw54GcYyuILSQXT7MXqQ09V3OoggWqZ21ZjwB7MA=.sha256",
  "sequence": 744,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521552351868,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%+8XFzBU3aaOa/2udA/fMvryfZPpIneHnagb2QwVHZKA=.sha256"
    ],
    "packs": [
      {
        "link": "&LYTBd1+PfkNw6KbP+URvRWe+fwsKlo1OTzoLbJHzYHU=.sha256",
        "size": 2373
      }
    ],
    "indexes": [
      {
        "link": "&oX1fAl4bq48Gc0WCwPfmONx6NHBWWurXw9dGHL+zz4c=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "c39b9fe2584b3292bb3f58f3050316c09a1a9e14"
    },
    "commits": [
      {
        "parents": [
          "8f7fdc9b06e5ca44bc4d1c5cdf112518284fae58"
        ],
        "title": "Bump version to 0.2.0",
        "sha1": "c39b9fe2584b3292bb3f58f3050316c09a1a9e14"
      },
      {
        "parents": [
          "93bdeaba1daeed126c189efdcbe9cde50c9e80dc"
        ],
        "title": "Document value-based API",
        "sha1": "8f7fdc9b06e5ca44bc4d1c5cdf112518284fae58"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "ce83c36f05d0f22cc1ecaadcb4fd9dd9a09e1923",
      "d3c0fe5079e4f44d847a81da104f9da9979de5d0",
      "32d9657dbdee838fd45b425ad27054bed13031af",
      "6d2cbaafa85e0e7a84c7da21e80f81472b801272",
      "19d547a0488d61fb746ef4228d92bc3c2f4ac04e"
    ]
  },
  "signature": "PKsAgGT7jIaTn/A6FJqyGWhMWV07vwVJk2E+NSqW90YW/ySF9oNAooPnPPne/cy+Ilifg4o2OQPF1sFU862WCw==.sig.ed25519"
}

{
  "previous": "%SS+8HxEtGb/KZJxvIHUWUOE4rTKzQgjYekK9auWVjTA=.sha256",
  "sequence": 745,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521552724825,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ezzFxttCiTcsYX7Jg0xGedE/0WGNVLcQw5rokKyLtg4=.sha256"
    ],
    "packs": [
      {
        "link": "&lI8+/vx6LpWr7n5Eh7cXzKChZ4PGaWNXGlcfzqKVdrc=.sha256",
        "size": 1945
      }
    ],
    "indexes": [
      {
        "link": "&f1CiqvXQRq6mZMXX+P/nNrt2SiNKZUwgtiFsjDURxy0=.sha256",
        "size": 1240
      }
    ],
    "refs": {
      "refs/heads/master": "9cfd18bce676189fb53b28075f24b03983556b45"
    },
    "commits": [
      {
        "parents": [
          "94195a71aac477c48eff050da9fa51856e7a055f"
        ],
        "title": "Publish update to value-based api",
        "sha1": "9cfd18bce676189fb53b28075f24b03983556b45"
      }
    ],
    "tags": [],
    "num_objects": 6,
    "object_ids": [
      "84ca972cd412ff8bcaab0b3b39757a2f6ff982c0",
      "8cd96529394928917bfd8b94f6f4ee0d53f7f03f",
      "200a070b4f903816f714b92380e1e38ca04d7625",
      "a5cb64d9d6e351d5cd9030d6a0457af299e904cd",
      "c1c1294bd366794e6a4794c817f1ed32324de610"
    ]
  },
  "signature": "7TWqJWcH3Ju/o04Eepfkk69+XM/zzZlO2JVUE7feO6D6nCm9KRjPmLAkrTQOqz1vC6kmn6pYM6onYO0ws/utCA==.sig.ed25519"
}

{
  "previous": "%2ORfiFYkvKGMqhwRxWGh0MtZdrp5W7WeL8AmVGfPdXc=.sha256",
  "sequence": 746,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521553014012,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%VLqvnWfMWx1Wur4FHCz1B/Gv0n92VmbNeRePwjk8tcA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%ufukw54GcYyuILSQXT7MXqQ09V3OoggWqZ21ZjwB7MA=.sha256"
    ],
    "packs": [
      {
        "link": "&VSQWIRs3U/4YExlI5Ri6Q47Ag1BR9akgU/4hvZDIPhM=.sha256",
        "size": 703
      }
    ],
    "indexes": [
      {
        "link": "&9MkkE6DI/I5XgpjmFmpI40P7BzYON0cYG35mGpiOC6A=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "832a5c6998e9e72e4114f3d534173b1571052ecd"
    },
    "commits": [
      {
        "parents": [
          "e99c05f16e53b7ac1678c20530497a84fd24943c"
        ],
        "title": "Prepare for publishing",
        "sha1": "832a5c6998e9e72e4114f3d534173b1571052ecd"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "1260d5beb636caeb198cbef4b27b874e22b80f7a",
      "e3afbb7bd45764dfe66e017bc0d58c0109b4d2ba"
    ]
  },
  "signature": "h8JoSpC1UKmBCnL4gZrT16fFsbSculRjl48o8V8M+b5So7ZUb0ATOTo/zzdIIDZzzLbilA8kHlESWXgwGqjkDQ==.sig.ed25519"
}

{
  "previous": "%tdtDcdNzDfIvYNAU4pCervGTih4F3/PwV/UiPn5T/30=.sha256",
  "sequence": 747,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521553323464,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%2ORfiFYkvKGMqhwRxWGh0MtZdrp5W7WeL8AmVGfPdXc=.sha256"
    ],
    "packs": [
      {
        "link": "&Yaomy02xjGYPrSNxpMvnn+vBkPFD+lZhentFmKX09Gw=.sha256",
        "size": 3902
      }
    ],
    "indexes": [
      {
        "link": "&JXQ98f+VOjJpEkbl4jYMqGxjuzMSOOQFaROMmHBaNeA=.sha256",
        "size": 1464
      }
    ],
    "refs": {
      "refs/heads/master": "78f664f32484b83bda3564323bd277832974fed5"
    },
    "commits": [
      {
        "parents": [
          "fcbbbed5805a6594046be016e4b1d21d9dc51eae"
        ],
        "title": "Bump version to 0.2.1",
        "sha1": "78f664f32484b83bda3564323bd277832974fed5"
      },
      {
        "parents": [
          "139e453af1639762ce8e4ffb941c041d22c97764"
        ],
        "title": "Add back test code",
        "sha1": "fcbbbed5805a6594046be016e4b1d21d9dc51eae"
      },
      {
        "parents": [
          "9cfd18bce676189fb53b28075f24b03983556b45"
        ],
        "title": "Derpfix",
        "sha1": "139e453af1639762ce8e4ffb941c041d22c97764"
      }
    ],
    "tags": [],
    "num_objects": 14,
    "object_ids": [
      "89cb4eeae1be8a70439256a5c5b2552102bd63a8",
      "b7eed2c58bbc045d790b284d80f067c09894dd1a",
      "f01f1661d95e65e124c7c7d46d0f64c8c5d9b320",
      "1b9533af0271fb72db2a07e0f6c0ed32e9ff042e",
      "13eb29f29c39f5f19f18fdb7e1a83fd6182a6ce8",
      "fc894d0845ddb8af460c8b38962e235b8f4d98b1",
      "3d29c50c231e84cc5782ec5276a80077c403110f",
      "dca2151e7859db8b56cd9ca9da16b688d8a5c70d",
      "00b20d2d297c5166356dc24dab45cfa8579cc0ec",
      "09f53eb81728661d44b5c3a62419e8039ff16551",
      "b47cdd43e420a127b1092cc0961d3a1202154804"
    ]
  },
  "signature": "C4bhKKEueajkmxh3VRZkz8ZZMOD88Ge3N9KGwJT4x4WiAoV1phh9AkMN8BVUVP9ERdW+do+29iPCTP75tBw3Dw==.sig.ed25519"
}

{
  "previous": "%bZ5a5nWR4d4cC6O51zQx9cPcvG8TzJCTvtjn0eVGdR8=.sha256",
  "sequence": 748,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521560494565,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%SS+8HxEtGb/KZJxvIHUWUOE4rTKzQgjYekK9auWVjTA=.sha256"
    ],
    "packs": [
      {
        "link": "&t10MYb1SSC5/rohc4fHkbQDFPfmWg3tUqhhS9fykXo8=.sha256",
        "size": 1927
      }
    ],
    "indexes": [
      {
        "link": "&1I/+OVjAfW2edIwM+15FqgDCK3BxaLoNe5NgM44oQ3w=.sha256",
        "size": 1184
      }
    ],
    "refs": {
      "refs/heads/master": "4daffdc761e26c3ef86153d2f4bc52d3852ab64e"
    },
    "commits": [
      {
        "parents": [
          "c39b9fe2584b3292bb3f58f3050316c09a1a9e14"
        ],
        "title": "Move reader/writer parameters put of the traits themselves",
        "sha1": "4daffdc761e26c3ef86153d2f4bc52d3852ab64e"
      }
    ],
    "tags": [],
    "num_objects": 4,
    "object_ids": [
      "d2d6355ed69e81533f28126de2d4fddc6327c2b8",
      "7297e4c205dccd3fc27ec48e33974bbe4dedde91",
      "a82210661e60c2ee5441f7982fa0503d68b69869"
    ]
  },
  "signature": "9zXwiZkzwm5LRljSBy01sRlHteAiF+cc/XWYo60VDMLq+gHGJTKSSFYG0e7GTjvRljlc8ttVfeHjOvbffw5kAA==.sig.ed25519"
}

{
  "previous": "%+4ZACFFIoN1c8weGAfZhAHUCnWnkvFr2zDZzeFvALGo=.sha256",
  "sequence": 749,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521561162976,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%bZ5a5nWR4d4cC6O51zQx9cPcvG8TzJCTvtjn0eVGdR8=.sha256"
    ],
    "packs": [
      {
        "link": "&5W2FQADpRO8S5Q2ZvySxKmyNauKpXOMNokjok+TP/jQ=.sha256",
        "size": 5534
      }
    ],
    "indexes": [
      {
        "link": "&2HW4ytVRZ9tKrRsCbN9z7oX2mCQ0LoU99SCh6eY27/k=.sha256",
        "size": 1436
      }
    ],
    "refs": {
      "refs/heads/master": "5ec4df3e34ff71364b710c3acb4912efd465027a"
    },
    "commits": [
      {
        "parents": [
          "78f664f32484b83bda3564323bd277832974fed5"
        ],
        "title": "Move reader/writer parameters put of the traits themselves",
        "sha1": "5ec4df3e34ff71364b710c3acb4912efd465027a"
      }
    ],
    "tags": [],
    "num_objects": 13,
    "object_ids": [
      "84be72452140b8ca9ea02ec0c8e1595b2013cbe2",
      "9e7bc077eb6f06964b0af933e8f998eb1995d566",
      "f53138f0dd16c9ab45adda7f94b974f63792ab27",
      "fad08a4e6eef2ddb00ed3aa81b7f1ebb63557adf",
      "f1d6380f1bcd0ca4403e5ba8439296858739d447",
      "4110094ed0aec6ca175bd7faddc9d17adc290e8d",
      "393455314c14b865bcd4caf18bcaf9c82814b9e5",
      "2860482d2f744c4fa693e708288a1ea2e06db2b6",
      "d5b6092355dd8b048f56b46d7ebb9d91b45d0ce3",
      "8a63377782f595a025a1d135f15b14655de0e4d7",
      "e14c4dd938a5d5aab261e1efd1f54e2eb91c72bf",
      "f39dd5cff3ef711bf46ebc45e2d42e973b6bd328"
    ]
  },
  "signature": "xfrAd7TU4brqIZda//RgytSLP+OAjTAv5OuoenfyBZVvs61dOLYOPHhQ9gjJm4BphGmmVhxuKd8Gv3TFd00+Aw==.sig.ed25519"
}

{
  "previous": "%XZfFYSW7zQ2yMb7XWsiHtfpIEFHwZpCqe4h2J8Sli1Y=.sha256",
  "sequence": 750,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521631320489,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%VLqvnWfMWx1Wur4FHCz1B/Gv0n92VmbNeRePwjk8tcA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%tdtDcdNzDfIvYNAU4pCervGTih4F3/PwV/UiPn5T/30=.sha256"
    ],
    "packs": [
      {
        "link": "&R4bRY8heZMAdMEK8f4hxATg3pzlGAgLE47Jkf+VxR+4=.sha256",
        "size": 3626
      }
    ],
    "indexes": [
      {
        "link": "&OjhqQPLAsI30V5RsOxRql9GKEOz+TbJ2xm+iFxR+1Ak=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "fb72b6de6610019bd48ebd5c4c2eb19caeb17046"
    },
    "commits": [
      {
        "parents": [
          "832a5c6998e9e72e4114f3d534173b1571052ecd"
        ],
        "title": "Move reader/writer parameters put of the traits themselves",
        "sha1": "fb72b6de6610019bd48ebd5c4c2eb19caeb17046"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "f11a99d20b334b53a1b3a8cd0250f55487aae714",
      "9a29277cf797fafb86768b79354ff83f0d52b116",
      "d8c3870f9912549c9c609c3d2fd56a2253ad8e76",
      "00a0b539927710a15aac5e9fafa52503933a8eba"
    ]
  },
  "signature": "AAdOWK7ZV7QMCBOOh4J8fqxI6WYlAQIUX2D62jBGVQYA6x+iVQlLAkCXjacHRSVBws8KxNF8qAQvgzrSRnxiBg==.sig.ed25519"
}

{
  "previous": "%MyE/LvB7jXMek3OQaS/UNaxHHu1hYpqsqY0HtKFovDs=.sha256",
  "sequence": 751,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521631413800,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%JGxgemwHraUI0Q7wOl71rCq228w6hdqh/SmRzUKOors=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%+4ZACFFIoN1c8weGAfZhAHUCnWnkvFr2zDZzeFvALGo=.sha256"
    ],
    "packs": [
      {
        "link": "&n/G22wDiPp59ZFaSeKQWSfSss+4+dQkPYm18VH3vXVA=.sha256",
        "size": 619
      }
    ],
    "indexes": [
      {
        "link": "&6fBULFTLzeaD3yQRqbyxK5q9RmR53PbJYgS7yxZwSFw=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "a3647fa1e1415869e6a168802a1fb4b84f41f849"
    },
    "commits": [
      {
        "parents": [
          "4daffdc761e26c3ef86153d2f4bc52d3852ab64e"
        ],
        "title": "Bump version to 0.3.0",
        "sha1": "a3647fa1e1415869e6a168802a1fb4b84f41f849"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "8f705de2e956c8f826f50fd6ab792533ea6bebc9",
      "8ae627d32571ecf146c925292ea204eb58c14f47"
    ]
  },
  "signature": "svltTPkmUzh1tM/zdmNutDsVrfs3pdOL9XQlcHHXP8yXraLGJqfw5/zAsHUOU3vpjTFsJ/diZKdZeaMypEcEBg==.sig.ed25519"
}

{
  "previous": "%/ba9dO231uDJVNNK5oM36Pz7RSeVusq3Qr235NSDDF8=.sha256",
  "sequence": 752,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521631526798,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%XZfFYSW7zQ2yMb7XWsiHtfpIEFHwZpCqe4h2J8Sli1Y=.sha256"
    ],
    "packs": [
      {
        "link": "&iklnRZ6heqtE/UtnQcrDqP8aGu7JXgOJAb0KJkfXbqQ=.sha256",
        "size": 2104
      }
    ],
    "indexes": [
      {
        "link": "&h0tNDc2L7QbV9XgpPNllo/sWDdXxr5Ile9ZkMpK4Im8=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "f4478a6ac42dcb41e9aabd1c44bbbf9a5c47cf16"
    },
    "commits": [
      {
        "parents": [
          "5ec4df3e34ff71364b710c3acb4912efd465027a"
        ],
        "title": "Prepare for publishing",
        "sha1": "f4478a6ac42dcb41e9aabd1c44bbbf9a5c47cf16"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "29e561a935f7ff0f113ba87a218164d6621a5fd8",
      "462be8e1e9223e4685372e12ecb7e3c440f507f6",
      "93e78c4f2a548067fe0ecd204ce7517f8db7dbe8",
      "2630e234423e01e5850e9f28228ce54f1e84bd1e"
    ]
  },
  "signature": "UJA0u5a+dCaD8LaXzuebyodu7hA2iZWYhqp/7jZ9pvUZYrmKtOFT9OEa9VqIyXgFMjTjqCB5Qp5PvlpXooP5Ag==.sig.ed25519"
}

{
  "previous": "%3/MSv4GciB+QozLW5RybdV911DdqRtRfNP933xzcG2I=.sha256",
  "sequence": 753,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521631604680,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%VLqvnWfMWx1Wur4FHCz1B/Gv0n92VmbNeRePwjk8tcA=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%MyE/LvB7jXMek3OQaS/UNaxHHu1hYpqsqY0HtKFovDs=.sha256"
    ],
    "packs": [
      {
        "link": "&N/iRI1yUp6w+1hJGajHodqzKIFc2Ybg4FfMBhbVhKCg=.sha256",
        "size": 703
      }
    ],
    "indexes": [
      {
        "link": "&ZmfPhjKdSnztYkK5kKTpiMJL3kh7nCdi2MAn5mNRv3Y=.sha256",
        "size": 1156
      }
    ],
    "refs": {
      "refs/heads/master": "3f2e29bd18bb644b003be8ae4194b8c55e33381c"
    },
    "commits": [
      {
        "parents": [
          "fb72b6de6610019bd48ebd5c4c2eb19caeb17046"
        ],
        "title": "Prepare for publishing",
        "sha1": "3f2e29bd18bb644b003be8ae4194b8c55e33381c"
      }
    ],
    "tags": [],
    "num_objects": 3,
    "object_ids": [
      "f4d7e8f6576bf77072f0f7f558edf6ebe149a3be",
      "a8e57bb50043a6226e56f910a1b2a0e140c1e27c"
    ]
  },
  "signature": "6G8FS3y8+KnCSPJqbqVvIiK29L+zRpW76Qudz/bC7o5/e0VNxZQ5iW2Hk/djm1cfCbnqsa61BzCcoLi6NVpyDw==.sig.ed25519"
}

{
  "previous": "%U7z/paoB4ysob5igPd08prCLw6YBLlQ0CZ134MuX6JY=.sha256",
  "sequence": 754,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521631709838,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%3/MSv4GciB+QozLW5RybdV911DdqRtRfNP933xzcG2I=.sha256"
    ],
    "packs": [
      {
        "link": "&FE2HNJhvejbbiB+Is9UvzK5cf7IPXG0Z1YGD1Ur+su4=.sha256",
        "size": 3404
      }
    ],
    "indexes": [
      {
        "link": "&vcRIu9XzdraSTGOHpoIH63rNr1rI/saplkuGdNN8tmI=.sha256",
        "size": 1352
      }
    ],
    "refs": {
      "refs/heads/master": "5c1e8233ad54cb39494d836f2d797675f256d57f"
    },
    "commits": [
      {
        "parents": [
          "088084891a207c3b526c313fc882a90bcf05e7c7"
        ],
        "title": "Bump version to 0.3.1",
        "sha1": "5c1e8233ad54cb39494d836f2d797675f256d57f"
      },
      {
        "parents": [
          "f4478a6ac42dcb41e9aabd1c44bbbf9a5c47cf16"
        ],
        "title": "Add back test code",
        "sha1": "088084891a207c3b526c313fc882a90bcf05e7c7"
      }
    ],
    "tags": [],
    "num_objects": 10,
    "object_ids": [
      "6987ac45083d7679f253299558b53c2307cd8968",
      "41ff4b142ff24c28e86b69ade6550ba594aa0d38",
      "26303cfb6cf92a311c5046abc9de6ac9db20cd07",
      "86eadec9b2f7214004b8d568bc675979d2f607b4",
      "15ae0440905f8e95b3a2ff7d20648bf873213526",
      "e14c4dd938a5d5aab261e1efd1f54e2eb91c72bf",
      "71ab7d9145b46c9da3623456534ab15f20fbd107",
      "c512038cd672b25ddeaa3b45c223c1fc172ba196"
    ]
  },
  "signature": "zI2zEQacxUpafw6s18aOpsFIe+7p7v4aofIhcbA61klW5QTVI+HMxzhKK1Vz4QqwnXYftDlCOr4QFix2DzBWDw==.sig.ed25519"
}

{
  "previous": "%/HRHcmrrWKFtk/1c+51gs22GjUfc//IK7Jg+zDAk1Zo=.sha256",
  "sequence": 755,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521634865442,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%fDjtH40oENJrx8gvG0CxgDvAD4eY8QmCzLvordfUDSE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%rdghhycts0ONTO3Q5B0qDoozo/u1KXuhy7Lo0v4wP7A=.sha256"
    ],
    "packs": [
      {
        "link": "&3QxfAGJ4+n1gu1xZZItnOC4BoYtC1rsAbU1xsrKVJQA=.sha256",
        "size": 3287
      }
    ],
    "indexes": [
      {
        "link": "&0KBsT9sob6Q85C9tQ5asnF9Ys67eZYo5cNT6391Gyck=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "955d1f134dd3e0a987c1974f3786a86bf09d46c1"
    },
    "commits": [
      {
        "parents": [
          "2c8046b3a5d8fefe78114b3baef9656c44d7b09c"
        ],
        "title": "Bump version to 0.3.1",
        "sha1": "955d1f134dd3e0a987c1974f3786a86bf09d46c1"
      },
      {
        "parents": [
          "3462488701fe1ac5901381da54b996372a6170d5"
        ],
        "title": "Update to futures 0.2.0-beta",
        "sha1": "2c8046b3a5d8fefe78114b3baef9656c44d7b09c"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "e12f1a5fc6f37806c85fd13f7b1b3a06dd31114d",
      "30fd1f7b5e1deded9a63d00e7c0b547c135349c0",
      "fd6a9cf6dab04adba7097dc57a8d8f759e6c588a",
      "b47bc7f190fc7d38e0ba47647d6afb0e0f5fb056",
      "1768bd8924ba92e20c1fdf2db6e544cac4e0d932",
      "000878ffbbfd11a63797f416091c8f3ab1a47c89"
    ]
  },
  "signature": "gn09st83yFFz22JfIaqhUJdJAxaoj7L8MI6Rr4MSEfd9T97DoYeq5cIZ53FZMp4WBL7wxnW7QIM+6oWb+yX6CA==.sig.ed25519"
}

{
  "previous": "%0xWm6gUHbxLJMAdRZH9bYOEK+OkovHLafKnbXPOrcDw=.sha256",
  "sequence": 756,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521643744229,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%1VOVPaWXE6QKEt1llRqlEzsFAVOyBzxSj5YkmsiCyVE=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%lTli8wC7PRljOhMd++fVIU8ltImiCyVZHfbhIWUKLYw=.sha256"
    ],
    "packs": [
      {
        "link": "&CP067IjjcYaQweCKgSatlBd5Ux2qJjQPdZXU4o2JqD8=.sha256",
        "size": 2047
      }
    ],
    "indexes": [
      {
        "link": "&usGT6pnc4y0pYachmhPLYMhhbz4GqJ8SMvKH9K1dxVQ=.sha256",
        "size": 1408
      }
    ],
    "refs": {
      "refs/heads/master": "94f6655938d1080cc38b40834f2ee53785a2b76b"
    },
    "commits": [
      {
        "parents": [
          "4378db57db0e9b8773c641f1976bfad9a54dc17e"
        ],
        "title": "Bump version to 0.2.5",
        "sha1": "94f6655938d1080cc38b40834f2ee53785a2b76b"
      },
      {
        "parents": [
          "d3715fd2f510b27ff2ec9b64ed36b7efd565c798"
        ],
        "title": "Fix typo",
        "sha1": "4378db57db0e9b8773c641f1976bfad9a54dc17e"
      },
      {
        "parents": [
          "89bf1808e70601af25d8d8fa7c3151f05a95ad4a"
        ],
        "title": "Add LimitedReader",
        "sha1": "d3715fd2f510b27ff2ec9b64ed36b7efd565c798"
      }
    ],
    "tags": [],
    "num_objects": 12,
    "object_ids": [
      "5ba94de5db547f8a6870643fec4f2c9de42e22cf",
      "ca23e224d0ca451c1af297c6d726c4869f88a5dc",
      "17d0837e92cf411dc6fbc11ea8bd4378fe016caa",
      "3e18d22ff52e4d94376013a1d041887ebdbc92a6",
      "4cd4ef05c8f95ce4ae8d87d63a1890ed63efbd6a",
      "968bf8d2daf7c6e61e89fa1f9431834ea97a8a19",
      "60f730ceec2f05609c926071008c4e78247129f8",
      "46240074e5f0da7ffc6d2f5ac72a01611c5561e9",
      "384a76124e90f5f2d5e8090a56b2abbcfa6c890b"
    ]
  },
  "signature": "z5MfKXgM+HNqhks3YrT8BUbRKYmsLWC0fQZ4RXVxcmlGPdbx0D9VutRvJcbGNIAyQITKnrv0p0j7muUUAB9YBw==.sig.ed25519"
}

{
  "previous": "%xflPIGy/1lWzxgx9HafHgXMm1HqGSco7AUhzHCsMonw=.sha256",
  "sequence": 757,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521644337467,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%/HRHcmrrWKFtk/1c+51gs22GjUfc//IK7Jg+zDAk1Zo=.sha256"
    ],
    "packs": [
      {
        "link": "&0IF1U21QLzJJjBQa3tAcTl+pDQo0TtklRehJn0ChArA=.sha256",
        "size": 2342
      }
    ],
    "indexes": [
      {
        "link": "&QBJ3TkkWhUVPNxE7f505vws86dBvuQCSkHnpQKY78Xo=.sha256",
        "size": 1408
      }
    ],
    "refs": {
      "refs/heads/master": "9e880efb4c6fcc3057f19989ad2a1a87ef295188"
    },
    "commits": [
      {
        "parents": [
          "aab352e70e867393aa070cd29e8f6c0e529b6197"
        ],
        "title": "Bump version to 0.3.2",
        "sha1": "9e880efb4c6fcc3057f19989ad2a1a87ef295188"
      },
      {
        "parents": [
          "431c83083c88062aef643c2e885b4b5e0248154b"
        ],
        "title": "Add AndThen decoder",
        "sha1": "aab352e70e867393aa070cd29e8f6c0e529b6197"
      },
      {
        "parents": [
          "5c1e8233ad54cb39494d836f2d797675f256d57f"
        ],
        "title": "Update to async-ringbufer 0.3.1",
        "sha1": "431c83083c88062aef643c2e885b4b5e0248154b"
      }
    ],
    "tags": [],
    "num_objects": 12,
    "object_ids": [
      "6941e0be4261d893d598ad54afcea3829a046481",
      "84b0fa5e5bb1325d4b6f81b84a29ca0b7ca713d9",
      "2691d58e2063365a25926b189cd2f94d26194434",
      "9cfe224c32624e0917b9db9e2bb6872dd93a8ef3",
      "770e6fedf027cf99c754733c21983c718e27e539",
      "3d0871cb857db0cfff88055449222bdd6ec23aa5",
      "d14f6e6c28683621c59e50d0e445ba6bade997a4",
      "1fb650bf2504e6d7c47675a3e229d7094c07eacd",
      "3b37383e18641b4b50ffe1b2c201600fe9245614"
    ]
  },
  "signature": "GPpmlkf7hPkys+llKjCAb8Y5rmmnpCMoz9KaIUw5ti1ywZidCK77wRzU7RatXNRviZuOzn+NYmyUM+UvGRzDBg==.sig.ed25519"
}

{
  "previous": "%wRAoAEnN2PnEIHp8pbMIz2X3/gVkAo0gHXsR/NXq8ro=.sha256",
  "sequence": 758,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521645021454,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%e9xLkc8HSMt9hf/JI6HvjniY37sd23NPa57CTm2GN0c=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%wRAoAEnN2PnEIHp8pbMIz2X3/gVkAo0gHXsR/NXq8ro=.sha256"
    ],
    "packs": [
      {
        "link": "&cwuJZDkpC1t7lC45Wsg/S6zquLeOj19r/80cEXgqpFw=.sha256",
        "size": 4027
      }
    ],
    "indexes": [
      {
        "link": "&6S0gWX95w9JoyY/T5W+jwSpkD6zFGNxNaizjCecsu8s=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "21efee286b3d273a2530caeb9a563524427197b7"
    },
    "commits": [
      {
        "parents": [
          "c4a9971e99637856c785b4c7ba674d8969b9d8ba"
        ],
        "title": "Bump version to 0.3.3",
        "sha1": "21efee286b3d273a2530caeb9a563524427197b7"
      },
      {
        "parents": [
          "9e880efb4c6fcc3057f19989ad2a1a87ef295188"
        ],
        "title": "Add DecodeExact",
        "sha1": "c4a9971e99637856c785b4c7ba674d8969b9d8ba"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "c88344386dfb07563ed4cdc8e9ea4100e3bef677",
      "420763e0c42de08398ef7a599327bec5394e5224",
      "402c175168781f607322f4590d422d4b091eb6e8",
      "ea0be6c49c2926438cdb1142de86f1177c766896",
      "72c63ed668ded147e2b6a6bb6cd269289a2cf206",
      "36442647afadb0d4fb09eadad6aeef76c99f3f38",
      "4fa3d727df31e781b6f0d0f49b92575e546f286e",
      "8abaa47a82e9d83999125b5340d0688bbb7459d5",
      "ea80aa869872b7e2919b23f00068874b3f49fb08"
    ]
  },
  "signature": "PHkWCsV1G5fOOTCXD2nYa32uL+it9t6LZUNkj45V/gZFVKFfrjxYWCIr55RE6M3sC3jo/Et8Hg/htr7PxFJxAg==.sig.ed25519"
}

{
  "previous": "%lwnLTJ+bH2CIqMtgjcODmyg7lIDBYs8Q4V0I74EXN6Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 759,
  "timestamp": 1521715246034,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@sHFNLAao6phQ5AN17ecYNUbszDa4Qf6DhyQsjtQfdmY=.ed25519",
    "following": true
  },
  "signature": "iAkJsSbCaKZ3613CtXq6Ss8hTLIoB7b6SKeC1aarTZ8IiOC1xEoa1ZEXlLvPCrZ7pkkbnzg/eHzYr0A/RHpZAA==.sig.ed25519"
}

{
  "previous": "%wd/rXGyYE7UYXVvy7BHMIGcH4fQGXIeCKMrE2Py+OVU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 760,
  "timestamp": 1521802508724,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@dBQlwh9Gtr3i5YMOGtIOKtGNVepeu+nyb6KGl1vtOcM=.ed25519",
    "following": false
  },
  "signature": "OceHAWWWVEMgUJx9LV7zqxXojuqxg844FYlfSGA/uBMaif043w9JmMKmbPJKXAwry2GGpfb6N5z4BNrtzmXICg==.sig.ed25519"
}

{
  "previous": "%G3YrmBj7VVVmo25nYOtpLLW32FNEdqrFPubUzcUbP5E=.sha256",
  "sequence": 761,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521814173885,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%Mcqkm3xnXlqzLHlgg3t1fBAFqeEnP94ZecuXof4bduo=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%JcujYuB2TlUO0m1vEgf20EAFsMY0AJZao/mSUNV07T8=.sha256"
    ],
    "packs": [
      {
        "link": "&78804leW3/QxCMC6hkcIhdktElxoyoOtw/bbxUpskVA=.sha256",
        "size": 9260
      }
    ],
    "indexes": [
      {
        "link": "&xkcSUmqLAuIqbU2QEGegSUPuEVg4NCni4fHhlp44yyY=.sha256",
        "size": 1632
      }
    ],
    "refs": {
      "refs/heads/master": "c595d016ff685dddf49fd3467415012d5215a8fd"
    },
    "commits": [
      {
        "parents": [
          "c569400e2821fdd94376cffb1ef365939e64028a"
        ],
        "title": "Bump version to 0.4.1",
        "sha1": "c595d016ff685dddf49fd3467415012d5215a8fd"
      },
      {
        "parents": [
          "56c0018c4a6170bc7d67ea64d49d4c98a383537f"
        ],
        "title": "Add PrefixLen codecs",
        "sha1": "c569400e2821fdd94376cffb1ef365939e64028a"
      },
      {
        "parents": [
          "d8a76eb6ac4c2fdaeb72af48c4420b7affbd2da5"
        ],
        "title": "Bump version to 0.4.0",
        "sha1": "56c0018c4a6170bc7d67ea64d49d4c98a383537f"
      },
      {
        "parents": [
          "3e9ecbbb587589ca8115b7de86ea24249fba1d6a"
        ],
        "title": "Update to value-based traits",
        "sha1": "d8a76eb6ac4c2fdaeb72af48c4420b7affbd2da5"
      }
    ],
    "tags": [],
    "num_objects": 20,
    "object_ids": [
      "170a40dbbc26c791bc6aa7147b1354ff68c8144e",
      "ecf728c3089f2e37191d96700f63cedbcdf2ac10",
      "1a0565788d3c79de43c0b2fc4ae9d4c228646fe8",
      "ed14c4c8ce6ef01a7e6ea043c0912ab47778f61d",
      "545c24d05b89b85b58ee7958fa84a1370772fce9",
      "72c41c808367af8df64901fafbfedcdc3adb7785",
      "ede75b22c6789c96d8367871149929fd6f871b36",
      "2f387e1a7c462bd307f0d8cbc9ff94f09d63f861",
      "c4eac8bc9bb32429448d86910f75676a8a4399cb",
      "f18d7e29cd10aa59873def1ed556ecce87f4cc26",
      "dbd95cb28bb62c1bb754768dc900ea860b77d690",
      "d24571d133d8ca7cdde2514534059c72d5553617",
      "72b0175a90cb82fe4ac79c94214f4ddc4a71e949",
      "6adb13a365da31ea31cae1ca5fc77a0f2f3e1b11",
      "c818238a4e62cb38ee6975a08dfdd4b466faf24f",
      "f3be58266f2cf92c49f536f12c6bad6eaaad1bed"
    ]
  },
  "signature": "9z8Bb/ECPImN8ZUv4OZb0SSx2+Rszw4y2dhZsgP8HyiHrgRq07QLCqG47Ag7i/bo22Cha6V4mPMmgoJIbMbWAw==.sig.ed25519"
}

{
  "previous": "%wRTMe9PjejLUC+Zf4PFhXgwjgvCyv0TLL7aHkT5uIc4=.sha256",
  "sequence": 762,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521815848506,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "yamf-handshake-rs"
  },
  "signature": "w6bbx0IUAugyeXG55w2Zdc+lCckWpW1jOHN349se+G6w3qDe1H4ItIwy7ogr56TEhs4atR9BK8tkHGmiWgkTCw==.sig.ed25519"
}

{
  "previous": "%eAoyM5sQTTDosKWg5NtHvUCFZxr/zQGzSB9JBQLdE+M=.sha256",
  "sequence": 763,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1521815862379,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%eAoyM5sQTTDosKWg5NtHvUCFZxr/zQGzSB9JBQLdE+M=.sha256",
    "refsBranch": [
      "%eAoyM5sQTTDosKWg5NtHvUCFZxr/zQGzSB9JBQLdE+M=.sha256"
    ],
    "packs": [
      {
        "link": "&2LNlfyPUrTynSRuUiMet9zRVIK0fHDfwmopksdr6Ixo=.sha256",
        "size": 13150
      }
    ],
    "indexes": [
      {
        "link": "&O+xOJUxfCVwDJxFzvLUH+Hj2xQoQOAbIdPTaQDjrWSY=.sha256",
        "size": 1296
      }
    ],
    "refs": {
      "refs/heads/master": "fda3b5a026c8a88f101275b84b26bda941e3dc88"
    },
    "commits": [
      {
        "parents": [],
        "title": "Add metadata",
        "sha1": "fda3b5a026c8a88f101275b84b26bda941e3dc88"
      }
    ],
    "tags": [],
    "num_objects": 8,
    "object_ids": [
      "93e21c1dd40b45001ee886bffc1d3d07b4285112",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "3bbee4625eb0f48118afcabe359ce3fd33b68ba4",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "8f624627d76edd87fcd7e868dad29346f71a1826",
      "81b826a13f51a1eb6fba67ec93e7244fcadce832",
      "31e1bb209f98ec5fc6b7cbea4c4766a555c87247"
    ]
  },
  "signature": "ypS0L8ZWYwg7mmkAZfCBlSp2pFnvErdszzRTelCn8yBILCPoQF7RzCc7y+YwxXYVLBBO09TkW3NWlX2z5G/SBw==.sig.ed25519"
}

{
  "previous": "%74UVQ2lPV/TKL7Ffm0tyhyV7bTWGYac3wAQagVU2o0M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 764,
  "timestamp": 1521881336788,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%G59Uz1dNq255QJSr+q9xx96liTVBCUUPkKwNKVcGfFE=.sha256",
    "branch": "%tlEw51EklbTl2lkLULHNVGm85k9C9YDg0wbk9v31eV0=.sha256",
    "reply": {
      "%G59Uz1dNq255QJSr+q9xx96liTVBCUUPkKwNKVcGfFE=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "webassembly",
    "recps": null,
    "text": "> There are lots of ways we could apply webassembly to ssb: one simple one is we could send a wasm program to flume and it could perform a query without streaming everything to the client, this would mean client apps wouldn't need new sbot plugins.\n\nMy first reaction to this was to keep things declarative and non-turing-complete, because I don't like fun things. But this would still be an improvement over the current situation.\n\nI argued for keeping flume out of the core ssb spec [here](%wGjW6iCPpbLIUkh5y32CHt2aPYVblKhw+g60V6Yl9rI=.sha256), you might have missed that post [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519).",
    "mentions": [
      {
        "link": "%wGjW6iCPpbLIUkh5y32CHt2aPYVblKhw+g60V6Yl9rI=.sha256",
        "name": "here"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "SR+ck1S0TJAVnpOOpIpcsn2e9KOC2cChuTILrv465K5QbRYgML3+N8gkIpsoAG2nrRC08ju+Qqg6sUnGuvEmBA==.sig.ed25519"
}

{
  "previous": "%OtbsAHAHhjDf/rJLu4dbEG/0RbxVoVqsRPxkmT8APYk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 765,
  "timestamp": 1521926729192,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%G59Uz1dNq255QJSr+q9xx96liTVBCUUPkKwNKVcGfFE=.sha256",
    "branch": "%rN1h0dkGArChRKhYwbi0Dk5V+UmyIdqa5P2pFQarCYQ=.sha256",
    "reply": {
      "%G59Uz1dNq255QJSr+q9xx96liTVBCUUPkKwNKVcGfFE=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "webassembly",
    "recps": null,
    "text": "> but are you saying you would rather not have plugins all together?\n\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) No, it's just that there are clearly different kinds of plugins (database indices, replication logic, private messages, ...), but they are lumped together. It's difficult to get a clear picture of the scope of plugins. Why are some things a core part of sbot, while others are pre-installed plugins, and yet others are plugins you need to install manually? And where are the borders between ssb, sbot, flume, and randomness?\n\nAll of these thing are currently difficult to disentangle. It feels like you have these things sorted out, but there aren't any resources about this out there (that I'm aware of). ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "gCUQeFhd0bdVPWml1aagVlqNrbUgaEGsleQj2WS9Nqk3ejUhejhwKldBX+nQ9imvBchj+4Sm9NqCUwm2Q9uxBg==.sig.ed25519"
}

{
  "previous": "%PmX1EKF6KVABZXECwSK6YdaNMfS5Mp6M4RWuHhYPu2Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 766,
  "timestamp": 1522138646869,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbpm",
    "text": "Here's an interesting alternative version resolution scheme: https://research.swtch.com/vgo-mvs\n\nFeaturing linear time algorithms for a bunch of things, and also backs things up with theoretical CS.\n\ncc [@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) ",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "5VNS9N9464NHaLK8kLugzb8UJ1fhm24/OdnYRIepp/XMDSTLAaka8hw0qryGJn2N9q4+yjId0E/LvCvU3+JuBg==.sig.ed25519"
}

{
  "previous": "%HTRsrqKwq4nV4RGOvJy3FGtjMMyEdYW+Dc2S5wHIJPk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 767,
  "timestamp": 1522175333746,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
    "following": true
  },
  "signature": "Xju4eFCze8gm+OnPVW9RCJYOggAyazgHPMcT0pyQJVXRblPT6nR7CUl+ekHPLjSqTYJQdUWPNwZlVSQNwDb4Dg==.sig.ed25519"
}

{
  "previous": "%Rq73OHxwIld69XxWCAkss67FNGey3zDzMRwjSyHhSnI=.sha256",
  "sequence": 768,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1522324535780,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "look-lang-rs"
  },
  "signature": "PVEDrL1M57PacgzlbJQ76RiN4OLXx0a4qr1eQVd/wFcf+JV49c+vJhT4PCzL5gVoybZPO38eq5WQhq+/3YrLCg==.sig.ed25519"
}

{
  "previous": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
  "sequence": 769,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1522324547694,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [
      "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256"
    ],
    "packs": [
      {
        "link": "&3jDoyOE8fCRVBPAC3tMKD7FbhQqtLi5b9deudP3j7YI=.sha256",
        "size": 15250
      }
    ],
    "indexes": [
      {
        "link": "&tZIINp3yWELK0CHQhiQNoi75x0dmc2LArZUxXmNNwLc=.sha256",
        "size": 1408
      }
    ],
    "refs": {
      "refs/heads/master": "303ea9e649c42bb8d8a31d5863ea5afa92663859"
    },
    "commits": [
      {
        "parents": [],
        "title": "Initial commit",
        "sha1": "303ea9e649c42bb8d8a31d5863ea5afa92663859"
      }
    ],
    "tags": [],
    "num_objects": 12,
    "object_ids": [
      "7d300a7dc27eb7e1385143609a28bab98318331e",
      "143b1ca0147427236f1dd485fa0972d492eada75",
      "9146574e4b8b534fe4bf6dd32e1227d325220ba5",
      "710ccc044539e9ffebbd1b582c89fec5d8dbbc7d",
      "5c349381762471b29c94eef13f21ec90a9e2c4d8",
      "9621cf1bf88daf93940ad973e8409e4a08e037ff",
      "2bde40d24b69b7d8feb6d7eb7bc5b68cf181325a",
      "070b031c7d9122de662fee642e4bfc392766f78e",
      "53c65531dda85cbd07b5d1956c7866b54e2e41e9",
      "45f99b93e2dd621b27c35509615e88ba25848755",
      "327cb01affe76c74b6e1638ae65c6257edf5e80b"
    ]
  },
  "signature": "Z5L2AL88/pQSf63O2Shq3O+BRPszAaSaB8lDn2fWVN48MHauKXl58vbKA3zWIBrj6Yl4/E68pAO/JrxQBsiPBg==.sig.ed25519"
}

{
  "previous": "%JS2KbLq58894UGsHsyayR4T7o4aHGuRq6pl7dq9Ks/M=.sha256",
  "sequence": 770,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1522494069867,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%JS2KbLq58894UGsHsyayR4T7o4aHGuRq6pl7dq9Ks/M=.sha256"
    ],
    "packs": [
      {
        "link": "&Dj/ZkvZ+F7JB+fJAapaISjSXjyHmTj03xwBEbsz6KYI=.sha256",
        "size": 8335
      }
    ],
    "indexes": [
      {
        "link": "&89hYvzyIQt885WbpfoANKIkdy7QPg70fbABEir00pXo=.sha256",
        "size": 1660
      }
    ],
    "refs": {
      "refs/heads/master": "c99978334a64d8260ba775c820c51fa6bde101b4"
    },
    "commits": [
      {
        "parents": [
          "b04dd80039ac11f21d4f412dbd04d6c216b9ea12"
        ],
        "title": "Switch to abstract syntax, implement identifiers",
        "sha1": "c99978334a64d8260ba775c820c51fa6bde101b4"
      },
      {
        "parents": [
          "303ea9e649c42bb8d8a31d5863ea5afa92663859"
        ],
        "title": "Add more concrete syntax",
        "sha1": "b04dd80039ac11f21d4f412dbd04d6c216b9ea12"
      }
    ],
    "tags": [],
    "num_objects": 21,
    "object_ids": [
      "23afb187f49dd86ed6dc56af3042779b36852b7a",
      "c9eee9c316252a57c516939c3457e45ed78a9673",
      "8e336100f5105492a0278ff97e75612d22dd9bc6",
      "0828c90c716349cf3cb4507c706cf2d0bad677fd",
      "48549958b7b4d044f824680dd799db674971851f",
      "c2e20f2455bbccb263093257aa8434299a9dcc20",
      "9a737d8a9184a9a04e5d0ac455894ada6ab2699f",
      "2d7bca71f0b5dabff9b4d5f671f231bc0c3ba4ce",
      "f739d10047dffdbd5b3585fbfa07d1ee8a6f7e7b",
      "1d527c48491c44de6935d65949e294b2d862b94d",
      "f8d63cd02e0699604bc433ffd6773e7b50451d24",
      "5503a2c82f360979bc23f31641b4344ae21963bc",
      "6e539c3ad41ec6d4c065c22d7109d8272f418527",
      "9ec0a767827eaceae6bf0f86d241f73cf63ce47b",
      "19de4a0f9119a9c0b1ed1ca6ab3243ce53f00cb1",
      "c432abf174dc387108ebfb98aeecc70b2aa15a4b",
      "cdc89deb29db0e6796c9abdffb1517c48e996d90",
      "2c72a46f872a4f299b86fb4d26910eda21cacb2f",
      "413a6b4b4859ddfbcc138066b5ac1e05e043c766"
    ]
  },
  "signature": "W7fInuV3ahiv0SATlxywI5egwbtRPxqrGh659Xc77Kkb+s5tltyr33Zp7iQeOaeVJwolS/wRBagalH9JM6XRDQ==.sig.ed25519"
}

{
  "previous": "%2mCt7Zs82A87ZB5IsRgP9Z0NO7N1PIpc3ztyyMqUjZQ=.sha256",
  "sequence": 771,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1522674417387,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%2mCt7Zs82A87ZB5IsRgP9Z0NO7N1PIpc3ztyyMqUjZQ=.sha256"
    ],
    "packs": [
      {
        "link": "&oJmipeX+4LzJErSzcwJv09V9a9Gb9qETQzSUGDSkT58=.sha256",
        "size": 5795
      }
    ],
    "indexes": [
      {
        "link": "&ZKX3rZ0QZ2ChEyPcDIAM5E8O6VUMW2lMh2b0xaTxebU=.sha256",
        "size": 1660
      }
    ],
    "refs": {
      "refs/heads/master": "cc64f45311f2f9e01c9856c9e442da4e81b24e7a"
    },
    "commits": [
      {
        "parents": [
          "82db05b71375fa730fda9972af98f2afc8ec7430"
        ],
        "title": "Implement type parsing",
        "sha1": "cc64f45311f2f9e01c9856c9e442da4e81b24e7a"
      },
      {
        "parents": [
          "9d9a5f2e7bcf66f4aabcb14aef25149a0e216713"
        ],
        "title": "Implement attribute parsing",
        "sha1": "82db05b71375fa730fda9972af98f2afc8ec7430"
      },
      {
        "parents": [
          "c99978334a64d8260ba775c820c51fa6bde101b4"
        ],
        "title": "Implement skipping whitespace and comments",
        "sha1": "9d9a5f2e7bcf66f4aabcb14aef25149a0e216713"
      }
    ],
    "tags": [],
    "num_objects": 21,
    "object_ids": [
      "d96372feee2ece54ae8b224fbffd5d1ec90f7599",
      "1954f42170ab3481e8d360db8efa90a7cd9050b3",
      "46242b9bca3b091fb8652dfb54f7672a622010a3",
      "c42966058096fb938d2cb4db6dc0358afc54c672",
      "036ebcda3df6a2fb2c69dfddd779b76f4eb3e369",
      "7816282fbcb3f1445400e6392463b22c542c6a8a",
      "0127c82fc81b23698b7eb7ca0e23215559b6ccc2",
      "e2f82ee7ee0b45065b4b6095d3077f3c2b87894a",
      "06ba14d9c0309d77a26a29f6b8b7f2cd5d35889d",
      "fb879cc8b0caeacf842112de7e0e9fabdbc7f702",
      "93663dc1f30c2038b78e5a21b5ffb1002ab9b585",
      "4b5ec03a8152695feeef09db6e3e4d5bb058daac",
      "afd5e7a5e8f7a5ab3e7ae6a83176bf8bae0e875d",
      "d26492b8b7d84b4e9e6e37dda4881e8beee90c0e",
      "77a0ce3b7fe81ca035dc53cee069c4773547a2d5",
      "d67676f39f58b788f6a87c01d47e35d712a9c7be",
      "dd4a3210c3f9ead153bcc33f384d92341472861e",
      "aa4ce4ad90ecbfa29a3476172ece714adc53a64a"
    ]
  },
  "signature": "PyhkHz9Bb69Gtx35MJD/hDyMeR6pPj0nRO3DsFWmR4iQTlEJKlvcS3Lv4PDttFcKH/X9IKYARgqZwni0vS1mCQ==.sig.ed25519"
}

{
  "previous": "%Zo2+O5wbLNwqWa+pCLpAzRjHrSEM+jGzQ+z1f1iq1JI=.sha256",
  "sequence": 772,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1522675982018,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%Zo2+O5wbLNwqWa+pCLpAzRjHrSEM+jGzQ+z1f1iq1JI=.sha256"
    ],
    "packs": [
      {
        "link": "&2Hrpm9dZ5JQGqoRyYCiX/ruS+8L6FowzczRD6kRENEw=.sha256",
        "size": 5035
      }
    ],
    "indexes": [
      {
        "link": "&tGBjsdnahB5cgS2o+Fd3oukyeFsDip+ashQdYacKtFM=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "881bdda16edcfc79c778ce3571bbb1aadec02a86"
    },
    "commits": [
      {
        "parents": [
          "97b74d4b2d0f20b142ef001200cb9f1e9707f0ec"
        ],
        "title": "Actually commit type parsing code...",
        "sha1": "881bdda16edcfc79c778ce3571bbb1aadec02a86"
      },
      {
        "parents": [
          "cc64f45311f2f9e01c9856c9e442da4e81b24e7a"
        ],
        "title": "Lessen restrictions on whitespace for attributes",
        "sha1": "97b74d4b2d0f20b142ef001200cb9f1e9707f0ec"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "9b51b5de6749c2be3f5a060792be51d22cec6d08",
      "bf486ba97f4617c78217f1913aa29691d10ff3cc",
      "34c375adf3c84c66472308c64dbcf655fdec688f",
      "7ddf7cd46733e9771cb469c74d1c0abb9038d9c0",
      "bf2c0bff339f11d559a019cc86bdceb89cea3da9",
      "079dd7d5c9ba91819f0eaedc69c3ec11408a4c20",
      "6694afaa42a7b8b589caa92fcd27d418e8c963f4",
      "2d44b834eebd1f0bc0e371a0718676755839c5b8",
      "9c0f3d84e83f659ea3d4dd804f30513c674e17d7"
    ]
  },
  "signature": "Iea/7m6ObhJO2s4nllr9zIB6cPJ1J9Oxd1JJmwVC6kh0EDLtewWx+emH487w8ACVWmZrTFpoPi4wiIFpgbA8DA==.sig.ed25519"
}

{
  "previous": "%GrHARLVBju+ZsTq2elSgImjHWO4d/+y+n9CsTP3r1JQ=.sha256",
  "sequence": 773,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1522708920191,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%GrHARLVBju+ZsTq2elSgImjHWO4d/+y+n9CsTP3r1JQ=.sha256"
    ],
    "packs": [
      {
        "link": "&Mi1aoome4vv5BvK5nA4z6t+Hz+oaSmCukvTY2Myi84A=.sha256",
        "size": 6168
      }
    ],
    "indexes": [
      {
        "link": "&nKkapmrg/2bDgCEpxxlnUjEDYF+laXJ+NdjvSFimnXk=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "4b3385e5ad14e11ba317513c29e4ebd6393388cd"
    },
    "commits": [
      {
        "parents": [
          "881bdda16edcfc79c778ce3571bbb1aadec02a86"
        ],
        "title": "Implement typedef parsing",
        "sha1": "4b3385e5ad14e11ba317513c29e4ebd6393388cd"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "8a3717e520e326d59d293a00b3dbb6ff32cec87b",
      "e8ead7fac4e4a561383dbe2e0b1088e1302b91f2",
      "fcfb1eb71dc3404e72944fdbb91de36d08ad05fa",
      "9ec30bca590156ad06f4ddd6c6cdcedbff922304",
      "f5c4589fbc0344b5b71ce4f705432182e4bfc6aa",
      "eb950074c6bfbc57020db4e47bc6cbd60ca8f6b5"
    ]
  },
  "signature": "irv1hoOp+iSRsPEP5qiXOFsFvkp0zvcV3S3UN4g3YP9pVfwkh1UNJMsC1dd4XnzsZCuhXq9qrbzHOXA0v6tiBg==.sig.ed25519"
}

{
  "previous": "%a+JWnd6uVSuouH7PsrAliE6z946wqFFsipS7rFTutyc=.sha256",
  "sequence": 774,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1522768227334,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%a+JWnd6uVSuouH7PsrAliE6z946wqFFsipS7rFTutyc=.sha256"
    ],
    "packs": [
      {
        "link": "&jnBZEwl7thp1+Masw0HRqUxscbAjUHGSiNE27sEPY5c=.sha256",
        "size": 5755
      }
    ],
    "indexes": [
      {
        "link": "&z+8qxkucBRcg88C0toRHo125S3ZTaoODZNuUNonXeRw=.sha256",
        "size": 1380
      }
    ],
    "refs": {
      "refs/heads/master": "1009998f7b010d0d5ff42d0f0ce3cb54d3acd6f1"
    },
    "commits": [
      {
        "parents": [
          "fcc8670ef5f64256e13e3bb6e30ec000d1309d29"
        ],
        "title": "Disallow hyphen as identifier character",
        "sha1": "1009998f7b010d0d5ff42d0f0ce3cb54d3acd6f1"
      },
      {
        "parents": [
          "4b3385e5ad14e11ba317513c29e4ebd6393388cd"
        ],
        "title": "Allow attributes in more places",
        "sha1": "fcc8670ef5f64256e13e3bb6e30ec000d1309d29"
      }
    ],
    "tags": [],
    "num_objects": 11,
    "object_ids": [
      "9455a7b163c7a51761b457cdce4b3cc15d70557c",
      "9f73fbb438935175c1913fa036fa7077be02380f",
      "23e352d866f93d78242ad9516d867580cdf98c33",
      "392bdd3f010a2e9d7a65ef77f85eafa259d01c19",
      "29e47a52e467b4c5c153078a4b8a0fadd141762d",
      "d4be75a8fe6a5916a3e654161b789d960fc9b9bf",
      "a9d2a9027c9b332adb4fa1b172f558eca9cd3b4d",
      "14e69d957bd18c26ee34c04bd221c9d2efd85737",
      "01cdd8c30afe6d9a858639bcfba05f11467749c6"
    ]
  },
  "signature": "NFsC+SfNUEpc235Gu7RXYGRcPjw2+07rIaegvAYYaoiAdRN2LuE8205Zs3vYYgrytCYxcvs2s1wO4wjDJmfWCQ==.sig.ed25519"
}

{
  "previous": "%tbjovoyV7SAcFp7cI+8+1s6HTNob39bDwHElLJs2uoQ=.sha256",
  "sequence": 775,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1522793541366,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%tbjovoyV7SAcFp7cI+8+1s6HTNob39bDwHElLJs2uoQ=.sha256"
    ],
    "packs": [
      {
        "link": "&26AhwvjhyvCIKxG3PQAZxh4bqkZ7NeLJieJahlBoqB0=.sha256",
        "size": 9812
      }
    ],
    "indexes": [
      {
        "link": "&rZcmmmrbZhOS9SCvDIbU5wGiKf6rTNuEjqZZitgf1b4=.sha256",
        "size": 1464
      }
    ],
    "refs": {
      "refs/heads/master": "bca901429f358fbe4de0ac6177df36b0fd9b8a34"
    },
    "commits": [
      {
        "parents": [
          "6eeb899c81566948fa35481e4f94e584926662be"
        ],
        "title": "Implement irrefutable-pattern parsing",
        "sha1": "bca901429f358fbe4de0ac6177df36b0fd9b8a34"
      },
      {
        "parents": [
          "1009998f7b010d0d5ff42d0f0ce3cb54d3acd6f1"
        ],
        "title": "Rename product to tuple",
        "sha1": "6eeb899c81566948fa35481e4f94e584926662be"
      }
    ],
    "tags": [],
    "num_objects": 14,
    "object_ids": [
      "bd1a6185f880fb40e9c4a8c4c31f0395814a4545",
      "9b632a1aa3a07e43ed2428d605e4338c0b629d60",
      "6ac1c8528288a097ddd5731d7eabce5b63ccff70",
      "361d02918e115903f1c7bb781c78b33d3485ad63",
      "e36a450a5da988d69696ae9c4e1da9c22199d042",
      "ef014f007c9deffd56aa7076105de7e7f5c89951",
      "9a02c8077b40976b369f1017ec83a9e331f70811",
      "9f4750f603f00ebee026674bb11397b99c3a069b",
      "405a54989c8d9b11c9fd0da8352c3dccdbbdc724",
      "94b409ada57e325961889c685b6c4528fc07a26f",
      "301350ff1694b416390bafee8e6f92e965690742",
      "281497dbf912e090d9f137fecc66c1c49197230a"
    ]
  },
  "signature": "k0I1MPwnGcIFgWP9Pz9e9mREojTWxJzjnGifv9gcn6S9mPhltSm2KrREtkcyHnMqQE3TO69u9iR3Az5/O9UVCQ==.sig.ed25519"
}

{
  "previous": "%CO5mzks43FAMt+JSAgK3t23i9edIFCA2TRxTlmStuSY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 776,
  "timestamp": 1522828342435,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%dHxp1cHm6aaG6xvkWt8Lu11jhIrUhObsbmozkUvBsEA=.sha256",
    "branch": "%lJyHK+nrkcXkpO0EIH/3379lFoc/hDhB9tQIRSWOTI8=.sha256",
    "reply": {
      "%dHxp1cHm6aaG6xvkWt8Lu11jhIrUhObsbmozkUvBsEA=.sha256": "@BCM6DHYJvWzwWi1lFl2tjDXjaqyZAEmJH5ZONSpXhtc=.ed25519"
    },
    "channel": "bitcoin",
    "recps": null,
    "text": "And, unlike annah, it isn't turing complete (annah - as far as I understand it - has a terminating program normalization process, but still allows terms with non-normalizing dynamic behaviour).\n\nIt's always nice to see more investigation into turing incomplete languages. The [rule of least power](https://en.wikipedia.org/wiki/Rule_of_least_power) makes me want to use them, but there are few well-developed and well-maintained ones (and also I prefer imperative programming over functional, and they usually take a total functinoal programming approach). ",
    "mentions": []
  },
  "signature": "JdkS+SOLA3jD8NEI82BeknUB7IUhiCL6MgOVoszJx99LjrVs+5oWwVnzgz36+NjASNvTGAwe/Gq2jxE7NjSoCw==.sig.ed25519"
}

{
  "previous": "%f7zBnoKrsh6CV0gQBi8s+MGjoiJh8cdODOpWx3gxTgQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 777,
  "timestamp": 1522838116434,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "bitcoin",
    "vote": {
      "link": "%e////uv+IhjwDSo2x9YTRUGk/VbnQ6wu2XByekfuc6U=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "5scVsHnMQYJtDLFUkJAmtqUX3NmpmnrcOC5DIBtDnF7APwkIKRje454EAhOQkiRuIU9qv1zu/GV3v6gYyH9gBw==.sig.ed25519"
}

{
  "previous": "%TaYyjsfcnY6LXDnRrrKqJXsl3baCbJ82g2nYP4NKqHg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 778,
  "timestamp": 1522838675788,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%dHxp1cHm6aaG6xvkWt8Lu11jhIrUhObsbmozkUvBsEA=.sha256",
    "branch": "%e////uv+IhjwDSo2x9YTRUGk/VbnQ6wu2XByekfuc6U=.sha256",
    "reply": {
      "%dHxp1cHm6aaG6xvkWt8Lu11jhIrUhObsbmozkUvBsEA=.sha256": "@BCM6DHYJvWzwWi1lFl2tjDXjaqyZAEmJH5ZONSpXhtc=.ed25519"
    },
    "channel": "bitcoin",
    "recps": null,
    "text": "[@alanz](@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519) #somebodycould write a dhall-to-[serde](https://serde.rs/) translator. At that point, you'd get conversions into all of [these data formats](https://serde.rs/#data-formats), unlike [dhall-json](https://github.com/dhall-lang/dhall-json) which \"only\" supports json and yaml.\n\nBut dhall is (intentionally and for good reasons) too limited to serve as a general-purpose programming language.",
    "mentions": [
      {
        "link": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519",
        "name": "alanz"
      },
      {
        "link": "#somebodycould"
      }
    ]
  },
  "signature": "Yk3z+8wbyE3+/fCEK8LpulO8n+akxeHh/SujdLtN0ebklyrNpWPbFozIfQqVaSCfKzrLkhLn1wkvvCJDB1zMAw==.sig.ed25519"
}

{
  "previous": "%KqVWiNFnbcVAvl6IuJP1lXSJnUTjCANzLS28yQDltVg=.sha256",
  "sequence": 779,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1523003356958,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%jJDgxGWD1gZHqFLQejbSgI2HwxcHKIb34/GyAnoWCh4=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%xJuaUxomv/WLZY7wLgOJaXCqkQxeO0rdEGDOXRHEgBQ=.sha256"
    ],
    "packs": [
      {
        "link": "&sQjUskHGTYCE426ibPRrFW7UjN1/M8N5pcb26trL0TE=.sha256",
        "size": 2470
      }
    ],
    "indexes": [
      {
        "link": "&d/UKKeMBvAQ/B7BWMwoyt6rjMKThRRzVdu4hceMcmao=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "b408a87cccf61c4b3350ff41c81cf451a7ab7297"
    },
    "commits": [
      {
        "parents": [
          "d41d3dab79790cfa0b62abb48dfc02718c318408",
          "ced4d0ef987f4cd21dc58dcc8c3aeee4abd3ce21"
        ],
        "title": "Merge pull request #1 from yiwang/yi",
        "body": "Use raw strings for json in tests",
        "sha1": "b408a87cccf61c4b3350ff41c81cf451a7ab7297"
      },
      {
        "parents": [
          "d41d3dab79790cfa0b62abb48dfc02718c318408"
        ],
        "title": "try use raw string with quotes",
        "sha1": "ced4d0ef987f4cd21dc58dcc8c3aeee4abd3ce21"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "1f32963dad6dcb3ff1aa6ef1ec144d81146011cd",
      "9e16b40e10fa0a984041b486fe23d1511b881032",
      "395a07572bf6a624d72010c5b66ebb50db210405"
    ]
  },
  "signature": "9OyT5ir6Y2C2KJUWVK5PIlArlB4Niic2RWuLzixNxr4zu140JSt8sv+pGfOOVK+msq0WtQnISnCp1HWq+kj/AQ==.sig.ed25519"
}

{
  "previous": "%R44uvV+a+4KD7J4mOHMw6OzHvyf7EAJWPYvbQLFQQ3A=.sha256",
  "sequence": 780,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1523022156312,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%CO5mzks43FAMt+JSAgK3t23i9edIFCA2TRxTlmStuSY=.sha256"
    ],
    "packs": [
      {
        "link": "&WMV8tMoERhzOYYYdlGfNAb2XbElhAkyjwe8WaHbMJiw=.sha256",
        "size": 10026
      }
    ],
    "indexes": [
      {
        "link": "&zsyzYYm+q1brFgvp4n4ad4HIjKLxO0qQP7JGqxhQsPM=.sha256",
        "size": 1548
      }
    ],
    "refs": {
      "refs/heads/master": "b5e3ca7e19a2f0dd094795369ee808f4a575aba2"
    },
    "commits": [
      {
        "parents": [
          "07ea3ae2079fb4f9dc5b11a867626f115714bf22"
        ],
        "title": "Complete the AST",
        "sha1": "b5e3ca7e19a2f0dd094795369ee808f4a575aba2"
      },
      {
        "parents": [
          "bca901429f358fbe4de0ac6177df36b0fd9b8a34"
        ],
        "title": "Make pattern lists recursive",
        "sha1": "07ea3ae2079fb4f9dc5b11a867626f115714bf22"
      }
    ],
    "tags": [],
    "num_objects": 17,
    "object_ids": [
      "e8dc45764fea75032e1cb7c089b6e96f8c139f51",
      "10bef68ad10ee9b55cff2acc04f5dbc514b694cb",
      "052e6c287f2f5216d833610900257d87fe40d70a",
      "e238319c4cab679c0c2d58378335cfbcaedab0ab",
      "697ad07dc5ec575c5f10582300f82f5c39c96ae4",
      "57c5ff84a9585dcd16ebdd2ab16d5a918b300839",
      "0ce8adb0cd5a7baf0c2b558fcd551e59de03b704",
      "3837cb519ea4a4b868bf8b502f0391921bef07d3",
      "85654feffaf03937a631726cf359adb3c5d89f44",
      "3806fd6053ade6c56ddf029a8ec7b7b7ee5bb8ce",
      "82ade3543ecc95affa431fc78eb064ae4a6351f6",
      "29213038fd9e1c44dd33e0449c65c42693424075",
      "9f73557042018820f05ac12c15457e4253209d8e",
      "3e495c92e4415faa0db1c68455f2951483faaf1a",
      "50bab26587e1b6e3e37c3aea47139571c34767f0"
    ]
  },
  "signature": "fKwQp9N16D6FguLuIYKXp/0fKR5Xg/Y0cc56/BEPBa4mrF9rf2qCxly0LYPdi/UdnAG6au75io+GAvmdfnWvDw==.sig.ed25519"
}

{
  "previous": "%OseplrEINCACkWg3FQAO8hnDi1rK5Ugi8fNm+QM8t28=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 781,
  "timestamp": 1523090443120,
  "hash": "sha256",
  "content": "z3Zo4Tqv6z9ankXpQmXWZ1tQBvfqxK3xxLoaKQJG/MUK79vzW3n6p0Q3jxyiST6TpRcVkTmhHg8Uc0j+B4QVnR2QKeuy4oMtevIVncGxJdkR5JPn3zyy8XoUVsTmyOmBjkgPfgiBnuZ0kgBQPgeEQFYFAhe6Mp4hlLsbUvSHcwREb+r6kOwJFHjnPStYkTdKHATvunop9DoACvrr/09jnkUUUeN3iCTSKsKdqmJC24UV2Y89qsyODziuhsmuA+lCpSCtuGoVAxCMghiKLzVbUMu2x+u5ntpv6ImIsJwowPaRB4BQFNgjkSwGqKZnNTM98So78b5Of1jWmguPa5r4poxfEPnGIFU28eaM+REQtjlvq9XP5XfFTwmDmxvI0Si3N44Mbfb/TsAUb6LHXnJW/Fnlz3OwYTebu9/RXskDJxS6GTm9O/kLzV2qima6XZflbhfFA8pWT2vRxLmM6FzC7cJO0w1NslNbSh5JcyWznHmK6kfiPSKwczHtGP2ujw3cCDiXOCGRIuaYEuVoiS78ZgGBxm6ihaX/w5Hf+JAvBmuJ2u8djZxyUyt+cE4jYkVdFBZdThsCQwhlaPMosOfpXOVh6uiIJIxcju1HXXVAg+b1zv/se8ubJUooA69SkUEwCCmo2XhSn8l6qOBhGGiIP07PmPq0FknjToeOcvHv4GEpK+h1bts6j13F3wOQopj7Iu6j7CXPxxnaL74m8/V1GPzmb0juRkbyx18vW/mcx3n7aeeaCX2USr3b5iJ4IVD+JZUB7GhkSot0JVZOJGaN3e9OI/68fFV/mUY0PsfXcNO9AeV16GW+gdF/KWMjeBVhVPhSTBL1HmbBmrfQ+HxRTOrFXSpuU2EOZdvmIHkScm7N9EiNwkHXsX9frWRRRR53RXYLqxttBi9gmsN6GD31ofECpd7qAj80vk3G7k+1/K8IMWhwgwvVhufM0+uXez6JR8rlQqdW67VNvk5VFl/6CyV2bybxEsU3+dzI2nAVq8SlUklBDOuja7qaZAT4NnOzWALZwIF2ZjIUKB/P/0SM420+ABy0o/smJo+Om+Jh1mM+Yz4pwNzeLCgmvHBRhqw6TKyajWeEMfKEnkEREzb3nufsa6wJAU/Qp8kjPibPkKpsvVdwsslgcq9zUaaavCuakMgyl9o4lpocS5FEKh1rT9/22Y/FGOfPrsZdxxJ8V9mzfn/siibopYsE1nNkEzPNu+erenGJMm2x+mH76BtAQgGWrThgdmOjoTvBWPl7dgDLzGdX5j2z0Si9PBsALaViqGCbXb0RQ5gPu6ruEUswcx6YywNIdCLDy8+fVAxX0G6vHR0hZFq+PAleBuuoxOg2ryhfAXQlE8DaQ7736DAIl+cJMw5ny10R0i7HTx+NTqR2QOyULhCMVbQSEwzzzfVhMLvBjljtRw6knNTSaNbhdBBzcoOnPmO2IoF7h9Mvc7/JLf8OpHwFJ1cxnAoE7bXELv9Pxp/YgXKwshMK4883ye0WaBb6H4LEqTSYAmNZo9M2XoTMcblhYq+JS50zqnbgQ/x4UXAJYkh+ioCM3/LgbkT9iV8yfiqOApOXaBjAOAqIqeb+1wf3cZZi9BFyPDP7wdAIsgWOqgUrGHPDLJtvTfowNDBTn1jTU0IC0fAkE0Xf4GL8Y2KDYFZ5ZeIi5v45MIDJ138Clnsa/ekNbMU032QTAkJ9L45Aquuf5xtF6NW4N2WCIOQ997jfac9bdOuUEFuSsd8WseS5h119K7w+uGL4Ts74WHZHPFJETeAhxQFSJ5ifQ55WiCERR63KvbKU3dQ0fK2K3K7jedGv9q/rDbINXTbi1vQ1Bu3JyS0Xt+S6bzyYBEFTulfB51jUF/tg/TZ3Gu8JAM4FtdfD8Ij6n2E4PmJOJF3q35vbXcqEJ5zOP7VOZilbAtesHyHYBxZYiTWKzfj7lmsd2dkLT5rSt7RFdf+7w+kE4Lg/jgpexvjeu0aByMODE3wMIr87p836EdWgvTA1XsxOoHEhrantViooxEbylBHRqkD0RsMuJ1fd9OpNb4EJEV3SxYUH4LxsQQ==.box",
  "signature": "HhocJecywnhraXEdI/QgWkDX6HwcnjZSYiI8jpbCBSrzxLpWop28VCBcf34GVHLmrSL+B0jHXTw655/YPas4DQ==.sig.ed25519"
}

{
  "previous": "%KnCJf9vnjWlkEvVcSioO674BlCDmi5rTrQgdtcOzSxI=.sha256",
  "sequence": 782,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1523139270542,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%OseplrEINCACkWg3FQAO8hnDi1rK5Ugi8fNm+QM8t28=.sha256"
    ],
    "packs": [
      {
        "link": "&+Jul5wkA72e70chuZi3mmlsBqsESwETuX3pg93qzr08=.sha256",
        "size": 9255
      }
    ],
    "indexes": [
      {
        "link": "&AFp2XLDpHBcDSNLVBT7+AP8ct3ZXt/eaH7iYw28aVpM=.sha256",
        "size": 1576
      }
    ],
    "refs": {
      "refs/heads/master": "32536c36fe69a32d3691207e144321854123a3fa"
    },
    "commits": [
      {
        "parents": [
          "45af91d27c75700d73f7d3d049d3b7542493486e"
        ],
        "title": "Implement literal parsing",
        "sha1": "32536c36fe69a32d3691207e144321854123a3fa"
      },
      {
        "parents": [
          "26bda91fe2615b8ca57612a5401eed4815f9add7"
        ],
        "title": "Remove magic ast node",
        "sha1": "45af91d27c75700d73f7d3d049d3b7542493486e"
      },
      {
        "parents": [
          "b5e3ca7e19a2f0dd094795369ee808f4a575aba2"
        ],
        "title": "Add trait for positions of ast nodes",
        "sha1": "26bda91fe2615b8ca57612a5401eed4815f9add7"
      }
    ],
    "tags": [],
    "num_objects": 18,
    "object_ids": [
      "0ad4ddb65870849a0665d63932c861da891bdab3",
      "a8d56acf8834b9384c2c5e1a7c4e2d6091120388",
      "448d35ac220194a34299e086c11b07ae790a521e",
      "892de4fbe5145935a11c2ad8cb70a3004c9e9dc1",
      "eb57b7b509350d4b558e4a2b717273fefe7d19f1",
      "dcda81a488bd4556495f221b1cdb50c6b73d847b",
      "6d25c5668ba4dbe116a5215c235d5d1ffe87a187",
      "7790229f28a711e8b4fbeb1e8ac87d8cea69e85d",
      "3c8e03093c3cc1a45086252bd9f354f2ccdc2fab",
      "8704e792aaf2b157a8015ba4649a80403e264779",
      "3b9119cc3561660dd021f5032689bc3fa6d8a0c8",
      "3ffb1b7629d8dfca6072f6642402313679315b6d",
      "9fb70a9b26980047804a15e54506de4267bb5985",
      "d4744bed705d25481de61e78b245cb6715387b32",
      "a8279f7debc54e1c9cddc97c6d4793a73c97bc8a"
    ]
  },
  "signature": "/JBErPGJfcV6n7MI8Safh7aBiQ/RkejvYnbCWJY5nDksrWaDJgkq2Dm9v63c7HTt5XDTbr+3K2SnnGA9gDMBBg==.sig.ed25519"
}

{
  "previous": "%B95lGgNRy+O2exHflfjA164UhlDmeyPL0U2jLOgxp8I=.sha256",
  "sequence": 783,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1523221645365,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%B95lGgNRy+O2exHflfjA164UhlDmeyPL0U2jLOgxp8I=.sha256"
    ],
    "packs": [
      {
        "link": "&WPPncSg0ZeU0DO5I5jAioK0I4OIdSRo4BlrzEddEw04=.sha256",
        "size": 7345
      }
    ],
    "indexes": [
      {
        "link": "&Ii48+3QQGZ918ISNdUDWyHbSo3SVP0C4ZAIAJiGcbRg=.sha256",
        "size": 1212
      }
    ],
    "refs": {
      "refs/heads/master": "79e1400382a285496b3b5264da334b9ae3748ac0"
    },
    "commits": [
      {
        "parents": [
          "32536c36fe69a32d3691207e144321854123a3fa"
        ],
        "title": "Implement some more parsing",
        "sha1": "79e1400382a285496b3b5264da334b9ae3748ac0"
      }
    ],
    "tags": [],
    "num_objects": 5,
    "object_ids": [
      "380ec52a5a33cdfd528653189c69988628ea19b9",
      "38f511ca0d21cb1c2f73c23e63070f9fcf3c3840",
      "fd031975c1562e95ce15b6bd0dd959d28b73e14c",
      "d175a05ffd12917b62ae31a2a8b20327b8ef865d"
    ]
  },
  "signature": "qOcUEV0mJMJlE+gGtzojE9uEOb37PKJ18UQ8T/zVFSlcIGb8/sSyNxi5BSxSVCV1OfsXJ/QdAzp3tUAUF7iXAw==.sig.ed25519"
}

{
  "previous": "%OHsSRq7QtZYgQCsEBjOiaDsceZ+7bCKEvEahmZozHqY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 784,
  "timestamp": 1523258781956,
  "hash": "sha256",
  "content": "JO/K8vtZLgDMsZOoegKAnbacQQCr41qAwjY6a5pbMEXcm8fAbeE4AIhyNjGwyUHBorm3KnLaVRsp+nAcw0dHCYH7V5C45+FzWNVsKnmF+RHXZZr3f9wgA4uSMVtwr/ZKio6kbXXNxZPoi2ximG41q1ncchbvQkw7+394Iroftx9Tp0iEsVawXHObEJtIvRrLEQBO10a98vjub247JPycCbOOZORQtpv3GFb+qTTe/kJSjDBEUTKVc18mfXquxUltwVwYyBeZqil6cr32IQbDHk8bD4WL5sMbQ1BJ1mgFGDi2R3qbKJ0Yhmsj8kXfqD5c7p8djtDY1RGYL5lZNerYw856c4cTbC7pjlAwUJLH3Z9LcV8BUjs09HqFNseIlO06h4Url13FyM94Q//Dvo2d5IEvAfieqwKQYb3tPoQiZpOYLCn2oj6VMHDcgql2+FFj0O8zlhHOMcoyjp2npfE5yACSW28Lm5OYVqxRbnyRqCz/THYqK/czNotkx2ox5ncgUmfMLxPe+Xs3zD8ENdLhdDpItMeUebVssmqWkK7gDKP2bJXqV5I2yk5k5Axtzv3MNNLft3gLzYKV1TN/IKtutOW9zVQIEB0Jd/16ZPx3QmA0UM7wAcYaHtqRyX/iBxUsHpg4+87dThOUXA28K8VJzg2F8a4htZE2aTtzTfr1kLsqaN1+k4FM5/dYbiI6IhYvcScyxCfBQmrrcjToPVu//+tGp5JhLYyN78zpLwukcSSQMTjv6FcYogpTgTPtvWRZqpL1e2q6rLCiTjvjnQL9L0kyMTliun+vICiioWml5C236mFOAD1yQL7E9tDvfsK5JPTcRvgPNoFO.box",
  "signature": "VPWK4FogC3AmdkYSmQzonE5FvIC5N0gAoYH1iTJCvkaWnar6PyPk9R1kvHIcOz32s5/W7eGBuecH91zz8Gi/Dw==.sig.ed25519"
}

{
  "previous": "%OtSfyjEu4cova+qnDV8PNoBRyXlrEbWw/J7ZcWg0K4U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 785,
  "timestamp": 1523273478942,
  "hash": "sha256",
  "content": "kpYArbCdJlDlr0etKzL1Ud70V7zCAMjP4euPNY8dvK1aZPwjeWQUT+ZCUmAB5VyCNq2jtk7OJGQQeXTxphfkwH7kifia6UF4uKnpczGY4H/8kCACu5fy7RO7XKfXfB4Q3TklqBVYXBpMgNFuXcrUWO2vVsWNXr5XuJTSo51f4QMNutbeqMcvFCoK8Gpgbx2lHCNoXNDMFggiDIHMdwzgJQiouGrOJnrk1i5PAUdkf6+Hch/2uj0lkLl/0BVL9ATQl74PeSPADfxv5WQEpXh0IyU10krWVNo1gEIxD4aJMCr7+bwFjTE4eboDzOgkMQ7blVqbV1SaMtB37OsGyOCP+pmK94USK6YhFLj9onRTyOXJmRXDIdeCHJCz0YoK1meoOLZWDD80EH9UdvfPkARPHRVOVYGiZzCe9+yXQnJ56e5ZZpxfyXE1BkrHKa58k2bA197UW5K14C8nKxgIVg7bbQVOrV56c27F7iq4hqmLmvcPQAMkC/9mJltU5ska2QDg+wDG4r6BR8WnuwVrOB8SC62l5fQSDPc9hTRoqZzH5QCeYSnRymplEg/PPEK7MnHUN1jRSvuWQhAalvf+mO01ebjDLD+pYNuxzGTQCfL5R3qiPPR8Jg2/hEZLdrXRwF2PVWsSHVNzCtDMVofs+04oOSwrn6IcwORmuAykKTyLy4dWO6KMHCn/Kfezcd37fhY1hZ4vBr9QQG+LoFa6nPnkVVhCgVe7MbQHvZ3DS34l4Dbh8lMwGVSC/nBqGXpwLiE1WDjoRuFthhXUty0URiJWnosIwAAye7CKbjS48WtHQ9DgxEhtzhYThpKo7+zleD5HS5YmX4b1ZBAHTfhEqhMBo0Y/dASlW1t6RNXl5D7YC9I70xXIScZb2WIkCSMC4k6zzUi2GZqE0PvqIgH3E0US8ZxB2YB/yqcsm13sX2rU6P3Ureo/SZ0Bitxm3Q+APOvZJNaXos4gwJFH/u1fzXxttXfYFf8zUKJCv2sUujPOOd+PyuxJslrKV2Y8stWu1y8V5UwIRuZWDjjIIbYtYJTMe9fxBQzfH5a/SPPtRluR21FmagFF2BCrzXj4z5YECiYhO7wf3yupahUOBS69EAAzb02Mi2a/LidcGU/7GB5LMEKWlZ0eRhrqnCUvO29rCMCOlB3Fa5dTW62+sHyLf1SeESO1+skNH/nELh4lh8wi.box",
  "signature": "UNxw5i3oP9Z3Twa3iKF/RihFaG6SCqpU4cfs9nDNr9Z9DDmilopeWCja+ECXtgjaULsG6SF/JL7fIvq7dob3AA==.sig.ed25519"
}

{
  "previous": "%MW+b29+Jl+MPkpJ7tD7+ONW7UewXRR6e+e9Ls3tIOeA=.sha256",
  "sequence": 786,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1523455672696,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%OHsSRq7QtZYgQCsEBjOiaDsceZ+7bCKEvEahmZozHqY=.sha256"
    ],
    "packs": [
      {
        "link": "&6OxyY8zQ1FmzGwn89HejfGP0dhiECst7ZBZznUmzOIc=.sha256",
        "size": 14589
      }
    ],
    "indexes": [
      {
        "link": "&lTblRyiS5Ddv6c9U4LYXc2FscxoUNQVehQHjFCyaq5Y=.sha256",
        "size": 1268
      }
    ],
    "refs": {
      "refs/heads/master": "f6a50579e3ae85129d8221aad4d34482f138144c"
    },
    "commits": [
      {
        "parents": [
          "79e1400382a285496b3b5264da334b9ae3748ac0"
        ],
        "title": "Write a custom tokenizer",
        "sha1": "f6a50579e3ae85129d8221aad4d34482f138144c"
      }
    ],
    "tags": [],
    "num_objects": 7,
    "object_ids": [
      "a2ebf19669e8d3829dc241280f570eb64ab5aeb5",
      "135e0becbfd57f43dd9045bf81449e7e17237550",
      "d877db6f6fd72df9f99acd4f8a8e2a194223bb76",
      "6d6aaaca8bbbc3871113113aa91fbc77ef60a787",
      "3159377197c267702a49348140b02e71d5430d86",
      "c12155a8b15ffc8d9e2f1b3a58334aea7ab4ebe7"
    ]
  },
  "signature": "org42RJwonilPi+U3hEKZvSptGfErXUElGM9WOhS/8i399JmeZ1gCgKqEHNYizPHzXrvOIeiY33C3rcaeCD3Cg==.sig.ed25519"
}

{
  "previous": "%VVxbv0d+PXIKh8AikIjvjAxLbcqNko+kDwh/IVMrx70=.sha256",
  "sequence": 787,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1523482977136,
  "hash": "sha256",
  "content": {
    "type": "git-update",
    "repo": "%feOeLyzZE3sHy30+udKyY/oF/miEHvA3lnp8xmodJHQ=.sha256",
    "refsBranch": [],
    "repoBranch": [
      "%VVxbv0d+PXIKh8AikIjvjAxLbcqNko+kDwh/IVMrx70=.sha256"
    ],
    "packs": [
      {
        "link": "&+XNiZDmht1jNcAq13eqDW50IRLkkFw1YIlThi9lRlaY=.sha256",
        "size": 11028
      }
    ],
    "indexes": [
      {
        "link": "&L/iYRLQTw1gmpeYLSDnJo1uPrUTKTHgnr+7XNrTpKH0=.sha256",
        "size": 1492
      }
    ],
    "refs": {
      "refs/heads/master": "45e2ab504f7efbb3d291a0c35fe97d10400bf27d"
    },
    "commits": [
      {
        "parents": [
          "2c6afed7b9025bf83ad7f7c25546c8d8a7b521e5"
        ],
        "title": "Start writing nom-style parsers",
        "sha1": "45e2ab504f7efbb3d291a0c35fe97d10400bf27d"
      },
      {
        "parents": [
          "f6a50579e3ae85129d8221aad4d34482f138144c"
        ],
        "title": "Backup first attempt at writing parsers by hand",
        "sha1": "2c6afed7b9025bf83ad7f7c25546c8d8a7b521e5"
      }
    ],
    "tags": [],
    "num_objects": 15,
    "object_ids": [
      "1cbd5fa73032854afedcc48af9648ba28dedccd4",
      "307c16d5ab893fd7f3e11cf94b5981c40b9112f9",
      "3c63a8f365a0c379aece56b3305de9a52ca47490",
      "9a790582569710db4ba682598a3a6f7f7104c49f",
      "651a694dcb1f46b483a54164e7848642e63d18dd",
      "b82aa3f12615e823ec040f255313a8af66998d98",
      "46a9a03f506ade7f95c32ebd8a72a4ca077c07b0",
      "4b00fa8f357a2754e4b25accce8a18b0e64e3c01",
      "0371ca2a3e198c6987d2a37910a3945bd807b92c",
      "817a5518ce18421e115352611bac0000932ca1b2",
      "795b0efa3d23db7fb9398f79e1a23b59baecc0b9",
      "fdb058946d5acd112dc4b384668f33a69601c954",
      "57b41e6f582b770f3bc2155211114febd83ede43"
    ]
  },
  "signature": "848hFiTFzCHHNO2NEsYVbnEf0W/bynSMOZzBZhBQ5Zccc7s+Lj9PRt11TYO2KcQzkir80NTafPZt1VyVHxItCA==.sig.ed25519"
}

{
  "previous": "%b6dVBrkWBGBk6kNqRUKhcTQH1iNca7fjRHIei2+jb1U=.sha256",
  "sequence": 788,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1523529854962,
  "hash": "sha256",
  "content": {
    "type": "git-repo",
    "name": "minimal-version-selection-rs"
  },
  "signature": "09tjicEzOKUhcFzPf6EZL7lNM2SAI54mYMLan1ry6vNFAEKnaHWp6dNfh/gfELUfP+SFM7qxm30FXkr5SO6+CQ==.sig.ed25519"
}

{
  "previous": "%BHjonF+Q/3tVCff1OPi/KJe4JnbRemS3OCp4DZtuyMo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 789,
  "timestamp": 1523548961548,
  "hash": "sha256",
  "content": "5D8J3ESo4gqUrMP6GyqfG5btzBmfa2VFH8s/QqYLGY0HkpvTbSQwfE4ABOPeSUPhw5miHIzwy3VYsbwYK66Ahacq4dyS4DtcyidgSkw4OYVeIjnpfnfdNR6V0I4cUJIggYJ7At+4WtjwSgibWYFbm4GPeETZIxDaDQWItyxZrYBc97mqZJUe7sH+YO5+b1A8q1BiKEmlGiC2o9/AaV4Ve9fwCtjMZgLnmlav73nwoLvyvnc2tbFJ4vMs92cDuh/mJe5OjwEyPhLCA5xaDfpErJYh6suVGBMOQCCgWwww4ggNuNRo2qgkHgE+1a0FDmrjtqViTmSKYAVJAgChJXPxwdhd3I9NwZJL/4SypsA2Q807mcsYfnxwepNywA9DLASEsmm/Y0xg0lEwobmoWJZvnVLC5ubvPLub2Bo/4+9uwlBA4j9nP8MjNlre7wwOtNf4ZM0lfytUQ0r6wyb4Qywea61CFZJnweKuTkJ/8k+DZNtkbhXH9U1Ppk35uMZiGWzIMDb7fDtvhTfbGQe7cywr8Izt2vSub4HVxDaGSjiMQ1+TtE1Yr1AWJwjYUT8I6vDA22DZBsBa5tqAqZnCpGoaI2d3FxPvc1N20FLqMXDe8RbLrMelalZ3uHJu+iJeRerC8hcGAKnOzM86ry7EjPgUj52wN6niD9hAzcPSuV2Z5w5XBU3wNiuUIUO0O7V3Hf5HZbwKyVRrm4G8dnFDHKkiDT5/VrORV2AnF+r3Kf05kvVRIjaTrLAjyLFoCqBCJDuQSFstv39w/BSrnMcPD9tTEa3waXlXyPvmk+e4ctr/zP7geOdASkLU8+Ic0HVNRUB2UAxU6JaPpxAqPWWNZgrwiQRj+3LXbga5ZLhif/5aOqBdOST87c75811U/e6HyVhfOay9wR4KonQTTGhKGkpywSFVZqt5p0TZ+8kUgPferkpiMi4SjMOxdnPavJsEdUoWBVObQpFz+OjCLercdEm+lfOsTdWm1vV4BnU91ZOcmAyCRpZn/rfklaUqzLFOaI6U8esBvPwe3Qe6yRBQwXUb6n17yWXmGPzg2uyArOIQbPkqulrq6h4XGXP2sC8tcGgaybiBMTStObVncEQhqg==.box",
  "signature": "j2AW1eCW6GTg0EC2NHl1yPqL5UjfQOnXGCsFGH315lGTVNNu11oeEiNL+B/JTC7AgrODZST6NJrO3VMmtpMTAw==.sig.ed25519"
}

{
  "previous": "%RrTynWR0K+cLHMeYg9NyBmLNE5AzRmk4+rsOiEkOQCA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 790,
  "timestamp": 1523556817294,
  "hash": "sha256",
  "content": "pXnk5wE38fRNWOUcI7+NtlMAqKSfjCSjQhkneNoRS5KFoaEKqi+ASV6T4DFYRLrXD6tnDUr2WgRGC9AuyD5A6QlQO6+da89wDE6wiHKyPZe2izfbw0mD+Z/Z1eQilMUqK8ps6zjPWYwf2IWEgcKIxDo7YvXPQkOIuUUT8gty6nRHxZ4QmGD/utt4f2nAaVhvZ6IU+rB5rTGvfs7Pela8ZhEwCRT1XOUP7qUDJAi5+O1yG8DrYMukFCiDafO4onsALd8fbHoYDDetbquUe2VzFbg4P6Epx1xKmGoyWdlhyxHatWAd6aEqitO1kCavgNwbGZR5G1IqQrYpdmy541H+uD21cdrndKkQlzCa1Wq+2SSMqU715jGsSE2gtnZKjBxVp9tsRixipUKdTlveXpDMdIJytR6M4PMJr4indMtq4RkwAJkLI6+1azT93BGS4JE2stpIW+nc5dsPR1FzsaufJ2KNEZWLbPZo4aop3FVleO12AToj0Ak6h8DKA8i1Nz8rCByfv0u7z32RXalEt8Kn/8+wyHshJVenD5VSSZ/vnp8qoKLnDkwjnoptsUy6xp2/QWVdsBqQUueb+U6R6R4WhyH5bbERsY0+NJ+v+slywe36QqrulX/oIBIf1nwvtbLfdcu3fulRRM008ArELFFqI026PsysmV5wzfQ4PwRphDoFBqeoteLkrVDV1e25Rk+TIubgtg3GYZMLfAHBaViQpUNFaZ5NWL6iYkLf9BNMnUtHm5oSjPie53bMUeG7wbBjwLDK/2hBi2vugd+SZ2wE68iqS7jaNks5JCzzTIZ0pJ5hsU43tAMGEDJEz7/8q+CfGzm7ewWFlGs1XbfiL7OZlfiuLPaTF1Rd8sOfQSbUGSuS/cAnFgAnypWdJG9M8BjUiIK+UAB/z3DbNfWcBWnQNsJEvtAciatfdh6RLqAjuM5/N8X//eEDHPmdBEl1JFR9R0Oxf5yZZ/OSOBdBM7u3v9vM/lBEyMCF0Q34l35i6ibXTrdENlDLzB51I8+T7ErcDocm/CJBHIY8wNDiWAYJXJ83F1nqovzOUjuE3ut37a1cCHJdcOMThnWdUoXLhP7HBgZWXN/szWJHYRNXYJooaK59u4/J5+cVp+dKTHygIi0XNLkPVrYCAqabltug3yFfHRZcZI1LLp//KpBItNEYz6EQkHY/ArOfRSpvpkldB35fLyBiUP48Yi94oPRADMWuTVerOMl3abWkS24pUwsTvWJ3D8INakQqFE+6aT6Bfm6bGVBZUAtEAnYHr042cDK8JrrgHZ7nWe+MZd1L+OM2sYPLwYWB8IaBl/TB9Ab30f7VxBO/2z4alGD+q37ugZ3UQi491Ql1BrF/Nfl0XYf13Q+b1ARw+mQ3fQCVoRC94wMcJorf7iElUk11+k8BNKtalvZREBzEum1WTQtqcI8kDQDAC+dysbQjHVqgK3Y+l+qMPyNWBYeNOq8OjkwQUEND+Ts=.box",
  "signature": "0/HTt2/RwMUUbTW1bp1jOjbOKPMVNCjeqxH0CQqH+TQUraCcAReTNKvrX4VKxKe8WJwxx+ogKGO8+aMrrDLhDQ==.sig.ed25519"
}

{
  "previous": "%iSnzHzdLKjEUG1t313YQLePnUHtRDXxdioq+EjjYuYg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 791,
  "timestamp": 1523604866558,
  "hash": "sha256",
  "content": "HzrJW7xv7fVPcxEMu7QXrQFu0HYY5bmCUb8JhSwalHo0Vydx66aeUAteRu8lnblMsiDr/GyV12hcCHOB9FspDybZq0nJfT6kziYvTh+fDukyt85bbVMfB/EPI7uywQrwY7DE61/H+eu1dWPynu9NaxlyKPQImG5tTIlrJvjJ2+klJmaE8aDi42zs+2N2Kwk4InFVDidoHm8y6wnDD7hDDW7IxY03xOROPEIK+K4dXV5Fn5XGoiAcEjZzrSMHVg5vnkJv6N6wgGNepG4VCh2PT3tH+MmQ5Imt1VkzRU7UZHhBe2LQ2DYyyoZmAY9RRxdVTiHTZ4i4EA/sue4dob+Hrrt9x5zaVk+oX+tzodTm1end51rqpAwPGSQxahJ9a73PweAC8nLJWIxOL4XZ1/lvkt+TibXNAQ9MkibP8ldOzhDNzaQPzgTjBD3xp5UAEJ31A32KdswketASlhS6YHrqtzfBPnJZv+QHeK93lwdPR6Y2l+Fmf+Yt+//nYd7+bPv6tYLP7+2PprDyzS0R7Mw1DQjHBVYjI5u1QVByNy5SsU+I86aK4JKvGeUn+hjRAE4M/Pa/9D/nj09W/fywSm8LzZOLozDPJuCT/x3qyFwT0WxqecP9IvvuAHYjAxZpbCiRq1TklF30LEuKikJxcmibP7Mu5NScvemg8x28VE53qFQlNjdhg2cEKMlVoLXDaxYmG1gLTDi4nMgDe+BnW9x3jod3KAc4aEZYgmrrBHd30l3ZGzYwQZV1QURzGbhZcjpb1nkVd6DomtPq14OD3ZGwiI6K/gv9oKiw23xt15+bnI+8tksvDf7GxOerKhYnWLJtRAP6RtalbLBmmrQVLL8EE/hHjdHlUIIuy1QW7Ro8463Hr0lPMmVaasZFfhpq2vg/nKzrt52OSVXv8VyTJjecwC0r+ftE1DG52FmKR0fWya9ONqUBAV7pxfAhHHOPCq7YDwJ2zQhLgUx1gTxzZeENX3e9wvdTqCZnwQhJiS+KVmMTrkOzAjqYIlY/h6FXrBXjdo9c4sN/Tz+F1xUDe8B9RUZI9JKClzCVUKuJnYnKVj6+dDBvTFl3psAZB3Qw6g50xP6FQ1AajuS3iMf2VtZs6iKVTgY2RPfGHHc5mdqtFp2jv28wRgYITn405OOaIRVHNRBaKz8blxeP6n9ZB4hTnUij8L7woXNz7VWw1uw=.box",
  "signature": "ux2VrrbEGcMTcCNLj3hE1XIu+If4Zy9ks5eAcUwZUXIAs3NIZfBzsT+9rTsq/CFo23pfDaII+zoF25KviwwaCQ==.sig.ed25519"
}

{
  "previous": "%wRuYqKg8e1BhZYtsDI3U03WeSAIJsV6lDcMkoIeOa+A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 792,
  "timestamp": 1523618412003,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%PUW9oP4vv+wfEDKdF+roi3zakg0+UxyAKNvz9tEUG94=.sha256",
    "branch": "%PUW9oP4vv+wfEDKdF+roi3zakg0+UxyAKNvz9tEUG94=.sha256",
    "reply": {
      "%PUW9oP4vv+wfEDKdF+roi3zakg0+UxyAKNvz9tEUG94=.sha256": "@N1wKacXQpJV9mQqYOSbFuELi88oqsWkV7kqNqRoKRYs=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@slothbag](@N1wKacXQpJV9mQqYOSbFuELi88oqsWkV7kqNqRoKRYs=.ed25519) There's [patchfoo](https://github.com/ssbc/patchfoo) which seems to be what you are looking for.",
    "mentions": [
      {
        "link": "@N1wKacXQpJV9mQqYOSbFuELi88oqsWkV7kqNqRoKRYs=.ed25519",
        "name": "slothbag"
      }
    ]
  },
  "signature": "MO+Ejpww8F0cHKZZDclOb7LS4veAydvLPM8oQIDbZD40UMe0CJGYoJ0yohCqEM+v6c8pvCys6t3hz6zVcqGICg==.sig.ed25519"
}

{
  "previous": "%F7llxmAKckl+LrQ4+/wvkf0ZaxY6a9+0H8BflcUVWQY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 793,
  "timestamp": 1523998853429,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "%weTgYwCrhTX/41yq8KQ7sx3MoRCyn4Fus7ErHJBso5U=.sha256",
    "attendee": {
      "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    }
  },
  "signature": "9kQ0YN7NdOv0weyzdA1+vJZd+ejvLHuHEXIyu9GQRTKsWgaTLDF8HWZ+eEndmCoqRUvdA/7nbc8YHN3cdwLVDw==.sig.ed25519"
}

{
  "previous": "%9qwC7yFXVgbWwXvOq60/zP2cdjvdApMjdirrY/VmwLE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 794,
  "timestamp": 1524911020162,
  "hash": "sha256",
  "content": "jr6wJzhvs6Avqk3gzBVOw8S90htu4VG1PzGMQUQ7z+XVMz6c3inBPd9k6hoB+HWrcS/AAugt4RnXoyxdqS8QL7rNNgd57d4mtnLDki9sNIonGoyLfVVa4CRrtIKlq0xMVm0MWk7quB3cGWw+3wdQ/coktr2SF8eW2/y1vPa5ehzz+LFXGY1EV1h/Ayc4NqZlkBjym3tGoydo/tP4ChikMedtiHwgsKht9IrJydIT+ex/iz4Hw0pb2wepN+Gz1wbpD2TFQO0/Q7YDgFGxfVZCsK238vDni17NQR+uCkZ+Ho9f3nhLY3XPZxk/MiGa4I/hICda3WeEWKlutqO7wxt6MKsq1QUc7wKGxdxzPQaEbD7LrOtbDfF8/ilX5gAQyozIU/UBBu4KDh57KER7blS2goBC96W1UY8igmGHtH2oHubj4TBilxgindkeUc+skrqmMruM9AZDlKys+poBZlLuPpia67EQEF2v/LEocSydSemfq8xHtOglwJSSiqUN/CQ470isTBG1E9mvUrgOSA65ldI+JGPMirE5hZ0uPYPeSlYRyvJMgogIRzlHhenLI+iIpm6xnNgt2sRfQOiVV7vPdul3a0IbQJ8auGpGZY8LFOzR+TU+JnqcUCmVPSwqzpU8JLIG+1jsPCksJUBOACiwjorFAn2O4aGKdATgC+pR1Rvixl7VYHg2HyiV3b5pq2hvfGvJoA7U48UYW+oaytOUYkrHEuXOXeAtuOAbtdlDR9uICOpxT/EmFNY9kwGtXLbgl4aQi9eoXjMbCpLK3R7o5c8JMmPHJPfpo+jljQ9PJkjkN5qQAZR9TGGFZX6/p/IdlkaPgN4ramXVXsqT/8ats1qpQOMyegfWW0XIwbB3EfXhB9V+WHiabFi1NB4DFgAKq7vq2hXrMP0dydA7TqeRs1wI3S/WCe5N/m5AfV3NNo4Rq+fAKkrVTVR7QjHKV+vgzjHaIUQkQGyWXXQ9AKpQK3s10sNkxi4yr1/NHPWA8j4E4mvKRr4MPyeRpVKmnf5Qz/vpDHxfzOFhxO352d31fSA2BVS8gnlDADKwbji3+yMgKWV9mzCITgCcydJf1P46BQ5zp45LQDuGbGYno223TJLtnoMncSVcSEdcs8Y1rYoelJheFAbbPBNfnL5l1BRcoRUi7A4IXLEPZmCCCciwmEveJks0Na+hv9kqVMfSwJtlaS60olztqU8I2TOwN9SGt/uUDkob8eYOzttKSe3XIHhKMxzuBgur4Ui1qywiBi92pIwvRJbYPvRW5T6NFQlq5WGe0RWlr2qZSLmBV4Lhc7xTw9dVF21x9/C0LaD8zOcD1QWKHY7N2yxMu7J9XkWU9dNmYJd8paYHV5ChoQw717f31EUX6q8qkY4VuNs+ioEIM32TkYoG71es8vOlVkBT8tWFkgBqTHlW3syrmdPoW5qOxT9dPf7/.box",
  "signature": "Hi47brzPRt6iO3RKle61z7Vv5ggVBTER0QE2i4JCbTZKGu0XsnMLs1/aU7S6bBEwBh/SSY9SkrYbgsNNEOxNCA==.sig.ed25519"
}

{
  "previous": "%o+UX6+OmYNH7mkhIWZQR+BvQusJ0CQyxsM7YjTzi4Lc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 795,
  "timestamp": 1524952717856,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "mmt",
    "vote": {
      "link": "%/js+jazABMpea4NirMRrcmUzgo9kxnkQkNjSx4KMyp0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "qc8+MB2jpQj1llzSN5D6iMIiT8c8tgotAkIjQzEtIAkp+eebW4NxDk/T9CpU5Z/BwoePMQ8Mb93DSwpA7LU4CA==.sig.ed25519"
}

{
  "previous": "%6jqw6dkUQnNwXl1sb/+zeoRpombJb60GGiHOUl6mW2A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 796,
  "timestamp": 1525380748236,
  "hash": "sha256",
  "content": "ICwl/m4GMBq//GB46xXPcgfmuoW24IhhFL7v8jLGsIhHg2eJccv+VyvRMhW/n9FnIjwgSFvm3nW1MjrbpVeJnaL1DSGxikMODPJuqRM1FDEp+WVfObR0kwX3jbfLPUBQxIO1TQEcSQOe41O8HO3GZ6YsDxiFU0ENpwPhZLbw7Af1bAXHwWVTnhmr8Z92UAZLmWzddRC9eZcrgSgGIXDAQaDkwuUAEO8Ylk6PYk8bvq8o6yMy3iAYAFvq5+43FGH/99ZSRO4eCpdN5OPmm7S23eQ3HmIxKbIjyJ5VgnPiMyZCzNGrwOnmgzuOf5q1/938yedaWD6nD3RwL3kow6i9nDDBKFSzeyzmfQFPT9rR3pgsBavoi+Omip1b5crvR8KHIZH59pRUguoxPPR3qU/icD4c7fMAmgnbYJGTUq+C1XF5pBd2bC1ysBMcrXcOHjFvKa6X89mkhBswBBxcDQ/ZPwuD8ZT0uz+/dA9g0nTK3OoUTL8M28wI+VeevKSYt7d22tvnowhywDNcBRI5F7/fLMusKqiLiJ9b542NQLnCQX2WyeD3xPUFeT6Q3lqyAgXy/7dkzlYByQMYZ1DaFzWZo2f5WLZjGT1mzUr6RcyQ3AUJUVNvSD/cyON8ZdXNg6Sl3LEWOCCCpg6iEzDzkoZJsTc4BCwUBdgxv7SmKILx8Y09u7+hKjl+DikxiWtLCV3fGjr7wsBISXx6IYeofPle6OsBoLX3PmJvwQce28KliSA0kJjRdpZPXf3SisiT6HYNjUv4surmXmGNq+bWH5U8F7BsZLM4KiZtmIDYDLPF3IaEopmrBbDLsCO7GWZXAKDM0al0yuJKQKmw96msBY45EB9FtDHDKGr0gjeDpjraRYL1gd9nKQioztsPoHHEQlEudj77vMCggIc+gxM5neoTXrPuuT7VJu92KAaJ7xNqWZyndLkU2JI42aVDYwjcvGxGI1wGvSoPzsWrnDsG1DU7WqnCR1DZjs2jJD1yKm5LyLo37o6JL7K5j5vGz1Pxoh3oTr2KvhAXVYnpzUoD2AOf59bgBoUitkUFXPWAsj2Xo/9ep7WyY9yHccHavVle407IW6j/MqjL2xMxRssTqSSelD5mPqp1Uu3N0j2nkTzxciJqtQrSJYLoDtgv5FB3pIB9Bfu5hM42GAd1xtIwfrAoxp8dpVW90wBDkh4YqWidaNiNhhoWSdHYfII47+3I5KtVTeLmJxDGkXW53477HztbEOK3X70ualg/uLhaQN6f32BQD9OGuUbst/Q703fOL8ooV+YRItuk6BmpSBm0ajjmZ+07phtAd7/ZWua0sNiocKJgcnkQuqslxe1u+WsN++c0LLPa8sgKxR8990ltEP6GxCFpeQj0RVtb2VzF7wu3/09P/Fr7u/timjj4IwChyfBQ+awTQ/CNTqsz1amiBsS2vvKv4u3d6G5D2e7Lb9zH57YBpKrosSfGwVVDLjf59wh5JmNS78aux7vSqxNBL7V9yj5o5kI=.box",
  "signature": "LtT0oEln0T0BAaaDek4nc3jOYGR5mpWbgehhN/oWGpMlYDy4ccIEnA2wfuF0m1LH4emKl+ICZ0kFApJ9LEhEDg==.sig.ed25519"
}

{
  "previous": "%S/Q4B86GF/E4cl5mj5QI5aJadT3tJKH5P58+TnkyZf8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 797,
  "timestamp": 1526714739809,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FRUoV4kFAvQe29oD9jMpxdU8qFLP0RhrpV9fIRgkxa8=.sha256",
    "branch": "%lfPRU/AlWmpCoXXqNoeKkpgOJr2JbXh0v+G/l13FUfE=.sha256",
    "reply": {
      "%FRUoV4kFAvQe29oD9jMpxdU8qFLP0RhrpV9fIRgkxa8=.sha256": "@k53z9zrXEsxytIE+38qaApl44ZJS68XvkepQ0fyJLdg=.ed25519",
      "%lfPRU/AlWmpCoXXqNoeKkpgOJr2JbXh0v+G/l13FUfE=.sha256": "@C3iYh/12sO1uvKq1KcZXLFxSySzxOkHxXN8rtNB5MGA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Fabián Heredia Montiel](@k53z9zrXEsxytIE+38qaApl44ZJS68XvkepQ0fyJLdg=.ed25519) Some more \"replace the internet\" projects:\n\n- https://fossil.net2o.de/net2o/doc/trunk/wiki/net2o.md #net2o\n- http://unravel.org/ #unravel\n\nI second the addition of #gnunet.\n\nHow about a section with direct links to technical overviews (whitepapers etc)? The [habilitation of the main gnunet author](https://grothoff.org/christian/habil.pdf) is an impressive read.",
    "mentions": [
      {
        "link": "@k53z9zrXEsxytIE+38qaApl44ZJS68XvkepQ0fyJLdg=.ed25519",
        "name": "Fabián Heredia Montiel"
      },
      {
        "link": "#net2o"
      },
      {
        "link": "#unravel"
      },
      {
        "link": "#gnunet"
      }
    ]
  },
  "signature": "NuVNyONTkPxXRkYkWPpIb6xmsqmppYkENg6csvglmKquX8zfAp+Yg8Vyr7sZIWQvpx5ZUSmxNly1cD/bXVIFAQ==.sig.ed25519"
}

{
  "previous": "%IwmG6gKE2nUSRCuabaj+Ktd9sUIkvhAOPUOvUbc8Gno=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 798,
  "timestamp": 1528276467862,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%PDWcZEfqdYshC14lmh2YWIjXOMgxziG6mjktPb+Hf6U=.sha256",
    "branch": "%lrBX6jMkdTx0uVcpEERpUJV4FbsbUJsmuzAAVMzcIz8=.sha256",
    "reply": {
      "%PDWcZEfqdYshC14lmh2YWIjXOMgxziG6mjktPb+Hf6U=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%lrBX6jMkdTx0uVcpEERpUJV4FbsbUJsmuzAAVMzcIz8=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "This turned out longer than I expected, sorry for the rambling. I do feel like this post introduces some new thoughts into the discussion though.\n\n> I'm very doubtful about \"chrome and firefox preserve order of object keys\".\n>\n>I hope it ends up fully bijective. Bencoding is a great bijective simple well-documented encoding, though not with the seeking properties you seek. It simply requires keys be lexically sorted.\n\nThis, so much. We can't use [bencoding](https://en.wikipedia.org/wiki/Bencode) directly (no floats, no json quirks), but it solves a lot of the same problems.\n\nBijections with json get tricky, because, well, json. **I'd argue that we don't actually want bijections between encoding and json, but between encoding and javascript values**.\nThere are arbitrarily many json encodings of the same value. Even if you disallow trivial encoding variations (e.g. whitespace insertion) or less trivial ones (string escape sequences, zero-padded numbers, and many more of the things that make json a horrible format), you still get e.g. key ordering issues. Do we really want to consider `{\"a\": 0, \"b\": 1}` to be a different value than `{\"b\": 1, \"a\": 0}`? There might be issues with backwards compatibility, but I really hope we can use an encoding that produces the same bit sequence for these two values.\n\nSsb chose json because it is schema-less, and you can just read the data in and work with it as js values. But we can just as well define a format with the same properties, so ssb should not really be tied to json's quirks in any way (again, aside from backwards compatibility).\n\nSo: **what exactly does the set of values we need to encode/decode look like?** Both in an ideal world, and with regards to backwards-compatibility? We can't design an encoding without specifying this first.\n\nOne more point: Nothing forces us to use the same encoding in the database and on the wire. I can happily talk to other instances over the wire protocol, but then store data in a completely different way. So *please* don't mess up the wire protocol because of database considerations. Sure it gets more efficient if they share a format, but the consistent wire protocol should take priority. Actually, it's not even the wire protocol we really care about, there's nothing stopping us from adding different rpcs which use a different encoding. The really important part is the bijection between values and the bytes we want to hash. Everything else is replaceable.\n\nAnd a final addendum: We don't really need a bijection, we just need both the encoding and the decoding function to be injective. It is perfectly fine if the decoding function is only a partial function. Or in less mathy terms: It is okay if there are byte sequences which do not correspond to a value. But every byte sequence must correspond to *at most* one value.\n\nI lied, this is the final trail of thought: We can use a different hash suffix to introduce a new encoding, like `.sha256_ssbenc`. An implementation would know that the hash points to a value encoded in the fancy new ssbenc rather than the current json encoding. Clients would still need to implement the json decoding (else, all old content would be lost). But using this scheme, we should be able to design a reasonable encoding without tradeoffs due to backwards compatibility.",
    "mentions": []
  },
  "signature": "WelSqT9QmFdTGdfpVvcDm2EIOJWcYbEfDHSYf1QDcSayEu4pBCI8F2vHM6NhM5yB9yVpXBO9Oaseg3WoX0eqCA==.sig.ed25519"
}

{
  "previous": "%BZhJuocEHF57P9SuQwgzwhq7HRzvh5+R6+wUu6TKCgI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 799,
  "timestamp": 1528449339784,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%PDWcZEfqdYshC14lmh2YWIjXOMgxziG6mjktPb+Hf6U=.sha256",
    "branch": "%jz/4FlbpoUuGiunDwlBJRI5SiU2X8Vt4nABx7kl+H+Q=.sha256",
    "reply": {
      "%PDWcZEfqdYshC14lmh2YWIjXOMgxziG6mjktPb+Hf6U=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%jz/4FlbpoUuGiunDwlBJRI5SiU2X8Vt4nABx7kl+H+Q=.sha256": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "**TLDR: Everything gets better if we treat objects as unordered key/value pairs rather than ordered key/value pairs.**\n\nFor those wondering about the v8 implementation details I am talking about: https://github.com/ssbc/ssb-feed/issues/11\n\nI feel like I am arguing a different point than [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519). Performance improvements are nice, but I primarily see a new encoding as a chance to fix some protocol internals. While this might not be the feedback you expected (and it might not be part of the rabbit hole you explored during the self-nerd-snipe), I still urge you to consider it seriously.\n\n- - -\n\n> The point of an in-place-read system is that you don't actually need to encode or decode it, once you've created it. You create it, you store it to a file, you read it from that file and send it over the wire, they receive and validate it, store it and read it. but no one encodes or decodes it any more. If we have in-place-read we don't actually need bijectiveness, what bijectiveness gives us is an easier upgrade path from the current system, which is a different thing, but still something very useful.\n\nBut at some point, the data needs to be translated into the higher-level data structure that is exposed by the api. A `getHistoryStream` function won't return raw bytes, it will return some sort of (language specific) values. My questions target this part of the process.\n\nThe encoding function should be a function from these values to byte buffers, and it needs to have the following properties:\n\n- actually be a (total) function (each value has exactly one encoding)\n- be injective (different values produce different encodings)\n- have an inverse function (aka decoding)\n- the inverse function is injective (different encodings decode to different values)\n\nThe current system does not have all of these, so doing the same stuff, just more efficient, won't make things any better. Maybe faster, but still fundamentally broken.\n\nBreakdown of the above requirements:\n\n##### Total Encoding Function:\nIf the function is not total (i.e. there exist unencodable values), there are values that can not be hashed. This requirement is (maybe even too) obvious. The json solution fulfills it.\n\nEach value having at most one encoding is necessary so that content-addressing via hashes works. Whether the json encoding fulfills this one, depends on your definition of the set of values we want to encode. In json, a different ordering of the key/value pairs in an object results in different encodings. In consequence, the order of the values of objects matters. This has been a major source of frustration for all protocol implementers, as well as the dependence on explicitely unspecified v8 behaviour.\n\nWith a new encoding, we get a chance to fix it, by treating maps (aka objects) as (unordered) sets of key/value pairs, rather than (ordered) lists of key/value pairs. This is what most people would intuitively expect, and as far as I know, that is also how all current rpc methods treat objects.\n\nIf there was one thing I could change about the protocol, this might be it. Technically, the current json encoding is a proper function, but only because the domain is a superset of what would actually be sensible.\n\n##### Injective Encoding\nThis one is pretty clear. Failing to be injective not only messes up content-addressing, but it alsomeans we can't get a decoding function otherwise. Json fulfills this.\n\n##### Inverse Function\nThe inverse function does the encoding, so it is quite obvious as well. It only needs to be defined over valid encodings, not arbitrary byte sequences (but since a peer might send arbitrary bytes, there needs to be error handling). For each encoding, there must be at exactly one decoded value. For js (where objects are ordered), this would require some sort of canonical decoding order, propably established implicitly by decoding in sequence.\n\nBeing a proper function is especially important in the ssb context, because otherwise the (probabilistic) guarantee of values with the same hash being the same values is lost.\n\n##### Injective Decoding Function\nJson fulfills this, but only because the order of key/value pairs of in-memory objects matters. If the js api representing values as actual maps rather than js objects, than the json encoding would not have an injective decoding function.\n\nWhy does this property matter? Not fulfilling it violates the guarantee that things with a different hash refer to different values.\n\n- - -\n\nSo technically, the json encoding works. But practically, replicating the order-dependent maps is a pain in any language that is not javascript. And actually, it would also be a pain in js, if the implementation did not rely on details of v8. Maybe #somebodyshould make a PR to v8 that changes the internals, thus breaking the reference ssb implementation.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "#somebodyshould"
      }
    ]
  },
  "signature": "ej1eUZ+H4NwKgp7M2w9v1dhrsMpVH9AWAnGbwD+oWWWlpjsvsTXIvBU8lvkZVlBabU7EYZcYyE0kVc5HXmiBDg==.sig.ed25519"
}

{
  "previous": "%CNyXWKel0eBjXslhR0wd3t/co1zz8Ki2l8y/tnAAnzk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 800,
  "timestamp": 1528455173258,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%mGIrR2DWXceENNZrVNwyEUpukxUv7bKAQABc2nkxizQ=.sha256",
    "branch": "%/lUigqzlmzyJXDZkRs5SRABXmXEdHuOyMCyEl7qV18Y=.sha256",
    "reply": {
      "%mGIrR2DWXceENNZrVNwyEUpukxUv7bKAQABc2nkxizQ=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%/lUigqzlmzyJXDZkRs5SRABXmXEdHuOyMCyEl7qV18Y=.sha256": "@dBQlwh9Gtr3i5YMOGtIOKtGNVepeu+nyb6KGl1vtOcM=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> They're also fine for human consumption (“50 minutes ago”, etc.), aren't they?\n\nWhich makes them part of the application layer, not the protocol layer. If your client wants to display those messages, it can look for a timestamp key in the message content.\n\n- - -\n\nSince we are on the topic of timestamps: What is their data type? Unsigned 32 bit integer unix time? Unsigned 64 bit integer unix time? An IEEE float (32 or 64 bit)? A series of characters matching the regex `[0..9]*`? Or `[0..9]+`? Or perhaps `[0..9]*(\\.[0..9]*)?`? What about `NaN`, `Infinity`?\n\nWhen I got a floating point timestamp when testing the rust implementation, I literally stopped working on it for a few days, out of frustration...\n\n- - -\n> monotonic timestamps could be a should not a must.\n\n:heart: ",
    "mentions": []
  },
  "signature": "ESqDsOPwRjVvC6WQg1J09RsNu+ILgL8mh6oqGl1Ui3QLKucvIh4IOFI9XQ+/BqQ14UreOMmVys6tGCge3QtHCA==.sig.ed25519"
}

{
  "previous": "%j+FmeN6BCz0VoYdgv8g3MB/WEyBYvV8knEzp1ZrogUM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 801,
  "timestamp": 1528455179325,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%zsb1/yxINUL9v3/pOHD3DMuFu++KvfQganwub5aGS/0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "2FoNvqGyyQtQRKqADItR/5dd/X3QmnwBbM440XsskCLiQpiZ1s3/Y0dIC05PUeBNhsV8Qqj3ONcuGHfKA7UKBA==.sig.ed25519"
}

{
  "previous": "%7gLqLnHj03fBFXTg7OyQ/VaNY7p+7lXwPYvSJdvzIxA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 802,
  "timestamp": 1528455184921,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%kM+R6IQHFFBvpNklvoqZippDArNXdIfi//s2IW7mRh4=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "97UrH+nfovyvRx422k1dzFAyEGGpsCbYfV5x7CsP2VpDno4/3MQC4dspHHRV9WYTa1QBOaGGOC6T3HV+5cdNAg==.sig.ed25519"
}

{
  "previous": "%YZftAgJmHi2Znu1wtZhULfnhNACP9j0uJEj1rPsQlHQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 803,
  "timestamp": 1528458911744,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%JUWVLBCYh07bUykWTkXfj0m8ybzM26TTOJfo1XG3tVw=.sha256",
    "branch": "%uAEPtpeROJpzs8E1sEOLiU69I3CFywxHk6Sih2FjWEI=.sha256",
    "reply": {
      "%JUWVLBCYh07bUykWTkXfj0m8ybzM26TTOJfo1XG3tVw=.sha256": "@DJVbfRTEhC3cH1zU5/BAx6MgKIX1fkkytaRziA10suw=.ed25519",
      "%uAEPtpeROJpzs8E1sEOLiU69I3CFywxHk6Sih2FjWEI=.sha256": "@DJVbfRTEhC3cH1zU5/BAx6MgKIX1fkkytaRziA10suw=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "There's the fun topic of NAT hole punching[1]. Pubs can function as the server for hole punching, establishing direct connections between NATed peers. I don't know if that is currently implemented, but at least it is possible. So to join the peer network, a client needs to know a pub with a public, static ip address, this pub can then facilitate p2p connections.\n\nSsb sends network addresses as [multiserver addresses](https://github.com/ssbc/multiserver), so it would be possible to implement a type of NATed ip, consisting of the ip and of a (pub) server for hole punching.\n\nImplementing all of this is not trivial, but it is at least possible. There's also a bunch of [literature](https://scholar.google.de/scholar?q=peer%20to%20peer%20hole%20punching&hl=en&as_sdt=0%2C5) on distributed hole punching. It's too long since I read any of these, so I can't recommend any specific papers though.\n\n[1]: https://en.wikipedia.org/wiki/Hole_punching_(networking)",
    "mentions": []
  },
  "signature": "WoMJ1yOWNMS3CHYbgfUbnmiHocC911SnTNEkVKbs0lYIUVzeaeRyYk+M1ugSlhVrwwgDFHz32Uj7NtiYuBWJAg==.sig.ed25519"
}

{
  "previous": "%pvISESQdxWPvLGcPYIRnvV3q/NuWRtNp+ocNKMe0cb8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 804,
  "timestamp": 1528459645411,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%JUWVLBCYh07bUykWTkXfj0m8ybzM26TTOJfo1XG3tVw=.sha256",
    "branch": "%pvISESQdxWPvLGcPYIRnvV3q/NuWRtNp+ocNKMe0cb8=.sha256",
    "reply": {
      "%JUWVLBCYh07bUykWTkXfj0m8ybzM26TTOJfo1XG3tVw=.sha256": "@DJVbfRTEhC3cH1zU5/BAx6MgKIX1fkkytaRziA10suw=.ed25519",
      "%pvISESQdxWPvLGcPYIRnvV3q/NuWRtNp+ocNKMe0cb8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I'm too easily distracted... [This paper](https://hal.inria.fr/hal-00945700/file/paper.pdf) seems both fairly self-contained (although I'm pretty biased since I already knew the concepts it works with), and it proposes an algorithm that could be adapted to the way ssb currently works (although ssb does not use a peer sampling service for a random network, rather it has the network topology mirror the social graph, but I don't really know the details of this).\n\n[@kik](@DJVbfRTEhC3cH1zU5/BAx6MgKIX1fkkytaRziA10suw=.ed25519) and cc [@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) who might be interested stuff that decreases the central role of pubs.",
    "mentions": [
      {
        "link": "@DJVbfRTEhC3cH1zU5/BAx6MgKIX1fkkytaRziA10suw=.ed25519",
        "name": "kik"
      },
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "YMH4izMUdBlhM/3laZarkAB+U1FdkTrU669H4QesN8i1r1t51i6G/qyFUOtkD7jmcVJt/3c5ySHGRXlr7J/ABQ==.sig.ed25519"
}

{
  "previous": "%7l7VO8P7lD2EkiYETAesycigoUg1u8OkJbhC+ZDCTbc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 805,
  "timestamp": 1528473282579,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%JUWVLBCYh07bUykWTkXfj0m8ybzM26TTOJfo1XG3tVw=.sha256",
    "branch": "%/Woy02645kVEWZLH2Kjl0Vo5kE0KMVMEoPOwuarT3Jo=.sha256",
    "reply": {
      "%JUWVLBCYh07bUykWTkXfj0m8ybzM26TTOJfo1XG3tVw=.sha256": "@DJVbfRTEhC3cH1zU5/BAx6MgKIX1fkkytaRziA10suw=.ed25519",
      "%/Woy02645kVEWZLH2Kjl0Vo5kE0KMVMEoPOwuarT3Jo=.sha256": "@DJVbfRTEhC3cH1zU5/BAx6MgKIX1fkkytaRziA10suw=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@kik](@DJVbfRTEhC3cH1zU5/BAx6MgKIX1fkkytaRziA10suw=.ed25519) Yes, I think so. As long as there is a path between any two nodes in the overlay formed by the existing connections, these two nodes can connect directly to each other, even if both sit behind a NAT, by relaying the whole-punching setup via the overlay.\n\nBut to initially join the network, a new node still needs either the address of a static peer (just like you need to know a pub in order to start gossiping in ssb), or a natted peer with a statically known RVP.",
    "mentions": [
      {
        "link": "@DJVbfRTEhC3cH1zU5/BAx6MgKIX1fkkytaRziA10suw=.ed25519",
        "name": "kik"
      }
    ]
  },
  "signature": "dwEOnPftwQC4BPLnI6vPcByNiPLD91oQfYwUHIaTpKpulpRVa/SUoB7tXGFf0pJkYxdv8h+FYzeWoLpbDinBAw==.sig.ed25519"
}

{
  "previous": "%EtLHFvKhJtsadA4K8CYwY93vw61K8yu4jZbCYmReeb8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 806,
  "timestamp": 1528532795598,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%mGIrR2DWXceENNZrVNwyEUpukxUv7bKAQABc2nkxizQ=.sha256",
    "branch": "%CQ6OBaclKKK850GgTHnWFgSfPFjQ8P3NPhl2hi0VpeI=.sha256",
    "reply": {
      "%mGIrR2DWXceENNZrVNwyEUpukxUv7bKAQABc2nkxizQ=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%CQ6OBaclKKK850GgTHnWFgSfPFjQ8P3NPhl2hi0VpeI=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> @Aljoscha the timestamps come from https://github.com/dominictarr/monotonic-timestamp.\n\n[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) The problem is this: I don't care at all how [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) computes his timestamps. Ssb is a distributed system, anyone can throw anything at you. In fact, all users who replicate [@Vendan](@wLinNWXMCITML7/3DyVrcQvhVuit7rQehPJdXlsyuVU=.ed25519) have timestamps in their database that were not generated by the code you linked to. There simply is no place where \"timestamps come from\".\n\nSo when I ask for their type, I really want to know which kind of data has to be rejected, and which data has to be processed, as mandated by the non-documented protocol. Here are some fun cases that come to mind:\n\n```js\n0\n42\n001\n0.0\n1.0\n0.1\n0x1B\n0x1K\n-1\n-1.1\n1.2e-37\n1.2E4\n1.2E+4\n\"\"\n'single-quotes'\n\"cookies?\"\n\":clock4:\"\n\"2018-06-09T02:03:18.707Z\"\nundefined\nnull\nNaN\nInfinity\n+Infinity\n-Infinity\n[]\n[0, 1]\n[0,]\n{}\n{\"a\": 0}\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n```\n\nAnd then there is the question of how valid timestamps should be treated. Parse into a float (how many bytes?)? Parse into integer? How do comparisions work? As floats, or lexicographically? How do I compare `01` and `1`?\n\nYet another question: How should invalid timestamps be treated? Ignore the message? Block the complete feed? \n\nThis is the stuff that matters. I'm not asking these questions because I want to know the answers (honestly, I'm afraid of them), I'm just stating them, because they matter more than any piece of code you could link to (or I could search for).",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@wLinNWXMCITML7/3DyVrcQvhVuit7rQehPJdXlsyuVU=.ed25519",
        "name": "Vendan"
      }
    ]
  },
  "signature": "6GCZKcOcLONe30fqO6pj3ifIE/ROuo16Ca2MEFpkkxSyy75q4H8TLI0ss2a1g8wFqnIxLFrlgGiAFZTNlgqbAQ==.sig.ed25519"
}

{
  "previous": "%8DzQ9ev1SBo6l0NAPfgquz3ETaXUo90b5B4Mrd4FEcQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 807,
  "timestamp": 1528534610754,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%mGIrR2DWXceENNZrVNwyEUpukxUv7bKAQABc2nkxizQ=.sha256",
    "branch": "%8DzQ9ev1SBo6l0NAPfgquz3ETaXUo90b5B4Mrd4FEcQ=.sha256",
    "reply": {
      "%mGIrR2DWXceENNZrVNwyEUpukxUv7bKAQABc2nkxizQ=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%8DzQ9ev1SBo6l0NAPfgquz3ETaXUo90b5B4Mrd4FEcQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "And I forgot a whole class of problems that come with the limited precision of floating points. There's a few ambiguous cases you can construct. And good look with the (or should I say \"a\"?) [json spec](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf) not clearing those up at all. There's a bunch of implementation-specific behavior hidden in here, and it is already baked into the protocol.\n\n- - -\n\nI'm sorry if I sound bitter, but these are real problems with the protocol. \"We'll use json, that's easier\" and \"We'll add timestamps, that's easier\" add up to a complex mess, where not a single person, not even dominic, knows how exactly everything works. These are the reasons I have become rather inactive, and I already feel frustrated just from my last few posts.\n\nAs much as I love the design space ssb is exploring, the protocol details prevent me from committing to it. I don't even want to blame anyone. All design decisions are trade-offs, and the ssb protocol as it stands allows rapid development, high experimentations, and fast exploration of the design space. But these come at the cost of the ability to stabilize the protocol, and of long-term maintainability. I joined the community in a phase where the importance of these properties already shifted to the latter. So even if intellectually I can understand/retrace/justify the protocol design (or protocol evolution?), I mostly feel frustration.\n\n- - -\nHuh, this post turned out different than I expected... But there have been (and are) quite a few other technically-inclined users with similiar feelings, so maybe this should be discussed more. CCing a few channels/humans who might care about this meta-protocol stuff. Feel free to add more, I'm lacking the energy to go on a search right now.\n#butt-studies #community-gardening [@corlock](@sHFNLAao6phQ5AN17ecYNUbszDa4Qf6DhyQsjtQfdmY=.ed25519)  [@Teq](@CxnSXWYjPT160y7QbmTFtWaWT09080azgErYPt1ZeZc=.ed25519) (you were part of the research project about people's motivation on the network, right?)",
    "mentions": [
      {
        "link": "#butt-studies"
      },
      {
        "link": "#community-gardening"
      },
      {
        "link": "@sHFNLAao6phQ5AN17ecYNUbszDa4Qf6DhyQsjtQfdmY=.ed25519",
        "name": "corlock"
      },
      {
        "link": "@CxnSXWYjPT160y7QbmTFtWaWT09080azgErYPt1ZeZc=.ed25519",
        "name": "Teq"
      }
    ]
  },
  "signature": "8tH1pokAwqJXtXeFSfcMtZYXc82ZMNwFV1XNQdOw4mFmlyQxiCdjcGvjxUK9A0rg8xJJTQEXKFQh66ey8eNvBA==.sig.ed25519"
}

{
  "previous": "%9J5PfeWqO2VkFXH4GDM9fMPMktUZIsALQUyFp761fbw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 808,
  "timestamp": 1529225490525,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%PDWcZEfqdYshC14lmh2YWIjXOMgxziG6mjktPb+Hf6U=.sha256",
    "branch": "%75HdnYC/E/BY2N9qhAodVUEqquc6/xx1EYUOUP3TrSI=.sha256",
    "reply": {
      "%PDWcZEfqdYshC14lmh2YWIjXOMgxziG6mjktPb+Hf6U=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%75HdnYC/E/BY2N9qhAodVUEqquc6/xx1EYUOUP3TrSI=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519)\n> The issue I have with that is that in (most?) statically typed languages (at least Go or C or so), accessing fields one by one it would be really annoying to type-cast all the time [...].\n\nHonestly, I don't think this should matter. Developer convenience of encapsulated implementation details should *not* influence the design. If your language has functions and can hide the struct internals, you can get a nice API for this. It might be annoying, but not really a lot of work (even when parsing, you also need to define all the types you parse to).\n\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)  \n\n> Though, if you really want to parse the whole thing up-front, if you kept a handle on the original bytes and used those instead of reserializing the data, then you'd get the same effect. Order and thus the current order-dependent signatures would be preserved.\n\nFor in-memory use-cases this seems acceptable to me. But it restricts the design space of persistent formats. Maybe this new format is optimal and nobody will ever need to implement another way of serializing the data. But how realistic is that?\n\n- - -\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), I'd love to hear a direct answer to this question: Why do you want to keep objects order-dependent, instead of giving a canonical form (and introducing a new hash suffix if necessary for backward compatibility)?",
    "mentions": [
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "RaUM+DA0SXDYYwVucurDIxLzP9r3f54sXwr4zW/stlrVgA4Z2ZzVjiXixKPiE4XckUGKW2j4kHZGuSl6R6VwDQ==.sig.ed25519"
}

{
  "previous": "%plZMAQa+w+f2//mAnOpKPrRDq4HiAn8e2UMidD9N89g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 809,
  "timestamp": 1529241491884,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%Nws5Vhovd5SpFfgROddq+h3YR9JwDQWXS1ckWMA5JU0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "3yxlRAqJPy/3jgX0s6BvNEy7pEVSGzmz5LbMxo4j/4ulaWMfF3cFMmblca4oLkXh9jMr3xRhr+hc/iOp+48zDA==.sig.ed25519"
}

{
  "previous": "%MsttzhFYw0JsqMruOpuEjAjg/Lg6gpfWognY/BG1uy8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 810,
  "timestamp": 1529489772018,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%8+V5EzocB+eANABdRy9LpbZL1JoUYbF8UIm9ZLnwRi4=.sha256",
    "branch": "%KEPdbTmglcRC/9e3rBmT2Y9KpRp33W4u9V2OmsEy2r4=.sha256",
    "reply": {
      "%8+V5EzocB+eANABdRy9LpbZL1JoUYbF8UIm9ZLnwRi4=.sha256": "@d2vneic0a0Y7OoRYvhXf+nCOBIV/lFQXHmOcHNr/3/I=.ed25519",
      "%KEPdbTmglcRC/9e3rBmT2Y9KpRp33W4u9V2OmsEy2r4=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "The #ssb-implementations channel was my attempt at bundling this sort of stuff.\n\nAlso note that the rust modules are on hold, at least until the rust [futures crate](https://crates.io/crates/futures) stabilizes on a `1.0.0` release. I may or may not get back to working on them at that point - I honestly don't know yet.",
    "mentions": [
      {
        "link": "#ssb-implementations"
      }
    ]
  },
  "signature": "sDGxYzu45lNE1osq6Y2zHznnpG5I7eKymnEo9sWKnGRPzZrashKQrl0d131XLFQxjFE7T0/pywEaVHtFujXOAQ==.sig.ed25519"
}

{
  "previous": "%8HScoUqOjgtdbkd/SpYpsXnE4RHzRnPNUJCsgC4sl64=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 811,
  "timestamp": 1529923947672,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%a/FKqS1nDHHkjIWVv7BanmXP5ffB4L5hZVkf0qL79NE=.sha256",
    "branch": [
      "%+QJWa7Pc9Cjvyi3tkFTK2BGcxE8tC2+gUYvAr++Y4hQ=.sha256",
      "%Kl9dXixH8FGb3TX4QqVfLzte0MnkBJJfDA6fcaGOZRc=.sha256"
    ],
    "reply": {
      "%a/FKqS1nDHHkjIWVv7BanmXP5ffB4L5hZVkf0qL79NE=.sha256": "@3ZeNUiYQZisGC6PLf3R+u2s5avtxLsXC66xuK41e6Zk=.ed25519",
      "%+QJWa7Pc9Cjvyi3tkFTK2BGcxE8tC2+gUYvAr++Y4hQ=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@corlock](@sHFNLAao6phQ5AN17ecYNUbszDa4Qf6DhyQsjtQfdmY=.ed25519) As far as I understand it, the follow graph is *not* part of the core protocol. It is implemented in plugins, you could actually have ssb without this sort of replication. An example use case would be a package manager where each package is a feed, specifies dependencies on other packages, and a replication plugin would transitively replicate all dependencies of each package you register interest in.\n\nsbot includes the responsible plugin by default, and all clients which ship with an internal sbot include it as well. So while currently all applications agree on this replication strategy, it is not mandatory.  ",
    "mentions": [
      {
        "link": "@sHFNLAao6phQ5AN17ecYNUbszDa4Qf6DhyQsjtQfdmY=.ed25519",
        "name": "corlock"
      }
    ]
  },
  "signature": "QhewGSxbX7Q3EI8524YkGBtcz/r/H156x17V4cDKX/G/59i8BEtDda0i6WmpdFO5cu2PHzxOjZSNo3LaeDcmBg==.sig.ed25519"
}

{
  "previous": "%zL6dDs0B/ko6Ku7Cr92ncgXjbIBxpDMSU1F1D6Te9dU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 812,
  "timestamp": 1530172993186,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%2QyeqAwBcr7Z1qjuTegqgaPjzkcOqSVMKdy4k/d6KtY=.sha256",
    "branch": "%Jl/PQbEOEXkeY7mMkkTfp9XrDIYDBxjWq6Omcyqy16Y=.sha256",
    "reply": {
      "%2QyeqAwBcr7Z1qjuTegqgaPjzkcOqSVMKdy4k/d6KtY=.sha256": "@cWe8dc7juUTJUOq7wRJgscxnbII+Rm7/CUc5Ilx2PKU=.ed25519",
      "%Jl/PQbEOEXkeY7mMkkTfp9XrDIYDBxjWq6Omcyqy16Y=.sha256": "@3r4+IyB5NVl2in6QOZHIu9oSrZud+NuVgl2GX3x2WG8=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@hoodownr_swift](@cWe8dc7juUTJUOq7wRJgscxnbII+Rm7/CUc5Ilx2PKU=.ed25519) But what would the verb mean?\n\nHave you already seen [@Zach!](@ZqH7Mctu/7DNInxuwl12ECjfrAKUX2tBLq1rOldNhg0=.ed25519)'s essay [\"The future will be technical\"](https://coolguy.website/writing/the-future-will-be-technical/index.html)? It has a module on [verbs](https://coolguy.website/writing/the-future-will-be-technical/verbs.html), and is a fantastic read in general. ",
    "mentions": [
      {
        "link": "@cWe8dc7juUTJUOq7wRJgscxnbII+Rm7/CUc5Ilx2PKU=.ed25519",
        "name": "hoodownr_swift"
      },
      {
        "link": "@ZqH7Mctu/7DNInxuwl12ECjfrAKUX2tBLq1rOldNhg0=.ed25519",
        "name": "Zach!"
      }
    ]
  },
  "signature": "mhg4fGtzzThkDQ25ELW38LeXIld7cqhcJRSg7NcYeyoM4NtVueMCu/vAybjc9sEEAKDmN9Q6uNxfVm8UF37zDA==.sig.ed25519"
}

{
  "previous": "%j18cARPvDY7PV6QDpwhO1yT/aiqJAYHDGxe3v0UsD7I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 813,
  "timestamp": 1531339750339,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "invocation",
    "text": "### A Registry For Specialized Message Handlers To Allow a Modular Ecosystem Of Clients, For Which I Did Not Find A Catchy Title\n\nOr #ARFSMHTAAMEOC for short.\n\n#scuttleshell got me (re)thinking about an idea for a modular system of independent, specialized clients. This has certainly  been brought up already somewhere in the vast scuttleverse, but I'm not aware of any specific thread. So maybe this one can serve as an #invocation.\n\nImagine each client could specify to some *registry* process (that could be scuttleshell, or simply an sbot plugin) which message types it can render and interact with. Additionally, it would register a command that can be used to start it and directly present a UI for a given message hash. This would be done persistently.\n\nYou could then build clients that only deal with a very focused set of message types, à la git-ssb web-ui. When a more \"general purpose\" client encounters a message type it does not know about, it could query the registry whether there is a client installed that can deal with these messages, and if so, it can present a UI to open the message type in this specialized client. Opening the handler would simply happen by sending an rpc to the registry with the message's hash to the registry. The registry would then handle things like client startup (and run-or-raise functionality, see below).\n\nTaken to the extreme, you could have a skeleton client that does nothing but process all messages and delegate to dedicated handler clients. Another possible architecture would be a bunch of specialized clients which all delegate to each other.\n\nThat's the whole gist of the idea, but there are a few fun avenues to explore here. For example:\n\n- If a handler for a specific client is already running, it probably should not open a different instance, but the message should be opened in the current instance (also focus needs to switch to it). Could be done by registering itself at startup with the registry process and opening a muxrpc channel between the two, so that it can be notified when it should open a message.\n- What sort of information should be registered? Aside from the message type and the command to run the handler, it might also be nice to specify a description of the message type, maybe and icon, etc. This also opens up the issue of localization.\n- You could also go further and register a [web-component](https://www.webcomponents.org/introduction) (or something equivalent) to display in a general-purpose client. This is js-specific though, so I'd personally prefer something declarative and language-agnostic.\n- There might be multiple clients that can handle the same message types, how should this be dealt with?\n\nIn addition to this fairly basic form of modularity, you could do some pretty fancy things like self-describing messages, and dynamically discovering, downloading and running message handlers. But these sort of thing lie further in the future (and come with their own large bag of problems).\n\nThis #ARFSMHTAAMEOC of locally registered message-handlers however is fairly self-contained, and not terribly unrealistic. It does somewhat rely on [oop-plugins](%a0K84ZSjySdxxpoGaX5UV0RWzElSor7pgyR9aC0/KFo=.sha256) though.\n",
    "mentions": [
      {
        "link": "#ARFSMHTAAMEOC"
      },
      {
        "link": "#scuttleshell"
      },
      {
        "link": "#invocation"
      },
      {
        "link": "#ARFSMHTAAMEOC"
      },
      {
        "link": "%a0K84ZSjySdxxpoGaX5UV0RWzElSor7pgyR9aC0/KFo=.sha256",
        "name": "oop-plugins"
      }
    ]
  },
  "signature": "1EPHuO/lrMvSJNkbYJbwoE5tOlWXmF4FI4uqwDBoDbU1RgDs/4lkPjOwwH9RZtHXryloNUWKX//4uh39riEEAg==.sig.ed25519"
}

{
  "previous": "%evFWDkc/iLCnjB32J0o4QOQ9pkOGWHQiSXPIKSGqJVA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 814,
  "timestamp": 1531401577296,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%w1/E7i97T+tCTRn70h2Xx/gDAmwxNiWMkEJF1h1X+1M=.sha256",
    "branch": [
      "%FaXIV6IbtrCeDFwFfnGwT47sKT+1vBmXPiqYU/ZZGWY=.sha256",
      "%LDvJkd+HhTDPqj8IFxm+pJWKZ0uJ3rT/NzgvVltMGl4=.sha256"
    ],
    "reply": {
      "%w1/E7i97T+tCTRn70h2Xx/gDAmwxNiWMkEJF1h1X+1M=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
      "%LDvJkd+HhTDPqj8IFxm+pJWKZ0uJ3rT/NzgvVltMGl4=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519"
    },
    "channel": "go-ssb",
    "recps": null,
    "text": "Regarding unix sockets for unencrypted connections:\n\n> I would guess secret-stack because it's the one that sets up net + shs, and the encryption is coming from shs. multiserver is just a bunch of client-server types put together.\n\n> That sounds very suitable for implementing local unencrypted connections. I'm just wondering what's the support of that in Android, macOS, and these non-Linux OSes.\n\nI think it would be more principled to include the local channel in multiserver. That could be a `native` connection typecan use any os-specific ipc channel in the implementation. On linux that would be unix domain sockets, windows could use whatever native API it has.\n\nSecret stack could then set up one of these native connections, without encryption, in addition to the default localhost tcp and websocket connections.\n\nBy doing this, we'd also get local gossiping for free (mostly useful for testing). The gossiping code however should only gossip native multiserver addresses over native channels.",
    "mentions": []
  },
  "signature": "m/G3o85t6PiFVOnF8ZTBL9TtmUUNskd+KdQSDzp3XhE62Wb4NbBVWlKFk6r5t9r9qtljzvBZIXcftX1DZwtzAQ==.sig.ed25519"
}

{
  "previous": "%jO3ecXaHwLMKpio5QH/Sx1JWzlF5BCYHe2Zz5rhqDms=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 815,
  "timestamp": 1531430936262,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "go-ssb",
    "vote": {
      "link": "%LBWRyhld+mHw3qb9ICRXEqIyPNEkmLJhvqViJX6bXcc=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "4eMCVWXBqoSf+gyRg6D5gdF7uqFLWhwtd38gk7f50+7khfwa1ORGW+C12ooQOMVBXCWJcdwVy/igTxfoot6jDA==.sig.ed25519"
}

{
  "previous": "%STf93wZ2fek+JHv9YU4C4YP0zUqMZgeAVZQcst6Lm1Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 816,
  "timestamp": 1532249606128,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519",
    "following": false
  },
  "signature": "Y2QJZ7sFi+8lkMQuYngyIhsUZlrprKb0SXmK31IWIAuZ3Ie9vUur2EYS3e+Tp3JUF+68gHOdahKzIpA12fG/DQ==.sig.ed25519"
}

{
  "previous": "%mRofv7SmXoAOBn/Q+QAcIq+pXnwaV3v3J6fz7DcgN8Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 817,
  "timestamp": 1532787625081,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc-grants",
    "vote": {
      "link": "%NahlzqB+W895V43+4rNW09W3MQZOz9UjpTA9e2b2GxI=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "w5mX1pRCh5SwdUBpDAjXSVN+rQwAsVLIZzExBpWjhO4FCX/2KqlxHPgBvKw0Py4l0JjiX3kcbGzfSYQWyxHbDA==.sig.ed25519"
}

{
  "previous": "%Gy0mo5ACqbAAF/rfqCkYqB0LWBs3Cnm6CFrImDni0UU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 818,
  "timestamp": 1532787629581,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbc-grants",
    "vote": {
      "link": "%OOIQaVZeroRtW0i7SpdahneL4zjtv/h8B2K2fIH7H7Q=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "ipotaR8tlTqQo+YLVoS3LNe6Tsmeaz5R/GBgSG/mXKteyF6UHHa8WFM+fUFxApfL/YfgRvDORDaZlsgziZFuCw==.sig.ed25519"
}

{
  "previous": "%ezhAzUctcTkJrcw5y39W2aNte6fUHPiR0bk7Wpg+Wjs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 819,
  "timestamp": 1533826619241,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "conceptart",
    "subscribed": true
  },
  "signature": "SctM9rxyHa674pF9Z71lU8D30ptJ0tb1CHHqY7R49wHnZUMnCtSR382NbeId86uofpm9Hs73FFh/Jeiv9N5YCA==.sig.ed25519"
}

{
  "previous": "%Z5ZtxCTNFN47LGlvzDZJKbjCd3cA6XNoFrdC/fa+7hA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 820,
  "timestamp": 1534089290507,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@isFCNRNxl80IIy2ibgenfgEPqqFQ3vU5qyXCu+mSSeI=.ed25519",
    "blocking": true
  },
  "signature": "s/ew7ej41ypQ+Lkw14ZIBmOb2M7J2v6zHNIWiOrBYmTbmOANDUPZPSZumO6O0Fn9QdyRASREPCeP4nkflAQ8DQ==.sig.ed25519"
}

{
  "previous": "%HR2TUjCH5YGHJGvrsUW14dsj/175Auct6cLm+GOOy6M=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 821,
  "timestamp": 1534155857545,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%27rdEuNneOwaXtG7N8mA/LCFMWEy7SgSbvboWw74vGw=.sha256",
    "branch": "%NTwav7x0ZyoY4LpC7GLTOcmXo/FfJcg8RPW5W7Ii0Bc=.sha256",
    "reply": {
      "%27rdEuNneOwaXtG7N8mA/LCFMWEy7SgSbvboWw74vGw=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
      "%NTwav7x0ZyoY4LpC7GLTOcmXo/FfJcg8RPW5W7Ii0Bc=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Couldn't you simply perform a secret-handshake, but throwing away the negotiated secrets instead of encrypting the connection afterwards? This way, local processes get the speed benefits of unencrypted communication, while still having to prove their knowledge of the secret key.",
    "mentions": []
  },
  "signature": "qNmHC+u+f+bU76IB9HxwlXPnu8uliaqkYw1Q3+EfRfdjkXjLIVpC3LwUXeFGqZ5LaQOd4LdD9DKVDqBDceJSAQ==.sig.ed25519"
}

{
  "previous": "%P85H1frHRa0IYf8WBrLkRudnWfCTkMLAJMXCeGK3bIY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 822,
  "timestamp": 1534617824036,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%35qaqstoN3NB2MawCyZesFaLStO3ynUQf9LxlAGQK3M=.sha256",
    "branch": "%ao0oe3fEsTXPScT+xCskZqQzFdgaSfM5ez4SfKYkFnY=.sha256",
    "reply": {
      "%35qaqstoN3NB2MawCyZesFaLStO3ynUQf9LxlAGQK3M=.sha256": "@RHCdibs1o7RnEOxHFq7TfDn2RXHC2yeQh7CyK0tAJyc=.ed25519",
      "%ao0oe3fEsTXPScT+xCskZqQzFdgaSfM5ez4SfKYkFnY=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Berlin? Wait a second, that's where I live. Can't say for sure yet whether I can make it, but I'll try.",
    "mentions": []
  },
  "signature": "x5jX3CciM5wWFOr2XjA7Ds+oTkC+vsxEsn9kByxsKnEecB2RHu2ks5t9TwXX1TVvy0VriZkHfGVYS4fUHiLTCg==.sig.ed25519"
}

{
  "previous": "%WKEv8OA5RmGKjiRdlqx42cqv55AoLmMPlB4/Jq6Z2g4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 823,
  "timestamp": 1534617830448,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "%35qaqstoN3NB2MawCyZesFaLStO3ynUQf9LxlAGQK3M=.sha256",
    "attendee": {
      "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    }
  },
  "signature": "kmgC6NwFMBJ226Ad4fGkiN6WA6cG0SkcAD1u4T6fxVx39Mv7WHUwwkKtKEvt7E+GmkF0aWG0M+jAFVtm9wRoCA==.sig.ed25519"
}

{
  "previous": "%MsJZSrgracwmTpzdM/2Qj9/ZDVYw+96DD0/PRQdRd6Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 824,
  "timestamp": 1534689964586,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "%35qaqstoN3NB2MawCyZesFaLStO3ynUQf9LxlAGQK3M=.sha256",
    "attendee": {
      "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "remove": true
    }
  },
  "signature": "fP4LqJY+UoVHJFjdnlkXvcSVQrKwS1L8iApsefad+HhXaV7yOVF3CUJHmEBO622sSoMPlQRTBaPFvX5xTt4yDw==.sig.ed25519"
}

{
  "previous": "%47Xr66gRcTFuVyVKmDJdvIGx5IOH2DDKg/oGxNxJ6NE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 825,
  "timestamp": 1534868057124,
  "hash": "sha256",
  "content": {
    "type": "post",
    "text": "I accidentally designed a human-readable data format today. It tries to deal with the issues of [canonical data representation necessary for content-addressing](%CNyXWKel0eBjXslhR0wd3t/co1zz8Ki2l8y/tnAAnzk=.sha256), and with the associated [problems with floating point numbers](%8DzQ9ev1SBo6l0NAPfgquz3ETaXUo90b5B4Mrd4FEcQ=.sha256). Also, it an serve as the syntax of a #lisp. So in case anyone is interested, here's the spec.\n\n# SDN\n\n**s**imple **d**ata **n**otation\n\nThe billionth human-readable data format. Derived from and very similiar to [edn](https://github.com/edn-format/edn), but more minimalistic. Also attempts to specify how to precisely deal with floating point numbers.\n\n## General\n\nSDN must be encoded as utf8.\n\nThe whitespace characters are `\\n` (ASCII character 10) and ` ` (ASCII character 32).\nWhitespace is ignored other than to separate elements.\n\nAn sdn file consists of exactly one element.\n\nAny line starting with `;` outside of a string literal is considered whitespace.\n\n## Elements\n\n### nil\n\n`nil` is an element, it is the single value of the unit type. It represents absence of information.\n\n### Booleans\n\n`true` and `false` are elements, they are the two values of the boolean type.\n\n### Strings\n\n```sdn\n\"A string, \\\\ \\\" \\t \\n \\u11B3  \"\n```\n\n(This description is mostly stolen from [TOML](https://github.com/toml-lang/toml#user-content-string))\n\nStrings are surrounded by quotation marks. Any Unicode character may\nbe used except those that must be escaped: quotation mark, backslash, and the\ncontrol characters (U+0000 to U+001F, U+007F).\n\nEscape sequences:\n\n```\n\\t         - tab             (U+0009)\n\\n         - linefeed        (U+000A)\n\\\"         - quote           (U+0022)\n\\\\         - backslash       (U+005C)\n\\uXXXX     - unicode         (U+XXXX)\n\\UXXXXXXXX - unicode         (U+XXXXXXXX)\n```\n\nAny Unicode character may be escaped with the `\\uXXXX` or `\\UXXXXXXXX` forms.\nThe escape codes must be valid Unicode [scalar values](http://unicode.org/glossary/#unicode_scalar_value).\n\n### Integers\n\nAn integer consists of one or more digits `0` - `9`, optionally prefixed by a `-`. No integer other than `0` itself may begin with a `0`.\n\n`-0` is not a valid integer.\n\nIf an integer is suffixed by a `N`, it is an arbitrary precision integer. Else, integers outside the range of a 64 bit two's complement (smaller than -9223372036854775808 or larger than 9223372036854775807) are invalid.\n\n### Floats\nA float consists of an integer (without an `N` suffix), followed by a dot `.`,  followed by one or more digits `0` - `9`. It may be prefixed by a `-`. It may be suffixed by an exponent. An exponent is an `E`, optionally followed by a `-`, followed by one or more digits `0` - `9`.\n\n`NaN`, `Infinity`, `-Infinity` are valid floats. `-0.0` and `0.0` designate two different floats. There is only a single `NaN` (no signaling, no sign bit, no payload, etc).\n\nFloats are [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) 64 bit floats. Any floats that can not be represented exactly must be [rounded nearest, tied to even](https://en.wikipedia.org/wiki/Rounding#Round_half_to_even).\n\n### Rationals\nA rational consists of one or more digits `0` - `9`, followed by a `/`, followed by one or more digits `0` - `9`. It is an arbitrary precision rational number. The denominator of a rational is not important, i.e. `2/6` may be internally stored as `1/3`.\n\n### Symbols\n\nSymbols represent identifiers, they consist of alphanumeric characters, or `# : / . * + ! - _ ? $ % & = < >`. A symbol may not start with a numeric character, and `nil`, `true`, `false`, `NaN`, `Infinity`, and `-Infinity` are not valid symbols.\n\nWhen some characters can be parsed as either a number or a symbol, they must be parsed as a number.\n\n### Lists\n\n```sdn\n(x 14)\n```\n\nAn ordered sequence of elements, represented as `(`, optional whitespace, any number of elements, optional whitespace and `)`.\n\n### Set\n\n```sdn\n#{\n  a b c\n}\n```\n\nAn unordered collection of elements, represented as `{`, optional whitespace, any number of pairs of elements, optional whitespace, and `}`. Each element may appear at most once.\n\n### Map\n\n```sdn\n{\n  a b\n  c d\n}\n```\n\nAn unordered collection of key-value pairs, represented as `{`, optional whitespace, any number of pairs of elements, optional whitespace, and `}`. Each element may appear at most once.\n\n## Equality\n\nTo enforce the uniqueness of set entries and map keys, there has to be an equality relation.\n\n`nil` is equal to `nil`, `true` is equal to `true`, `false` is equal to `false`.\n\nTwo integers are equal if they consist of the same characters. 64 bit integers and arbitrary precision integers are never equal.\n\nTwo symbols are equal if they consists of the same characters.\n\nTwo strings are equal if they result in the same data after resolving escape sequences.\n\nTwo floats are equal if they result in the same IEEE 754 64 bit float after rounding. In particular, `NaN` is equal to `NaN`.\n\nTwo rationals are equal if they both describe the same rational number, e.g. `2/6` equals `1/3`.\n\nTwo lists are equal if they have the same length and all corresponding pairs of elements are equal.\n\nTwo sets are equal if they contain the same set of entries, independent of the order.\n\nTwo maps are equal if they contain the same set of pairs, independent of the order.\n\nAll other pairs of elements (in particular elements of different types) are unequal.\n\nContinued in the next post.\n",
    "mentions": [
      {
        "link": "%CNyXWKel0eBjXslhR0wd3t/co1zz8Ki2l8y/tnAAnzk=.sha256",
        "name": "canonical data representation necessary for content-addressing"
      },
      {
        "link": "%8DzQ9ev1SBo6l0NAPfgquz3ETaXUo90b5B4Mrd4FEcQ=.sha256",
        "name": "problems with floating point numbers"
      },
      {
        "link": "#lisp"
      }
    ]
  },
  "signature": "lcJG6X56PYPeaanX4xz8WEJpgVc21KAbYEq2QRLeIm/fOPm3icMRch7B5K0qosse7hUU1sqFCA4LEdmvOKL9BQ==.sig.ed25519"
}

{
  "previous": "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 826,
  "timestamp": 1534868075032,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256",
    "branch": "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256",
    "reply": {
      "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "## Canonical encoding\n\nThere can be multiple encodings of some value that decode to that same value. In some settings (e.g. when working with content-addressable storage), this ambiguity is harmful. This section describes a canonical way of encoding data to prevent these problems.\n\nThe sources of non-unique encodings are:\n\n- leading and trailing whitespace of an sdn file (this includes comments)\n- escape sequences in strings\n- floats with exponents\n- floats with rounding errors\n- rationals with different denominators for the same number\n- whitespace in lists, sets and maps (this includes comments)\n- order of entries in sets and maps\n\nThe canonic sdn representation of some data is obtained as followed:\n\nOmit all leading and trailing whitespace. Omit all whitespace that is not needed for separating elements in collections. Separate these elements by exactly one space character (ASCII 32).\n\nIn strings, do not use any escape sequences other than for quotation marks `\"`, the backslash `\\` and the control characters (U+0000 to U+001F, U+007F). Escape `\"` as `\\\"`, `\\` as `\\\\`, and control characters as `\\uXXXX`.\n\nFloats must be encoded such that there is a `0` left of the decimal point, and the exponent must always be included. For example, `10.0` becomes `.01E2`, `-2.0` becomes `-0.2E1`, `3.0E0` becomes `0.3E1`, `0.4` becomes `0.4E0`. Additionally, if deserializing a float would involve rounding, serialize it as the float it would round to.\n\nFor rationals, use the denominator with the smallest possible absolute value.\n\nFor sets and maps, we define a total order on canonical elements. Sets must list their elements sorted from smallest to largest, and maps must sort from smallest to largest key. The order is defined as the reflexive (according to equality as defined above), transitive closure of the following relation `<`:\n\n- `nil` < `false`\n- `false` < `true`\n- `true` < any 64 bit int\n- any 64 bit int < any arbitrary precision int\n- any arbitrary precision int < any float\n- any float < any rational\n- any rational < any string\n- any string < any symbol\n- any symbol < any list\n- any list < any set\n- any set < any map\n- for 64 bit ints `a` and `b`: `a` < `b` if a is smaller than b\n- for arbitrary precision ints `a` and `b`: `a` < `b` if a is smaller than b\n- for floats `a` and `b`: `a` < `b` if `totalOrder(a, b)` is true, as defined in the IEEE 754 standard. Which, by the way, sits behind a paywall, but searching the web for `IEEE 754 pdf` or something similiar helps.\n- for rationals `a` and `b`: `a` < `b` if a is smaller than b\n- for strings `a` and `b`: `a` < `b` if the utf8 encoding of a is lexicographically smaller than that of b\n- for symbols `a` and `b`: `a` < `b` if the utf8 encoding of a is lexicographically smaller than that of b\n- for lists `a` and `b` whose entries are already canonical:\n  - if `a` is empty and `b` is not: `a` < `b`\n  - if the first entry in `a` is smaller than the first entry in `b`: `a` < `b`\n  - else, `a` < `b` if (`a` without its first entry) < (`b` without its first entry)\n- for sets `a` and `b` whose entries are already canonical:\n  - if `a` is empty and `b` is not: `a` < `b`\n  - if the smallest entry in `a` is smaller than the smallest entry in `b`: `a` < `b`\n  - else, `a` < `b` if (`a` without its smallest entry) < (`b` without its smallest entry)\n- for maps `a` and `b` whose entries are already canonical:\n  - if `a` is empty and `b` is not: `a` < `b`\n  - if the smallest key in `a` is smaller than the smallest key in `b`: `a` < `b`\n  - if the smallest key in `a` has a value smaller than the value associated with the smallest key in `b`: `a` < `b`\n  - else, `a` < `b` if (`a` without its smallest key) < (`b` without its smallest key)",
    "mentions": []
  },
  "signature": "+SfpIUHAntiBKU4ExEvGQLRYoHJsxG2ZSLA2iLykqcQr9dyTzAJgk+z/jR5tGWXRPLH71EU6Wt8apiJQZpNfBA==.sig.ed25519"
}

{
  "previous": "%BWJdgqSV4sAPx4hlGYRmxyoMK2hd4iQFr4NwkpgXppU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 827,
  "timestamp": 1534889618639,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256",
    "branch": "%o5JKPcNwI6cFaaNGb/S3LijxiIDgdhG6O/zKLaUxOZI=.sha256",
    "reply": {
      "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%o5JKPcNwI6cFaaNGb/S3LijxiIDgdhG6O/zKLaUxOZI=.sha256": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@alanz](@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519) Good catch! Changed to\n\n> A rational consists of **an optional `-`, followed by** one or more digits `0` - `9`, followed by a `/`, followed by one or more digits `0` - `9`.\n\n- - -\n\nI also realized the canonical representation of floats is ambiguous, it would allow both `0.1E0` and `0.01E1`. (Hopefully) fixed by changing to\n\n> Floats must be encoded such that there is a `0` left of the decimal point, **a nonzero digit after the decimal point,** and the exponent must always be included.\n\nEquivalently, it could mandate to always use the lowest possible exponent (still with a single `0` left of the decimal point), but the other formulations seems easier to understand to me.\n\nI just found a canonical float encoding in the [XSD spec](https://www.w3.org/TR/xmlschema11-2/#f-doubleCanmap), which might be better than rolling my own.\n\nAlso, simply printing and reading floats is [apparently](https://lists.nongnu.org/archive/html/gcl-devel/2012-10/pdfkieTlklRzN.pdf) [rather](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.4152&rep=rep1&type=pdf) [complicated](https://popl16.sigplan.org/event/popl-2016-papers-printing-floating-point-numbers-a-faster-always-correct-method).\n\nI fear I'll have to read the full IEEE 754 standard and at least those papers, if I want to make sdn a real thing.",
    "mentions": [
      {
        "link": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519",
        "name": "alanz"
      }
    ]
  },
  "signature": "tQWfHKu/nkmAAUJKpurbAVDhWBHrkVKQn6TrmjeIatoNzHEmIQtydhw6LqIO3OwEpLOV8PAu4dGt9PHiwsj/BQ==.sig.ed25519"
}

{
  "previous": "%egSI90yb8njJAfRCKTiK6YTuIrhQgPTl0INjyRbUDNs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 828,
  "timestamp": 1534917858919,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256",
    "branch": "%P06BAdmR4oCJxijS5VhYcmo0KKJXc8mcW3QUUdiWL5k=.sha256",
    "reply": {
      "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%P06BAdmR4oCJxijS5VhYcmo0KKJXc8mcW3QUUdiWL5k=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@christianbundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519) Alphanumeric is correct. These are identifiers as used in a typical programming language, i.e. names of variables. Disallowing alphanumerics would result in some rather interesting code =D Anyways, (hopefully) clarified as\n\n> Symbols represent identifiers, **valid characters are alphanumeric characters and any of `# : / . * + ! - _ ? $ % & = < >`**.\n\nThe list of non-alphanumeric characters is a true subset of printable ASCII characters, chosen to allow writing common operators. In lisps, there is no distinction between operators and function, you'd invoke `(+ 2 3)` just like any function. The non-alphanumerics are chosen to allow common names such as standard arithmetic operators.\n\nConstraints on these were:\n- ASCII only (allows implementation without caring about encoding details (if the implementation is allowed to assume valid utf8-encoded files))\n- no conflicts with the syntax for collections\n- leave out enough characters to allow syntax extensions (a lisp probably wants to use a superset of this data format, e.g. for quoting and pseudoquoting)\n- avoid confusion (no `[ ] , '`, few people would intuitively read `[1,2,3]` or `'a'` as identifiers\n\nThe list can be extended without breaking backwards-compatibility, so new characters could be added - although I don't expect a practical need for this.\n\nI was unsure about including both `.` and `:`. Perhaps I should remove one of these, so that a superset of this format could use them for scope resolution (i.e. `foo.bar` as in js or `foo::bar` as in rust).\n\n- - -\n\nA (somewhat) easy solution for the canonical form of floats could be to use the criteria defined in the papers on float printing:\n\n- correctness (rounds to the correct floating point number)\n- optimality (uses the fewest number of characters)\n- some tiebreaker in case multiple correct and optimal results exists. This could be as simple as lexicographic ordering, but I'll look whether these algorithms have some consistent, clean (if maybe implicit) tiebreaker.\n\n- - -\n\nRationals need some updates as well. What is the canonical representation of `x/0` for any positive integer x? What about `-x/0`? How are equality and the total order defined on these? Should they even be allowed? I was also sloppy with the syntax, it currently allows arbitrary trailing zeros.",
    "mentions": [
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "christianbundy"
      }
    ]
  },
  "signature": "bZaT4JwvJIjCwaV0vUe9reJfVqfAJjpR3YAVJ0D4SbZsnQUWtDZCHas/s41m0rEbUoc0rR9EQZey+f5K+gu1CA==.sig.ed25519"
}

{
  "previous": "%bF/4zJewgbDJF0K0TRhXaDSgZ8bx23hBJu2rc47B6Ls=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 829,
  "timestamp": 1534927032402,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256",
    "branch": "%bF/4zJewgbDJF0K0TRhXaDSgZ8bx23hBJu2rc47B6Ls=.sha256",
    "reply": {
      "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%bF/4zJewgbDJF0K0TRhXaDSgZ8bx23hBJu2rc47B6Ls=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Published this on [github](https://github.com/AljoschaMeyer/sdn).\n\nI decided to disallow rationals with a denominator of `0`, since this would force readers to have a data structure to represent this. In all the use cases i can imagine, simply using one of `NaN`, `Infinity` and `-Infinity` should suffice anyways.\n\nAdded a disclaimer about the conflict between human-friendly formats and canonical forms: \n\n> The canonical encoding somewhat defeats the point of a human-readable format, since it normalizes away all whitespace. For this reason, it might be better to use a more efficient (and in the case of floats less painful) binary encoding. For this to work, there has to be a bijection between valid canonical sdn encodings and valid canonical binary encodings.\n\nAnd I settled on a canonical format for floats:\n\n> Floats must be encoded such that the resulting string:\n>\n> - rounds to the correct float\n> - has a `0` left of the decimal point\n> - has a nonzero digit after the decimal point\n> - includes the exponent\n> - is a shortest possible string satisfying these criteria\n> - if there are multiple shortest strings satisfying these criteria, chose the one with the smaller exponent\n> - if there are multiple shortest strings satisfying these criteria with the same exponent, chose the smallest number among them\n\nThis may look complicated, but there are algorithms for this, which are tuned for performance and are used in real projects (e.g. there is (or at least was) [code in V8](https://github.com/marcandrysco/Errol/blob/master/grisu/src/double-conversion.h#L61) that can compute this canonical form).\n\n- - -\n\nThis has now reached a point where I can step out of the rabbit hole and start implementing it. I won't implement the canonical formatting until I need it. I also have a binary representation sketched out, but that will have to wait until I want to actually use it as well.",
    "mentions": []
  },
  "signature": "kk6hedK9QqjLNEa2U6gsPH3Zyoln2nN37io2C1uY8xpzWORqrqV2Wsvei47raPHsfYODxGXKmaWNqHCsBy5WCg==.sig.ed25519"
}

{
  "previous": "%VeoeBI3halXd4s0WGPZe4F3tchyE+KRiZv86F4yX/cQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 830,
  "timestamp": 1534927940955,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256",
    "branch": "%VeoeBI3halXd4s0WGPZe4F3tchyE+KRiZv86F4yX/cQ=.sha256",
    "reply": {
      "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%VeoeBI3halXd4s0WGPZe4F3tchyE+KRiZv86F4yX/cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Since I have now had an unhealthy overdose of float formatting considerations: [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) and [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519), how do you serialize floats when generating ssb messages in go? Do you use the same defaults as V8 as for when to use exponential notation, whether to use `'e'` or `'E'` etc?\n\nI wonder whether these are specified as part of ecma script, or whether these are again implementation details that crept into the ssb protocol =/",
    "mentions": [
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      }
    ]
  },
  "signature": "Mu3joP4YhO6tUC04MwmjYqJrs79LpY7PzE23hZHwFdzK4y2dGmnHBz7M5PfUeY7hJVeakHa1EVBbo9bfGhnBBA==.sig.ed25519"
}

{
  "previous": "%jv8E22imE76+/3qX//Lp1Vn/HsBmvwAsa4cNQbCjQ6I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 831,
  "timestamp": 1534960864336,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "open-studio",
    "subscribed": true
  },
  "signature": "Cy9MLg2ZFUe7EcHU/wgiasxjKedevIPgx4ojG9H5cgZzCotadwCoTpxbLMbcCSGAYNLNH0Hdd6sfJ2xrxDcuDg==.sig.ed25519"
}

{
  "previous": "%4uxPywYhWVWz6CoxASxJDqHqMqjCfV/8wS4RsLrfxjs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 832,
  "timestamp": 1534971265088,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "reply": {
      "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) I lack the energy for a thorough response to this, but here are a few immediate reactions. I apologize in advance if these turn out too raw or direct. I hope this does not come out as too negative, I really do appreciate you taking the time to pick up this conversation.\n\n> fork from [@aljoscha](@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519)'s proposal [...]\n\nJust to clarify: This was not intended as a proposal for ssb, this was simply me going down a fun rabbit hole about choosing a syntax for a lisp. This started by thinking about highly dynamic languages with content-addressable module loading, see #ssb-annah for the origins of this (I remember mentioning a \"lisp with an event loop\" somewhere in that channel, that's what I was fleshing out yesterday). But I'll take the bait and consider the potential usage for ssb in this response.\n\nHad I intended this as an ssb proposal, I would have suggested a binary format instead, together with a human-readable, non-canonic display format.\n\n> I think the SDN proposal just goes to show how difficult it is to design a cannonical format, [...]\n\nI disagree with this being difficult, it took less than 24 hours to come up with that - all the difficult stuff has already been solved elsewhere. The equality relation and the total order take some space to write down, because they are inductively defined over all data types, and there's a bunch of data types (more than ssb would need btw). But none of the cases are really complicated - the sole exception being floats. But canonical floats become easy in a binary format - IEEE 754 defines binary exchange formats. Disallow all but one `NaN` representation, done.\n\n> [...] and the benefit of that is just the ability to parse to an intermediate data structure, then serialize again, and have the hash still be the same.\n\nThere's a more important part: Any two programs which happen to generate the same data will serialize it to something with the same hash. That's one of the first properties I'd want a content-addressed system to have.\n\n> Given the kind of data structures different languages and runtimes might prefer are not necessarily exactly the same enough to preserve all features required for cannonicity, this can be awkward...\n\nssb enforces data structures, no matter whether its data format has a canonical representation or not. It currently enforces a data structure where maps are ordered sequences of pairs, which is awkward.\n\n> as it was that the JSON implementation which did support `json==JSON.stringify(JSON.parse(json))` cannonicity in V8 (but not in the JSON spec)\n\nI'm not sure if I parsed this sentence correctly, but the property you state does not hold in V8, and everything would be horrible if it did hold.\n`JSON.stringify(JSON.parse(\"2.00000000000000000000000000000001\")) == \"2\"`, and that's a good thing. Else, node would be forced to always remember the corresponding source string to any json it parses. Which defeats some of the points in parsing.\n\n> If it doesn't require a lot of code, it requires a lot of specification...\n\nCode in total, or code one needs to implement oneself?\n\n> On the other hand, a serialize once design is simpler overall (the signer is the only one to serialize a structure, other readers parse, but keeps a handle on the raw bytes, and just write that instead of reserializing) and doesn't introduce requirements to parse it into any particular type of structure.\n\nThis completely gives up on the idea that equivalent data structures should produce the same hash. And even stronger, it gives up on the idea that identical data structures should produce the same hash. To me, this is completely absurd.\n\n> Implementations can choose their own optimizations, but that is difficult with a cannonical format. And also, a non-cannonical format can be designed for other desirable features, such as read performance, in-place access, or ease-of-implementation.\n\nDoes a canonical format inherently conflict with performance and in-place access?\n\nAs for the ease of implementation: I don't think the complexity is too big (assuming non-textual floats). There just isn't a format with a readily available implementation (although XML comes close). In js, we have easy access to highly optimized json parsers. These optimizations might make them more complex, than a straightforward implementation fo something like sdn would be.\n\n   ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
        "name": "aljoscha"
      },
      {
        "link": "#ssb-annah"
      }
    ]
  },
  "signature": "WTVbLqe61ApT1Y8kuZMzoTDj1u7olJ3q2PHhE8f1QUjKK1FK4Tk09o8+EZrKJTVX367Sj/A+cOmiO1NlryqvAg==.sig.ed25519"
}

{
  "previous": "%ZiLzt1ZBsSzltPioH2AoorHGV96bWjPCl8Afhr621O8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 833,
  "timestamp": 1534973546505,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": "%ZiLzt1ZBsSzltPioH2AoorHGV96bWjPCl8Afhr621O8=.sha256",
    "reply": {
      "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%ZiLzt1ZBsSzltPioH2AoorHGV96bWjPCl8Afhr621O8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Ok, sleep is overrated anyways. Here's a 20 minute design of a hypothetical data format ssb could use. I just wrote this down without spending much time thinking about it, so please don't interpret this as a serious proposal. This simply tries to serve as a demonstration that nothing about a data format with nice properties is inherently complex. From the perspective of a computer, this format is both simpler and easier than json.\n\nThe concrete encoding is fairly arbitrary, there surely are more efficient alternatives that could be substituted without violating any important properties. Also, this is not at all how I'd design this from scratch, instead it incorporates the json/js/ssb quirks I remember off the top of my head.\n\n# Hypothetical SSB Data Format (HSDT)\n\n## Logical Data Types\n\nAn hsdt value is one of the following:\n\n- `null`\n- a boolean (`true` or `false`)\n- a utf8 encoded string (may include null bytes) // TODO replace ut8 by whatever encoding js actually uses, if that is how ssb stores strings\n- an IEEE 754 double precision floating point number, excluding the infinities and NaNns\n- an ordered sequence of values, called an array\n- an unordered mapping from strings to values, called an object. An object may not contain the same key multiple times (strictly speaking, this may not be compatible with ssb, because json doesn't enfore this)\n\n## Human-Readable Encoding:\nEncode arbitrarily (whitespace, floats, object order etc) as json. Never use the human-readable encoding programmatically, other than to diplay it to the user.\n\n## Encoding\n\nNon-canonic binary encoding or an hsdt value:\n\n- if it is `null`, encode as an unsigned 8-bit integer `0`\n- if it is `true`, encode as an unsigned 8-bit integer `1`\n- if it is `false`, encode as an unsigned 8-bit integer `2`\n- if it is a float, encode as an unsigned 8-bit integer `3`, followed by the 64 raw bits of the float\n  - when parsing, error if the raw bits signify an ininity or NaN\n- if it is a string, encode as an unsigned 8-bit integer `4`, followed by the length as a [varint](https://github.com/multiformats/unsigned-varint), followed by that many bytes\n  - when parsing, error if not valid <insert the encoding used by ssb here>\n- if it is an array, encode as an unsigned 8-bit integer `5`, followed by a varint indicating the number of elements (alternate version: a varint indicating the number following bytes that correspond to this array), followed by the encodings of the contained values in order\n- if it is an object, encode as an unsigned 8-bit integer `6`, followed by a varint indicating the number of entries (alternate version: a varint indicating the number following bytes that correspond to this object), followed by the encoding of the key of one of the entries (optimisation: skip the tag designating it as a string), then the encoding of the corresponding value. Repeat until all entries have been encoded.\n\n## Canonic Encoding\n\nThe only source of nondeterminism in the non-canonic encoding is the order of entries in a map. For the canonic encoding, sort the entries lexicographically based on their key.",
    "mentions": []
  },
  "signature": "q31RYvTR+ggn92XrbcxRJ6uBdTzmgUOud547f//qczgfsgRMoP4jjsrAehSUafCUBRhoq338S8aULXSKzI1/Ag==.sig.ed25519"
}

{
  "previous": "%euTgqawxHIGxR6rGWWvsn7nNVKQ4jojF0ljMoGXvhBM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 834,
  "timestamp": 1534974209605,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": "%euTgqawxHIGxR6rGWWvsn7nNVKQ4jojF0ljMoGXvhBM=.sha256",
    "reply": {
      "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%euTgqawxHIGxR6rGWWvsn7nNVKQ4jojF0ljMoGXvhBM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I lied, there's another source of nondeterminism. For the canonical encoding, all varints must be the shortest possible varint to express the number (i.e. zero must be encoded as `0000_0000`, something like `1000_0000_0000_0000` is not allowed).",
    "mentions": []
  },
  "signature": "lM31xNOdM/pVkYtNTzi2Mp3jC6dAsna+Bjm5KooAKhDAy1/q3F+HRRd9jClJu7HTZ5LTriAV9ZP0uPBDAkFaAw==.sig.ed25519"
}

{
  "previous": "%H3/+bNmXKaOlSPSRlvF7FUIPKs+lwpyKXTE0A4dpCvc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 835,
  "timestamp": 1534976305408,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": "%u1/Uiu1d3cdBp6Wh8PlwASINiKoNv70CC2zg7S/3IAY=.sha256",
    "reply": {
      "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%u1/Uiu1d3cdBp6Wh8PlwASINiKoNv70CC2zg7S/3IAY=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> Wow [@Aljoscha](@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519) thank you so much for this work you're doing here.\n>\n> It's really important engineering work that no-one else is tackling.\n\nThis isn't engineering, it's ~~polemic~~ a proof of concept. **hsdt as sketched above is *not* a good format!**.\n\n> Maybe we can avoid having to have the _one true encoding_ by using [multiformat](https://github.com/multiformats/multiformats)\n\nSsb does not need one true encoding, all cypherlinks carry a (free form) hash suffix, which could simply indicate the encoding that was used to compute the hash. And ssb server implementations can talk to each other via morse-code encoded messages if they like - the database doesn't care. No need to switch to multiformats because of this. What we do need is _one true logical data model_.",
    "mentions": [
      {
        "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
        "name": "Aljoscha"
      }
    ]
  },
  "signature": "dwwG/We5OXC3qcBPoUPaIbE43i5jOOuaiOAWmH5SC0QRJSTqI2JxjwKraL/SXTvwo0BgsrlDB545opjMWeIfAA==.sig.ed25519"
}

{
  "previous": "%zxVj+dRhYbo/lJ2k+frMN0Mbg5LV8I2v1nAvyFvG/4I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 836,
  "timestamp": 1534981888495,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": [
      "%EcT/R+1IlqbZ4L4cmkGXAyHQP59C1XbJj4B+IreZCr8=.sha256",
      "%Xutn0jiOZv4E/F3asp4cGJPWEwYcMJ0KW886EE06o7E=.sha256"
    ],
    "reply": {
      "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%Xutn0jiOZv4E/F3asp4cGJPWEwYcMJ0KW886EE06o7E=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "A few more remarks to make hsdt more sensible:\n\n- directly dumping the bytes of floats can be trouble because of different machine representations. A serious encoding should use an IEEE 754 exchange format.\n- using a full byte as the tag rather than the minimum makes encoded messages larger than they theoretically need to be, but dealing with the compact data is probably slower. I would personally err on the side of simplicity rather than theoretical optimality.\n- to make some of the encoding specifics less arbitrary, I see two obvious routes to take:\n  - **simple**: use big-endian, fixed size ints for lengths rather than varints, and indicate collection sizes as the number of elements\n  - **efficient**: use varints for lengths, and indicate collection sizes as the total size in bytes\n\nIf this was only used for calculating hashes, I'd go with the simple version. But it will often be sensible to compute the hash and then send the data on the network, in the same encoding. In this case, I tentatively lean towards the efficient solution. Note that calling it \"efficient\" is somewhat simplistic: Encoding and decoding varints is more expensive than fixed size ints, but that should be negligible. More important is the unit of lengths. Decoding becomes simpler if collections are prefixed by their size in bytes, but this makes encoding more complicated. You can't really do streaming encoding anymore ,since you need to encode the full collection content to know the size. But I think this wouldn't be too expensive, also you can compute the sizes without actually encoding. Add some memoization for nested size precomputation, and things should stay efficient. Non-streamability is not that much of a problem because we have a size limit on messages. Speaking of which, a new encoding is an opportunity to fix the intermingling of size limit and unicode character counts.\n\nWith these above changes incorporated, I would consider the format good enough. It's still only a drop-in replacement for json. If there is serious consideration of adopting a new format, I'd like us to take the time and consider possible improvements to the logical data structures themselves. Some ideas (not saying all of these are good ones or would be compatible with or sensible for ssb): integers, rationals, byte arrays, NaN, infinities, sets.\n\nAs for compressed floats, my hunch is that it's simply not worth it. But [this](https://stackoverflow.com/questions/8630609/compressing-floating-point-data) looks like a good starting point for exploration rather than rolling our own.\n\nAnd then there's the actual engineering aspect, i.e. benchmarking different encoding details like float representations, how to store data type tags, etc.\n\n- - -\n\nI feel like I should add a disclaimer that I have no idea what I'm doing here. I'm just looking for clean ways to achieve nice mathematical properties, but I'm neither experienced in protocol design/implementation, nor do I know a lot about the performance properties and considerations of networks and data bases. It is entirely possible (and rather likely) that common sense is misleading me, or that I'm missing points that would be obvious to someone more qualified/experienced.\n\nAnyways, I feel like I can't postpone reading the full IEEE 754 standard any longer. Maybe tomorrow I'll then try to find a sensible way of dealing with floats, and then I could do a js implementation of the `simple` version of hsdf, to further prove the concept. But for now, I really need to get to sleep. And I kinda wanted to implement a lisp rather than dealing with ssb internals again... Oh well =D",
    "mentions": []
  },
  "signature": "pcVDRjcki+nfTSzaFUXUIqopXoVolS/B0EoofCk5EUJ/K8Sj3Ax4spGjO9b05lm/F6VIaAMRby1YfwHWIWSECQ==.sig.ed25519"
}

{
  "previous": "%ruNFSjPd/7SbhIhwU2Vce8beucrCmCzlTVZN9DacmLQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 837,
  "timestamp": 1535012446848,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": "%ruNFSjPd/7SbhIhwU2Vce8beucrCmCzlTVZN9DacmLQ=.sha256",
    "reply": {
      "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%ruNFSjPd/7SbhIhwU2Vce8beucrCmCzlTVZN9DacmLQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "## Argument against the argument against canonical formats for signed data\n\n##### TLDR:\n\n[@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519):\n> Maybe this is ok?\n\n[@Aljoscha](@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519): **NO!**\n\n- - -\n\n*Since this rather long response starts with some definitions, you can skip straight to the core argument in the next post.*\n\nThis is a more principled argument for a canonical data format, now that I'm more rested. Sleep is a wonderful thing, it lets you detect that abbreviating `Hypothetical SSB Data Format` as `HSDT` might include an error. But messages are immutable, so it's hsdt now. Maybe it's an acronym for **H**ermie's **S**hiny **D**ata **T**reasure?\n\nAnyhow, let's talk about data with a canonical encoding, since that's all I seem to be doing these days. By \"data\", I mean the logical set set of values an ssb message could have. The logical values are not the same as actual json encodings, and they are also not the same as in-memory representations.\n\nFor example, the json strings `1`, `1.0`, `1.0E0`, `1.0e0`, `10.0E-1`, `0.01E1`, `1.0000000000000001`, etc. all decode to the same 64 bit floating point number, as specified by the IEEE 754 floating point standard. The fact that some of them also all describe the same mathematical integer, rational, real, etc. is completely irrelevant. We only care about the logical data model, and in our case, that's IEEE 754 64 bit floats. I'll call encoded strings like these *equivalent*, but not *identical*. They all decode to identical logical values though.\n\nWith objects, this difference extends into memory. We tend to think of objects as maps from strings to arbitrary logical values. For maps, there is no specified order of the entries, we only need to be able to insert, remove and query keys. So `{\"a\": 1, \"b\": 2}` and `{\"b\": 2, \"a\": 1}` are equivalent but not identical encodings. If you expect their decoded values to be logically identical though, you are wrong. Js preservers the order of object entries, so these two parse to different objects. Most critically, when decoding and then reencoding them via `JSON.stringify`,  we get to non-equivalent encoding strings again. I won't use this post to argue for true maps rather than ordered sequences of pairs as the logical data model for ssb, I did that elsewhere.\n\nJust for completeness: Strings also have problems with escape sequences, but I just want to establish some base terminology, not discuss all the problems with json - such a discussion would not fit into the message limit.\n\nA *canonical encoding* is one where there is exactly one valid encoding string for every logical value. For floats, that could be done by disallowing all but one decimal representation. For true maps, that means fixing the order in which the key-value pairs must be listed, for example by sorting the keys alphanumerically.\n\nWith this established, why do I care so much about canonical encodings? Because ssb needs to compute hashes. Hash functions are true mathematical functions by definition, so given the same input, they produce the same output. Intuitively, we would thus expect any single logical value to always result in the same hash, both across implementations, not to mention inside a single execution of a single program on a single machine. But you can't compute the sha256 hash of a logical data structure, you have to encode it first. And if there are multiple equivalent but not identical encodings of a value, different implementations could produce different hashes for the same logical value. A valid implementation is even allowed to randomly chose a valid encoding each time. In all subjectivity, I consider this an undesirable property.\n\nContinued in the next post...\n\ncc [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519), [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519), [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519), [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519)  ",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
        "name": "Aljoscha"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "7mG/5V3uv2BMOON72wSujD+Ls77PfLOBOrUGxWDpOKJf1E7sJXE798zuLJ0lL9GV9LK7x3cSlN3RU/KbrCh5BQ==.sig.ed25519"
}

{
  "previous": "%sGSwIni903eIrSjuwh3Bjm3pBxDoRieBojCChIMzkLw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 838,
  "timestamp": 1535012462204,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": "%sGSwIni903eIrSjuwh3Bjm3pBxDoRieBojCChIMzkLw=.sha256",
    "reply": {
      "%sGSwIni903eIrSjuwh3Bjm3pBxDoRieBojCChIMzkLw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "### Countering the arguments against canonical encodings\n\nAs I read it, [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)'s main arguments against enforcing a canonical encoding are complexity and the fact that the alternative of \"serialize once, verify from the original encoding\" works. I consider the complexity argument void, as demonstrated by hsdt. With a simple encoding, canonicity does not require a lot of work.\n\nThe \"serialize once, verify encodings\" scheme would not work for something like ipfs. For the ipfs, the data deduplication requirements mandate the use of a canonic encoding. This does not hold for ssb messages. By assumption, each message contains a unique combination of feed id and backlink, so no two ssb messages should ever result in the same hash. Does that mean that we never hash the same logical value twice, and thus all my rambling is irrelevant? Yes, and no, with strict emphasis on the \"no\" part.\n\nDue to the message uniqueness assumption, the \"serialize once, verify encodings\" approach does work for ssb. It's not pretty, our code could not be reused by any other project without this property, but it would work. It places some serious constraints on all ssb implementations though.\n\nHashing is not the only time in the lifecycle of an ssb message when it gets encoded. Encoding is also necessary for transmitting messages to other peers, and for persistent storing of messages. In each of these three encoding use cases, there are different properties we want the encoding to have. We might want to save bandwith by compressing the data as much as possible when sending over the network, or we might store larger, but quick-to-access data in the database. Different implementations might want to take different choices here - we can not predict their needs. These encoding choice always involve tradeoffs.\n\nThe encoding for the hashing however, is fairly arbitrary. It should be somewhat performant, but that's it. But with \"serialize once, verify encodings\", we force every database to store the possibly suboptimal original encoding, whose only purpose was to compute a completely arbitrary hash. Why does it have to be stored? If Alice sends a message to Bob, Bob needs to verify it. Now suppose Carol is not directly connected to Alice, but she subscribed to her feed. Carol gets the message from Bob. But Carol still needs to verify it. But in order to so, without canonical encodings, she needs the original message encoding. So Bob (and everyone) needs to persist this encoding, and needs to send it over the network as well.\n\nBob could have two databases, one for original encodings to send during data replication to peers, and one for fast access for client applications. Running two different databases with the same content wastes space. And have fun guaranteeing consistensy between these two. So as a result, \"serialize once, verify encodings\" forces every forseeable ssb database backend ever into a specific storage format, or to deal with inefficient space usage and synchronization problems. Similiarilly, it constrains how peers can sensibly exchange messages. More space-efficient encodings become useless, since the original encoding needs to be stored anyways.\n\nNow here's the thing: a canonical encoding used for hashes solves these problems. It decouples the bytes to be hashed from the bytes to be persisted or transmitted. With a canonic hash encoding, you can read from your highly specialized database encoding into a logical value, compute its hash, and it is guaranteed to be correct. If we find more efficient formats for data exchange between peers, we can use them, decode received values, compute the canonical encoding, hash it, and verify against the claimed hash of the message.\n\nOf course we can just pretend we found an encoding that will be sufficient for all future rpc and database usage, hardwire it into the protocol by using it for hash computation, and have future devs curse us. But I remember a thread on ssb where futureproofing protocols (e.g. via multiformats) was generally considered a good thing. A canonic encoding does exactly this. And it costs us very little - hsdt would be both canonic, and more efficient (in both space useage and CPU cycles) then the current json-based implementation. And a new format can be introduced in a backwards-compatible way, due to ssb multihashes.\n",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "dJYREnEoSgrbA8t2DDjCA8l9OvRzwr2sgrZhv2QoM7+BstmXG80afE+XJxN/US+SPMP2bt5OPtKyMGczyu2NAg==.sig.ed25519"
}

{
  "previous": "%l7PFjPvDHdmqskz9UNjEfjE0J6ktjKi5KMdrF+vZHPo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 839,
  "timestamp": 1535021183545,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": "%sGSwIni903eIrSjuwh3Bjm3pBxDoRieBojCChIMzkLw=.sha256",
    "reply": {
      "%sGSwIni903eIrSjuwh3Bjm3pBxDoRieBojCChIMzkLw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%l7PFjPvDHdmqskz9UNjEfjE0J6ktjKi5KMdrF+vZHPo=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Errata to [the section on nonequivalent objects](%sGSwIni903eIrSjuwh3Bjm3pBxDoRieBojCChIMzkLw=.sha256): Js actually leaves the iteration order unspecified. But that basically makes things worse, not better.",
    "mentions": [
      {
        "link": "%sGSwIni903eIrSjuwh3Bjm3pBxDoRieBojCChIMzkLw=.sha256",
        "name": "the section on nonequivalent objects"
      }
    ]
  },
  "signature": "2sHOvjHCN2q91MbRjKucJg8LaFcEIg6ZwvUO6kPufmd1VtbgKEwiAtKHEXiOF7/b6LZKsX3JpkwRELsYwUqxCA==.sig.ed25519"
}

{
  "previous": "%f6sO0SWfJDqAgWNKEa9kCh4PC/RCtx6ByPaAyScukbc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 840,
  "timestamp": 1535021537521,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "hsdt",
    "text": "I'll start fleshing out a more serious [hsdt](%euTgqawxHIGxR6rGWWvsn7nNVKQ4jojF0ljMoGXvhBM=.sha256) design in this channel. This will involve a bunch of reading, since there's already a billion schemaless binary data formats out there. But for now, here are a few unordered thoughts I'd like to get out of my brain.\n\n- - -\n\nByte strings can be implemented just like utf8 strings, except no encoding verification happens. A js parser can return `Buffer` objects. Seems like an easy include to me.\n\nIn general, I'm willing to sacrifice extreme simplicity for real practical gains. For example, it would be simpler to only have byte strings, but not utf8 strings. But signaling that some data is textual definitely qualifies as a \"real practical gain\".\n\nJson has no values for `NaN`, `Infinity` and `-Infinity`. But sbot will happily decode `123E456` to `Infinity` and `-123E456` as `-Infinity`. Unless somebody bothered to implement a check for that, in which case my mental model of the ssb development process will collapse from sheer inconsistency. So hsdt has to allow representing `Infinity` and `-Infinity` as well.\nAs for NaNs (there are multiple versions: signaling and quiet, positive and negative sign bits, payloads): Adding support for NaN would make this a superset of the previous json format, which would still be backwards-compatible. In that case, I'd argue to only include a single NaN. I won't complicate a general-purpose message format for people who want to send NaN payloads over the network... Also, I still haven't looked into how the IEEE 754 exchange formats handle NaNs. Hopefully there's a sensible predefined way we could use.\n\nCan we have integers? Js numbers can store signed 32 bit integers without rounding errors. But if storing integers as floats (as js does), parsing the integer `2` and the float `2.0` would result in the same logical value, which would then have to be encoded the same way. So we can't do that. Adding integers would thus require js implementations to store them nonidiomatically. On the plus side, that means we could do 64 bit integers. And also, having different runtime representations for integers and floats would be idiomatic in most other languages.\nNote that you could also use byte strings to store integers, the encoding would even be more compact than varints for integers greater than `2^15 - 1`, but less efficient for those below.\n\nOther integer considerations: Do we need them enough to warrant the added complexity? Signed or unsigned? Stored as varints or fixed-size?\n\nA note on the runtime consequences of canonical encodings of maps: This makes tree-based map implementation vastly superior to hash-maps. A tree-based map can simply iterate over its keys in lexicographic order, a hash map can not. Js objects do not directly support iteration over entries in lexicographic key order, and neither do js [maps](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map). I think js is dynamic enough to present the same interface to user code as objects, while internally using a tree map. And again, for statically typed languages, this should not be a problem at all.\n\nCan we have sets? Do we want sets? Canonic ordering of sets would be slightly more difficult than for objects, because we'd need to order arbitrary values rather than just strings. Possible solution: Sort the encodings of the inner values lexicographically. This again constrains runtime implementation: Sets would need to be represented as trees with a custom ordering function. Nothing problematic, just something to keep in mind. And again, js doesn't like this, but statically typed languages don't mind.",
    "mentions": [
      {
        "link": "%euTgqawxHIGxR6rGWWvsn7nNVKQ4jojF0ljMoGXvhBM=.sha256",
        "name": "hsdt"
      }
    ]
  },
  "signature": "DA0EjGOgs8jhlkTgIiFN0mZAn/7rqa5OnyAaBLdtoQTE4Wn844HBrYbqc+v2d4tpn9l5p65CiAKRxp9KciyPDA==.sig.ed25519"
}

{
  "previous": "%M8p1Lkzs8YWDGC+avdXeM9sNMDTkfT8J9xmz0KkEftA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 841,
  "timestamp": 1535022067731,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%nYbyOa+rxfB08rQLv/YD+FRt1JyUdzwWoUcSrK5pAMQ=.sha256",
    "branch": "%vRL+PBKxA81JWx9J8XsgekS/8+0TT1Gw4N7Ht5zlI7I=.sha256",
    "reply": {
      "%nYbyOa+rxfB08rQLv/YD+FRt1JyUdzwWoUcSrK5pAMQ=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
      "%vRL+PBKxA81JWx9J8XsgekS/8+0TT1Gw4N7Ht5zlI7I=.sha256": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519"
    },
    "channel": "ssb-implementations",
    "recps": null,
    "text": "> and it feels like this whole thing about encodings is going in circles anyway, at least I don't know how to break it.\n\nI hereby commit to do the following in an attempt to break this cycle:\n\nI'm going to flesh out #hsdt into a serious alternative (unless there is already a suitable format out there), while posting about design decisions so that anyone who has the time/energy can weight in. I'm going do a reference implementation in C. At that point, there will be an alternative that is more efficient than the current system, more suitable for ssb, better specified, has a portable implementation, and is backwards-compatible.\n\nThen, others will need to step up to get it into sbot. I don't commit to that part of the struggle just yet, and I hopefully won't need to.\n",
    "mentions": [
      {
        "link": "#hsdt"
      }
    ]
  },
  "signature": "GJLUJf5iKSZ80ZeBwfAuAYPTbxWtC03RYVlxpJncO1bGrzAQy6KmBlJo7lP6df8tKKr0cj6swe+e3nhb6E+GBg==.sig.ed25519"
}

{
  "previous": "%nPFVF/DDD3gaFGa0UbcIwtOIKr6EfnL7Cv2JhBsLxjI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 842,
  "timestamp": 1535022079664,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-implementations",
    "vote": {
      "link": "%nYbyOa+rxfB08rQLv/YD+FRt1JyUdzwWoUcSrK5pAMQ=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "3MVZQgW7HB8VXaIJ5UdztyRksG7HBIEHl9X7DAWUBAY1XRY9B7htrpuKNvfP7ndlyBSID/6k9DxSukaAe7afDw==.sig.ed25519"
}

{
  "previous": "%YwwfrqnKaA5xgsf2pr9/gQBZtxIhAtIwV/I7o87WXIw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 843,
  "timestamp": 1535028854690,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "hsdt",
    "text": "A short list of existing formats and (partly very subjective) comments on them. I consider hsdt simple enough that the effort in (re)implementing it is well worth getting a format that is better suited for usage in ssb than using an existing, overly general format. But feel free to point me to any formats I missed that are not ruled out by the comments below.\n\n## [ubjson](http://ubjson.org/):\n\n- emphasizes \"absolute compatibility with the JSON spec\", i.e. not good\n- has a cool-looking human-readable format\n- has high granularity of typed integers, but no varints\n- has arbitrary precision numbers. The encoding for arbitrary precision numbers refers to json.org without further explanation...\n- does not draw a clear distinction between logical values and machine values, allowing conversions. There are workarounds, but this would cause a lot of pain for ssb.\n- has a `char` type for printable ASCII.\n- has no notion of canonicity.\n- stores binary data as arrays of uint8 - how can the decoder know whether to parse such an array as an array or as a buffer?\n- does not specify float encodings, just links to wikipedia.\n- has an optimization for container types that store values of the same type. That can be worth stealing.\n\n## [Smile](https://github.com/FasterXML/smile-format-specification/blob/master/smile-specification.md)\n\n- does not prioritize simplicity enough, far more stuff than needed for ssb\n- a few java-centric design decisions\n- painful to read spec =/\n- allows lots of different encoding choices, painful to get canonical\n\n## [edn](https://github.com/edn-format/edn)\nOnly included because stumbling upon this triggered this whole data format madness. Does some interesting things, with vastly different goals than the other formats listed here. But ultimately not a good fit for ssb. Also underspecified.\n\n## [BSON](http://bsonspec.org/)\n\nHas different design goals (optimized for databases), so unsuitable for ssb\n\n## [MessagePack](https://github.com/msgpack/msgpack/blob/master/spec.md)\n\n- supports application-specific extensions\n- supports timestamps\n- no notion of canonicity\n- simpler than cbor, but not by much. cbor just seems to be the strictly better choice\n\n## [CBOR](https://tools.ietf.org/html/rfc7049)\n\n- 53 pages of rfc\n- might be the most <battle-proven, industry standard, boring> choice (in a good way)\n- it certainly would not hurt to use an ietf standard\n- can store tiny data portions in the tag byte of some data, generally uses a lot of the tag byte - leans towards efficiency rather than simplicity, but in a well-engineered way\n- indicates length of collections in number of items, not in bytes\n- supports signed and unsigned fixed-size integers (8, 16, 32, and 64 bit)\n- support 16, 32 and 64 bit floats\n- has both `null` and `undefined`\n- supports byte strings and utf8 strings, can store short length indicators in the tag byte and allows different bit sizes of the length indicator\n- maps support arbitrary keys, not just strings\n- does not have an optimization for homogenous collections as in ubjson\n- not underspecified\n- defines no official notion of canonicity, but gives a list of [suggestions](https://tools.ietf.org/html/rfc7049#page-26) (iirc, ipfs uses a canonical cbor subset). My favorite sentence of the whole spec might be \"If NaN is an allowed value, it must always be represented as 0xf97e00\".\n- also talks about a [strict decoder](https://tools.ietf.org/html/rfc7049#page-28), which is basically the opposite direction of canonic encoding\n- has some \"non-normative advice about converting between CBOR and JSON\"\n- defines a human-readable [diagnostics format](https://tools.ietf.org/html/rfc7049#section-6)\n- has a section that reviews other\n\nCbor optionally supports bignums, decimal fractions, dates, times, bigfloats via a semantic tagging mechanism. However:\n\n> Decoders that understand these tags MUST be able to decode bignums that have leading zeroes.\n\nThis means that a canonical cbor encoding can not support bignums without violating the spec.\n\nWow, this is a well-designed format. A few of these features are overkill for ssb, collection lengths are not specified in bytes (I haven't made up my mind which representation I prefer, although I lean toward item counts), and a canonic form would require some work (that may or may not make it impossible to reuse existing implementations). For `boring scuttlebutt`, I'd definitely use it. As for real scuttlebutt, that would depend on some design decision, e.g. whether we want strongly typed integers.\n\nThe cbor spec also includes short review of [alternative protocols](https://tools.ietf.org/html/rfc7049#appendix-E), including msgpack and bson.\n\n## Conclusion\n\nI basically see two reasonable choices: Either use a subset of canonical CBOR, or define a format that only does exactly what we need (and which could also add ubjson's optimization for heterogenous collections). To make this choice, we need to know how exactly the logical data model for ssb messages should look like, so that's what I'll tackle next. I will need input from all other interested people (Dominic in particular) though, as I should not make these decisions alone.",
    "mentions": []
  },
  "signature": "PmsimwoI5qX9XvJUMJEDzhDCK86qNvsLojqtSDmv4D62u1k0WWCvZKk8kWNgGf1RANI5L7tjdR4G2hRLkkJXBw==.sig.ed25519"
}

{
  "previous": "%/ttYRSNYiCDRwOEIcpSKMHGFpV0dnCwjecQcHvBin2E=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 844,
  "timestamp": 1535032724345,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "hsdt",
    "text": "# Minimum Viable HSDT (mvhsdt)\n\nTo get everyone interested in improving the ssb message format on the same page, here is a more serious, optimized spec suggestion, superseding the original [hsdt draft](%euTgqawxHIGxR6rGWWvsn7nNVKQ4jojF0ljMoGXvhBM=.sha256). This is what a custom format could look like. It would still need to adapt to the choices of the logical data model ssb should have. For now, I just specify the absolute minimum we'd surely end up with (ok, binary strings are not part of the absolute minimum. But seriously, there's no reason to exclude them). Other things that might become part of the data model: integers of either exactly one, or of various fixed sizes and signes, floats other than 64 bit floats, bignums, bigfloats, rationals, sets, stuff I'm forgetting and that you should suggest.\n\n## Logical Data Types\n\nAn mvhsdt value is one of the following:\n\n- `null` (the single value of the unit type, representing absence of information)\n- a boolean (`true` or `false`)\n- a utf8 encoded string (may include null bytes)\n- a string of arbitrary bytes\n- an IEEE 754 double precision floating point number, excluding all but one representation of `NaN`\n- an ordered sequence of values, called an array, not necessarily homogenous\n- an unordered mapping from strings to values, called an object. An object may not contain the same key multiple times. Values are not necessarily homogenous\n\n## Binary Encoding\n\nEach value is preceded by a single byte, indicating its type. Conceptually, this byte is split into the *major type* and the *additional type*. The major type is stored in the first three bits, ranging from 0 to 7. The additional type is stored in the remaining five bits, ranging from 0 to 31. This scheme is stolen from [cbor](https://tools.ietf.org/html/rfc7049), which heavily inspired this spec. choice of major and additional types tries to keep compatibility with cbor when possible. This scheme also leaves sufficient space for adaption to a larger logical data type model, and for backwards-compatible extension should the need arise.\n\n### Primitives\n\nThe major type `7` (`0b111`) is used for `primitive` values: `null`, `true`, `false` and floats.\n\n- The tag `0b111_10110` (additional type 22) indicates a `null` value.\n- The tag `0b111_10100` (additional type 20) indicates a `false` value.\n- The tag `0b111_10101` (additional type 21) indicates a `true` value.\n- The tag `0b111_11011` (additional type 27) indicates a 64 bit float. The eigth bytes following the tag represent an IEEE 743 double precision floating point number. <Imagine I precisely specified how to encode floats here. There are existing standards for that, we can pick one, move along>. A special case are floats that indicate NaN, these must be encoded as `0xf97e00`, and reading any NaN other than `0xf97e00` must be signaled as an error.\n\n### Byte Strings\n\nThe major type `2` (`0b010`) is used for byte strings. The additional type signals how the length of the string is encoded:\n\n- If the additional type is `n` where `n` is smaller than `24`, the `n` bytes following the tag represent the byte string.\n- If the tag is `0b010_11000` (additional type 24), the byte following the tag is to be interpreted as an unsigned 8 bit int `n`. The `n` bytes following that integer represent the byte string.\n- If the tag is `0b010_11001` (additional type 25), the byte following the tag is to be interpreted as a big-endian unsigned 16 bit int `n`. The `n` bytes following that integer represent the byte string.\n- If the tag is `0b010_11010` (additional type 26), the byte following the tag is to be interpreted as a big-endian unsigned 32 bit int `n`. The `n` bytes following that integer represent the byte string.\n- If the tag is `0b010_11011` (additional type 27), the byte following the tag is to be interpreted as a big-endian unsigned 64 bit int `n`. The `n` bytes following that integer represent the byte string.\n\n### UTF8 Strings\n\nThe major type `3` (`0b011`) is used for utf8 strings. The additional type signals how the length of the string is encoded (exactly the same as for byte strings):\n\n- If the additional type is `n` where `n` is smaller than `24`, the `n` bytes following the tag represent the utf8 string.\n- If the tag is `0b011_11000` (additional type 24), the byte following the tag is to be interpreted as an unsigned 8 bit int `n`. The `n` bytes following that integer represent the utf8 string.\n- If the tag is `0b011_11001` (additional type 25), the byte following the tag is to be interpreted as a big-endian unsigned 16 bit int `n`. The `n` bytes following that integer represent the utf8 string.\n- If the tag is `0b011_11010` (additional type 26), the byte following the tag is to be interpreted as a big-endian unsigned 32 bit int `n`. The `n` bytes following that integer represent the utf8 string.\n- If the tag is `0b011_11011` (additional type 27), the byte following the tag is to be interpreted as a big-endian unsigned 64 bit int `n`. The `n` bytes following that integer represent the utf8 string.\n\nA parser *must* check whether the decoded string is valid utf8, and indicate an error if it is not.\n\n### Arrays\n\nThe major type `4` (`0b100`) is used for heterogenous arrays, i.e. the array must contain at least two entries with different tags. This is a derivation from cbor.\n\nThe additional type signals how the length of the array is encoded. It works exactly like the length encoding of strings. Once the length has been obtained, read encoded values until you read as many as the length specified.\n\nThe major type `6` (`0b110`) is used for homogenous arrays, i.e. all entries in the array have to have the same tag when encoded regularily. This is another derivation from cbor. The additional type signals length, as usual. For homogenous arrays however, the first byte after the array tag is interpreted as another tag, the `element_type_tag`. When parsing the following bytes, instead of reading a tag, directly substitute the  `element_type_tag`, without consuming any bytess.\n\n### Maps\n\nThe major type `5` (`0b101`) is used for maps. Minor type and parsing work exactly like heterogenous arrays, except that the length indicates the number of key-value pairs, rather than single entries. A key-value pair is encoded by first encoding the key (always a string, but you must still use the correct tag), directly followed by the value.\n\n## Canonical Encoding\nFor a canonical encoding:\n\n- always use the smallest additional type that can contain the length of a string/array/map\n- serialize maps lexicographically sorted by key (ignoring its tag). Note that this is not how cbor recommends doing it, cbor instead sorts first by length of the key, and then lexicographically. Either makes sense, no need to decide this right now.\n\n- - -\n\nNote that except for the split of arrays into homogenous and inhomogenous ones, this is a strict subset of cbor (the canonical sorting of maps only violates a recommendation, not an actual part of the standard). If the homogenous array optimization ends up as the only difference from cbor, it is probably a good idea to drop it and be fully cbor compliant. It is however important that ssb restricts itself to a small subset of cbor, since there's a few things in the standard we don't want.\n\n#ssb-implementations #ssb",
    "mentions": [
      {
        "link": "%euTgqawxHIGxR6rGWWvsn7nNVKQ4jojF0ljMoGXvhBM=.sha256",
        "name": "hsdt draft"
      },
      {
        "link": "#ssb-implementations"
      },
      {
        "link": "#ssb"
      }
    ]
  },
  "signature": "b8T0uK0cSsC/bZlrQK3Q8upb2wwEb8aDlcohJWbLkfjFkJ940nLtlaTU5aRFY8M4ECyM5QQIRqJ7pT0CZXJ6AA==.sig.ed25519"
}

{
  "previous": "%y5G9E1MJ8sv4NSyQ+T8PszTTPEcf1j7vPkcHSR3AuXA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 845,
  "timestamp": 1535034692175,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "hsdt",
    "text": "# Extending the ssb message format\n\nBefore you can talk about encodings of ssb messages, you need to know what to encode. Currently, the set of values in ssb messages is the following:\n\n- `null` (the single value of the unit type, representing absence of information)\n- a boolean (`true` or `false`)\n- a utf8 encoded string (may include null bytes)\n- an IEEE 754 double precision floating point number, except the `NaN`s\n- an ordered sequence of values, called an array, not necessarily homogenous\n- an unordered mapping from strings to values, called an object. An object may not contain the same key multiple times. Values are not necessarily homogenous\n\nIntroducing a new encoding can serve as an opportunity to also extend that set of values. I invite everyone to think about how and which additional data types can improve the experience for people developing on top of the ssb protocol. CC #ssb-show-and-tell, #ssb-learing and #ssb-grants for visibility to devs working with ssb.\n\nAdding a bunch of features makes ssb more complicated though, so features should be well-justified. Adding support for complex numbers probably isn't worth it.\n\nAnother consideration is how ssb-client APIs can expose the data to the user. In statically typed languages, there won't be any problems, you just define a type for everything. In dynamically typed languages like js, this is a different story. The current set of message values has been chosen because it has a direct mapping to built-in javascript types. Adding new types without direct js equivalent will make the js API feel less natural.\n\nOn the one hand, ssb is currently tightly coupled to the flexible and rapid programming experience this allows. Adding e.g. various fixed-size integers would feel off in that environment. On the other hand, ssb is not tied to js in particular. In statically typed languages, the lack of different integer types (any integer type at all) is baffling and unreasonable.\n\nI think adding binary strings to the message format would be worth it. Currently, you need to use base64 encoded strings for binary data in messages. The js API can simply hand [buffer objects](https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_class_buffer) to consumers, no need to introduce non-standard types.\n\nIntegers might be more controversial. So far we did fine without integers (floats can represent any signed 32 bit integer anyways), but not having any integer type might seem absurd to anyone not from js-land. I currently lean towards including a single integer type (signed, 64 bit), unless the js crowd surprises me by advocating for the full set (8, 16, 32, 64 bit, signed and unsigned).\n\nThere is a big caveat with integers though: The js API can not parse them into normal js numbers.\n\n> Js numbers can store signed 32 bit integers without rounding errors. But if storing integers as floats (as js does), parsing the integer 2 and the float 2.0 would result in the same logical value, which would then have to be encoded the same way. So we can't do that. Adding integers would thus require js implementations to store them nonidiomatically. On the plus side, that means we could do 64 bit integers. And also, having different runtime representations for integers and floats would be idiomatic in most other languages.\n\nOther data types to consider are sets (which are currently represented as arrays in many message types), and arbitrary precision numbers, bot integers and rationals. But I'm most interested in your opinions on integers, as well as sensible data type I completely missed.",
    "mentions": [
      {
        "link": "#ssb-show-and-tell"
      },
      {
        "link": "#ssb-learing"
      },
      {
        "link": "#ssb-grants"
      }
    ]
  },
  "signature": "hPRli4SZ+tbwFS4yAqKLgGhtbSe0qh+fn/j7Kc2FpVAyixBg2nb5pi2KFdJjZDD2I5fDv218C4VpqMfCnxyYAw==.sig.ed25519"
}

{
  "previous": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 846,
  "timestamp": 1535037001439,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%A/FTHW8A5cEBS0T1BLMe2K3hJs9/V4wda/KBgZWDtXg=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "48TnHitzcFTlJpKu1LvApPnkcrG7ASi6F3vG81Q0KQ+fI7qnjNznvjpIgUMT09/xOqCDWFtho+qeeZNiTF9VDQ==.sig.ed25519"
}

{
  "previous": "%dB7XyAk+xcnLIZjQ7m3hXTksiE+LCPT36cZWzrJBrpY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 847,
  "timestamp": 1535059436102,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y5G9E1MJ8sv4NSyQ+T8PszTTPEcf1j7vPkcHSR3AuXA=.sha256",
    "branch": "%giW5PvjvR37kQasEE+v5PL986A11wQYtgQL2WJUMDmI=.sha256",
    "reply": {
      "%y5G9E1MJ8sv4NSyQ+T8PszTTPEcf1j7vPkcHSR3AuXA=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%giW5PvjvR37kQasEE+v5PL986A11wQYtgQL2WJUMDmI=.sha256": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "[@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) Thanks, noted and will be fixed in the next draft.",
    "mentions": [
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "y4xRlRVAyr7OS+VbISAnPYaSL8EwZ+T6u+vl8x29It5l48YLciXBq1vgRJw2ZC2ErZCGJQqp6slzq5Dnx17vBw==.sig.ed25519"
}

{
  "previous": "%NdQPDbnqkr4QpxOWXDcB4EykRCdzuojUMLs6p+mu/vQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 848,
  "timestamp": 1535059769286,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%YH6PDaakwNu0D83EBHBLuwSlVhr/5aezVoE8p0IaNf0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "cvYDwlH4fiLr9PVyNw968Mu1YEPyTrBEP3XP7gmjWOeuBXQYdSDzaHr7FvMWna9DR4tUoArC4t7fFSFxo+oABw==.sig.ed25519"
}

{
  "previous": "%MSYTHlm/j7ZK4HWezDo4Z+yNtycSvK4ij9gvPisHWDY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 849,
  "timestamp": 1535061890110,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%YH6PDaakwNu0D83EBHBLuwSlVhr/5aezVoE8p0IaNf0=.sha256",
    "branch": "%Koilz8/Bsqn1nu0Ws2lrYcDlOrf0eug/Gdi3o4gOqCU=.sha256",
    "reply": {
      "%YH6PDaakwNu0D83EBHBLuwSlVhr/5aezVoE8p0IaNf0=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%Koilz8/Bsqn1nu0Ws2lrYcDlOrf0eug/Gdi3o4gOqCU=.sha256": "@uOReuhnb9+mPi5RnTbKMKRr3r87cK+aOg8lFXV/SBPU=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) I'm all for backwards-compatible extension and against a reboot/fork. I think hsdt can be introduced in a backwards-compatible manner.\n\nJust to check whether I correctly understood your formulation of the backwards-compatibility criterion (it took me a few attempts to parse this): \n\nThe first part of your formulation of the backwards-compibility requirement (\"It should be possible to represent the current JSON based data in the proposed format, [...]\") does not talk about the logical data models, but about concrete representations, correct? Because the logical model is satisfied by hsdt: The logical data model of hsdt is a superset of the js values that form the logical value of json. This distinction is important, is important, e.g. json does not support `Infinity`, yet the logical model contains infinities, since e.g. `123E456` gets parsed to the float representing positive infinity.\n\nBut for concrete encodings, it's true that canonicity and this criterion conflict (for object order, as well as for floats and for escape sequences in strings). But do we really need such a strong criterion for introducing the new encoding without forking the network?\n\nI simply assumed implementations would keep sending messages in the encoding that is used by their hash. So all old messages would be sent as json, but newly generated messages signed by hashing the new encoding would be sent in this new encoding. There'd be a transition period where sbot would update to include code for dealing with the new format, while still using json. And once sufficient time has passed and most sbots are able to handle the new format, we start using the new encoding.\n\nWe don't get the efficiency benefits for old messages, but this is playing the long game. **And if you want rpcs that can transmit old messages more efficiently, that's completely orthogonal.** You could implement rpcs that transmit old messages as non-canonical cbor, the standard even contains a section on how to convert between json and cbor. But this does not effect the encoding used for hash generation at all.\n",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "lcWhfO+Lh3nVwuf8loi8V0wL15t3Uv/2jabZ2jwr1DZq8eH9OSuyX6Bs0fS3TnNTIFUwrN8TUsn5Bp1LjNsZBw==.sig.ed25519"
}

{
  "previous": "%UEfWC40HZ2Gw0VuNCyrppK37lfsSM+u+MdTnroxEiy0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 850,
  "timestamp": 1535062591425,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%y5G9E1MJ8sv4NSyQ+T8PszTTPEcf1j7vPkcHSR3AuXA=.sha256",
    "branch": "%pw6/cqXgH6i+8robB2IDHKEl01iKcdClEN5tKPSgMM8=.sha256",
    "reply": {
      "%pw6/cqXgH6i+8robB2IDHKEl01iKcdClEN5tKPSgMM8=.sha256": "@dBQlwh9Gtr3i5YMOGtIOKtGNVepeu+nyb6KGl1vtOcM=.ed25519",
      "%giW5PvjvR37kQasEE+v5PL986A11wQYtgQL2WJUMDmI=.sha256": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "I think I was overly eager to apply the homogenous array optimization to cbor. Too much data is stored in the tags, e.g. the strings `\"a\"` and `\"ab\"` have different tags. This optimization would pretty much never apply. So I'll drop it, at what remains is a subset of cbor, potentially with collection sizes in byte counts rather than element numbers.\n\nIf we end up settling on a larger logical data model, this might stop being a subset of cbor though. Sets, for example, could be done by using major tag 6 (which cbor uses for a tagging mechanism we definitely don't want for ssb). And I kinda like the idea of sets. Currently messages can't express collections of non-string values with efficient (`O(log n)`) containment checking.\n\nI'll do a C implementation [here](https://github.com/AljoschaMeyer/hsdt-testing-area) (without the homogenous array optimization), that can switch at compile time between the two options for collection size representation. That should be suitable for benchmarks. It should also be easy to extend for additions to the logical data model.",
    "mentions": []
  },
  "signature": "FeBiIZBUOiHkgh4PzxFy0Qi71fc2ZhEM6enuucxaBBzb6NMsypoCRB8Fn3mrvsaq1DNnpGinly+JIrzMoM7rDg==.sig.ed25519"
}

{
  "previous": "%xnunKrxSLZc2W8P2RlL6KAuCUiFAZDlDqnTVuMoJNhs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 851,
  "timestamp": 1535097087155,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%YH6PDaakwNu0D83EBHBLuwSlVhr/5aezVoE8p0IaNf0=.sha256",
    "branch": "%FxZLUG4BFgMUC3MzB20sbsZQZR8rl2UjNiRHdS2CFu8=.sha256",
    "reply": {
      "%YH6PDaakwNu0D83EBHBLuwSlVhr/5aezVoE8p0IaNf0=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%FxZLUG4BFgMUC3MzB20sbsZQZR8rl2UjNiRHdS2CFu8=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> What happens to historical messages, of which thousands exist? Did I misunderstand something?\n\nTheir relative amount on the network will converge towards zero. Imagine if the www made design decisions that optimized for the tiny set of websites at 1994. The unproportional impact of those site, compared to the web of today would be ridiculous. Oh wait, they did actually make those irrational decisions. It's one of the reasons why pretty much any format in the www is a mess.\n\nThe old messages worked so far, they will not suddenly break on us. They are not well-designed, but they do get the job done. Their hashes are already set in stone, no way to change it. All implementations will have to be able to verify old messages, but not to produce them.\n\nIf efficiency demands it, there can be a separate set of rpcs (or some additional rpc parameters) that allow transmitting them in some cbor subset with a bijection between json. Receivers can then transform the cbor to json and verify. But this efficient json replacement won't be used in any hash calculations anywhere.\n\nAn alternate choice is to transmit the old json in the form that was used to compute the hash. That's even more inefficient than the current design, but it makes it extremely simple for newer ssb implementations to handle legacy messages: Just run sha256 on the bytes, done (actually there's some complication because of the signature is inserted *inside* the json, not appended, but that can be worked around, since all signatures have the same size). Since there will be virtually no old messages, the lower bandwidth efficiency (and it's not even that much worse than the current system) does not outweight the fact that no one needs to emulate the current verification algorithm. This is my preferred approach, but I expect [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) to weight the short-term performance penalty of this higher than the simplicity gains, and thus to oppose it. :green_heart: Dominic, no hard feelings.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "co/tyhYpUVnVud9Pqje/AK2O4Wr1lbLI4WojSPJbPrOGZ6XlJy5RaAqEX6/0rpXvdguZNM2m5uvnxf4daFJmAQ==.sig.ed25519"
}

{
  "previous": "%Qi6B9Eobql5XOX0EcRaFOmu1h6P2rKTkAVe1IsQfIkw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 852,
  "timestamp": 1535097895562,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
    "branch": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
    "reply": {
      "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "Here's another potential extension I did not mention here yet: Maps with arbitrary keys, not just strings. A nice thing about them is that we could emulate sets with them, by using null as the entries. Sets are great, because you can quickly test whether something is in them. In ssb messages, we only have that capacity for strings, by doing objects with null values. But arbitrary-key objects generalize sets, and could thus replace them. And of course, they are useful on their own.\n\nCbor maps already support arbitrary keys, so this would not change the encoding at all. But then the js api could not use objects any more, but would have to use `Map`s. That would be a breaking change to the `ssb-client` js module. Would that be acceptable? I personally think that the protocol design should not be restricted because some implementation would need to change it's api.",
    "mentions": []
  },
  "signature": "LgI9cA3ZjLgnX5L2eU4qsj/HXQBAOTE6VUDDZwUJwDddDtgCA4yKhKzpcM39PR5Xfkyzw49EBwbpCLoljGpkAA==.sig.ed25519"
}

{
  "previous": "%IMRY4WM/GqpmfGtnZEc/Ha7tbWuUW0vtpCjsyGp5Feo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 853,
  "timestamp": 1535108677957,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%IcyzwxSHarxWq0enpfBPTocg2RF9cQkSnc8vNlbx2ok=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "JGpXn2SbXy5HfjxkCmr5eJh+I3VuDTzF1uXuakgPHHWx7qS9qu6nFsw00HZOLWgw1CTgxI1lSJWSPb0ZKpTVAg==.sig.ed25519"
}

{
  "previous": "%f/cm2fC8KpxY13VKGjFj/g87PPxV+rnhXqAVoNwi298=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 854,
  "timestamp": 1535123218015,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "hsdt",
    "text": "I'm confused about how cbor represents floats. There's no clear statement of how a float should be converted into a binary representation. There is a [list of examples](https://tools.ietf.org/html/rfc7049#page-42), but they don't conform to the IEEE 754 [exchange format](http://www.dsc.ufcg.edu.br/~cnum/modulos/Modulo2/IEEE754_2008.pdf#page=21).\n\nThe IEEE exchange format puts the sign bit at the first position, followed by 11 bits for the exponent, and the remaining 52 bytes are the fraction. Positive infinity is thus `0x7ff0000000000000` (a zero bit, eleven 1 bits, 52 zero bits), and negative infinity is `fff0000000000000` (twelve 1 bits, 52 zero bits).\n\nThe cbor examples however list them as `0xfb7ff0000000000000` (positive infinity) and `0xfbfff0000000000000` (negative infinity). In binary, that's\n`0b1111_1011__0111_1111__1111_0000_...a bunch of 0s` for positive inf and `0b1111_1011__1111_1111__1111_0000_...` for negative inf. These differ at the first bit of the second byte, so that seems to be were the sign ends up. There are more `1`s than in the IEEE representation. I have no clue how they got those numbers, simple shuffling of bytes due to endianness can't create them.\n\nSo if anyone has any idea at all how to interpret this, please share it. Blindly pinging [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) and [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) on the off chance you could recognize this from some low-level stuff?",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "l+2qev0fu+FsKup+zNvOx+OU3EY8H+I8/0CEm6cwHEs00AoOUgzjtnxuNRD7HYoXhvSZhk8G8lO6IRkxOqcnDA==.sig.ed25519"
}

{
  "previous": "%4wr1tPxHZPxrCcFaz1l9ECEsn/TGAmcAeLqD07yLuYU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 855,
  "timestamp": 1535123480391,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%4wr1tPxHZPxrCcFaz1l9ECEsn/TGAmcAeLqD07yLuYU=.sha256",
    "branch": "%4wr1tPxHZPxrCcFaz1l9ECEsn/TGAmcAeLqD07yLuYU=.sha256",
    "reply": {
      "%4wr1tPxHZPxrCcFaz1l9ECEsn/TGAmcAeLqD07yLuYU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "And just after writing this, I realize that the second and third byte of the cbor representations are the first and second byte of the IEEE representation. Still no idea what the `0xFB` at the start of the cbor ones means, or where it could come from.",
    "mentions": []
  },
  "signature": "g5t00fh85tnQilGMAPLK9R/L2rJ4JKsdAwX8YzT1B3GKUA17bKdns3rA3KnQS1O5eyNs3WTZkRW51SYgzu47Bw==.sig.ed25519"
}

{
  "previous": "%Q99IchJ99st2eis4fkffFh/q37xal3/GWfxcANIoSZw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 856,
  "timestamp": 1535123707604,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%4wr1tPxHZPxrCcFaz1l9ECEsn/TGAmcAeLqD07yLuYU=.sha256",
    "branch": "%Q99IchJ99st2eis4fkffFh/q37xal3/GWfxcANIoSZw=.sha256",
    "reply": {
      "%Q99IchJ99st2eis4fkffFh/q37xal3/GWfxcANIoSZw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "Ugh, I'm stupid. The first byte is the cbor tag that signals a 64 bit floating point number... Sorry for the unnecessary pings.",
    "mentions": []
  },
  "signature": "cgJjhv3J6mwNv/vkx36lzEcCS6S6edCVjS2Xfnd+r21Esu+r948PalyicnZzVvJjZv/0Ifg4Pgw+wrj6Kjg2BQ==.sig.ed25519"
}

{
  "previous": "%DUlydOEudMzWsSrjEEEAzX2KgtPgfdJL8mYDixeOEKg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 857,
  "timestamp": 1535140890499,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EyGGCcjAbaShKFCMxXKYiZjQe17SR298D0SLTuKmZpo=.sha256",
    "branch": "%EyGGCcjAbaShKFCMxXKYiZjQe17SR298D0SLTuKmZpo=.sha256",
    "reply": {
      "%EyGGCcjAbaShKFCMxXKYiZjQe17SR298D0SLTuKmZpo=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "That's nice to hear. This also means that sbot enforces canonical string escapes and canonical whitespace (disclaimer: I'm afraid to check whether it treats `\\n` and `\\r\\n` identically).\n\nThis would also mean that if V8 changed its `JSON.stringify` defaults, previously valid messages would suddenly get rejected. But, good news: This only applies to objects (which we were already aware of), not to floats and strings (see below).\n\nFor those curious enough, [here](https://www.ecma-international.org/ecma-262/6.0/#sec-json.stringify) is the specification of `JSON.stringify` in all its glory. Relevant points for this discussion:\n\n- stringify is allowed to print object entries in arbitrary order (in [24.3.2.3, step 8](https://www.ecma-international.org/ecma-262/6.0/#sec-serializejsonobject) it iterates over [EnumerableOwnNames](https://www.ecma-international.org/ecma-262/6.0/#sec-enumerableownnames), which helpfully includes a comment that this yields the same iteration order as `for ... in`, which is unspecified)\n- stringify specifies the escape sequences used when [printing strings](https://www.ecma-international.org/ecma-262/6.0/#sec-quotejsonstring), so those can't randomly break on us\n- stringify [specifies](https://www.ecma-international.org/ecma-262/6.0/#sec-tostring-applied-to-the-number-type) how to print floats. Fun fact: negative zero must be encoded as `\"0\"`, so it is impossible to have it in the current ssb messages. Our number type is officially \"IEEE 754 double precision floating point numbers except the NaNs, positive infinity, negative infinity and negative 0\".",
    "mentions": []
  },
  "signature": "AkrrVGQyaZunaSj9Gysn+YMUIHj//i2YzM8oyDG1a9vDdVxh/DFwYFGwzONSC7z3umz9WxX1o+SIvqvTesD4AQ==.sig.ed25519"
}

{
  "previous": "%91oWEK4ePS7ijWpYofdRTxbtu4fPSNcfWt2CM6VQ/4c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 858,
  "timestamp": 1535141838412,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%YH6PDaakwNu0D83EBHBLuwSlVhr/5aezVoE8p0IaNf0=.sha256",
    "branch": "%hHjcqytnr1uBwKZ5gMdOqkRJ8UIFXArjW8WnZvktRA4=.sha256",
    "reply": {
      "%YH6PDaakwNu0D83EBHBLuwSlVhr/5aezVoE8p0IaNf0=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%hHjcqytnr1uBwKZ5gMdOqkRJ8UIFXArjW8WnZvktRA4=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> yes these two concerns are orthagonal - and that is a good thing! they are not opposing concerns! that means it's possible to have a design that addresses them both!\n\nI think this quote perfectly demonstrates why we seem to disagree on so many things although we have similar goals. To you, the orthogonality means that we can *find* a single solution to both. To me, it means that we should *avoid* a single solution to both. Each of these problems can be tackled individually, without the need for any compromises. A single solution needs to satisfies the constrains of both problems, which will either increase complexity or reduce quality.\n\nI do not see the roll out plan as an ordered sequence of steps. To me, these are two fully independent changes that could happen in any order.",
    "mentions": []
  },
  "signature": "7eJsctn16coh6t/9guMdCFt4FEXZhqfRAOD7Yvziko464Ay7Sr0wWW3WTFdgYxVh3SUFMd5pR4J/pY6ztOMeCQ==.sig.ed25519"
}

{
  "previous": "%sQTPrTr9+G9/9tB+YpC8hHcA86g7N4XrDqMZOd/fmuw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 859,
  "timestamp": 1535143633689,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%J1gpPxJ+DYP0uYwYlnPQ5XdhF8XBgsr5eH2CLkbZQRY=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "R1tVjRpCciQJB1gbZkz7ZGULNYSjoOiniNO27Fs77U7+oRc+SteEQ0zj25MeLon8oY167vEJrZ3OWq+GHfeyBw==.sig.ed25519"
}

{
  "previous": "%1D/uxuOtYEe81+FM3WNQzSSOlWhnUCuezSC+hxYBwkk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 860,
  "timestamp": 1535148201172,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EyGGCcjAbaShKFCMxXKYiZjQe17SR298D0SLTuKmZpo=.sha256",
    "branch": "%g0fifNmOI2iQ1WwSQvyPl6089Am+D5Q3hCh63vqBx2A=.sha256",
    "reply": {
      "%EyGGCcjAbaShKFCMxXKYiZjQe17SR298D0SLTuKmZpo=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%g0fifNmOI2iQ1WwSQvyPl6089Am+D5Q3hCh63vqBx2A=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Yup, I think so.",
    "mentions": []
  },
  "signature": "6Oz4JV+HwGH7+hoVxRVgAoAuMxHDR5J5Ok8+G343D9nHOWOS7+kuMRVb/5q03pZvppCoQ87xbWgDl0pqkloMDA==.sig.ed25519"
}

{
  "previous": "%v0FMgoxOZuEGmCI/u/qiwl9UBMPepHQW/ApXg5QXR2s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 861,
  "timestamp": 1535182012590,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256",
    "branch": "%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256",
    "reply": {
      "%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Ugh, this is annoying. I will write a post today about using a binary format with an implicit schema for the non-freeform (i.e. non `content`) fields of messages. This can be done in the most simple and efficient way if the order of these fields is fixed. Messages with the new hash prefix required for hsdt can introduce that, but I hoped the same format could apply to the rpcs that send semi-canonical json as well. But more on that later today. I woke up to a page of notes scribbled at 3 A.M, there are a lot of posts incoming for you guys today...\n\n> I propose at the very least, rejecting messages that do not have the signature last\n\nYes, please. This is super important for the opt-out-of-legacy-verification-details mechanism I sketched at the end of [this post](%Qi6B9Eobql5XOX0EcRaFOmu1h6P2rKTkAVe1IsQfIkw=.sha256) (and which I plan to flesh out today).\n\n> Every current message has a hash field, but it's not checked. that means the current implementation would still accept messages missing the hash field.\n> We should make this required\n\nOr drop it. What value does the field have if it is not required? Is it used anywhere at all? Or does it simply duplicate information already in the multihash suffix of the signature?\n\n> But, prehaps we can take advantage of this opportunity to add a version field?\n\nVersion of what (honest question, not rhetorical)? Don't we have the hash suffixes to indicate message formats already?\n\n> Thankfully, this means the signature is not mutable, but the hash is.\n\nCan you clarify this? As I understood you post, the signature field always uses the correct value, but cypherlinks can contain garbage. Is this correct?",
    "mentions": [
      {
        "link": "%Qi6B9Eobql5XOX0EcRaFOmu1h6P2rKTkAVe1IsQfIkw=.sha256",
        "name": "this post"
      }
    ]
  },
  "signature": "dR1KJBuC6YNrNQgTs/Ph9xHK2Oz75CSvfDQvAfLyKjB2bLxgyber1Z5jysQOufLgfSE9ZEinsbtRfYF7FOOZAw==.sig.ed25519"
}

{
  "previous": "%SHjA6SE3Q9piu56RuAoKmaeTvgxakCWRAmbY4Un5DKw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 862,
  "timestamp": 1535182864751,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
    "branch": "%IMRY4WM/GqpmfGtnZEc/Ha7tbWuUW0vtpCjsyGp5Feo=.sha256",
    "reply": {
      "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%IMRY4WM/GqpmfGtnZEc/Ha7tbWuUW0vtpCjsyGp5Feo=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "And another idea: a special type for [cypherlinks](http://scuttlebot.io/docs/advanced/links.html).\n\nThese are special enough that a decoder should be able to recognize them and give them their own runtime type. Js currently just uses strings and needs awkward, text-based [functions](https://github.com/ssbc/ssb-ref) for detecting them and extracting data.",
    "mentions": []
  },
  "signature": "RlvFJAy3WWrNlm+XBF5XbAMK5Xo7XvLnnQep1o2HW8VGF0Ivm8V8VrWlzEVL+CYPhFleoo9uT0xwnoLRIiImCQ==.sig.ed25519"
}

{
  "previous": "%I97qRXW3GuTaAyl0Vh1R1meRx18Jjlcedm0QFdi3Qho=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 863,
  "timestamp": 1535192236329,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebutt",
    "text": " # Simpler Message Metadata\n\nWarning: This is a lot of text, containing a lot of information, as well as strong opinions. Dive in at your own risk.\n\nMy proposals around #hsdt are focusses on a json replacement in schemaless free-form data, i.e. the `content` field of ssb messages. But that is not the only place where ssb uses json. Another place where json is used for schemaless data is muxrpc. I won't go into muxrpc here, but it is worth to keep in mind that most of the current discussion around data formats can be applied to muxrpc as well. In this post, I'm going to discuss the metadata of messages.\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519) [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519) [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519)\n\n**tldr: message metadata can be radically simplified and shrinked, roughly an order of magnitude**\n\nIntroducing hsdt will require a new hash suffix. That gives us complete freedom on how to lay out message metadata. And there is some room for improvement over the current situation. [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) has [just posted](%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256) some information relevant to these considerations.\n\nA quick quote from the [protocol guide](https://ssbc.github.io/scuttlebutt-protocol-guide/#message-format) for convenience:\n\n> | previous  | Message ID of the latest message posted in the feed. If this is the very first message then use `null`. See below for how to compute a message’s ID.                                       |\n|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| author    | Public key of the feed that the message will be posted in.                                                                                                                               |\n| sequence  | 1 for the first message in a feed, 2 for the second and so on.                                                                                                                           |\n| timestamp | Time the message was created. Number of milliseconds since 1 January 1970 00:00 UTC.                                                                                                     |\n| hash      | The fixed string sha256, which is the hash function used to compute the message ID.                                                                                                      |\n| content   | Free-form JSON. It is up to applications to interpret what it means. It’s polite to specify a type field so that applications can easily filter out message types they don’t understand. |\n\nThere's also a `\"signature\"` field, containing an ssb cypherlink which depends on the encoding of all the fields listed in the above tables.\n\nAll messages have this same set of metadata, and we can utilize that. In practice, some oversights have crept in, but hsdt can ignore all of them. In this post, I'll discuss the idealized setting that applies to hsdt. I'll do a later post on how this can be adapted to the semi-canonical json replacement.\n\nSo how should the metadata be encoded? We can simply concatenate the actual metadata values in a predetermined order, no need for any keys. The encoding becomes `<total size of message in bytes?><feed id?><backlink to previous message><sequence number?><hash?><timestamp?><content><signature>`, where `?` means that we could get rid of the entry. Now on to the details. There are a lot of them!\n\n### Message Size In Bytes\n\nThis is an interesting one with a few possible ways to go.\n\nThe first take on this: Messages have variable length, so to decode them, we need to tell the decoder the length. Thus we need to prefix it. This could be done either with a fixed-width integer (depending on what message size limit we end up settling upon, 2 bytes might be enough), or with a varint.\n\nA second view: The message is already transported somehow, the transport framing already knows the length, so no need to include it again, simply reuse the length as specified by the transport layer. This places some restrictions on the transport protocol though, it can't do something like `<sum of length of three messages><msg1><msg2><msg3>`. The current transports don't do this (afaik), but I dislike the idea of tight coupling with transport protocol details.\n\nAnd a third perspective: All metadata has to be self-describing in its length, so there's no strict need to preix the length. A parser can just read through the metadata one piece at a time, allocating memory on the fly, and automatically knowing when to stop. An implementation can chose to do memory-related optimizations such as bulk allocation by taking transport framing data into consideration, but there's no tight logicl coupling.\n\nI currently favor the third perspective, but I'm not settled yet. Including a size makes parsing easier and adds to the robustness of the whole thing. If the message size was included, it should be the first entry, so that data bases could simply drop it if it wasnt needed. I'd argue against putting it into the hash computation though (it is easy to ignore the first part of the encoding), since it does not include any actual information. It's just meta-meta-data that can be reconstructed from the logical model of the meta-data.\n\n*continued in next post...*",
    "mentions": [
      {
        "link": "#hsdt"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256",
        "name": "just posted"
      }
    ]
  },
  "signature": "3XXZWd3udcE0ob7OVqEaLTIMipo3c5YuCthrqFE+BjTSCUmrjvgtHggQPE3kivyGFbnNgBNyntp50TQ0KzuXBQ==.sig.ed25519"
}

{
  "previous": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 864,
  "timestamp": 1535192296362,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "### Feed ID and Backlink to Previous Message\n\nThe backlinks are the heart of the personal blockchain of each ssb user (aka the feed). Together with the message signatures, they deliver the cryptographic guarantees of ssb. So surely there's nothing to change about these, right? Wrong.\n\nFirst of all, cypherlinks could be changed to a binary encoding. A byte tagging the type (currently done by an ASCII sigil), followed by a byte indicating the hash function (currently suffixed as a free-form string). In case of healthy paranoia, only use the first four of these 16 total tag bits for the sigil, that leaves 12 bits for the hash function, giving us 16 possible sigils and 4096 possible hashes. If ssb ever uses all of those, it should be burned to the ground anyways. The hash function tag implicitly specifies the length of the hash, so these two tagging bytes can be directly followed by the hash value (in binary, not in base64).\n\nThe binary encoding would be simpler to parse than the current encoding (no base64 fiddling, no indeterminate length (putting the suffix at the end makes parsing unnecessarily complicated)), and more efficient (can directly dump the binary hash data, more compact representation of it, much shorter metadata). But this was more of a digression, the actual encoding of cypherlinks is orthogonal to the metadata encoding. It's just easier to roll out both at the same time.\n\nBut there's another thing we could improve, and that's related to the feed id metadata. I argue that we can completely drop it, by making a tiny change to the backlink: The first backlink of a feed should not be `null`, but the cypherlink to the feed id. That way, given any message, you can theoretically determine the feed id by following the linked list. To get the abstract model of ssb working, it is not required to store feed ids with each message. Especially since ssb assumes to always know all previous messages of a feed (else, full verification is impossible), so there can be no \"broken\" cypherlinks. Don't worry, I'll discuss out-of-order messages (\"ooo\") in a few paragraphs.\n\nTraversing a cypherlinked list of messages to find the feed id is of course a bad idea in practice. A real implementation would store it, for example by keeping all feeds in a map from ids to sigchains. Or by storing the feed id together with each message. That's how current implementations do it, because the current signature scheme mandates it. But by moving this out of the required metadata, implementations get to chose how to deal with this. The conceptual model becomes more simple, and concrete implementations gain the freedom to improve.\n\nSsb does have a scenario where we can't traverse the full linked list, at that's ooo. A database can ask its peers for specific messages, without requiring the full feed of the author. Instead of verification, you trust the identities that linked to the requested message that it is indeed valid. Does this mean that the feed id just has to be in the metadata of each message after all? No, because it can be separately transmitted as part of the ooo response. Again, this moves the complexity out of the rigid conceptual model into the flexible implementation details. The rpcs are less flexible than the db implementations, because different peers need to agree on the same rpc calls. But they are still much more flexible than the hash-enforced representation of every single message on ssb up to this point.\n\n### Sequence Numbers\n\nEverything I said about the feed id also applies to the sequence number, except that it is even simpler to replace (no need to change the first backlink to null). Let's get rid of sequence numbers!\n\n### Hash\n\nThe `hash` metadata must match the hash suffix that is already included in the signature. The information is redundant -> drop it. It is [already optional]((%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256)) anyways.\nJust for completeness: Since this is conceptually part of the signature, the current default representation of `hash` followed by `content` followed by `signature` is suboptimal for parsing reasons. Also for completeness: Just like cypherlinks could be encoded in binary, so could be signatures, so that the hash data becomes either a single or maybe two bytes of data.\n\n### Timestamp\n\nThere's already been discussion on these, both [recent](%mGIrR2DWXceENNZrVNwyEUpukxUv7bKAQABc2nkxizQ=.sha256) and [some time ago](%GtkaBL6N3vg+gG0HV2RWwlAMq3uZWYr7zOFxUUHtNHE=.sha256). They are still mandatory, but the requirement for them to increase monotonically has been lifted. So now you can generate random timestamps, without the protocol punishing you. And if it can be done, than it will be done. There are enough people who randomize their git commit times for anonymization already.\n\nStill including mandatory timestamps just gives client devs the illusion that they could rely on them, when they really shoudn't. Client devs have been burned by this [in the past](https://github.com/ssbc/secure-scuttlebutt/pull/215), and it will happen again, unless timestamps are completely removed.\n\nIn a distributed system, it is impossible to get true global timestamps, both logically and through limitations of physics. And why would ssb even want global timestamps, if it is about subjectivity? What we do want, is a total order on messages, which is why timestamps even use floats rather than integers. But we already have this total order, it is given by the sigchain. And unlike timestamps that can be made up, this order is cryptographically verified.\n\nJustifying timestamps because they are needed for database queries is dangerous. They might be made up, so the queries might not make sense. And not every message type needs this, so why enforce it on everyone? If you want timestamps for your message, add a timestamp to its content, and use a flume view for database indices. Also, there will be other implementations, that might not want to provide timestamp-based queries (because they are completey useless in a ditributed setting anyways), so the core ssb model should not force them upon devs.\n\nIf your ssb-related code relies on timestamp queries, it is already broken.\n\n### Content\n\nYeah, let's not remove that one. I do have some ideas for a better encoding than json though...\n\n### Signature\n\nLet's not remove these either. But a binary representation would be sensible, following the same arguments and design as the binary cypherlinks. If cypherlinks use the encoding of 4 sigil bits and 12 hash function bits, then signatures would also need to have 12 hash funcion bits, thus requiring two bytes as a tag and leving 4 bits unused. That's totally ok, just mentioning it for completeness.\n\n*continued in next post...*",
    "mentions": [
      {
        "link": "%mGIrR2DWXceENNZrVNwyEUpukxUv7bKAQABc2nkxizQ=.sha256",
        "name": "recent"
      },
      {
        "link": "%GtkaBL6N3vg+gG0HV2RWwlAMq3uZWYr7zOFxUUHtNHE=.sha256",
        "name": "some time ago"
      }
    ]
  },
  "signature": "NSDm6Vb4WE1o/djLMUOJrM9RXPZW4wpeiB8z8DYzvoOj7B5T1N3gdKqiiBo0c3UneYQat5SWwgW8y/vbcNgeAg==.sig.ed25519"
}

{
  "previous": "%wS07I+2kNlzrM92xRKifaUgK7omIdgWxVt+rlXxmhwc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 865,
  "timestamp": 1535192318409,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%wS07I+2kNlzrM92xRKifaUgK7omIdgWxVt+rlXxmhwc=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%wS07I+2kNlzrM92xRKifaUgK7omIdgWxVt+rlXxmhwc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "### Summary\n\nI propose the following metadata format: `<binary backlink><hsdt content><binary signature>`. It is slightly more efficient and simple than the current one.\n\nOn the surface, these proposals involve some radical changes to the very core of ssb. But keep in mind that this only changes the \"implementation details\" of the protocol, not its \"api\". Some of these ideas shift complexity to other parts of the ssb stack, e.g. by giving the database the responsibility to track feed ids and sequence numbers. Still, I think this is more than just moving complexity around. Keeping the core as simple as possible is more valuable than making e.g. the database easier. The database is an actual implementation detail, whereas the message format is not. In true implementation details, iterative improvement is much more realistic than in the core protocol. The more complexity is moved into these details, the more empowered are we to tackle the challenges.\n\nAnd aside from this lofty, abstract bullshit, there are real performance gains. Just ballpark the current size of the metadata and compare it to the size of a single binary-encoded backlink and a binary-encoded signature. That might be a decimal order of magnitude. There are *a lot* of tiny messages (e.g. `votes` aka \"likes\", `contact`, etc.) where the metadata far outweights the content. So with these changes, I get my conceptual purity, and [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) gets the performance. Everybody wins. Well, except the people who need to adapt the database and the rpc protocols. But that might include me, as I really want to see these changes incorporated.\n\nI'm deeply excited that a new hash-suffix gives us the opportunity to introduce all these changes in a backwards-compatible way.\n\n- - -\n\nA quick addendum regarding ssb's rpc protocol: Just like messages, muxrpc has both metadata of a fixed scheme, and free-form content. The metadata could be optimized as discussed in this post, the actual data could use hsdt. I'd prefer to postbone changes to muxrpc right now and focus on messages. I already have sketches for a format #bpmux that improves over packet-stream (more space-efficient, easier to encode/decode, built-in backpressure, more consistent, clearer separation between multiplexing and rpc layer, no type information, optional datagram based implementation with truly independent backpressure of substreams). Since packet-stream and muxrpc are somewhat intermingled (e.g. backpressure was added as part of muxrpc, not packet-stream), it makes sense to tackle both of these at once. But I won't open this discussion right now, I'm already spamming the network enough with #hsdt. And the current discussion is already taking too much of my time anyways.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "#bpmux"
      },
      {
        "link": "#hsdt"
      }
    ]
  },
  "signature": "7V7VKl5cSbn1ZkcTk1aVC+uAPGK3lzFNN+YQZoyhVBp1wJRAfXUliYJGd7eiUDb9jfVlMvLwxdMXLY1b2V3+Dg==.sig.ed25519"
}

{
  "previous": "%zdZgOCh5yDq60+PAr0zbSbYc8GFfY+7cbfG6eKIMy18=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 866,
  "timestamp": 1535200463929,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%VOHdM4dihXR8OnGT/FHtW2VlLmAhq+UTVzflSblU47k=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "RiqSPl/PKnGF4VzKUdN9BUrnEuuDPv9d0F3C6a2UIq+cV+SWUlAu/fUprOeBurWVIT71C/XVrzgB9IMAOKR+Cg==.sig.ed25519"
}

{
  "previous": "%9qA2lz+/Awt2U8/bQQ2T8XVGfPULR+6T2mTsvsK2EcQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 867,
  "timestamp": 1535208918056,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "hsdt",
    "text": "# Minimum Viable HSDT Draft 3\n\nI finished a [reference implementation](https://github.com/AljoschaMeyer/hsdt-testing-area) for the third draft of hsdt, the spec is included below. There's a test program that reads data from a file, decodes it, encodes it again, and checks whether the output matches the input. I used this together with [afl](http://lcamtuf.coredump.cx/afl/) to find programming errors, and it has been magical. When I started writing this, afl has been running for 10 minutes and has not found any new errors. But as I'm writing, it found a new crash, roughly as it discovered the 400th code path. This is the first time I finally got to use a fuzzer, and it is magical. But enough rambling, here is the spec for the format the code implements (canonical version). It's an updated version of [this one](%y5G9E1MJ8sv4NSyQ+T8PszTTPEcf1j7vPkcHSR3AuXA=.sha256), mostly fixing some small details around canonicity and floats.\n\n# MVHSDT Draft 3\n\n## Logical Data Types\n\nAn mvhsdt value is one of the following:\n\n- `null`\n- a boolean (`true` or `false`)\n- a utf8 encoded string (may include null bytes)\n- a string of arbitrary bytes\n- an IEEE 754 double precision floating point number\n- an ordered sequence of values, called an array\n- an unordered mapping from utf8 strings to values, called a map. An map may not contain the same key multiple times.\n\n## Binary Encoding\n\nEach value is preceded by a single byte, indicating its type. Conceptually, this byte is split into the *major type* and the *additional type*. The major type is stored in the first three bits, ranging from 0 to 7. The additional type is stored in the remaining five bits, ranging from 0 to 31. This scheme is stolen from [cbor](https://tools.ietf.org/html/rfc7049), which heavily inspired this spec. Choice of major and additional types tries to keep compatibility with cbor when possible. In fact, the current spec is a subset of cbor. This scheme also leaves sufficient space for adaption to a larger logical data type model, and for backwards-compatible extension should the need arise.\n\n### Primitives\n\nThe major type `7` (`0b111`) is used for `primitive` values: `null`, `true`, `false` and floats.\n\n- The tag `0b111_10110` (additional type 22) indicates a `null` value.\n- The tag `0b111_10100` (additional type 20) indicates a `false` value.\n- The tag `0b111_10101` (additional type 21) indicates a `true` value.\n- The tag `0b111_11011` (additional type 27) indicates a 64 bit float. The eigth bytes following the tag represent an IEEE 743 double precision floating point number. <Imagine I precisely specified how to encode floats here. There are existing standards for that, we can pick one, move along>.\n\n### Byte Strings\n\nThe major type `2` (`0b010`) is used for byte strings. The additional type signals how the length of the string is encoded:\n\n- If the additional type is `n` where `n` is smaller than `24`, the `n` bytes following the tag represent the byte string.\n- If the tag is `0b010_11000` (additional type 24), the byte following the tag is to be interpreted as an unsigned 8 bit int `n`. The `n` bytes following that integer represent the byte string.\n- If the tag is `0b010_11001` (additional type 25), the two bytes following the tag are to be interpreted as a big-endian unsigned 16 bit int `n`. The `n` bytes following that integer represent the byte string.\n- If the tag is `0b010_11010` (additional type 26), the four bytes following the tag are to be interpreted as a big-endian unsigned 32 bit int `n`. The `n` bytes following that integer represent the byte string.\n- If the tag is `0b010_11011` (additional type 27), the eight bytes following the tag are to be interpreted as a big-endian unsigned 64 bit int `n`. The `n` bytes following that integer represent the byte string.\n\n### UTF8 Strings\n\nThe major type `3` (`0b011`) is used for utf8 strings. The additional type signals how the length of the string is encoded, excatly the same way as for byte strings. A parser must check whether the decoded string is valid utf8, and indicate an error if it is not.\n\n### Arrays\n\nThe major type `4` (`0b100`) is used for arrays. The additional type signals how the length of the array is encoded. It works exactly like the length encoding of strings. Once the length has been obtained, read encoded values until you read as many as the length specified.\n\n### Maps\n\nThe major type `5` (`0b101`) is used for maps. Minor type and parsing work exactly like heterogenous arrays, except that the length indicates the number of key-value pairs, rather than single entries. A key-value pair is encoded by first encoding the key, directly followed by the value.\n\nWhen parsing a map, an error must be emitted if a key is not a valid utf8 string, nd if the map contains duplicate keys.\n\n### General\nA parser must emit an error if it encounters a tag other than one of those listed above.\n\nTODO this inhibits backward-compatible extensions. Specify which data to ignore instead!\n\n## Canonical Encoding\nFor a canonical encoding:\n\n- floats that indicate NaN must be encoded as `0xfb7ff8000000000000`\n  - note that this makes canonical hsdt less expressive than non-canonical hsdt\n- always use the smallest additional type that can contain the length of a string/array/map\n- serialize maps lexicographically sorted by key (ignoring its tag). Note that this is not how cbor recommends doing it, cbor instead sorts first by length of the key, and then lexicographically.\n\nIn a setting requiring canonicity, decoders must emit errors if one of these conditions is violated, i.e. when\n\n- reading a float that is a NaN other than `0xfb7ff8000000000000`\n- a length smaller than 24 is not directly encoded in the corresponding tag's additional type\n- a length smaller than 256 is not encoded with a corresponding tag's additional type of 24\n- a length smaller than 65536 is not encoded with a corresponding tag's additional type of 25\n- a length smaller than 4294967296 is not encoded with a corresponding tag's additional type of 26\n- the keys of a map are not in ascending lexicographic order\n",
    "mentions": [
      {
        "link": "%y5G9E1MJ8sv4NSyQ+T8PszTTPEcf1j7vPkcHSR3AuXA=.sha256",
        "name": "this one"
      }
    ]
  },
  "signature": "iPTcfQPnDuDPA+apKT1d3zbqvkh8dQGA4DYeii3xkqTL2PLIT5dcuodsL0TJ0U9TVZaoBFOo8chaIsftE3JCAw==.sig.ed25519"
}

{
  "previous": "%jt11rmbFmkR6tGQJDm99I4Z939Q2b0LmZCpkiOke/A0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 868,
  "timestamp": 1535223992808,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
    "branch": "%qSmbcexCBt2QGlu4ro9gvpTpvTxVe4g4cip8qn8ix14=.sha256",
    "reply": {
      "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%qSmbcexCBt2QGlu4ro9gvpTpvTxVe4g4cip8qn8ix14=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "Cbor and hsdt already have binary strings. I was pondering not representing cypherlinks as those, but via dedicated types.",
    "mentions": []
  },
  "signature": "Q2yOmbwgz8Ks9CSJsiQltEc9wpbL1dgCpdBDUeCTj6tZKqBIeII4LIASLYS0owCva2RJHZ9Mt4QapuThrxTPCw==.sig.ed25519"
}

{
  "previous": "%nPJPwr0g15RzzdhPjT1chd+HekmiWaj/jAi90QvG7ZY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 869,
  "timestamp": 1535224296311,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%b3ChRslXNpLBzH8fsZ0yLckg4hYHeMIu+pAPnYWdjUA=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%b3ChRslXNpLBzH8fsZ0yLckg4hYHeMIu+pAPnYWdjUA=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@moid](@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519) Just as before, by transmitting the sequence number. Server implementations would still keep track of sequence numbers and use them as usual, they just would not be included in every single message. Of course, and implementation is free to add the sequence number to every database entry. But it would not need to be transmitted as part of the message, and it would not be involved in the hash computation.",
    "mentions": [
      {
        "link": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
        "name": "moid"
      }
    ]
  },
  "signature": "bu3H1lRNOMT0UBv3U3kYXjH9pJAz0mo1ZF/P02wUlWleLCk0o5SOClAziNQRCz3ddP1+xQ7VeTCUpERBJTohBw==.sig.ed25519"
}

{
  "previous": "%lQTKP0cSpy6kDDRJ08c64qDvzrrd8zso96vkPHVkjRU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 870,
  "timestamp": 1535229354282,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256",
    "branch": "%lHk2x2ElJNcTXocbkOwkVGzOf0NpHXzz/P7XtudFEEs=.sha256",
    "reply": {
      "%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%lHk2x2ElJNcTXocbkOwkVGzOf0NpHXzz/P7XtudFEEs=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> Actually, second thoughts, I think we should focus only on defining the implicit format, not changing it.\n\nI can agree that enforcing `hash` in the current format to improve consistency is a sensible choice. But if we do a complete metadata redesign for hsdt, I'd strongly prefer to drop it.",
    "mentions": []
  },
  "signature": "xRUuuE8nxiR0hXvttACPuqT1Q387z9YAHC7g7UU4nR/gm44qSi+YCp6vjIvXKO81PRAuqXipvryNnwLt1MeVDA==.sig.ed25519"
}

{
  "previous": "%7k/41yCbyoHiB1MKIEEteIp7EyQK+NFIoRwOjN5G5ro=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 871,
  "timestamp": 1535231850209,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%wTjDyP6RnllwKgxy0azWu+qHqUvZea9Qo75PiXlCrn8=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%wTjDyP6RnllwKgxy0azWu+qHqUvZea9Qo75PiXlCrn8=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> type is not polite, it's mandatory. [I just made a PR for this](https://github.com/ssbc/scuttlebutt-protocol-guide/pull/8)\n\nSo conceptually, type is part of the metadata, it is just hidden inside the content objects. In case of a metadata redesign, I'd want to move it to the actual metadata. That's clearer and also saves a few bytes (because there's no need for a string key `\"type\"`).\n\n> I think removing the sequence number forces the hand of implementers a bit too hard.\n\nDoesn't it free the hands of implementers? Right now, there is an enforced way to deal with them, the change would allow them to handle them how they want. Maybe handling message-embedded sequence numbers is done implicitly when using a schemaless database, but that's not the only choice. Since metadata is actually structured, it would make sense to store it in a relational database. And in that case, implementers need to deal with it anyways.\n\nHaving to roll your own sequence number memoization can't be that complicated. Saving a tiny amount of work for a subset of the implementors (of which there won't be that many) can't be worth complicating the protocol. In some sense, explicitly transmitted timestamps sacrifice user experience (in the form of performance) for developer convenience. Which is not an approach to software engineering I support.\n\nFyi, to me personally keeping the core as minimal as possible is a stronger motivation than the performance. But I can't really support the desire for minimalism with concrete argument, just a general sense that a minimal, simple core leads to better result in general. Performance improvements are just a symptom of that.\n\n> Also, timestamps: The application layer loves timestamps. Everyone is requesting indexes for that. As protocol designers, the application developers are our users, we need to keep them happy if we want people to use our protocols.\n\nDistributed timestamps are broken, that's a fact. And the current design encourages devs to use them anyways. As protocol designers, we have a responsibility to keep devs from doing broken things. It's like telling your kids that playing with firecrackers is unsafe, and then putting them unsupervised into a room full of firecrackers and lighters. Ok, that's a ridiculous metaphor, but you get my point?\n\n> If you remove the timestamps they'll just add them to the content, anyway, so I don't think you'll win this argument.\n\nThat's what I'd consider winning the argument (except I don't think of this whole thing as something to \"win\"). Timestamps are a nice, cosmetic thing to display, humans like them. Go ahead and add them to your messages. Go through the trouble and create flumeviews if you like. And then deal with the problems when things inevitably break. But you can't go and blame the protocol designers.\n\n> If someone starts spraying randomly timed messages it will tend to be behave weirdly in applications, and that will have social rammifications.\n\nYeah, that's a real interesting thing about ssb. Some people would start blocking you if you randomized them, others might understand the privacy concerns and actively seek out clients/apps that use timestamps sensibly (i.e. as nice-to-have, completely unreliable pieces of information that may or may not be true). If timestamps are not mandatory, than these things sort themselves out through social dynamics, and each group can have its preferred solution. Making them mandatory removes this agency from the users, everyone just has to pay the cost for them.\n\nTimestamp randomization is fascinating, because it may look like malicious action to some(I actually toyed with the idea to do it, just to make client devs deal with it, which is basically altruistically motivated malicious behavior), whereas it's an anonymity-preserver necessity for others.\n\nWho knows what would happen if all the timestamp-opponents (and I'm definitely not the only one) coordinated to simultaneously start randomizing. Would that divide scuttleville, or would the popular clients adapt? I will not try to start this experiment, but I would definitely be in the randomization camp.\n\n> Anyway, while these might be good ideas, I think it's going too far introduce these all at once. Just rolling out the binary format will be hard enough.\n\nI fear that the introduction of the binary format might be the best shot we get at doing these changes. Adding a new multihash is not something we should do lightly, but these changes require a new multihash. Hsdt requires a new multihash as well. I'd rather not rush out the binary format and then never get the momentum for the improved metadata encoding, but instead take some time and clean up the whole hashing-related business, which involves both message data and meta data.",
    "mentions": []
  },
  "signature": "fo9EOApsQ6j0zzqYdkoEUtctMm25NJoqLCL3pVNAJMsxw5RM2+t0MKZLn2zHprZPjdjdI+HhCStUsK78QbWOAw==.sig.ed25519"
}

{
  "previous": "%C86nXLzeNO1oSYyIiupm5hSejDByJK7Y9OTKpYcPXlQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 872,
  "timestamp": 1535232634008,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
    "branch": "%1SzX8UqabnPEE8ORfo/pv3/u6zdIZxH4m2uxj/sy9nk=.sha256",
    "reply": {
      "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%1SzX8UqabnPEE8ORfo/pv3/u6zdIZxH4m2uxj/sy9nk=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "> dedicated types in what name space?\n\nDedicated types in the logical data model. Imagine json would suddenly gain support for integers. These integers would then have the same standing as the old data types (null, boolean, float, string, array, object). Unlike json where this can't happen, we can do this for hsdt. What I'm asking for in this thread: What types of things other than null, booleans, floats, strings, arrays, and objects should application devs have at their disposal?\n\nNot thinking about this means accepting that the types provided by json form the best possible set of types, and everyone should only use those to build applications. Ssb currently restricts devs to them. But pretty much every developer who did not grow up in js-land would look at this at say \"Wait a second, the fundamental datatype of every machine is the integer. A large subset of algorithmic problems consists of manipulating integers. Do you seriously expect me to build apps without integers? Sorry, but I'm leaving for ipfs\".\n\nThere are some concerns with introducing new types, but for now I'd just like to survey which types might be sensible to have. Well, and I'd like to lobby for the inclusion of integers.",
    "mentions": []
  },
  "signature": "es9wI8/ZV8v8ykgaqcbO3xsuLs4ZBnKgmJphxfEXUxBmSQ3p2impsbP/hG28e87r1K951KnLYHnVTxX5mVV5Dg==.sig.ed25519"
}

{
  "previous": "%+4td00hm6klxesp9Lt8TgLbxKztabPABvypUvv8na9w=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 873,
  "timestamp": 1535234945579,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "bpmux",
    "text": "# BPMUX (back-pressure multiplexing)\n\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519):\n> [@aljoscha](@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519) very keen for back pressure rpc though!\n\nI guess [teasing about](%zdZgOCh5yDq60+PAr0zbSbYc8GFfY+7cbfG6eKIMy18=.sha256) an alternative message format and then not giving any information about it would be somewhat mean. So here are some notes on the protocol.\n\nAt its core, there's an abstract specification of different communication patterns, single unidirectional messages, request/response exchanges, sinks, streams, duplexes (combined sink + stream). Everything involves backpressure, data can only be transmitted once the receiver has signaled that it wants to receive data. This abstract specification determines the API exposed to the programmer.\n\nThere can be different concrete implementations for these APIs, depending on the physical (or logical) network over which the multiplexing happens. So far I've only specced out `bpmux/rel`, which implements the abstract specification on a bidirectional, reliable, ordered communication channel (i.e. what you get with unix domain sockets or tcp). But there could be implementations for infrastructure other than reliable channels, e.g. `bpmux/udp`, `bpmux/[sctp](https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol)` or `bpmux/[dccp](https://en.wikipedia.org/wiki/Datagram_Congestion_Control_Protocol)`.\n\nHere are some old notes of mine on the abstract model and the concrete bpmux/rel specification. I've iterated on the protocol design a few times since then, so they are not up to date. Key things I'd handle differently than described beloware unordered streams of messages, and the details of how bpmux/rel encodes packet types. The core ideas (credit-based backpressure à la [reactive-streams](http://www.reactive-streams.org/), packets à la packet-stream) are the same though.\n\nThe whole thing is pretty similiar to packet-stream, just with mandatory backpressure on all levels, and a slightly different abstract communication model.\n\nHere are the notes I jotted down a few months ago, I hope the above introduction helps you to make some sense of them.\n\n- - -\n\n# Infodump\n\nA protocol for multiplexing messages, requests and responses, and sinks, streams and duplexes over a bidirectional, reliable, order preserving channel. Provides backpressure for top-level packets as well as per-stream backpressure.\n\nTODO provide a description of how things work.\n\nTop-level packets are guaranteed to be delivered in the order in which they were sent.\n\nUnless indicated otherwise, sending a message consumes top-level credit (1 credit per byte sent, including metadata).\n\nThe VarU64 type is defined and implemented [here](https://github.com/AljoschaMeyer/varu64-rs).\n\nWhen receiving a packet of unknown first byte, treat the next byte(s) as a VarU64 and drop that many bytes after that VarU64, then continue the stream. If any new packets are added to the BPMux protocol, they will include  VarU64 indicating the remaining packet length directly after the first type. This will allow backwards-compatible protocol additions.\n\nTODO:\n\n- close top-level with error\n- reject min-credit\n- include min-credit in CreateSink and CreateDuplex\n- add greedy sending versions of CreateSink and CreateDuplex\n  - consume top-level credit to attach any number of items to directly send\n  - peer replies how many of these items it accepted (the dropped ones should be resent using inner credit)\n- handshaking (give initial top-level credit, specify min-credit)\n\n### Top Level Packets\n```\n/// Allow the peer to send `credit` more bytes of top-level packets (does not consume credit)\nMainCredit | credit: VarU64\n\n/// Indicate that no more Message, Request, OpenStream, OpenSink, OpenDuplex packets will be sent (does not consume credit)\nClose\n\n/// Indicate the lowest credit at which you can still fully function.\nMinimum | min_credit: VarU64\n\n/// The same as sending RequestCancel and InnerCancel messages for all requests, streams and duplexes (does not consume credit)\nCancelAll\n\n/// Send a message to the peer (one-shot, unidirectional)\nMessage | length: VarU64 | payload: [u8; length]\n\n/// The same as sending multiple messages. `total_length` is the remaining length of the packet (including the bytes for the length VarU64s)\nMessages | total_length: VarU64 | (length: VarU64 | payload: [u8; length])*\n\n/// Send a request to the peer (one-shot, receive a single response)\nRequest | req_id: VarU64 | length: VarU64 | payload: [u8; length]\n\n/// The same as sending multiple requests. The reqests are assigned consecutive ids, starting from `initial_req_id`. `total_length` is the remaining length of the packet (including the bytes for the length VarU64s)\nRequests | initial_req_id: VarU64 | total_length: VarU64 | (length: VarU64 | payload: [u8; length])*\n\n/// Indicate that you are no longer interested in the response to a request of a certain id (does not consume credit)\nRequestCancel | req_id: VarU64\n\n/// Send the response to a previously received request (does not consume credit)\nResponse | req_id: VarU64 | length: VarU64 | payload: [u8; length]\n\n/// Answer a previously received request with an error (does not consume credit)\nResponseError | req_id: VarU64 | length: VarU64 | payload: [u8; length]\n\n/// Create a stream from the peer, with initial credit\nCreateStream | inner_id: VarU64 | credit: VarU64 | length: VarU64 | payload: [u8; length]\n\n/// Create a sink to the peer\nCreateSink | inner_id: VarU64 | length: VarU64 | payload: [u8; length]\n\n/// Create a duplex with the peer, with initial credit for the stream half\nCreateDuplex | inner_id: VarU64 | credit: VarU64 | length: VarU64 | payload: [u8; length]\n```\n\n### Inner Packets\nThese consume inner credit, not top-level credit.\n\n```\n/// Allow the peer to send `credit` more bytes of stream-level packets (does not consume credit)\nInnerCredit | inner_id: VarU64 | credit: VarU64\n\n/// Indicate that you are no longer interested in more items over a stream (does not consume credit)\nInnerCancel | inner_id: VarU64\n\n/// Send an item over a stream\nInnerItem | stream_id: VarU64 | length: VarU64 | payload: [u8; length]\n\n/// Send multiple items over a stream. `total_length` is the remaining length of the packet (including the bytes for the length VarU64s)\nInnerItems | inner_id: VarU64 | total_length: VarU64 | (length: VarU64 | payload: [u8; length])*\n\n/// Signal that no more items will be sent over a stream\nInnerEnd | stream_id: VarU64\n\n/// Signal an error over a stream (same as InnerEnd, but with a payload)\nInnerError | stream_id: VarU64 | length: VarU64 | payload: [u8; length]\n```",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
        "name": "aljoscha"
      },
      {
        "link": "%zdZgOCh5yDq60+PAr0zbSbYc8GFfY+7cbfG6eKIMy18=.sha256",
        "name": "teasing about"
      }
    ]
  },
  "signature": "6B2u/vmhjXRpuIwRcGNWybwsvSLlOz74kYHQVtA0NodGohkLQZacANwWo+krasK4Ez8XNHmISJv3E/jRKA+dDw==.sig.ed25519"
}

{
  "previous": "%ScgGMfSbd4WXBtH7ry+pjaaxMFF4GRMdf5ddWdM/uE0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 874,
  "timestamp": 1535272140235,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ScgGMfSbd4WXBtH7ry+pjaaxMFF4GRMdf5ddWdM/uE0=.sha256",
    "branch": "%1/mEC4NBU56gri2Tn86NZ+22uW5Lkbz97Ice0mF/O/Q=.sha256",
    "reply": {
      "%ScgGMfSbd4WXBtH7ry+pjaaxMFF4GRMdf5ddWdM/uE0=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%1/mEC4NBU56gri2Tn86NZ+22uW5Lkbz97Ice0mF/O/Q=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "bpmux",
    "recps": null,
    "text": "Yup, it is similiar to muxrpc, but the actual encoding will be much terser, and it will apply backpressure to nearly every byte sent, not just messages on substreams.\n\nAs for the latency: You can do an exponential backoff thing, where you specify the maximum amount `cmax` of credit you want to allow, and you send credit updates whenever you received messages worth `cmax / (1 - (1/2))`, `cmax / (1 - (1/4))`, `cmax / (1 - (1/8))`, `cmax / (1 - (1/16)) etc. of credit.\n\nI also experimented with some optimistic messages that allow to overuse credit, but all of these turned out broken in some way. Some packets can specify an initial credit for the peer, but when trying to send an unsolicited stream of data to the peer, you first have to wait for some credit. Which in some sense reflects the user-level information flows on ssb =D\n\nAnother aspect, not mentioned in the notes at all, are unordered transmissions. Sometimes you don't need to preserve order of messages, and implementations that don't run on a reliable channel can utilize that. Not sure if this is really necessary, but it will be worth it to spend some brain cycles trying to figure out if there's an elegant way of providing it in the abstract specification.\n\n> If you want something to go really fast, and you give lots of credit, then want to stop it\n\nCompletely stopping something is done via cancellations and errors. I you just want to slow things down, you have to be conservative in the credit you gave in the first place. Assuming the network has no guarantees on latency, there's no way of taking back credit that is guaranteed to work. You could politely ask and hope that the network latencies work out in your favor and the peer does not pretend that your polite request came in too late, but that's all you can do. And this polite asking should perhaps be part of the application layer, not the protocol layer.\n\nI'll stop now, I really don't want to invest the time into fleshing this protocol out, before there's a consensus on the whole message stop.",
    "mentions": []
  },
  "signature": "S6xEqIpmg+32ovj5LHEuzHEc/8ectY+zvrrNpEVLLEmDJsTtuE4zQbZqh3mUyzKkvc7zguAkC5w2p5uIx1fSDQ==.sig.ed25519"
}

{
  "previous": "%J8liMO0/pXLopBGQDGb+/dte8Lgikq5ftoULGUWOYDk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 875,
  "timestamp": 1535272165234,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%6Cv3kn3pjIaKKIvdtPZwTut8oaJFUsJEK67qge1ul3I=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "AOyekOIqO/M7ZTQcH16bJPU3oWppMKtiUav579Xrcybr7kPldRfZBt09MHMEROkeDI2tYgGOSJ87SgW1/r9oAQ==.sig.ed25519"
}

{
  "previous": "%9fJewi8QwYSLaoAUQHlWLAGUwAPkWidS21MNMuANE+0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 876,
  "timestamp": 1535273669968,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%PR0VVV3dD0Q99s4KUxD5CZPwm6d66V/SzvLGOR1Qg2A=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%PR0VVV3dD0Q99s4KUxD5CZPwm6d66V/SzvLGOR1Qg2A=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n\n> This is too much for now.\n\nOk, that's a clear statement and I can work with that. Here is a list of facets of an hsdt rollout, packed into individually implementable chunks. We should be able to pick any subset of these and bundle it into a single rollout. I do not include any semi-canonical stuff, because that can be added at any point, independent from our choices here (and I'll be happy to contribute to the design).\n\n- introduce a new hash suffix for messages encoded in canonical [minimum viable hsdt](%jt11rmbFmkR6tGQJDm99I4Z939Q2b0LmZCpkiOke/A0=.sha256) (note: not the final spec!)\n- optionally remove byte strings from hsdt, if supporting them is too much work in the data base\n- optionally remove `Infinity`, `-Infinity`, `NaN` and/or `-0` from hsdt, if supporting them is too much work in the data base\n- extend the logical data model of mvhsdt with any subset of the following data types (some of these might imply database changes)\n  - various fixed-size integers\n  - specialized type for cypherlinks\n  - sets\n  - maps with arbitrary object keys (requires `ssb-client` to represent them as `Map`s, not objects, this is a breaking change)\n- specify a fixed order of metadata for hsdt messages, encode them efficiently (this includes a binary encoding of cypherlinks in metadata)\n- drop the `hash` metadata\n- drop the timestamp metadata\n- drop the author and sequence number metadata \n- prefix each message content with a string that specifies the type (thus it can be encrypted, yet does not need to be encoded as an ordinary map entry)\n\n> If we can deploy an improved protocol, we can deploy another one.\n\nI'll take you by the word.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%jt11rmbFmkR6tGQJDm99I4Z939Q2b0LmZCpkiOke/A0=.sha256",
        "name": "minimum viable hsdt"
      }
    ]
  },
  "signature": "NgUY+AW2R0ipehlP3+QpPZ1BHohzG5WQoC15Rhrg7leu8l6YyHPGPBjywJRVKpzw59Yola1uM7l7Rdzr0v1jAg==.sig.ed25519"
}

{
  "previous": "%CyL8VuY12NAk3fqJ2jMpuegRUlvMOLvnszczYS0KaBw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 877,
  "timestamp": 1535274272174,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%CyL8VuY12NAk3fqJ2jMpuegRUlvMOLvnszczYS0KaBw=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%CyL8VuY12NAk3fqJ2jMpuegRUlvMOLvnszczYS0KaBw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Just to clarify things, not as a serious argument to include this in the first rollout (and honestly, I can totally accept if this never makes it into ssb):\n\n> > In some sense, explicitly transmitted timestamps sacrifice user experience (in the form of performance) for developer convenience\n>\n> Apart from bandwidth, I doubt this would make a _measurable_ difference to performance, once it's combined into the entire application. And how much % smaller does it make the bandwidth?\n\n\"timestamps\" should have been \"sequence numbers\" in that quote, stupid brain. I agree that the performance argument is somewhat ridiculous for sequence numbers (in  variable length encoding, two bytes will suffice for the vast majority of feeds), but sequence numbers would be removed together with feed ids, and those do make up a relevant percentage of the metadata. But even then, it is not the performance, but the conceptual minimality I'm drawn towards.",
    "mentions": []
  },
  "signature": "zoapWqXsELPReWuuHiNgZZfNp88COGe7b9Yzc1JleTxoWJMyvFOecqfJMzABydGc4NVrK6xp4i3ebDQnwyATDQ==.sig.ed25519"
}

{
  "previous": "%CaCuBNYvDYasBowf5ZjTsCT8lW1ycMwfFsaqrTF+SzA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 878,
  "timestamp": 1535275325517,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-clients",
    "text": "> Who knows what would happen if all the timestamp-opponents (and I'm definitely not the only one) coordinated to simultaneously start randomizing [timestamps]. Would that divide scuttleville, or would the popular clients adapt? I will not try to start this experiment, but I would definitely be in the randomization camp.\n\nOut of curiosity, could the current client devs estimate how user experience would be affected if some subset of users (say about five people you follow directly) started posting messages with random timestamps?\n\nCC [@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519) [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) [@SoapDog](@gaQw6z30GpfsW9k8V5ED4pHrg8zmrqku24zTSAINhRg=.ed25519) [@Tim Schumacher](@o3eDT3n9urv1cyIWDuF+wQHBFj3I8OcE3L4Tla9RR8A=.ed25519) [@christianbundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519) [@ev](@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519) [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519) [@happy0](@RJ09Kfs3neEZPrbpbWVDxkN92x9moe3aPusOMOc4S2I=.ed25519) ",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@gaQw6z30GpfsW9k8V5ED4pHrg8zmrqku24zTSAINhRg=.ed25519",
        "name": "SoapDog"
      },
      {
        "link": "@o3eDT3n9urv1cyIWDuF+wQHBFj3I8OcE3L4Tla9RR8A=.ed25519",
        "name": "Tim Schumacher"
      },
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "christianbundy"
      },
      {
        "link": "@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519",
        "name": "ev"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@RJ09Kfs3neEZPrbpbWVDxkN92x9moe3aPusOMOc4S2I=.ed25519",
        "name": "happy0"
      }
    ]
  },
  "signature": "EmYft+3TMrJ1FiRXIw/1uThOBTdj4aDCNsIv6n5reJ8zEevlX6WWRA8/FNM3l90p/8W6jkprsUUpnAPwPUDOCw==.sig.ed25519"
}

{
  "previous": "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 879,
  "timestamp": 1535275784097,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ScgGMfSbd4WXBtH7ry+pjaaxMFF4GRMdf5ddWdM/uE0=.sha256",
    "branch": "%FK5aHeZGGD4PvcTGsnWBQi/VUSaBnGUMikIbYNxB180=.sha256",
    "reply": {
      "%ScgGMfSbd4WXBtH7ry+pjaaxMFF4GRMdf5ddWdM/uE0=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%FK5aHeZGGD4PvcTGsnWBQi/VUSaBnGUMikIbYNxB180=.sha256": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519"
    },
    "channel": "bpmux",
    "recps": null,
    "text": "[@alanz](@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519): And also QUIC and SCTP. There's a lot of related work out there, but ssb needs something that can be layered on top of a simple tcp connection. But rest assured, I'm not reinventing stuff without looking at what is already out there. Which, by the way, also includes libraries like zeromq and nanomsg.",
    "mentions": [
      {
        "link": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519",
        "name": "alanz"
      }
    ]
  },
  "signature": "qBYrDvMS4cpFXDBxAr7FnrSQMDJcj9lhKimftC7JNjbMlVdNNR4HblMzwKVbWStrWC5plcqEHau+p98FYIZhBA==.sig.ed25519"
}

{
  "previous": "%szjQzZ2UpNtE0rsVr0BHyXyMU19I3Es35iBQuZcsfU0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 880,
  "timestamp": 1535275799239,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "bpmux",
    "vote": {
      "link": "%FK5aHeZGGD4PvcTGsnWBQi/VUSaBnGUMikIbYNxB180=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "Ac5QYsGk03GZ5a1bcdZGwmnIdDxM/3aeAcZ8AGFeXI89Lph01pHOqNUojv7V73VOiBf8cRvAaKw3QFE0CgKlDw==.sig.ed25519"
}

{
  "previous": "%cKFoLmZHOyv0Ufjt+sen+4rCMReM+xQ7MFu9jAmfgN4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 881,
  "timestamp": 1535278638133,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256",
    "branch": "%RV4Op3d6LSVyj4wAHTTN0VesbNUSamPFtn7uuYGd1o0=.sha256",
    "reply": {
      "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%RV4Op3d6LSVyj4wAHTTN0VesbNUSamPFtn7uuYGd1o0=.sha256": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "Are sequence numbers of messages taken into account at all? I.e. always order messages from the same feed in sequence number order, use timestamps to establish an ordering between two messages from different feeds?\n\nThe cheeky quips are totally fine, it's not like I haven't been handing out a lot of them myself over the past few days =P I feel like I should mention though that timestamp randomization can have benign motives, such as anonymization of timezones (and computer activity in general). You might trust your immediate peers not to keep track of when they received new messages from you, but you can't trust any future crawlers of your immutable log. At some point, there will be communities of people who want to keep that information private, and they would have to chose another client (and also they'd be isolated from more privileged communities).",
    "mentions": []
  },
  "signature": "UQF3nbxiw3Fjlg84OMd1gDslkAP7g6mY3K1LmzbHuBxqeIjyjxLZYJyEMm++al7Kn4nZfAv1lOnDOPqT6YV7CQ==.sig.ed25519"
}

{
  "previous": "%gXnyWR2E0cF0/IVg4ItS4gVmNjiQCgo6ghQtSa+Emjs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 882,
  "timestamp": 1535283111905,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256",
    "branch": "%/DoCx+oBLDa4EL4e8xu72a31c63Du6bbHJ3h5uTL09I=.sha256",
    "reply": {
      "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%/DoCx+oBLDa4EL4e8xu72a31c63Du6bbHJ3h5uTL09I=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "[@moid](@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519) Is there anything about that use case that could not be done by adding timestamps to the message data rather than the meta data?",
    "mentions": [
      {
        "link": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
        "name": "moid"
      }
    ]
  },
  "signature": "axXYKaOmnoqpIy/HH2QJ1Ikln/edE6AbngBScZl71WgcmeWr/9sPNGI5xqWq6+8J0cA8KUxD2ekWBNd9vVppAg==.sig.ed25519"
}

{
  "previous": "%/+gIXJkrPYF3u5HsSpUrPvx/fDe6XWWAAqNjMe+9LI8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 883,
  "timestamp": 1535287724519,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-clients",
    "vote": {
      "link": "%bQbY1KfRmVss2pTckyEF0hTVdyFVnQ1PeGwbEyj2jhM=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "p4KFFlc8Aa772lG+TV5ZTa60MvO9kfrmyYR7Dy9wiTNdYY5pEOggHNADnpTeyA4HAyrnyDoTu3zcorJrT4lzCA==.sig.ed25519"
}

{
  "previous": "%s2df9551gqwO4Az35RwoJ3czjqLyk+HY1ueDKcgDepo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 884,
  "timestamp": 1535291911389,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256",
    "branch": "%bQbY1KfRmVss2pTckyEF0hTVdyFVnQ1PeGwbEyj2jhM=.sha256",
    "reply": {
      "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%bQbY1KfRmVss2pTckyEF0hTVdyFVnQ1PeGwbEyj2jhM=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "> You might trust your immediate peers not to keep track of when they received new messages from you [...]\n\nI just realized that sbot does track exactly that, as it provides methods to query based on receive order. Or does it only store the relative order instead of local timestamps (local timestamps are a completely fine thing to use btw, it's only global ones that are problematic)?",
    "mentions": []
  },
  "signature": "ZgXZ9IlnFB0buczTQS7jnDflvo0zRVEAG8d8OVRGztKfGf2SS7S7r4OQkKd6exvt9BlPyEWYiIHvcGg2Y6RWBg==.sig.ed25519"
}

{
  "previous": "%hU/NCkufPnOSTMXnR3wyvuOqGI2Gjfuwqtj3/fWiEzk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 885,
  "timestamp": 1535295849503,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ScgGMfSbd4WXBtH7ry+pjaaxMFF4GRMdf5ddWdM/uE0=.sha256",
    "branch": "%aR90vDH/9Pz6hIFLn5NZKtS2f3Vt3iwgmuvhmPgJVe0=.sha256",
    "reply": {
      "%ScgGMfSbd4WXBtH7ry+pjaaxMFF4GRMdf5ddWdM/uE0=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%aR90vDH/9Pz6hIFLn5NZKtS2f3Vt3iwgmuvhmPgJVe0=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "bpmux",
    "recps": null,
    "text": "The concrete programming api I have in mind lets the programmer set the maximum credit that is handed out at once (let's call it `cap`). The implementation would then transparently send out more credit to the peer, using the exponential backoff calculation above, with `cmax` set to `cap`. The peer can send as much data as it wants, but only `cap` bytes are in transit at a given time.",
    "mentions": []
  },
  "signature": "b6vkvWy65gofmXDz1X7klJiNd6Nh5r3GzI2VRBdGBGQEm8VBHbvhN0wLyzXm1C+nwmUxOYvfOS6P2juW0RWUAw==.sig.ed25519"
}

{
  "previous": "%kjVcquCp/RfaMF8gWL95j0jxfxT+KVQSYu3RmZZl1ps=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 886,
  "timestamp": 1535297854928,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256",
    "branch": "%WmXJJ5Wunkz5rKoo9QGiaqHcUJnhIUDM5xZ31ArtgUk=.sha256",
    "reply": {
      "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%WmXJJ5Wunkz5rKoo9QGiaqHcUJnhIUDM5xZ31ArtgUk=.sha256": "@dBQlwh9Gtr3i5YMOGtIOKtGNVepeu+nyb6KGl1vtOcM=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "> Here's such a thread: %hoAVki/…\n\nI miss [@Sybil](@rFgDtlYiyymSD4U96Av3pIil8xBj6afLXr87caoqAyo=.ed25519) =(\n\n- - -\n\nA quick summary of these things (mostly to sort this out for myself):\n\nMathematically speaking, sigchain backlinks define a [total order](https://en.wikipedia.org/wiki/Total_order) on all messages of the same feed.\n\nSubjective opinion: All chronological sorting of messages from the same feed should use this total order.\n\nIt is impossible to get a total order on messages from more than one feed.\n\nCypherlinks (assuming collisions are impossible ) define a strict [partial order](https://en.wikipedia.org/wiki/Partially_ordered_set#Formal_definition) on the set of all messages. This is the largest [happened-before relation](https://en.wikipedia.org/wiki/Happened-before) for which ssb provides cryptographic guarantees.\n\nSubjective opinion: All chronological sorting on messages from multiple feeds should be based on this relation. Receive-time or timestamps can be used as tie-breakers (which are needed since the order is only partial), but so could be alphanumeric comparison, or any other mechanism you can come up with. Since all tiebreakers are equal, none of them should be part of the core protocol.\n\nGiven a partial order (i.e. the happens-before relation defined by cypherlinks (which includes sigchain backlinks)), timestamps can be checked against it. Given two messages `m1` and `m2` with timestamps `t1` and `t2` respectively, if `(m1, m2)` is an element of the cryptographically verified partial order (i.e. `m1 happened-before m2`), but `t1 > t2`, then  the timestamps are inconsistent. If `t1 < t2` and `(m1, m2)` is in the partial order, then the timestamps may be made up, or they may not be. The very notion of a \"correct\" timestamp is useless in a distributed setting. The best you can get is \"does not violate the happens-before relation\", but that's all.\n\nEven if a timestamp is from the future (from your perspective), this does not imply a malicious lie, but can simply be the result of clockdrift (either on your end, on the peer's end, or on both ends), or any other sort of issues (hardware failure, sandboxing, timezones, etc.).\n\nThis is not a hypothetical and theoretical issue, it happens all the time. I can remember multiple times where I've received messages \"from the future\" in patchwork.\n\nAll of these considerations are related to cryptographically verified relations. You can go on and use a web of trust to get probabilistic guarantees for the quality of timestamps, such as in the thread [@kas](@dBQlwh9Gtr3i5YMOGtIOKtGNVepeu+nyb6KGl1vtOcM=.ed25519) linked, and there are surely some great \"solutions\" that involve proof of work. I'm personally not really interested in these approaches, at least not until we get the cryptographically secure parts done right.",
    "mentions": [
      {
        "link": "@rFgDtlYiyymSD4U96Av3pIil8xBj6afLXr87caoqAyo=.ed25519",
        "name": "Sybil"
      },
      {
        "link": "@dBQlwh9Gtr3i5YMOGtIOKtGNVepeu+nyb6KGl1vtOcM=.ed25519",
        "name": "kas"
      }
    ]
  },
  "signature": "67YPT6qaaCvlRaiH3cz0eYPumhOnzAAVK/9JaJaYzd/LNOs/EjTYnvFN1RzoTtN/MSDyn9zWZNmq2OE6wLCcCw==.sig.ed25519"
}

{
  "previous": "%G60GMTuFYWiQRxjNUDgnIQh9EhTY7uIcAJFwNA9nBM4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 887,
  "timestamp": 1535322691764,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%v6gP8x43gz6iJZHBVd2CLECIyNRARDBPix/BUWJbdkE=.sha256",
    "branch": "%HlCvPAKqzZLlytoY8xtBSGqk3nax7+S8YxIgn5mZsGY=.sha256",
    "reply": {
      "%v6gP8x43gz6iJZHBVd2CLECIyNRARDBPix/BUWJbdkE=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%HlCvPAKqzZLlytoY8xtBSGqk3nax7+S8YxIgn5mZsGY=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "B-b-but we were explicitly told not to burn things down. `cargo install sbot` does have a nice ring to it though.",
    "mentions": []
  },
  "signature": "8P6yKKD3V/lMe78S4OCDhYI90FkoKEWyCNCZim/SUh02mq6cfw+tcE5QXbABvOHL5XN8Vu8jMngiNbb8xXepAQ==.sig.ed25519"
}

{
  "previous": "%d3GVUPyyVp7gq3LOQTF77VnSiKa4Ytgf8Qbc/W0PF90=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 888,
  "timestamp": 1535322731463,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%HlCvPAKqzZLlytoY8xtBSGqk3nax7+S8YxIgn5mZsGY=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "2lwfIxmDwZDPep/BXOHSep554X0+ort4dApPlQeQoOP6lro2HKyjk1HlUtecqd1nwx0bFUuoNC1QwvJfDqndBQ==.sig.ed25519"
}

{
  "previous": "%KWRu/mQqXVWSZyAV9YbkF6mAkZmqVdNv84T8lA09ZGY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 889,
  "timestamp": 1535365240292,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-clients",
    "text": "Another question for the client devs: Would you be okay with timestamps becoming optional?\n\nOptional timestamps are a compromise where we still keep timestamps in the protocol, but a uxer can explicitly say \"I don't want to supply a timestamp for this message\". There are [valid reasons](%gXnyWR2E0cF0/IVg4ItS4gVmNjiQCgo6ghQtSa+Emjs=.sha256) for that decision. An explicit opt-out can be handled directly by clients, whereas the current anonymization mechanism of timestamp randomization causes clients to behave weirdly. Given a message that does not have a timestamp, here are a few things a client could do:\n\n- ignore it\n- sort by receive-time\n- sort by [causal order](%G60GMTuFYWiQRxjNUDgnIQh9EhTY7uIcAJFwNA9nBM4=.sha256), break ties (i.e. incomparable messages) by treating nonexistant timestamps as negative infinity, or by receive time, or by whatever else makes sense\n- diplay a large, red banner with the text \"User `@foo` chose to anonymize their timestamp. We don't want their kind here. Please block them.\", i.e. an explicit version of what patchwork currently does implicitly (Sorry [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519), I just can't help myself. I sincerely hope kiwi culture doesn't consider these snarks as too rude. If these are not ok, please tell me, and I'll try to adapt my communication style.)\n\nThe `ssb-client` API could simply omit the `timestamp` entry of messages which chose not to give one. Or if you prefer for things to break more silently, it can include a `timestamp` field, but set it to `NaN`.\n\nDo note that a malicious user could still supply insincere timestamps. Timestamps being inherently broken is not a thing that stopped being true. But with optional timestamps, these would clearly indicate malicious behaviour. For which ssb already has a mechanism, blocking.\n\nCC [@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519) [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) [@SoapDog](@gaQw6z30GpfsW9k8V5ED4pHrg8zmrqku24zTSAINhRg=.ed25519) [@Tim Schumacher](@o3eDT3n9urv1cyIWDuF+wQHBFj3I8OcE3L4Tla9RR8A=.ed25519) [@christianbundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519) [@ev](@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519) [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519) [@happy0](@RJ09Kfs3neEZPrbpbWVDxkN92x9moe3aPusOMOc4S2I=.ed25519)",
    "mentions": [
      {
        "link": "%gXnyWR2E0cF0/IVg4ItS4gVmNjiQCgo6ghQtSa+Emjs=.sha256",
        "name": "valid reasons"
      },
      {
        "link": "%G60GMTuFYWiQRxjNUDgnIQh9EhTY7uIcAJFwNA9nBM4=.sha256",
        "name": "causal order"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      },
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@gaQw6z30GpfsW9k8V5ED4pHrg8zmrqku24zTSAINhRg=.ed25519",
        "name": "SoapDog"
      },
      {
        "link": "@o3eDT3n9urv1cyIWDuF+wQHBFj3I8OcE3L4Tla9RR8A=.ed25519",
        "name": "Tim Schumacher"
      },
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "christianbundy"
      },
      {
        "link": "@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519",
        "name": "ev"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@RJ09Kfs3neEZPrbpbWVDxkN92x9moe3aPusOMOc4S2I=.ed25519",
        "name": "happy0"
      }
    ]
  },
  "signature": "lZDAEnewDS7gkP/bDfYQwM2pzliSD1JlDICeRvB5LBYXPtzDg4TDKls8f7YpAdJTRSWBqXoHDsEPUyrT+2MdAw==.sig.ed25519"
}

{
  "previous": "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 890,
  "timestamp": 1535365840124,
  "hash": "sha256",
  "content": "sbaqOCaWvMj55/JZ+aXcPHxaAj8/jv1Qw1j8kNGCKodcrEePgs1J/Z1mNGl8CtLW8q3L7N9e9SVGZ3V1eBJtnSCgZO5Aa7tzDosdn2VAv05YcLjMAwblaTr2RZd+2KA/Uv0lOxbX2QT3UzS9kaNxLmrSHF9yfxnM4uRQ9goXIXq0EJcM6T4vRwfHcaCp8ahzzQafpSGPaaLeHkclRERWo3ifbubso6gniCb89zf4RZvkb15nKzePcc7ebHCK1+hwerv2BoWlkCFFL6nvTW3ppCXWJOmrPVqz1QsyKMPFpASIbSBsXabet6KF5YQysSUOOVLtijyBI2c9bMoR5auD+tPeSMAMdcaRYPXxaQfLJX3u6sA+JIfuc2XeOs4A+BVCLlWyALtQnBxOn7AL7MBOcApooxunHaBvxLjWxJMqBKRrb2xrXRUkxbX+waifZ02WC3y+P8BedCZSYnd6UIIMWfgEzqOACybCVKI+hec2sO9YQhQmQSv+9VVsRinfh5unA+spqGcZ9DUEGb4IOf8kbIcNnUwVaNxBqvo4Vwk/0GsgIAPILBMSm/FpCl+30nKl9UTOrSu1qFqWICtyDVPjGZixiUMHXE9mzZVSuomnkpHuTwGxkVDwtHQU65RCcPLQEAV93v+8+Y0f9xSJNKYR5bIcei4AVNkQKCk7aU7zt0k+qpPF+TE8O+JxQMUIk4kZ2CsweoCWFgjCl3oTtsARldws/uU7vr6wuBuptMCOMi+hHId01l+BYdj6WT+Pe0DaM8je7N0jdFkFkjT7X5RhvsqbfXJUkEX67/IZZsjMcGMgk+pxYHRAGM4k/A5WJhCdTOZC0fjV5Uvc4ERzuql9nEkixqq7cP1iVWggKai2ZlkGi/tOV2Xo/cDdNowR51ks8e39CuA3rQ7JRWy18XXYEs74KVUqI9AcIle99RIjrGjdGdHfh0VlaDB64dTFVSvbZq587lbdL1p7ky9SAbkOYzkUe6tyMOHhyZs4DylBuIee5WphNxJ1BSVp8qZt6Lc7LGVJD7ekSbyjd4Lpitrk8PfbmCP75qzIVGH8YlSZpEnkyQMmJ81wiyfirlBdS4kaqRLIFE+nDqGNWspuGz8AULtAuzqIEfdWV/YW3e8a27wwMBtghGlSvOiJu7prjNbKTkd1JtLN7bSw5/+jYDhbJnv0hAfhMqaVVflnpJGrPxC6BobPDS3HpjzoIznwWRJ+wGOF2a8fpK/tKhJog0lQ7X7gULAftBAaBjWwv4TVbmoCz1fWnc93frD4TOuOK3+Zpl9Oct92OxAXZENHd1nmDgFMuiOSecae7VSdcheQlvpZjfHPfqDZeygjPlTm5fsVh3Q3YQ8N2KFr764UXUjzlL9G/hbPOHLH4MeqNfXJ+KFaU47lYpVqo1t22Txk9smnTqPkNp2T22fg/hQcs24yS9Q6TC2rAMzQy7P6GsOGwTu+hYcft0+MPzjI6fIso1vnbAmsyQnCsdblGIOfKCg=.box",
  "signature": "Wog6VXVVOiso0DbL0tbQOwywv6YVJTy13EQ9+Txa6cnKPuCTv8TiDouG86io6pq5pUEH6DaMi61y5+UWhuHiDA==.sig.ed25519"
}

{
  "previous": "%pqHtAjqO+FMUOietLtSbD0V0Rm90HMkEtYaosQ4J5cs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 891,
  "timestamp": 1535366330234,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-clients",
    "vote": {
      "link": "%BNPqpZbHBDKqEaH9NLOATuIEePJk7lLDBNDtYf37pTg=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "1GaY9mqpi93B+xRiBaeH6Dxar97kkNLLtlr03igl8kmcs9XU39iM2AkcCtg3X+1uupo5bJV8SBm7eAK5AJCmAg==.sig.ed25519"
}

{
  "previous": "%zfCprB3Tmj/qHE6u3U5B69WFnsJ99frd/vEd7VqTKYA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 892,
  "timestamp": 1535372141600,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256",
    "branch": "%jGn1EUZs1kEHXsmblm731oLxf/pb0IWT4fiejdvew2g=.sha256",
    "reply": {
      "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%jGn1EUZs1kEHXsmblm731oLxf/pb0IWT4fiejdvew2g=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "I guess optional timestamps essentially boil down to the following: Client devs can no longer ignore the fact that there are problems with timestamps. They are free to **choose to ignore** these problems (i.e. by requiring them and ignoring unstamped messages), but it is **no longer the default choice**.\n\nWhich would prevent situations like [@SoapDog](@gaQw6z30GpfsW9k8V5ED4pHrg8zmrqku24zTSAINhRg=.ed25519)'s \"I have no idea what happens\". I'd consider that a vast improvement.",
    "mentions": [
      {
        "link": "@gaQw6z30GpfsW9k8V5ED4pHrg8zmrqku24zTSAINhRg=.ed25519",
        "name": "SoapDog"
      }
    ]
  },
  "signature": "m0/LiRvkLVGGr/BNt/vBdcpsX3FFTIlwVeseUqd7aIRL4+fktoXIqR0B+d7lbL3Lqa0C7HFlh+H545gePoxEDQ==.sig.ed25519"
}

{
  "previous": "%K1UHLbkUDu1vPNel0vsulsUdLJs8y4tF2MMhZsV/RCE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 893,
  "timestamp": 1535372863813,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "hsdt",
    "vote": {
      "link": "%ezVgMxRO0Ne5kH1nQzClzT5omg0eYcA2w5nI6hjQWDs=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "9e5NCm0Or0cHeiVtSlmAHBoHwOEKl9a0KAH3XNfayHk2I1umPrzx3J0GQcf2+X7ruZp+9mc7TF2ptId2/INfAA==.sig.ed25519"
}

{
  "previous": "%3ULnCCMoHJrPkCNFH8nW+B8a6wwkWYIJOTeSjFU1OtI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 894,
  "timestamp": 1535379502178,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QwG8zd8clurICfDQixtvPHKCSFSVooriod7970O7VAo=.sha256",
    "branch": "%y/5qdKHTIRdmnhtrNxn67by2mBaRLtVkXlZxxDCMsTY=.sha256",
    "reply": {
      "%QwG8zd8clurICfDQixtvPHKCSFSVooriod7970O7VAo=.sha256": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
      "%y/5qdKHTIRdmnhtrNxn67by2mBaRLtVkXlZxxDCMsTY=.sha256": "@WeZBYERzjvfOVlgU7vMz7RSheqe4WaGEd87ewbMvnvQ=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) There are plenty of malicious attack vectors not as far-fetched as assassination:\n\n- actively search out and exploit security vulnerabilities in popular ssb implementations\n- denial of service attacks (I can think of multiple ways to exhaust or blow up pubs, just by having read the packet-stream code a few months ago...)\n- get a bunch of users to replicate illegal data without their knowledge (it's not that hard to get into the web of trust that is scuttleville), reveal it once enough people store that data on their personal devices\n\nUnlike assassination, these are actually worth worrying about.",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "yTxVmkE3Cy5hUma9VuF2IuSWHFOqLl3ds7xsd+pZT7oL4szkyZJNaefeH4v8TbEn/JN04wRXCiBCEofpNMnEBg==.sig.ed25519"
}

{
  "previous": "%VKQrvDreb+egCxnz8pyPK0LNsIUG7vKeWSsvYsx2/Yg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 895,
  "timestamp": 1535406239355,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256",
    "branch": [
      "%62JHg87dVSkPFPwpX5lOdjspgjTAGy+JxYs0GkXfZ40=.sha256",
      "%FiWmd8R2kJp8a12GWemQSANpwqKCOb/yngb+JEcbJU4=.sha256"
    ],
    "reply": {
      "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%FiWmd8R2kJp8a12GWemQSANpwqKCOb/yngb+JEcbJU4=.sha256": "@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "> I'm having trouble imagining how these timestamp-less messages will be used, would you be up for describing your application idea?\n\n[@ev](@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519) ssb at its core is a database, not a social network. Think of an arbitrary database on this planet that contains entries without timestamps. You just found a use case for timestamp-less messages. ",
    "mentions": [
      {
        "link": "@8Qee0I/DwI5DHSCi3p5fsl6FyLGArrnDz3ox9qZr5Qc=.ed25519",
        "name": "ev"
      }
    ]
  },
  "signature": "m/8D4SGCODufNKQ0gfOmeTJqybySe72aERCqVhTZYm7oelt5zISubvG8iQP3CysLTVyKumwCV3Ukc/WJ7HWiDA==.sig.ed25519"
}

{
  "previous": "%Tb4J9GfYmWtvVK3jMyM30DeGoEYoqfxG2bIEPIhH96w=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 896,
  "timestamp": 1535451289245,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256",
    "branch": "%5t6b2rGPMhoKodTnmzebCxR2+Ozb+jVIozaqZkTlR6A=.sha256",
    "reply": {
      "%5t6b2rGPMhoKodTnmzebCxR2+Ozb+jVIozaqZkTlR6A=.sha256": "@LzTjF5eAVC6xprPMGeNzqEP/EEBIGpM6hDaaY10hrz8=.ed25519",
      "%6KQkPDfIqOqBCroiWpTSXraZxzzPRRm9x3/qGptAAjk=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "[@masukomi](@LzTjF5eAVC6xprPMGeNzqEP/EEBIGpM6hDaaY10hrz8=.ed25519) I'm pretty sure a machine-learning person can write a fun little program that infers timezone, sleeping patterns, working times, travel, etc. with a frightening accuracy, given a feed with enough messages. Not everyone will want this to be possible. If clients encourage blocking in case of timestamp randomization, then these people are excluded from ssb, or at least all communities that use those clients. Which seems to currently be all of them, except patchfoo.\n\n> i'm not understanding what downsides I'm not seeing.\n\nTimestamps don't work in a distributed system. Things break if you rely on them. Physically speaking, it is impossible for two entities at different locations to agree on the same notion of \"now\".  More relevant for us, ssb needs to account for some [byzantine faults](https://en.wikipedia.org/wiki/Byzantine_fault_tolerance), i.e. peers may lie about the timestamps, or they might perceive a different time than you, due to clock drift, virtualization, or frankly bugs. Every once in a while, a newcomer on ssb asks why some post is from the future, or not showing, or why posts got reordered, etc. These are not bugs that can be fixed, these are consequences of client devs relying on timestamps. It just does not work, yet the protocol encourages to use them.\n\nI could not find a single good explanation that goes into detail of why the notion of distributed global time is impossible and undesirable, so here are a few different takes on it instead:\n\n- [tiny bit of physical background](https://www.quora.com/Why-is-clock-synchronization-using-a-global-time-impossible-in-a-distributed-system)\n- [CS education intro](https://www.cs.usfca.edu/~srollins/courses/cs682-s08/web/notes/timeandstates.html)\n- [paper by Lamport (who fortunately is a great writer)](https://amturing.acm.org/p558-lamport.pdf)\n- [blog post about a real-world example](https://plumbr.io/blog/monitoring/time-in-distributed-systems)\n\n[@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) Interesting idea. I want to stress that this does more than just \"getting the timestamp requirement out of the core protocol\": The core protocol can make no cryptographic guarantees about timestamps, but your suggestion does. And also, it is opt-in rather than mandatory.",
    "mentions": [
      {
        "link": "@LzTjF5eAVC6xprPMGeNzqEP/EEBIGpM6hDaaY10hrz8=.ed25519",
        "name": "masukomi"
      },
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      }
    ]
  },
  "signature": "juJE6JzcQfDd0Lddd8tMG5PsC+VXazFlNrTUQMx2pFePte2GiazFIxaryfZDgY/ghyIGC6tnwgDbAMR9Q6ymBQ==.sig.ed25519"
}

{
  "previous": "%ok5+4wuk4hdYmn1ZVUjXgzLjxl1tTUC/LgTzrw2UWYw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 897,
  "timestamp": 1535451436112,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256",
    "branch": "%5t6b2rGPMhoKodTnmzebCxR2+Ozb+jVIozaqZkTlR6A=.sha256",
    "reply": {
      "%5t6b2rGPMhoKodTnmzebCxR2+Ozb+jVIozaqZkTlR6A=.sha256": "@LzTjF5eAVC6xprPMGeNzqEP/EEBIGpM6hDaaY10hrz8=.ed25519",
      "%ok5+4wuk4hdYmn1ZVUjXgzLjxl1tTUC/LgTzrw2UWYw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "Addendum to [@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519): There are literally decades of academic research on this problem, as well as real-world engineering. If someone is serious about high-quality timestamps (with a specific model of error tolerance, be it in accuracy, trust, or something else), they can get them. They won't even have to come up with a solution themselves.",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      }
    ]
  },
  "signature": "omLlCUkD1QeDTx51V9XPXyTYQoFCv0cqBThZPhVUREPxAniHqfx5rtch74fBZtOKyIj/CeJBp0hCJlCPUNx0DA==.sig.ed25519"
}

{
  "previous": "%QFYXxt3nbizzwhQ2h5QGrkssfVwA32i0ChM8Y6hQpr8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 898,
  "timestamp": 1535452075685,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256",
    "branch": "%aDed3Gm2u14+kfnaOAcjyDUZOwVx87AVzb6KKnCZrZ4=.sha256",
    "reply": {
      "%lvG7sVymWqomjgoyvqkrYJ7nSn8hiPQI4cLqA7A/b9o=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%aDed3Gm2u14+kfnaOAcjyDUZOwVx87AVzb6KKnCZrZ4=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519) In case you missed it, in [this thread](%91oWEK4ePS7ijWpYofdRTxbtu4fPSNcfWt2CM6VQ/4c=.sha256) we unraveled the spec that ssb happens to use. So if you ever need a definite reference, you can look there. Have fun with the ecmascript specification, it is a joy to read.... =/",
    "mentions": [
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "%91oWEK4ePS7ijWpYofdRTxbtu4fPSNcfWt2CM6VQ/4c=.sha256",
        "name": "this thread"
      }
    ]
  },
  "signature": "74gaRIHY6Fc+yMHJnIyDSC+ru+Dk4PJ4uP1fW1xpELk6kGpqvnA/aB24Neri2dy14MxA+oQtTKHR1Gy3wHk4CQ==.sig.ed25519"
}

{
  "previous": "%4jNCUWoP0chc5Q/dxxSs+19zCHq8+6RmfYNEUH45ox4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 899,
  "timestamp": 1535454529720,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256",
    "branch": "%17/8VkYFog5wglS2zmB8kAK3vsoiN3xZ6sNu7CuZy5Q=.sha256",
    "reply": {
      "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%17/8VkYFog5wglS2zmB8kAK3vsoiN3xZ6sNu7CuZy5Q=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "Sorry [@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) for not giving an ack on your post. [This post](%K1UHLbkUDu1vPNel0vsulsUdLJs8y4tF2MMhZsV/RCE=.sha256) was indeed intended as just \"musing and rephrasing\", it didn't occur to me that it might come across as dismissive.\n\nThank you [@bobhaugen](@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519) for mediating here, and mix for clarifying how you read my post. I know communication is not my biggest strength, and it is phantastic to be in an environment where more experienced people like you two keep things from derailing.\n\nI'll try to write a proper response to the content of your actual post later, but for now I just want to get this meta-level stuff out. Especially since we seem to both be awake right now.\n\n> I think I'm more experienced in building clientside, and I think by working together we can figure out some awesome solutions.\n\nFor what it's worth, I fully agree with everything in this sentence. Even if it might not always come across as such.\n\n> If there was something else going on for you @Aljoscha that needs sayin, I'd love to hear it.\n\nWe only have finite time per day, and I spent *a lot* of mine these last few days on the protocol stuff. There's a lot of writing in a non-native language, and there is even more time thinking through this stuff. I have a clear sense of where I'd like the protocol to get to, but it's the details that are time-consuming. Well, and the parts where I am *obviously right* and everyone else is *obviously wrong* ;). Those are annoying too.\n\nI did start typing out a response to your post specifically, but I didn't feel it would come out right, so I focused on some other things first.  Which included not only writing posts that required less thinking for me, but also playing the piano, drawing some birds, fiddling around with #bpmux, doing the dishes, and sleeping (we live on opposite sides of the planet). Sometimes I even interact with other humans in meat-space. All of these are things I neglected the past few days.\n\nI'm willing to put in the time the whole process will take, because I believe it will be worth it. But I don't feel any obligation, so if I feel like drawing some birds, I'll do that instead.",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "%K1UHLbkUDu1vPNel0vsulsUdLJs8y4tF2MMhZsV/RCE=.sha256",
        "name": "This post"
      },
      {
        "link": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519",
        "name": "bobhaugen"
      },
      {
        "link": "#bpmux"
      }
    ]
  },
  "signature": "AMJ9oKmyy2sl14Iefw3ozLSW1q8msCMw5qBFXTQXFunYYuS8SGNMbhp5QUj+Qn7ftCCk2XFnMqqpDsJh5GqACg==.sig.ed25519"
}

{
  "previous": "%YQzcj30mk59WbsTDV9kv/gIriIwmApJhQ7dEog/6kYM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 900,
  "timestamp": 1535454714717,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-clients",
    "vote": {
      "link": "%17/8VkYFog5wglS2zmB8kAK3vsoiN3xZ6sNu7CuZy5Q=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "WxJ0Bl9dlYm5q5n3cc58N4lRm4ZWTEW3CKGtudts3qpEua2Nuc0Xrixiczi03hFGP5phztKXHzaKM5/+7glpCw==.sig.ed25519"
}

{
  "previous": "%9nAoUHF4Bc1i4RrGdO3YnNZSbCSIHItj1FOubBP/wMs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 901,
  "timestamp": 1535455229230,
  "hash": "sha256",
  "content": "Zd+KmID7/1gh/dS0uRlSIVFf4GNVAxD6mLw/CN3CPbXIpNMa4FprBmRfVXK+gWwGDuD6JzAxPTzBCOmkn5OmQvl9r/O9ghVAYJ/WDbgHqtFNVY4hlV6xMHMNwY3vkTpQQv+f4BRP88Zbpyn+Ho8N+g8/MyXIw+BB8Pa8wbODF3t221c4xdHrYltWf0qg0nxBZkgW3WNDzCggnHN7gnWQgoRtxUs1vN4N07mZYQLlXFr+Ru7aKoAt0NJim8m3cNsZ2P5yVdrgFFBeHDWB5tQWxZDGR+gzPJcHUH6ODjIBhnIjWivJLfPOkggWLvwvGG64n9q1iRL1vfVNnXnty+e+azzZUntSWPK0mBb56HcG1bmlUc4cOF/FJ2LONduhcvTK9To3EoIRylH8GAMrSLtLRqV7/OPp2QO7dw48fmicpTa1wCAzslKD9tPf1SgWJcLSAFjdPdhk9nVC5oWtQlZ0JDKK6RDoMRJt/lPXE2ZvCRRWM2Y4sTrYI9vql8czV6RYH3ssY4SY6YDa+u8xqGGa0f2LJxqHBh0PSW0AoOjO5EpOHJyICV+hd4YHEbhc4TxThRe8hBCtyjqyPgOHk65j9ru19IedVqTgeXNtHOxyYY7jlLcfuIxw3nOvk/IVVCNMR/IuqOO65u+33tH/r3u3wSUTn0jhM5UC5jCt3FlejZFV0P1JdtUVSw6OfGU/KV2po6xlK/jk4TWepyrVHLe9l5vQLv7BNP4/DjQJHpWcSnCnApGqhLLDRoJdWqiaM9oI/xpV73GT6X0wUbeV1dRSb2EJWcCQlbBZiNmZFq9Ge6f4r6pqBCMYGCPjuixgCPUmZGwxrhGMKo48YzNLyGfhWIcBtOPUmdQbowVbI2d1lU5dcxrCMAn2FUm+ODP4ecjg1g+kwgsFtVQXmOlPchEWUGY/Gqo6spNfh3lr9bIPUoOu3cF1p9m9aOtC5mdCsL/4g2BnrpHjr6CoFpbqcgIT/XdwQKLAlGD5Wrv3OtWHdd6laStYPg8pStrzlfpDqDa7OU17Igy+j6R0PAHk/3+BnsBowvAkj6OPoxWrbbt/zTFS+GEGCNwxbn5p7R6/+mYi0Q+9So+2pOzIaPOQw6dKR7fJ7KKAjuhnZIEGY+5FasjLPwYYNR5JjV20scRM.box",
  "signature": "QGSyasM8cOV6+xxRyzJn/7P4QWtIc/y5PneJWueMbFm4c3fhtVqNut//BT9DjrbU0wtf7JH/2Ns7sK3eAX9YBA==.sig.ed25519"
}

{
  "previous": "%ATrK9qVGJmUfBNARgF7aWan/J0pkTArisnzlyIXi3UI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 902,
  "timestamp": 1535455329307,
  "hash": "sha256",
  "content": "Woa6zumGrqG34RD1u0gI8MZF4AO9psN+6+X56aFn6S//mQ6BI0KN+1cL1irTUBQT3Fm10mtXgzPKt/8/ociIRxD8HElpcofnRVNiWrjZinoqxzv9fL7i+QCMgNeTwT/O+xYeWZDQXcVwm+YVbPJNTLNObt7WBTn4/IyZqS33buuZGIO2ZqvE7T9A+CIglW5q8c4XI8g07plH0jyA90vObN4N710RBh4iI39/HcK0Zx02+RhEfGLtXg15tkTZ7Po+m2T7OewzqgQIgdgLpIq0seQhzBK5Ii8JogrOpF2qjeNdZgWOvKG4CCjnQdYUtIuKvwWTcgW4w1W377d4pogp3xBgzQW/qbwFxBTov4iQM8VaAQgkfnTP15CUsKI9n5aEfDA0fSnTyM+iGmvBSUUInoZjro5s6Fe6IaVdd5V9FqvGkSzrkA1E7jgMx6YFCG8bu5/2IOEoOOCq7VXxPAFKcfdajGOiEtBRn/NfWYniN2SWuUu/8a9kg086Uaf1xRXM8Ty1yR8oMSfOFVrudDQVsJh1LbSPK9TT9StLq8b0BjI4HIkDjsSpteUcVGwXGF0PWJEkIeTh6mq+mchGXY6xvRBKsAsZa8VdvSXb4MdKFcNQoX4em2iixNwoWy9urohPb3RqWoE8SnumsifDwCNwTElNforHDsV2T6cxteFGh7mQ/G3HbwdCTojKY9UyJaYQGRbK3CTh0lT7eKEPaWoW0j6datUaZbo+DKnBubFZr4WqQbUb+amSI7Sj/SgxMZ/BQzvJP41Etj2STnki/juPhPWzTNyccSmyBrIORgN0VwnfHcCyyiYDwSdZSKCNFFNb//U8r2FTCQhioT8EuquqfYZwlZuKtxSnqq3cK/Vi+m8SW27AI6aXdIiZkFPfbv1ZTSBamE6LcCqvJeYbeofa+vlbPbVPLBc8dlM0ANln+cEPXG1LBujXBYmldYe+4upEGmD7B0EKlYZjJ/sKjpWWC81ovjtdtQrEBFXK0xsZfqnWlPwYzNx7Miupr7orujDVmFSvN78molAgcSoAeYv4F5TforH6bA==.box",
  "signature": "rdDVpJAVWL9hyPpOIBYjoFPqmuThumxSQ0Si3aNPlm2X9LwT5R9gpytXdGQeK9dIe9Z130xSbiqDt9BE7laHCw==.sig.ed25519"
}

{
  "previous": "%CGJaZjsv5o+5pk5EtnHIUPnK10tbDmiBbEGDyL4kLu8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 903,
  "timestamp": 1535460622737,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebutt",
    "text": "# Protocol Changes - A Todo List\n\nFor general transparency, added resilience against falling coconuts, and admittably as a defensive reaction to [this exchange](%17/8VkYFog5wglS2zmB8kAK3vsoiN3xZ6sNu7CuZy5Q=.sha256), I typed up my current set of scribbled notes on what still needs doing to upgrade the ssb protocol. It's very rough, but I'd rather start working on the entries themselves, than spending more time packaging them. There are a few open questions in there, a few more things I have yet to properly write about, and a bunch of preferred outcomes of mine.\n\n## Metadata\n\n### Timestamps\n\n- keep timestamps as they are, make them optional, or drop them?\n  - properly engage with [mix on optional timestamps](%DQb9ePNVVKaPcaxhMdQEEodWfnFUHaXQisiDqdwzkFk=.sha256)\n  - give better background on the problems than just [this post](%ok5+4wuk4hdYmn1ZVUjXgzLjxl1tTUC/LgTzrw2UWYw=.sha256)\n- timestamps as floats or ints?\n  - ints please, since we dropped monotonicity and float suffer [year 2038 problem](https://en.wikipedia.org/wiki/Year_2038_problem)\n- how to encode optional timestamps in the binary metadata of hsdt messages\n  - omit, or special value? Depends on other metadata considerations\n\n### Other Medadata\n\n- more in-depth writeup on [possible paths forward](%CyL8VuY12NAk3fqJ2jMpuegRUlvMOLvnszczYS0KaBw=.sha256) (dedicated post)\n  - figure out cost/benefits ratios for the things we could roll out in one go, suggest a reasonable package, probably keeping `feedid` and `sequencenumber`\n- figure out how to get `type` in to the metadata, but still encryptable\n  - suggest increasing size of type field so that it can hold 512 bit hash digests once 256 bit hashes become broken\n- use the changes to set a new message size limit, or at least its calculation, based on actual number of bytes\n  - including or excluding metadata?\n- content as \"blob\" (dedicated post)\n  - metadata could include hash of data, not the data itself\n  - personal blockchain then consists purely of metadata\n  - allows deleting and blocking specific messages without blocking a whole feed (GDPR!)\n  - replication rpcs can concatenate metadata and actual data, no need for additional blob roundtrips\n  - how does this work with the type field?\n  - how does this interact with encrypted messages?\n  - drawbacks:\n    - additional hash verification\n    - takes some work to implement\n      - changes rpcs\n      - changes db\n      - db can mabye \"cheat\" and store things as usual, converting as needed?\n      - additional failure mode in the client api: can have a message's metadata but not its content\n- work out binary encodings cyoherlinks, hashes and signatures\n  - could use ipfs multihashes, but should use a different type table\n  - could roll our own where the hash type implies the length, and only future hash types must encode length explicitly\n    - can preallocate ids for as-of-yet undetermined hash functions of a specific digest size\n    - not a lot of work\n- once all this is decided upon, find a binary encoding\n\n## Data\n\n### HSDT\n\n- add integers (yes)? add cypherlinks (yes maybe)? add sets (no maybe)? and arbitrary-key maps (no maybe for now)? (dedicated post)\n- how can new data types can be introduced to the ssb-client js api? (dedicated post)\n  - simply break things?\n  - preferred: use non-enumerable properties, maybe `toJSON` if needed - this is solvable\n  - migrate stringly-typed cypherlinks to hsdt cypherlinks?\n- find out how much new data types require changes to sbot's database\n  - Infinity, -Infinity, -0 and NaN are probably fine?\n  - what about integers?\n  - what about cypherlinks?\n- find out whether some db data migration is needed when rolling out hsdt\n- fix the last errors in the [testing-area implementation](https://github.com/AljoschaMeyer/hsdt-testing-area)\n- update the implementation with all additional datatypes\n- prepare a body of afl-generated test cases for other implementations to test against\n- figure out the conflict between keeping the protocol extensible by ignoring certain data vs ensuring canonicity\n- encode collection sizes in bytes or items? (dedicated post)\n  - leaning towards items, esp. since bytes don't *really* make decoding easier. When decoding an array, you'd like to know *how many* items to allocate, not their total size.\n    - considerations: async parsing, malicious size indication, highly nested input, when does encoding and decoding happen, compactness of data, ease of implementation, efficiency of implementation (benchmarks, ask arj or dominic for json data sets and convert json to cbor?), transport format framing data, does the binary metadata include the content size in bytes, streaming encoding and decoding\n\n### Semicanonical Json Replacement\n- all of the above again, with fewer decisions but more ugly workarounds\n  - not looking forward to this, but open to help dominic with the design\n\n## RPCs\n- read up on the replication rpcs\n- how should hsdt messages be added?\n  - should clients be able to only request non-legacy msgs?\n- figure out which rpc updates semicanonical json requires\n- in general, try to make rpcs take encodings as args and work across all of them\n- propose an encoding-agnostic rpc for asking for messages in the format that gets hashed, not the wire format\n  - new server impls only need to implement this and can then replicate the whole set of messages\n  - as efficiency demands it, they can update to direct handling\n  - nb: with the current hsdt proposal, hash encoding and transport encoding are identical\n  - nb: for legacy json message, hash ecoding and transport encoding differ, and obtaining the hash encoding is [painful](%91oWEK4ePS7ijWpYofdRTxbtu4fPSNcfWt2CM6VQ/4c=.sha256)\n  - nb: future ssb versions might want to add more efficient transport encodings (there's always the option of compressing the data), so this rpc should work with future formats as well\n\n## Other\n\n- figure out a whole rollout plan, what needs to be done, and coordinate things so it gets done, do as much as needed myself (but trying to stay clear from the database layer...)\n- figure out how to present a summary of everything for dominic after burning man\n  - and write it (dedicated post)\n- write my dream spec for ssb, ignoring backwards compatibility (suggested by @Piet) (dedicated post)\n- write down spec for leylines, similiar to ssb, except: (dedicated post)\n  - feeds are trees rather than lists, allowing partial subscription and replication\n  - untrusted gossiping mode with temporary ids over a fully random overlay\n- write down the full bpmux spec (thinking is already done) (dedicated post)\n- work on personal projects, not just ssb\n- draw [more birds](https://commons.wikimedia.org/wiki/Commons:Featured_pictures/Animals/Birds)\n",
    "mentions": [
      {
        "link": "%17/8VkYFog5wglS2zmB8kAK3vsoiN3xZ6sNu7CuZy5Q=.sha256",
        "name": "this exchange"
      },
      {
        "link": "%DQb9ePNVVKaPcaxhMdQEEodWfnFUHaXQisiDqdwzkFk=.sha256",
        "name": "mix on optional timestamps"
      },
      {
        "link": "%ok5+4wuk4hdYmn1ZVUjXgzLjxl1tTUC/LgTzrw2UWYw=.sha256",
        "name": "this post"
      },
      {
        "link": "%CyL8VuY12NAk3fqJ2jMpuegRUlvMOLvnszczYS0KaBw=.sha256",
        "name": "possible paths forward"
      },
      {
        "link": "%91oWEK4ePS7ijWpYofdRTxbtu4fPSNcfWt2CM6VQ/4c=.sha256",
        "name": "painful"
      }
    ]
  },
  "signature": "36IxQ03dZzsd37/1NqdDKnkwdFlvRRyrfIQ+ENMOzh6b6AmYku7R2mNKVbjwxx9oqW/wmC83ta9p0Iccw1GPBQ==.sig.ed25519"
}

{
  "previous": "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 904,
  "timestamp": 1535468093310,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256",
    "branch": "%YQzcj30mk59WbsTDV9kv/gIriIwmApJhQ7dEog/6kYM=.sha256",
    "reply": {
      "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%YQzcj30mk59WbsTDV9kv/gIriIwmApJhQ7dEog/6kYM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "[@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519)\n\n> mmmmm.... not sure. I _think_ matt is right about `post` type really benefiting from timestamp. It's really annoying reading things that are old when you want new things and a person just came into gossip range of you. or rather, it's strange, and sometimes embarassing when you don't realise how out of time your reply might be.\nIt's annoying when a whole persons feed sits on top of all your other friends content, that makes me tend towards blocking to remove the noise.\n\nI think causal order would mostly solve this. Imagine if the `ssb-client` API had taken causal order into account from day one, do you think you'd still need a timestamp on every message for convenient client development? Implementing causal order in sbot, adding client-sbot rpcs that use it, and recommending them as the default is something we should probably do. It would be unreasonable to expect every client to do this by themselves. Checking consistency of claimed timestamps would then be trivial, even if they are part of the message content, not the metadata.\n\nI'm somewhat inclined to dismiss every argument of kind \"message type xyz benefits from timestamps, therefore timestamps should be mandatory\". Ssb does not enforce a schema on your data. If you as a dev prefer to have timestamps available, feel free to add them. But if you want true interoperability, you must live with the fact that others may still produce messages without them, just as you must currently live with the fact that all timestamps you receive might be bogus.\n\n> I think if you remove timestamp you might have to make `branch` compulsory.\nI think `branch` is actually way more interesting that timestamp.\n\nI suppose you are talking about `post` messages here? As said above, you can just add a timestamp to it. But I agree that `branch` is more interesting, for the same reasons that I prefer relying on causal order rather than timestamps.\n\n> Downsides would be losing ability to do any easy queries.\n\n`<subjective opinion>`If you can not rely on it being correct, then sbot should not make it easy.`</subjective opinion>`.\n\nDo note that queries are implementation specific, not part of the ssb protocol. Ok, that is only half true, here is the more precise version: I do not know what kind of queries are part of the ssb protocol and which are not. Sbot uses the same rpc mechanism for talking to other servers and for talking to client applictions. Since every server could call these rpcs, they are technically all part of the network api (aka ssb protocol). In practice, a lot of these rpcs are intended to only be called by clients. For replication, you basically only need \"hey fellow server, please give me all messages of feed @foo, starting at sequence number 42\". There's no queries involved in that. I'd prefer if we clarified which subset of rpcs is protocol relevant, and which is not. And timestamp-based queries would probably end up in the \"not part of the ssb protocol\" camp.\n\nInstead, they would be sbot-specific, and applications written against that interface would only run agains sbot as the server implementation (or any other implementation that emulates the API). And that is totally fine (for the context of this discusion), it is also how any more advanced db stuff via flume works. But ultimately, the core ssb protocol specification is not directly effected by this.\n\n> Of yeah I tihnk as the database gets older being able to say \"only message published in the last year\" might become really useful. I _think_ this might be the case with all message types. Something like `tag`s don't really need a timestamp to operate, but at the same time, if I want to see new tags my friends have been gathering how do I do that.\n\nCausal order to the rescue again. Pick an arbitrary message which you trust to be from the correct point in time (e.g. a year ago), query for all tags which are higher up in the causal order.\n\nAdditionally, even if we don't consider queries by receive time as part of the ssb API, a server implementation is still free to store those and offer an API to the client. Combine those with causal order, and you get a pretty good approximation. And timestamps don't give you anything but an approximation as well, except that it can be arbitrarily bad.\n\n> I think we need to imagine a range of scenarios and propose how to build those quiries. Or to spend a week re-writing modules and _avoiding_ using timestamps to see how hard it is.\n\nThis would only be a fair comparision if sbot allowed to sort by causal order. I hope that in that case, the effort for clients would be reasonable. But simply avoiding timestamps even though sbot development has assumed their usage for years, will only give a skewed outcome.\n\n> I am **against** anything that makes querying any harder than it currently is - either I don't have good strategies or some queries are really hard already.\n\nAgain, we need to be careful about what of this is actually part of the protocol, and what is not. A server could have non-protocol rpcs  that look for a field named `\"timestamp\"` inside messages and sort by it. I unsurprisingly think of that as an abomination, but if that is what it takes to keep the core protocol simple, I'm willing to accept it.",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      }
    ]
  },
  "signature": "KWckUrJQcoD+gWBHE3AwWGuZnAw2zsICxA9RBfOpclJu3cutdrV9HV6eliIPew0+hnHRaPDACNATT6DZ87fEDw==.sig.ed25519"
}

{
  "previous": "%BASQNXkRozMiZN12SbPO/7MmjAhONd1Tbel2IYPEIH4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 905,
  "timestamp": 1535488062177,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256",
    "branch": "%HidNHo7F810IrmnBFC6twX5/WI+w7sqRHXwc/qsfPGo=.sha256",
    "reply": {
      "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%HidNHo7F810IrmnBFC6twX5/WI+w7sqRHXwc/qsfPGo=.sha256": "@uOReuhnb9+mPi5RnTbKMKRr3r87cK+aOg8lFXV/SBPU=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@cryptixInTheCloud](@uOReuhnb9+mPi5RnTbKMKRr3r87cK+aOg8lFXV/SBPU=.ed25519) [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519) \"identifier\"?",
    "mentions": [
      {
        "link": "@uOReuhnb9+mPi5RnTbKMKRr3r87cK+aOg8lFXV/SBPU=.ed25519",
        "name": "cryptixInTheCloud"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      }
    ]
  },
  "signature": "UNpedKySDUM6eKckbdkA0AStCxXSt5tjJI8Ib8AXRzDtU9e7WKa4vY5ySzNeY4Ie7z7rNnJVoqYBOXTDxGTkAQ==.sig.ed25519"
}

{
  "previous": "%H2DZWnHRyC1IYs/WSsLyOG5aXOdUUQnapcgIZmWRd7Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 906,
  "timestamp": 1535488500747,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%9VWASKdl78TVKP+Hn0bVqji6Avg0DpfSP4aUIT6rwJE=.sha256",
    "branch": "%vQNYNL6qhMbcWfzcDJL4/2WlEU0Et0Lapve8/A5dSj4=.sha256",
    "reply": {
      "%9VWASKdl78TVKP+Hn0bVqji6Avg0DpfSP4aUIT6rwJE=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519",
      "%vQNYNL6qhMbcWfzcDJL4/2WlEU0Et0Lapve8/A5dSj4=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519"
    },
    "channel": "ssb-protocol",
    "recps": null,
    "text": "[@bobhaugen](@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519) SDN (the first link) is *not* a proposal for ssb. But Dominic interpreting it as such triggered this whole avalanche.\n\nI'd add the #hsdt channel to the list, which is were I'm doing the data format design. The current draft for a spec is [here](%jt11rmbFmkR6tGQJDm99I4Z939Q2b0LmZCpkiOke/A0=.sha256). Another link to add to that list: [thoughts about data types other than those provided by json](%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256). I'd love to see more engagement with that thread in particular.",
    "mentions": [
      {
        "link": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519",
        "name": "bobhaugen"
      },
      {
        "link": "#hsdt"
      },
      {
        "link": "%jt11rmbFmkR6tGQJDm99I4Z939Q2b0LmZCpkiOke/A0=.sha256",
        "name": "here"
      },
      {
        "link": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
        "name": "thoughts about data types other than those provided by json"
      }
    ]
  },
  "signature": "/CPrNi5BAkSeQJwZzaeN0fqOHpX9tVI4brR9ECqegMeQtYkVgyXUH0sBwPKTaylvLATvQ5DrCfZ7LkNhWme8Dg==.sig.ed25519"
}

{
  "previous": "%yjlvZgzEM/WJg8FH9Yl7LAUpYAnzfuZV4wQW+uHBoN0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 907,
  "timestamp": 1535529798464,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-clients",
    "vote": {
      "link": "%76QoBmeB07QADgIX+LFNLOfz8KSOlkTFSJ+SVw+/DsQ=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "UcQK7XF8cNEXKPVj75XtD+Lee2DiqU6HQGy8PXhJApw7B8mGLOayVm4zM/691vtgfGKuxcVJPjSvtYL3hbP1Dg==.sig.ed25519"
}

{
  "previous": "%tUPvUpziBhEQsWBg1AAN51Em/5D44eJ8Q+zzOdR2pLs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 908,
  "timestamp": 1535531407557,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256",
    "branch": "%btlX80eRHsRka7bAEpU7m6CFKRn80foDIAZUU4XFg4U=.sha256",
    "reply": {
      "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%btlX80eRHsRka7bAEpU7m6CFKRn80foDIAZUU4XFg4U=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "[@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) Any (non-garbage) cypherlink in any ssb message establishes a happens-before relation. Most messages in the current social networking applications include cypherlinks. Building the partial order won't be a problem, and it is unlikely that it will be too sparse either.\n\nBy adding [cypherlinks as a dedicated logical datatype](%I97qRXW3GuTaAyl0Vh1R1meRx18Jjlcedm0QFdi3Qho=.sha256), checking messages for them will become very easy - with wort-case time complexity linear in the message size (with far better constants than would currently be required), and a lot faster in the average case where you get to skip a lot of data of differing types.\n\n- - -\n\nImplementation of causal order in sbot would be a great way for anyone to contribute to the current push to renew the protocol #somebodyshould. The causal order is simply the [reachability](https://en.wikipedia.org/wiki/Reachability) relation on the directed graph obtained by treating ssb messages as nodes and cypherlinks as directed edges. The linked wikipedia article mentions a few algorithms, and there should be a ton of literature out there. The implementation can stay fairly simple (without changing the database representation), but in the future it might be worth considering to adapt the db to allow constant-time lookup/computation.\n\nFun fact: Combining the causal order aka reachability relation with some sort of tiebreaker yields a topological sorting (which is a total order).\n\nComputing the causal order is another of those things where all the thinking has already been done for us. Moving to a db with constant-time reachability lookup will be some work, but might be worth it. But it is not required to so before we roll out causal order sorting in sbot, there are less sophisticated but still sufficently performant algorithms.\n\nCC [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519) and [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) for database related thoughts. You might want to keep this in mind for the go implementation.",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "%I97qRXW3GuTaAyl0Vh1R1meRx18Jjlcedm0QFdi3Qho=.sha256",
        "name": "cypherlinks as a dedicated logical datatype"
      },
      {
        "link": "#somebodyshould"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      }
    ]
  },
  "signature": "JerQOMR5zkApP/Jf2mwPiwzGoxN6sjtQMPZiN5wZ6FoIDCrCzP3ymMLtwDWdlMki3dVV3uJEIGBnWtXZgwZvAw==.sig.ed25519"
}

{
  "previous": "%IMrc+w6bSROTJzdlNpMhKcGc30wt4auwlN5/vC3gw34=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 909,
  "timestamp": 1535532055170,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256",
    "branch": "%m9+BbbUUNeqe8OtZ6e28jLQXjvfvIVQMIhBTQqLdjGc=.sha256",
    "reply": {
      "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%m9+BbbUUNeqe8OtZ6e28jLQXjvfvIVQMIhBTQqLdjGc=.sha256": "@LzTjF5eAVC6xprPMGeNzqEP/EEBIGpM6hDaaY10hrz8=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "[@masukomi](@LzTjF5eAVC6xprPMGeNzqEP/EEBIGpM6hDaaY10hrz8=.ed25519)\n> are there any real downsides to having them if you *don't* use them for ordering?\n\nIf there are timestamps, then people *will* use them for ordering. Look at the current client situation, Cel is the only one who does not rely on them (unless you specifically tell patchfoo to do it). Optional timestamps at least force them to consider it a partial ordering.\n\nThen there's the privacy concerns I listed above. And just as a general approach to design, trying to answer \"why\" rather than \"why not?\". (I'd like to link a quote here, but I'm offline. The best source I can give is to search the \"quotes\" section of bret victors's website for \"lua\") ",
    "mentions": [
      {
        "link": "@LzTjF5eAVC6xprPMGeNzqEP/EEBIGpM6hDaaY10hrz8=.ed25519",
        "name": "masukomi"
      }
    ]
  },
  "signature": "oajSXg2DQJl36rXRftAXZCNgUhd08g3GpmUzlCq08SA4SSNMuYJp72KlTsMPeGqBh6XX+5wdhZq6EQy2O9xLBw==.sig.ed25519"
}

{
  "previous": "%vafQ76/aMTL/sLAZGanORsEfRIFJ0wSpSHB4DUSq7s8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 910,
  "timestamp": 1535532147874,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256",
    "branch": "%H2DZWnHRyC1IYs/WSsLyOG5aXOdUUQnapcgIZmWRd7Q=.sha256",
    "reply": {
      "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%H2DZWnHRyC1IYs/WSsLyOG5aXOdUUQnapcgIZmWRd7Q=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "New entry: digest [this post](%76QoBmeB07QADgIX+LFNLOfz8KSOlkTFSJ+SVw+/DsQ=.sha256), learn about the rpcs in question, figure out how this effects everything else.",
    "mentions": [
      {
        "link": "%76QoBmeB07QADgIX+LFNLOfz8KSOlkTFSJ+SVw+/DsQ=.sha256",
        "name": "this post"
      }
    ]
  },
  "signature": "sc4/Y3NmQSrVMYpIYRdF59nXFbgOVRiMqnb/TgmiBNafZm5zR+uhF3QF9UjlkeqiVnm2vQSYPoHmgLnO1+q+DA==.sig.ed25519"
}

{
  "previous": "%q+aGwdKVqrMXIVo5EOQlEvU/1M93EVUI+Jo+8v/ILuA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 911,
  "timestamp": 1535532909745,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
    "branch": "%ezVgMxRO0Ne5kH1nQzClzT5omg0eYcA2w5nI6hjQWDs=.sha256",
    "reply": {
      "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%ezVgMxRO0Ne5kH1nQzClzT5omg0eYcA2w5nI6hjQWDs=.sha256": "@ppdSxn1pSozJIqtDE4pYgwaQGmswCT9y15VJJcXRntI=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "Note to self: What about 16 and 32 bit floats? Cbor supports them, would be trivial to add to hsdt. Don't know about database considerations. And whether we'd actually want them.",
    "mentions": []
  },
  "signature": "tCoHTmlT88+T7TV1h0q9kjc8OGDtjcFRot41XqSHiXGFdQNqQRpL3GOesiG8vR+p523QGi7Z1T2bGJxhcOw3Cg==.sig.ed25519"
}

{
  "previous": "%kXrRuCJFJlKoylDvStKuwbDrar9bIdsX3t+hNqp82bg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 912,
  "timestamp": 1535541931820,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-clients",
    "vote": {
      "link": "%9VJBZ8q2Ghe4DPu1oap/3K4M8WNYV7IqehLMMnT89do=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "1IUqRHu+kr0kh8F8Qj/rCkptBW1Cx32mBQ0jA7gXDq6dpaoQSg8bQjZ8p09P4Ymi6wCvVtmd4m25WlczFbpgAA==.sig.ed25519"
}

{
  "previous": "%TDswOwKeSLChymt5GM8Lnz5Fgiz4IOPra18kVkjytGU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 913,
  "timestamp": 1535557025036,
  "hash": "sha256",
  "content": {
    "type": "post",
    "text": "# Reachability in Databases\n\nForking [this post](%IMrc+w6bSROTJzdlNpMhKcGc30wt4auwlN5/vC3gw34=.sha256) about a database that allows efficient querying of the causal order of ssb messages to not derail the thread.\n\n[@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519):\n> SQUEEE!!!\n\nIndeed.\n\n- - -\n\n**TLDR**: Building a database that supports querying the causal order is not trivial, but possible.\n\nContext: The discussion about removing mandatory timestamps from ssb messages has led us to the realization that we'd need the database layer to support efficient queries about the causal order of messages, i.e. whether some message is cryptographically guaranteed to be older than some other message. The causal order is determined by cypherlinks: If msg1 refers to the hash of msg2, it must be newer. We can treat the messages as the vertices of a graph, and cypherlinks as directed edges. The transitive closure of the edge relation (aka the reachability relation) is the causal order we are interested in. When asking whether some msg x is newer than another msg y, we are asking \"Is there a directed path from x to y?\".\n\nThis is a well-studied problem in database theory and implementation. As a theoretical introduction I'd recommend [this summary](http://delivery.acm.org/10.1145/300000/298576/p230-yannakakis.pdf), but it lacks any newer results (published 1990). For an overview of the current state of the art, I recommend the related-work section of [this paper](http://delivery.acm.org/10.1145/2220000/2213856/p169-jin.pdf). But here is a summary of the basics, for your convenience.\n\nAll solutions to reachability query have to balance out three factors: Time complexity of query processing, space complexity of database indices, and time complexity of creating those indices. The two trivial solutions are:\n\n - not storing any indices, perform a depth-first search on the graph to answer a query. Query time is then linear in the number of vertices. This is not acceptable for ssb.\n - store the full reachability relation in indices. Query time is then logarithmic in the number of messages (or constant in the average case by using hash tables). This however requires storage space quadratic in the number of messages. This might be sufficient to test out how ssb without timestamps could work, but it is not acceptable in the long run.\n\nThe paper I linked to does a good job of roughly sketching the known approaches to interpolate between these two extremes, so I won't go into all of these. The gist is: They are good enough, and they get implemented in real databases. But there are a few ssb-specific properties we could use to obtain even better solutions:\n\nWe'd want efficient incremental updating of the indices, we can't recompute all indices from scratch whenever a message arrives. Luckily, we rarely lose edges or vertices from the message graph (only in the case of blocking). And we never add arbitrary edges, we only need to handle adding a single vertex and its outgoing edges (i.e. receiving a new message). These properties should allow us to find more efficient solutions than the general case. N.B: I did not find any literature on incrementally maintaining the reachability indices in general, so I did not find any on append-only databases in particular either.\n\nWe know that some subset of messages are in a total order, namely the messages from the same feed. No message is in more than one of these total orders. This allows a compact representation of reachability information that only takes up `O(n log n)` space: sequence numbers. Incrementally updating those takes constant time as well. These can be used to derive new algorithm from those for arbitrary dags. I also like how this implies that a sophisticated ssb database will always store sequence numbers explicitly, even if they are not part of the metadata.\n\nSome further observations: The message graphs ssb produces will be fairly sparse for the most part. That's good, the heuristics in the literature work well on sparse graphs. Theoretically, we even have graphs of bounded degree, because there's a message size limit. So in theory, there might be some funky [fpt algorithm](https://en.wikipedia.org/wiki/Parameterized_complexity). In practice, you can fit too many cypherlinks into a single message for that to actually matter.",
    "mentions": [
      {
        "link": "%IMrc+w6bSROTJzdlNpMhKcGc30wt4auwlN5/vC3gw34=.sha256",
        "name": "this post"
      },
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      }
    ]
  },
  "signature": "h1EnF0Zy4x12H1TmDGGuTWY/A4mjqTinjggnrkca4a9f5NZEiad8pSMZbXtEENK4eAGouArekaWscwnIk/qNBQ==.sig.ed25519"
}

{
  "previous": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 914,
  "timestamp": 1535622930469,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "go-ssb",
    "vote": {
      "link": "%eRGJb+Y0m/i0nbeUnRJr18xhC3b4nPJvDt0JvbwKx2w=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "YA928CNP8nvw9IMk1HlFhH5tdp6aSUtlO0MrdmiZgCRYpgukmbzpste/sBpJvduL42/b6+In7dirmm7tV3YwDQ==.sig.ed25519"
}

{
  "previous": "%sJ7jtmARffSF0k8VPaRSZHWtjIw9jb21I9ULxwn1WoQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 915,
  "timestamp": 1535627069041,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%Pi1jyjH+tXKgij+4a9wADb6qLPgXSczjgZnvxTCRy74=.sha256",
    "reply": {
      "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%Pi1jyjH+tXKgij+4a9wADb6qLPgXSczjgZnvxTCRy74=.sha256": "@IgYpd+tCtXnlE2tYX/8rR2AGt+P8svC98WH3MdYAa8Y=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@elavoie](@IgYpd+tCtXnlE2tYX/8rR2AGt+P8svC98WH3MdYAa8Y=.ed25519):\n\n> [...] I am really excited by the research prospects here.\n\nThis is funny, for me this is one of the areas of CS I try to avoid as much as possible. Too many heuristics, too much dependence on real-world caching behavior, too many trade-offs between time and space complexity. As fascinating as algorithmics are, I tend to back off once too many unclear tradeoffs have to be made. Oh, and everything that has to deal with file systems usually turns out to be rather unpleasant.\n\nA really serious implementation attempt at an ssb-specific database would be some sort of append-only schemaless graph database. Being append-only is super useful, but schemalessnes and supporting arbitrary graphs are both really painful to get efficient.\n\n- - -\n\n[@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) Feel free to ask about anything you'd like me to explain in less computer sciency jargon. I'm just defaulting to it, because it is the most compact way of getting these notes out.\n\nFor boring ssb, or just for experimenting, you might want to look at graph databases. There are a lot of implementations for [rdf data](https://en.wikipedia.org/wiki/Resource_Description_Framework), and [SPARQL queries](https://en.wikipedia.org/wiki/SPARQL) are relatively easy to get into. Rdf is ([somewhat](https://stackoverflow.com/questions/33865718/why-is-rdf-considered-schemaless)) schemaless, so it might be the closest \"real-world\" thing to ssb where we could benefit from lots of previous engineering. I did not find any serious attempts at or information on append-only implementations, only [this abandoned and unused one](https://github.com/kasei/GTWAOF).\n\n> Assume that the sorting algorithm will be almost always be given data that's already sorted as we'll already have a partial ordering from the last time it was sorted\n\nThe problem with this is that we don't want to store the complete partial order, as that requires too much space (num_msgs ^ 2). So all scalable approaches involve some form of compression ((usually) not by running a literal data compression algorithm, but by carefully deciding which parts of the partial order to store, at which ones to recompute on the fly). A new run of the algorithm would need to recompute which parts to store and which parts to drop. So in general, this approach does not really work.\n\nFor (initial implementations for) ssb, it might be performant enough to naively store the whole partial order, in which case your observations do apply.\n\nAn ssb-specific representation can use the total order on messages from a single feed for some optiizations. Answering a reachability query \"did msg1 happen after msg2\" can be though of as trying to find a path to `msg2.feed`, that reaches that feed at a sequence number `>= msg2.sequencce_number`. This still leaves enough problems to require a fairly general solution (intuitively, you might have to hop along many feeds before you reach the correct one, and when trying to find it, you do not know which other feed to hop to). But it might turn out that the average query on ssb databases can benefit a lot from out structual knowledge of the graph, even if technically it isn't in any graph class that guarantees better algorithms.\n\nWhen considering links between two feeds `A` and `B`, we do not even need to store all links. E.g. if message number 0 from feed A (let's write this as `A::0`) links to `B::2` and `A::1` links to `B::1`, we can drop the latter information. So we are not even storing the original edge set in the graph used for reachability queries, but a subset of it that has the same transitive closure (i.e. following all cypherlinks still leads to the same partial reachablity order). In some sense this means approximating the [transitive reduction](https://en.wikipedia.org/wiki/Transitive_reduction) (exact computation of it is infeasible in our context). This does not give us any [\"hard\"](https://en.wikipedia.org/wiki/Big_O_notation) improvements, but it is very cheap and will improve the situation in practice. We might as well use any structural knowledge about the message graph that we have. And the partition of the vertex set into disjunct total orders (i.e. feeds) is super useful for optimizations.\n\n- - -\n\n[@moid](@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519):\n\n> This is the hard part , the incremental update.\n\nYes, and it seems to be completely underresearched. Which strikes me as odd, don't real-world databases get updated from time to time? Well, it might also signal that this is really, really hard.\n\nMany approaches do something like \"let's encode all information in a matrix and then do a bunch of multiplications\", which is about as unincremental as it gets. So I fear incremental updates will involve a bunch of heuristics. But being append-only (periodically running garbage collection on blocked feeds should allow us to disregard the fact that technically there may be deletion of vertices) and having the partition into feeds makes me optimistic that a solution can be found. I just don't really want to be the person to look for it.\n\nI'm sorry about the paywalled links, I wrote this from univerity and didn't realize these were not open access. Here are open links:\n\n- the [theoretical overview](https://www.researchgate.net/profile/Mihalis_Yannakakis/publication/221559463_Graph-Theoretic_Methods_in_Database_Theory/links/57adf07e08ae15c76cb34ccf/Graph-Theoretic-Methods-in-Database-Theory.pdf?origin=publication_detail)\n- the [(somewhat) current state of the art with a related-work section that cites a lot of other interesting papers](http://www.cs.albany.edu/~jhh/courses/readings/jin.reachability.sigmod12.pdf)\n\n- - -\n\nWhile searching for these, I found [this paper](http://www.cs.rpi.edu/~zaki/PaperDir/DAGGER.pdf), which seems to deal with dynamic graphs specifically. Adding it to my reading list.",
    "mentions": [
      {
        "link": "@IgYpd+tCtXnlE2tYX/8rR2AGt+P8svC98WH3MdYAa8Y=.ed25519",
        "name": "elavoie"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
        "name": "moid"
      }
    ]
  },
  "signature": "ypgYT2cgMq4Aad4twfQCmFV5mlNzL6fCaFVc5Yxf6bdEz8ZvmVCj7OWnZA13k6oou3LgPGDRtdyIdB1olg4+AA==.sig.ed25519"
}

{
  "previous": "%SZzAqMDv1lqh0fo8CeWITAsp2QAozYDxz9HZA298Y8s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 916,
  "timestamp": 1535627700354,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%SZzAqMDv1lqh0fo8CeWITAsp2QAozYDxz9HZA298Y8s=.sha256",
    "reply": {
      "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%SZzAqMDv1lqh0fo8CeWITAsp2QAozYDxz9HZA298Y8s=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "And another paper for graphs that get updated: [SCISSOR](https://www.deepdyve.com/lp/association-for-computing-machinery/scissor-scalable-and-efficient-reachability-query-processing-in-time-w0axNUk8SQ) (didn't read it yet)",
    "mentions": []
  },
  "signature": "f4S/WGASZAwsN0fDgfpbRWbPRmwXhKJgvBmUH8v453x+x2elrk/OkJZrhRUjLd07jubqDv3/yQyIdadWaFDjDg==.sig.ed25519"
}

{
  "previous": "%20YTYK97A3MojxoDHD3kgHh2Zj1Dy7EF3NjlCXY54GA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 917,
  "timestamp": 1535630343991,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256",
    "branch": "%9VJBZ8q2Ghe4DPu1oap/3K4M8WNYV7IqehLMMnT89do=.sha256",
    "reply": {
      "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%9VJBZ8q2Ghe4DPu1oap/3K4M8WNYV7IqehLMMnT89do=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "Unless I missed anything, [this](%76QoBmeB07QADgIX+LFNLOfz8KSOlkTFSJ+SVw+/DsQ=.sha256) means that the server-to-server communication only relies on sequence numbers, and is not even aware of timestamps. So optional or removed timestamps will not directly effect the non-implementation-specific rpcs. That's pretty great.\n\nTODO: At some point, #somebodyshould clearly document the boundary between server-to-server and server-to-client communication. This is exactly what implementors need to know to get a minimum viable pub working.\n\n[@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519):\n> we don't find a performant way to do causal queries, which <opinion>forces use to defer removing timstamps / branch</opinion>\n\nI tentatively agree with that opinion. But what about making timestamps optional? How would you feel about optional timestamps without support for causal queries (yet)? Because it looks like the whole [database reachability thing](%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256) will be difficult enough to push into a later update. ",
    "mentions": [
      {
        "link": "%76QoBmeB07QADgIX+LFNLOfz8KSOlkTFSJ+SVw+/DsQ=.sha256",
        "name": "this"
      },
      {
        "link": "#somebodyshould"
      },
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
        "name": "database reachability thing"
      }
    ]
  },
  "signature": "UR0qaiZvYOX0TzX6Ba+PDk9fZjQfcICwrKBWfq3jdThIRvntGmZ2mjYlsmw0p3DJMPTMfhxHxsZEeyWsc1+YBg==.sig.ed25519"
}

{
  "previous": "%9nXDPTcYpm5U/h1Eq/0pG88Xh6iUDb7LM4nvoOT/ork=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 918,
  "timestamp": 1535630729067,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%fzInqqvna35/f835uXQ2QqKkxdCGqwH1EaLo2Fr73YU=.sha256",
    "reply": {
      "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%fzInqqvna35/f835uXQ2QqKkxdCGqwH1EaLo2Fr73YU=.sha256": "@uOReuhnb9+mPi5RnTbKMKRr3r87cK+aOg8lFXV/SBPU=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Jan van Brügge](@ZdKcwA/aQ96HRzvD7hyAMmsSzXx5kGzWRBbZJnNkXKI=.ed25519) [@cryptixInTheCloud](@uOReuhnb9+mPi5RnTbKMKRr3r87cK+aOg8lFXV/SBPU=.ed25519)\n\nTheoretically, there could be a server implementation that allows applications to define schemas up front, and that could use those for better database performance. But this is a whole other can of worms with its own set of problems.\n\nBut fundamentally, all apps need to work with free-form data. This is deeply ingrained in the values of ssb, because data is not tied to any applications. You can freely write your own programs that built upon the data already there, and there is no application lock-in.\n\nAlso note that we are currently considering to [extend](%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256) the set of values that can be stored, so thinking of it as just json will not be sufficient any longer.",
    "mentions": [
      {
        "link": "@ZdKcwA/aQ96HRzvD7hyAMmsSzXx5kGzWRBbZJnNkXKI=.ed25519",
        "name": "Jan van Brügge"
      },
      {
        "link": "@uOReuhnb9+mPi5RnTbKMKRr3r87cK+aOg8lFXV/SBPU=.ed25519",
        "name": "cryptixInTheCloud"
      },
      {
        "link": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
        "name": "extend"
      }
    ]
  },
  "signature": "2ma+0A/YLXfk/fT4/Tt0IbbVEr0RxOgy/T0HBr4cYceLBxsn3Kmold/Klu8PkiwAWiwP0B3GlJQon2Zl0vGEBA==.sig.ed25519"
}

{
  "previous": "%kjB05XmeipfsNZi7wFLEo6SrNB2F7l72MXDY8jUNf3A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 919,
  "timestamp": 1535637556447,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%LamCHQZ11uH6FYNKxH5UkZiCeTFzytRn9BbC82YwjFs=.sha256",
    "reply": {
      "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%LamCHQZ11uH6FYNKxH5UkZiCeTFzytRn9BbC82YwjFs=.sha256": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "More random notes:\n\nThe problems Dominic encountered when trying to [dynamically update the friends graph](%FOyO23xiOfbavyD5a8+KE2f5ZuU1bY/ko4dLRdCUpr4=.sha256) are related to those discussed here, whom to replicate can be reframed as reachability over paths of bounded length (which should be easier to answer than general reachability, since the length reduces the search space).\n\n[This paper](http://wwwconference.org/www2008/papers/pdf/p845-bramandia.pdf) discusses dynamic updates to a label-based index approach. Almost all complications stem from node delition problems - which we don't have in an append-only database. We also only add outgoing edges from a newly added vertec, but never incoming edges to a newly added vertex, and never edges between preexisting vertices. The latter is the most complicated case, but we get to ignore it. **So this paper hides - in a lot of noise we are free to ignore - a scheme for incrementally updating (2-hop label based) reachability indices in an append-only, acyclic db.** So apparently (cc [@moid](@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519)) this is not as big a problem as we feared.\n\n[This paper](https://domino.mpi-inf.mpg.de/intranet/ag5/ag5publ.nsf/db686c64d01079eac125614500594fe7/b78fbbcd4fb923dbc1256f0f001932d7/$FILE/SchenkelTW05.pdf) (\"Efficient Creation and Incremental Maintenance of the HOPI Index for Complex XML Document Collections\") describes how to include distances in the indices, which might be helpful for scalable computation of whom to replicate\n\nIf we want to incrementally support vertex deletion (i.e. blocking), these papers describe a method, but they come at the cost of larger indices. Since keeping reachability information from a blocked feed in the graph does not hurt (it will only improve the partial order), I suspect assuming an append-only model and doing the occasional cleanup recomputation is the better solution.\n\nCypherlinks always form (directed) *acyclic* graphs, which spares us some trouble, as that is what all of these algorithms assume as inputs. For the purpose of reachability computation, arbitrary directed graphs can be converted into equivalent dags. But in a dynamic setting, keeping that representation up to date is not trivial ([though possible](http://www.cs.rpi.edu/~zaki/PaperDir/DAGGER.pdf)).",
    "mentions": [
      {
        "link": "%FOyO23xiOfbavyD5a8+KE2f5ZuU1bY/ko4dLRdCUpr4=.sha256",
        "name": "dynamically update the friends graph"
      },
      {
        "link": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
        "name": "moid"
      }
    ]
  },
  "signature": "1jwQtmsC51YQkBcEjTPIb2atwl7E8Ad3KyybB9f7ThVdu4+KEk4d6oIxvVteeXXfgY7lCfzaMcS0epwISkEWAA==.sig.ed25519"
}

{
  "previous": "%Q3T7XeYjJEmlKpKxQIjtdvSSve0bQ1UiTkDG4uQZffE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 920,
  "timestamp": 1535639370824,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%XSNrNNZC5WMffylldE0Jzv7a6BFi2oh11SpquNr2nZU=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "5zi5oSU7CRegHXYYeFda4Lq2jXuSUm1LaV/f+Xi60kNjoiANQd9DtnUCQP6JDTB+aUM2c6hrPsXRFmzo0k14CA==.sig.ed25519"
}

{
  "previous": "%wo/R9YJQ93OO9gkAmIHGx4K6JFf2rRZyZcCMeN+wnVI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 921,
  "timestamp": 1535709792541,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256",
    "branch": "%G2knE02fQ889STwkAn5tEAGrcf13H36D5MP/KAzL0Mk=.sha256",
    "reply": {
      "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
      "%G2knE02fQ889STwkAn5tEAGrcf13H36D5MP/KAzL0Mk=.sha256": "@dBQlwh9Gtr3i5YMOGtIOKtGNVepeu+nyb6KGl1vtOcM=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) Your post triggered a surprisingly strong reaction in me, it made me angry. I've had an hour to cool down, but there's still some anger left, so I'm just going to channel it into this response rather than ignoring it. This post might turn out rather harsh.\n\nBoring scuttlebutt, almost by definition, choses easyness over simplicity. Ever looked at what it takes to implement TLS? It is *not* simple, but there happen to lie some implementations around, so it is easy. Well, until you need to obtain a certificate, and create some obscure manifest files. Ok, most of that is automated away. Which again makes it easy, but not at all simple. You are depending on an obscene amount of code to get encryption, all of which can break and costs resources. Guess what: [this](https://github.com/AljoschaMeyer/shs1-crypto-js) (go skim the code, it is almost trivial. Port it to C, done.) and [this](https://download.libsodium.org/doc/secret-key_cryptography/secretstream) also works. That is simplicity. Well, Dominic's secret-stream module is even simpler than the libsodium one, but both require orders of magnitude less code and coordination than TLS.\n\nSsb fundamentally chose simplicity in some areas (such as encryption), it just spectacularily failed to uphold it in other areas. And the interdependence of different parts of the js implementation is indeed not pretty.\n\nIf we want decentralized protocols to replace centralized structures, we need every advantage we can get. And since we are starting from scratch anyways, we might as well get the fundamentals right, rather then going down the easy path and creating REST APIs.\n\n*A short aside*:\n\nI just searched for a link to an [article about json](http://seriot.ch/parsing_json.php), and found it on hackernews. The first comment says \"Well, first and most obviously, if you are thinking of rolling your own JSON parser, stop and seek medical attention.\". So apparently, decoding your transport format is *\"obviously\"* such a complex task that no mere mortal should attempt to do it themselves. Seriously? You can implement a basic parser for the json-equivalent cbor subset in a few hours. Need a really robust implementation? Handle OOM gracefully, make it a state-based LL1 parser for efficiency, move recursion into a heap-allocated datastructure to prevent stack overflow on maliciously nested input, and make sure not to allocate too much memory just because the input claims it needs that much. You can do that in a couple of days. Run a fuzzer and use valgrind. None of this is black magic. The only thing you need to do is *not using json in the first place*. Nobody forces you to use it, yet almost everyone defaults to it. This widespread incompetence and failure to consider the consequences of choices is maddening.\n\n*End the aside*\n\nBack to the simplicity of decentralized protocols. By not going down the easy path, we can improve performance so much, that users will be able to feel it. Facebook sends [json](https://en.wikipedia.org/wiki/JSON) over [graphql](https://en.wikipedia.org/wiki/GraphQL) over [websocket](https://en.wikipedia.org/wiki/WebSocket) over [https/2](https://en.wikipedia.org/wiki/HTTP/2) over [tls](https://en.wikipedia.org/wiki/Transport_Layer_Security) over [tcp](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) over [ip](https://en.wikipedia.org/wiki/Internet_Protocol). Now compare that to sending a [subset of cbor](%jt11rmbFmkR6tGQJDm99I4Z939Q2b0LmZCpkiOke/A0=.sha256) over a [binary, datagram based multiplexing protocol](%ScgGMfSbd4WXBtH7ry+pjaaxMFF4GRMdf5ddWdM/uE0=.sha256) (think [dccp](https://en.wikipedia.org/wiki/Datagram_Congestion_Control_Protocol) with a few bytes of overhead (except due to cjdns we have stronger trust in the transport layer end thus end up with *less* overhead than dccp)) over [cjdns](https://github.com/cjdelisle/cjdns/). It is absolutely ridiculous how much unnecessary work is done in current mainstream stacks, and how many computanional resources and how much bandwidth is wasted because of that. And I'm not even talking about the various points of centralization in the traditional stack. Now ssb aims at mainstream adoption, so it'll have to run secret-stream over tcp over ip at the end of the network stack. But still, the result is going to be much more simple than traditional approaches.\n\nLet us face it, both the current ssb protocol and its current js implementation are a total mess, albeit a mess brimming with potential. But the though of \"fixing\" things by migrating to the easy, near-at-hand, complete desaster of a default stack, when there is so much potential for true improvement, is appalling to me.",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "%jt11rmbFmkR6tGQJDm99I4Z939Q2b0LmZCpkiOke/A0=.sha256",
        "name": "subset of cbor"
      },
      {
        "link": "%ScgGMfSbd4WXBtH7ry+pjaaxMFF4GRMdf5ddWdM/uE0=.sha256",
        "name": "binary, datagram based multiplexing protocol"
      }
    ]
  },
  "signature": "pCkB6kg6N05IcW/sjuxZJ+DqQu0rLYrV8Iw/nHuvMW3ddghRNkLDmmC72EDbBL6deTZuZbPVspW9cW53YIASAg==.sig.ed25519"
}

{
  "previous": "%GMMeHxGQarSUD0XBSz2dtbnrFGaKy12nJ29XXGr/B6Y=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 922,
  "timestamp": 1535711667517,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256",
    "branch": "%Fi8DJOqej7q09SYyf00XX8y6PAin/oj3hnN+Bi6dUws=.sha256",
    "reply": {
      "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
      "%Fi8DJOqej7q09SYyf00XX8y6PAin/oj3hnN+Bi6dUws=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) The aside was just me ranting about that fact that many people assume that encoding and decoding information is inherently complex, just because they are used to json. Whereas for a simple format, implementing an encoder and decoder should not take that much time. Even if it has to be a high-quality one, it is still doable with a reasonable amount of effort. And don't even get me started that almost all remaining complexity stems from choosing a self-describing, schemaless data format, even in cases where there actually is a clear schema.\n\nI don't know a lot about encryption either, just the basic properties provided by a few cryptographic primitives. As far as I know, Dominic and [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) are the people to ask on this stuff. If I remember correctly, keks has previously pointed out that shs is overly bulky for the guarantees it aims to deliver. Shs does have stronger guarantees regarding anonymity than tls btw. The client only needs to reveal its longterm identity once the server has proven its own longterm identity. I think you don't get that with tls, but I didn't check.",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      }
    ]
  },
  "signature": "9c3jqsJXZnuA1tvbv619d7RjsWOg2vgq9px1Js8BoyMEe93GAKDpr/sa/2qp5BSQk9/FVAjft1Tksbs3PsjMDQ==.sig.ed25519"
}

{
  "previous": "%fUcOWV0p4NtfEYwjiqZXOhtkJHeEG/Xjlt65YgOyO18=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 923,
  "timestamp": 1535712663320,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%XyoIXRMsltghbqxMTCkViFmnANBREMiVIriVO8pVfmg=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "FUvfOZr++t7VqyzNYof0QGmmFgjj7qSSMsG+f8YecaXYUlFrSJXWodGB3gQF3+C20nD7x6Ltb6yurnZPc012BQ==.sig.ed25519"
}

{
  "previous": "%K6rMbtP6c9yAgWfy1Iyqi249qckhicMs4r170NC7GWE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 924,
  "timestamp": 1535713746277,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256",
    "branch": "%bxliFX0Pwf3+8kJsAuu5ye5kTriArl9ME14IBJDeDrc=.sha256",
    "reply": {
      "%bxliFX0Pwf3+8kJsAuu5ye5kTriArl9ME14IBJDeDrc=.sha256": "@22YV3HX/BGClXH49ZebkcepqRpj7a9f5s0ddwhDSfxk=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@juul](@22YV3HX/BGClXH49ZebkcepqRpj7a9f5s0ddwhDSfxk=.ed25519) Without the backlinks, the feed owner can send out different feeds to different people, and they can retroactively change their feed. The cryptographic backlinks are fundamentally needed for ssb.",
    "mentions": [
      {
        "link": "@22YV3HX/BGClXH49ZebkcepqRpj7a9f5s0ddwhDSfxk=.ed25519",
        "name": "juul"
      }
    ]
  },
  "signature": "D5o2leQMB4b4ehqS3On4dReNmNUg3Mh4wGQCBS15AXDi0t0aXVyxXG6bxjUJDcZjHfGkSEyWnVfgOsv/R1gZAQ==.sig.ed25519"
}

{
  "previous": "%jju98RlPEnAaBxctP2QniUIy8GQ39aN0BUPaVY5V96A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 925,
  "timestamp": 1535714319638,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256",
    "branch": "%2KEprellnYgd9RIRdc+auyKQlzbl/6AhN9bFJfO0hAw=.sha256",
    "reply": {
      "%2KEprellnYgd9RIRdc+auyKQlzbl/6AhN9bFJfO0hAw=.sha256": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) These are really expressive slides, good job. What kinda irks me is the conflation of social graph and network topology. The blue part is about edges in the network topology, not about the social graph. The current implementation happens to map these somewhat closely upon another, but that isn't the only choice. You might as well define rpcs for running ssb on a random overlay gossip network with a dht for blobs and ooo. The protocol core is flexible enough to allow that.",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "cmR4Bqs7wAv9onDRExJyn7IS5YHr0S7frvJKRPHSysK7Ps4N2dwiTNwydbMvmKSi6IqZKE4OPcyqQwyPBTKLBw==.sig.ed25519"
}

{
  "previous": "%1xUOuDporcTRB7phzqlXSEfAWXvYjCIWzXGAesv+TF4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 926,
  "timestamp": 1535715937290,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256",
    "branch": "%NRzSfiekIslm7ne/I9CaXoFdoo/Cpa235iyqOrjb3lc=.sha256",
    "reply": {
      "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
      "%NRzSfiekIslm7ne/I9CaXoFdoo/Cpa235iyqOrjb3lc=.sha256": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) There's a whole conversation to be had there, whether the friend graph really creates a good topology. You can expect a bunch of cliques in the friend graph, but graphs with many cliques are prone to partitions in unreliable networks (commonly abbreviated as \"networks\"). A randomly created small-world network would be more resilient and increases the probability of data reaching everyone. Something like follower-graph based [VICINITY](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.148.3839&rep=rep1&type=pdf#chapter.144) (Warning: link to a specific section of a 200 page phd thesis. The whole thing is a great introduction for anyone who wants to get into the details of replication strategies.) over a random overlay would probably give better and more resilient results than purely relying on the social graph. Also there is the inherent mismatch between bidirectional network links and unidirectional feed subscriptions.\n\nBut let's not get into that full discussion right now, or at least not in this thread.",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "CKQncsWI517JuBerfUa1M7qfZFGt8Q2PQ3YLHvWbCkm+I6sinbXsf6b+Si+m8Ks95AT2e4BdnegN0zm0/jmwDQ==.sig.ed25519"
}

{
  "previous": "%aN5/REsZ1MfcrF8Hm6p60EJNzFR45J2xihYoCBKdq30=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 927,
  "timestamp": 1535717817390,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256",
    "branch": [
      "%GLU2h+114mXqWPm3/aURlqPKd07AQskwzWWSNQCokFA=.sha256",
      "%wvfvXjRiXe5ALdYHQi8cMwIEuC+TqJVTWrc4ezyavJU=.sha256"
    ],
    "reply": {
      "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
      "%GLU2h+114mXqWPm3/aURlqPKd07AQskwzWWSNQCokFA=.sha256": "@RtsOc2h1gqh0fRrjrUTHAkRBu9YyDgsD+EWsfLpykrc=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@juul](@22YV3HX/BGClXH49ZebkcepqRpj7a9f5s0ddwhDSfxk=.ed25519)\n> Retroactively changing your feed might be a feature, not a bug.\n\nRetroactive changes lead to inconsistencies in the local copies of different feeds. Currently a local database can be \"outdated\", but that's it. It is easy to reason about when designing apps, and easy to check for when gossiping. But with a retroactively changed feed, how do you know which of two disagreeing local copies is the \"one and only true\" version? How do apps deal with the fact that two clients may see completely unrelated datasets?\n\nI'm not saying there are no solutions to these problems, but simply dropping backlinks without introducing other coping mechanisms won't work. And the result wouldn't be called scuttlebutt anymore. ",
    "mentions": [
      {
        "link": "@22YV3HX/BGClXH49ZebkcepqRpj7a9f5s0ddwhDSfxk=.ed25519",
        "name": "juul"
      }
    ]
  },
  "signature": "qcrAExxUd7nOk9hVdfUZr+QViX99iwXVqmF2hIfGwuJ6apm/q/nwUdpiomRvw6GwurigcFI6qIvntPNUTD4RDA==.sig.ed25519"
}

{
  "previous": "%sYQM1hj91Rvc9C1ihXFkKTApX+/CltDHfPLgJpmkJyA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 928,
  "timestamp": 1535717879164,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%GLU2h+114mXqWPm3/aURlqPKd07AQskwzWWSNQCokFA=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "Ml1As3zfUuMHgsN5Cc/2OgrHv69wUvtCxDWX7ooFG1+VJ5PTmcB5jVJ1O+Ncfj8dkKKlJCjwUZ7Ty2F7VpbVCQ==.sig.ed25519"
}

{
  "previous": "%woojg3aB5XAdmf1P+KUmrWpiNBejLXw29lreEqtrxwQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 929,
  "timestamp": 1535717888032,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%OprLZOb/I90meahJJJJ/LipCSdjfB4xY212yQIYrbk8=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "xwcht1jaNkh3CBr6iu3ub2VkKKdl4ibAsHjFTuwhkBwYzuU4UURkr7S7mvipkkBmFdem0ztW2JXudKPeQs5NDQ==.sig.ed25519"
}

{
  "previous": "%Z00aytqpvpUl90PdVWb9A0IWrrjrKrW6zK/uvnHft3c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 930,
  "timestamp": 1535719035906,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%oCP+Z9HLpAD+tOz2T5kW9QBzeZwIgExTgHEjSVRNi4k=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "ZwR4K1gxeAeOt2KTnFYeJZZPV9VhDeb+YrlzS5dBmJmPJRbVyvfRxtSbKJ4o3bhtFxlM2Q58xLPId8YQXYfMCg==.sig.ed25519"
}

{
  "previous": "%OTB8jkc7mgmHtMeFn8aBb3LZlRl8HTcDT+eXe7UWmqg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 931,
  "timestamp": 1535719840625,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256",
    "branch": "%DxWlJlfqnhCMIK4Fqg75Qgd/10ZNr0gKfgwOvDs5UpE=.sha256",
    "reply": {
      "%GQyu9Sz1+UeC98CICYv10lH+Gf0Ai0qKDRSEluztvaU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%DxWlJlfqnhCMIK4Fqg75Qgd/10ZNr0gKfgwOvDs5UpE=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "[@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) The minimum change would probably be to just ignore all messages without a timestamp. This reworking would then consist of finding all places where things would break without timestamps, and dropping the message instead of handling it. Anything more advanced is completely optional.\n\nDo you have any preference on how ssb-client-js should signal an omitted timestamp? I currently see two reasonable approaches, either completely removing the `\"timestamp\"` key from all message objects without a timestamp, or keeping the key but setting the value to `NaN`. Any thoughts on what would make client adaption easier?\n\nCC [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519), would you also be up for looking through the patchwork code base for places that break when timestamps are omitted or `NaN`?",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      }
    ]
  },
  "signature": "FMrqKpJaBOC1kYIVvbXB5TY4KtrRHTvydQDqEw4vu150C4jgZtT5nwbLr2Ki9YuTfCaLfLCKrmAaPMkvCMkQDw==.sig.ed25519"
}

{
  "previous": "%IIakMBOFpmcxyUDnwtHkrVa4uLU3x8JLkBLf4wgg7ik=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 932,
  "timestamp": 1535756764383,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "bpmux",
    "text": "I finally wrote up the abstract [bpmux interface](https://github.com/AljoschaMeyer/bpmux) for multiplexing, and [bpmux/rel](https://github.com/AljoschaMeyer/bpmux-rel), a concrete protocol for providing this interface over a reliable, ordered, bidirectional stream. In addition to the multiplexing features provided by [packet-stream](https://github.com/ssbc/packet-stream), bpmux has backpressure on all payload data, allows cancellation and closing of all logical channels, and supports heartbeats for the top-level connection, all logical streams, and requests. All of these are required for building robust distributed programs.\n\nThere have been multiple points where I found the potential for deadlocks or race conditions, but I hope I managed to eliminate all of those from bpmux/rel. I'd love some more pairs of eyes on this though, so here are the specs.\n\n# bpmux\n\nbpmux is a family of protocols for multiplexing messages, requests/responses and duplex streams over a single logical connection between to endpoints. It supports backpressure on all (non-meta) data, and it supports heartbeat pings (that can correctly [work over tcp](http://250bpm.com/blog:22)). Each protocol of the family implements the bpmux abstractions over a specific kind of connection (e.g. udp, dccp, sctp, reliable ordered connections like tcp, etc.).\n\n## Abstractions\n\nA *payload* is an arbitrary sequence of bytes, with any length between `0` and `2^64 -1` (inclusive). A *sink* is a logical channel a peer can send data to, a *stream* is a logical channel where it can receive data from. Most data is sent in the form of *messages*, which contain an arbitrary payload. All messages sent down the same sink are guaranteed to be received at the corresponding stream in the same order.\n\nThe *top-level* context of a bpmux connection is both a sink and a stream for both peers. In addition, it is possible for either peer to open up new streams (the other peer then gets a corresponding sink it can use to send data to the stream), to open up new sinks (the other peer then gets a corresponding stream it can use to receive data from the sink), or to open up new duplexes which serve as both a sink and a stream (the other peer gets a corresponding duplex as well). The opening of a new sink/stream/duplex carries an arbitrary payload.\n\nThe top-level also supports *request*/*response* pairs, other duplexes do not. A request consists of an arbitrary payload, the other peer can then send a response to it, again with an arbitrary payload. Unlike a simple exchange of messages, there is a one-to-one mapping between requests and the corresponding responses.\n\nRequests and streams support *cancellation*, i.e. notifying the peer that no more data is desired. A cancellation carries an arbitrary payload. Responses and sinks support *closing*, i.e. notifying the peer that no more data will be send. Closing carries an arbitrary payload. While not mandatory, it is often appropriate to consider cancellation/closing with a zero-length payload as normal termination, and to consider other payloads as error conditions.\n\nAny duplexes (including the top-level) support both cancellation and closing, these can be done independently. With a duplex, it is possible for one endpoint to cancel it and for the other to close it simultaneously. Applications built on bpmux should handle this gracefully. The same is true for requests/responses.\n\nAn implementation of the bpmux abstractions is free to place upper limits on the number of sinks, streams, duplexes and requests that can coexist at the same time. It is recommended to support at least `2^32 - 1` concurrent ones. If there is a limit, the programming interfaces should be able to signal when the limit is hit, and applications should correctly handle this case.\n\nAll sending of payloads is subject to *backpressure*, which is tracked on a per-stream basis (including the top-level). At any time, one peer can give some *credit* to a stream. Sending messages/requests/sink-cancellations down a sink consumes as much credit as the size of the payload. If the credit on a sink reaches zero, no more data can be sent to it, until the peer has given more credit to it. If a peer receives more data on a channel than it gave credit for, it must immediately close the connection.\n\nRequest-cancellations, Responses, creation of a sink/stream/duplex, closing of a response, and closing of a non-duplex stream consume top-level credit. Closing a duplex stream consumes credit on the corresponding sink.\n\nCommunication must work even if only a single byte of credit is given at once. Implementations of the bpmux abstract specification must thus include a mechanism to split up payloads into arbitrarily fine parts. Everything else would be prone to deadlocks.\n\nNote that credit-based backpressure only throttles payload data, not meta data (such as giving credit or the metadata necessary for splitting up payloads). Otherwise, there would be deadlocks where neither endpoint has enough credit to grant more credit to the other endpoint. The backpressure mechanism thus does not prevent a malicious peer from spamming the connection, e.g. by granting a lot of credit one byte at a time, or simply by sending an arbitrary number of zero-length messages. Dealing with malicious peers is out of scope for bpmux.\n\nFor any stream (including the top-level) and for any unanswered request, a peer may send a *heartbeat ping* at any time. The other peer should then respond with a corresponding *heartbeat pong*. If the heartbeat pong does not arrive after a sensible time, the stream/request can be considered broken. For resilience, implementations should still send a cancellation to a stream/request that has timed out. Heartbeats do not consume any credit.\n\n## Protocols Implementing the Abstractions\n\n- [bpmux-rel](https://github.com/AljoschaMeyer/bpmux-rel) (reliable, ordered, bidirectional communication channels)\n",
    "mentions": []
  },
  "signature": "LppxBMz8I76xtK6sDKVUzrfdL2X/x9iZ4hOGHOGG2aq6JdABjylbrDc5/OLgqiq8iM1Gy8Z/fj0z4bG08NgmCw==.sig.ed25519"
}

{
  "previous": "%UwYCEb0LdZymBz0llz+QcqXd004x800DHiWJiYy+P80=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 933,
  "timestamp": 1535756872755,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%UwYCEb0LdZymBz0llz+QcqXd004x800DHiWJiYy+P80=.sha256",
    "branch": "%UwYCEb0LdZymBz0llz+QcqXd004x800DHiWJiYy+P80=.sha256",
    "reply": {
      "%UwYCEb0LdZymBz0llz+QcqXd004x800DHiWJiYy+P80=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "bpmux",
    "recps": null,
    "text": "# bpmux/rel\n\nSpecification for providing the [bpmux abstractions](https://github.com/AljoschaMeyer/bpmux) over an ordered, reliable, bidirectional communication channel, such as tcp or unix domain sockets.\n\nbpmux/rel assigns and 32 bit ids to requests, sinks, streams and duplexes, so that payloads can be \"routed\" to the correct \"destination\". A single endpoint has full control over the ids it assigns, it does not need to take into account any ids that have been assigned by the other endpoint. The only requirements are:\n\n- An endpoint may not send a request with an id which has been used on a previous request from this endpoint that has been neither responded to, nor cancelled, nor closed.\n- An endpoint may not create a sink with an id of any other currently open sink/stream/duplex that has been opened by this endpoint.\n- The same holds for streams and duplexes.\n\nbpmux/rel transmits data in chunks. Each chunk is preceded by a tag that indicates how the following bytes are to be interpreted, and how many of the following bytes to interpret. The first four bits of the tag indicate its *type* (all types are listed in the following section). The remaining four bits are split up into the named arguments in the parentheses after the name of the type. Most of the time, these arguments do not store data, but only indicate how many of the following bytes contain the actual data.\n\nThere are various ways of sending invalid chunks, including but not limited to: Disrespecting the credit limit, responding to nonexistent requests, sending messages down nonexistent sinks, acknowledging nonexistent cancellations/closings, etc. A conforming implementation can not produce invalid chunks accidentally. Whenever an endpoint receives an invalid chunk, it should abort the connection (without signaling any errors or closing and cancelling the top-level).\n\nConceptually, each chunk maps to a concept from the bpmux specification. There are chunks to open sinks/streams/duplexes, there are chunks to send messages/requests/responses, there are chunks for giving credit and sending/answering heartbeat signals, and there are chunks to cancel and close things. To avoid id ambiguity, there are specialized chunks for dealing with sinks/streams created by this endpoint and for dealing with sinks/streams created by the peer. And finally, there is the need to acknowledge cancellations and closings to avoid race conditions.\n\nTo partition data into arbitrarily small batches, there is a mechanism to put any payload-carrying chunk into *partial* mode. When entering partial mode, the total size of the payload is specified. All further matching chunks then contribute to the payload until it has been fully sent, at which point partial mode is automatically disabled.\n\n## Chunk Types\n\n### `Sink(id: uint2_t, len: uint2_t)`, type nibble: 10 (`0b1010`)\n\nOpen up a new sink.\n\nIf `id != 3`, the `2 ^ id` bytes following the tag are an integer that serves as the id of the sink.\n\nThe `2 ^ len` bytes following the sink id bytes are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much top-level credit.\n\nIf `sink == 3`, the chunk acknowledges a cancellation on a stream opened by the peer. The `2 ^ len` bytes following the tag specify the id of the stream on which to acknowledge the cancellation. `len` may not be 3.\n\n### `Stream(id: uint2_t, len: uint2_t)`, type nibble: 11 (`0b1011`)\n\nOpen up a new stream.\n\nIf `id != 3`, the `2 ^ id` bytes following the tag are an integer that serves as the id of the stream.\n\nThe `2 ^ len` bytes following the stream id bytes are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much top-level credit.\n\nIf `stream == 3`, the chunk acknowledges the closing of a sink opened by the peer. The `2 ^ len` bytes following the tag specify the id of the sink on which to acknowledge the closing. `len` may not be 3.\n\n### `Duplex(id: uint2_t, len: unint2_t)`, type nibble: 12 (`0b1100`)\n\nOpen up a new duplex.\n\nIf `id != 3`, the `2 ^ id` bytes following the tag are an integer that serves as the id of the duplex.\n\nThe `2 ^ len` bytes following the duplex id bytes are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much top-level credit.\n\nIf `id == 3`, the chunk is a heartbeat ping for a request. The `len ^ 2` bytes following the tag specify the id of the request for which to send the ping. `len` may not be 3.\n\n### `Msg(sink: uint2_t, len: uint2_t)`, type nibble: 6 (`0b0110`)\n\nSend a message down a sink that was opened by this endpoint (or the top-level).\n\nIf `sink == 3`, send the message to the top-level. Else, the `2 ^ sink` bytes following the tag are an integer specifying which sink to send the message to.\n\nThe `2 ^ len` bytes following the sink id bytes (which may be zero bytes) are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much credit for the sink.\n\n### `Msg:Peer(sink: uint2_t, len: uint2_t)`, type nibble: 7 (`0b0111`)\n\nSend a message down a sink that was opened by the peer.\n\nIf `sink != 3`, this uses the same encoding as the regular `Msg` chunk.\n\nIf `id == 3`, the chunk is a heartbeat pong for a request. The `len ^ 2` bytes following the tag specify the id of the request for which to send the pong. `len` may not be 3.\n\n### `Req(id: uint2_t, len: uint2_t)`, type nibble: 8 (`0b1000`)\n\nSend a request to the peer.\n\nThe `2 ^ id` bytes following the tag are an integer that serves as the id of the request.\n\nThe `2 ^ len` bytes following the request id bytes are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much top-level credit.\n\n### `Res(req: uint2_t, len: uint2_t)`, type nibble: 9 (`0b1001`)\n\nSend a response to a request.\n\nThe `2 ^ req` bytes following the tag are an integer specifying the id of the request you are responding to.\n\nThe `2 ^ len` bytes following the request id bytes are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much top-level credit.\n\n- - -\n*continued in next post*",
    "mentions": []
  },
  "signature": "xmA5Wv2060xE7hh/gKZiyk/Tvfs9v5RZkiadnJczaXMSxCljQvNvgpo6WgtzUJmfIqwfsB3uSB9Z6LLB0x+IAg==.sig.ed25519"
}

{
  "previous": "%EJ/JR51NhRyqcCuGvMXr17h2kx3EDshVKHEny83PCcg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 934,
  "timestamp": 1535756888227,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%UwYCEb0LdZymBz0llz+QcqXd004x800DHiWJiYy+P80=.sha256",
    "branch": "%EJ/JR51NhRyqcCuGvMXr17h2kx3EDshVKHEny83PCcg=.sha256",
    "reply": {
      "%EJ/JR51NhRyqcCuGvMXr17h2kx3EDshVKHEny83PCcg=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "bpmux",
    "recps": null,
    "text": "### `Credit(stream: uint2_t, amount: uint2_t)`, type nibble: 14 (`0b1110`)\n\nGive a certain amount of credit to a stream that was opened by this endpoint (or the top-level).\n\nIf `stream == 3`, give the credit to the top-level. Else, the `2 ^ stream` bytes following the tag are an integer specifying which stream to give the credit.\n\nThe `2 ^ amount` bytes following the stream id bytes (which may be zero bytes) are an unsigned integer indicating how much credit to give.\n\n### `Credit:Peer(stream: uint2_t, amount: uint2_t)`, type nibble: 15 (`0b1111`)\n\nGive a certain amount of credit to a stream that was opened by the peer.\n\nIf `stream != 3`, this uses the same encoding as the regular `Credit` chunk.\n\nIf `stream == 3`, the chunk activates partial mode for the next chunk following it. The `amount ^ 2` bytes following the tag specify the *total length* of the following payload.\n\nIf the next chunk is a `Msg` or `Msg:Peer` chunk, the sink on which the message is sent is put into partial mode. All message payloads on that sink are considered part of a single message's payload, until the *total length* has been reached. At that point, the sink switches back to normal operation.\n\nIf the next chunk is any other payload-carrying chunk, the entity specified by the combination of chunk type and id is put into partial mode, and all further chunks of matching type and id contribute to the payload, until the *total length* has been reached.\n\nFollowing the partial mode activation with a non-payload-carrying chunk is invalid. Writing partial payloads that exceed the *total length* is invalid.\n\n### `Cancel:Req(req: uint2_t, len: uint2_t)`, type nibble: 0 (`0b0000`)\n\nCancel a request that originated from this endpoint. Note that the endpoint issuing this chunk can not consider the request cancelled (for resource clean-up and id allocation) until it has received a confirmation from the peer. Otherwise, there would be race conditions with responses sent before the cancellation arrived. This note applies to all `Cancel` chunks.\n\nIf `req != 3`, the `2 ^ req` bytes following the tag are an integer specifying the id of the request you are cancelling.\n\nThe `2 ^ len` bytes following the request id bytes are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much top-level credit.\n\nIf `req == 3`, the chunk acknowledges the cancellation of a response previously awaited by the peer. The `2 ^ len` bytes following the tag specify the id of the request on which to acknowledge the cancellation. `len` may not be 3.\n\n### `Close:Res(req: uint2_t, len: uint2_t)`, type nibble: 1 (`0b0001`)\n\nClose the response to a request that originated from the peer. This signifies that no response will be sent to the request. Note that the endpoint issuing this chunk can not consider the response closed (for resource clean-up and id allocation) until it has received a confirmation from the peer. Otherwise, there would be race conditions with cancellations sent before the closing arrived. This note applies to all `Close` chunks.\n\nIf `req != 3`, the `2 ^ req` bytes following the tag are an integer specifying the id of the request whose response you are closing.\n\nThe `2 ^ len` bytes following the request id bytes are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much top-level credit.\n\nIf `req == 3`, the chunk acknowledges the closing of a request sent by this endpoint. The `2 ^ len` bytes following the tag specify the id of the request on which to acknowledge the closing. `len` may not be 3.\n\n### `Cancel:Stream(stream: uint2_t, len: uint2_t)`, type nibble: 2 (`0b0010`)\n\nCancel a stream that was opened by this endpoint (or the top-level).\n\nIf `stream == 3`, this cancels the top-level. Else, the `2 ^ stream` bytes following the tag specify the id of the stream to cancel.\n\nThe `2 ^ len` bytes following the stream id bytes are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much top-level credit.\n\n### `Cancel:Stream:Peer(stream: uint2_t, len: uint2_t)`, type nibble: 3 (`0b0011`)\n\nCancel a stream that was opened by the peer.\n\nIf `stream != 3`, this uses the same encoding as the regular `Cancel:Stream` chunk.\n\nIf `stream == 3`, the chunk acknowledges the closing of a sink opened by this endpoint. The `2 ^ len` bytes following the tag specify the id of the sink on which to acknowledge the closing. `len` may not be 3. Note that it is neither necessary nor possible to acknowledge the closing of the top-level.\n\n### `Close:Sink(sink: uint2_t, len: uint2_t)`, type nibble: 4 (`0b0100`)\n\nClose a sink that was opened by this endpoint (or the top-level).\n\nIf `sink == 3`, this cancels the top-level. Else, the `2 ^ sink` bytes following the tag specify the id of the stream to cancel.\n\nThe `2 ^ len` bytes following the sink id bytes are an unsigned integer indicating the length of the payload.\n\nAfter the `len` bytes, place that many bytes of payload. This consumes as much top-level credit.\n\n### `Close:Sink:Peer(sink: uint2_t, len: uint2_t)`, type nibble: 5 (`0b0101`)\n\nClose a sink that was opened by the peer.\n\nIf `sink != 3`, this uses the same encoding as the regular `Close:Sink` chunk.\n\nIf `sink == 3`, the chunk acknowledges a cancellation on a stream opened by this endpoint. The `2 ^ len` bytes following the tag specify the id of the stream on which to acknowledge the cancellation. `len` may not be 3. Note that it is neither necessary nor possible to acknowledge cancellation of the top-level.\n\n### `Hearbeat(pong: bool, peer: bool, stream: uint2_t)`, type nibble: 13 (`0b1101`)\n\nHandles heartbeats on streams. If `pong` is `0`, this is a ping, else a pong. If `peer` is `0`, `stream` refers to a stream opened by this endpoint, else `stream` refers to a stream opened by the peer.\n\nIf `sink == 3`, this refers to the top-level. Else, the `2 ^ sink` bytes following the tag specify the id of the stream to cancel.\n\nIf `peer` is `1`, `sink` may not be `3`.\n",
    "mentions": []
  },
  "signature": "GW6O5TCvARZAw07QDkw/qpUo/j0nQov2WIev9tHlRVIXPzMFNhNY/dWxgGdRx1AjL+HmLVyHB1E8VC3uLSpNAQ==.sig.ed25519"
}

{
  "previous": "%Qss9UHAeqL92K3NE9MJzwCvqi3lVzdd38K/SwvpsZS8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 935,
  "timestamp": 1535757578497,
  "hash": "sha256",
  "content": "RqDgDN1Ed4KP1CJLv/OUtao/usjgbgdez4zoXOSL3Lr1REx8MzrtAPnMsoAO7+XiLFOq5cMpZnPn19Tftl2pk2p0OjAFYaLT3xFobnzeR/a0Xj/MNIgTSn5Rt8LZ1/LmyQL2/MG88MljADs30eGl5haQcTJC7ttpmVRdjI3KRSqCXUwtBsWBf8g/EzUQR30H+AZYdvrMinPFmebKyrCgSc2jk4fYi/m9QndpNDaphtVsJimHRf/k5Oc1oVuiTUnDJyYcxRMpVdvHRWxhvhq2xqt3W78ewRzy5sGAZsTvTvRLU7JgWqKXGHTv+FHd8wd0UV/C6jiATUYBTLb5Lc2iACXt87BEwCVhH0XmgG5bAnzpgSSCWBXTb7yug7xIyw9MYDnuglU2V5tFE44PcgGxVT7KOARSO7Q52H0F1rbDUlICu4TghJ8sWA25LpmmXqZ3uxPE5ouKihLoqtuRz2Xu+cer1rcBuxwu109gkvvoikGoi7+cPm7avLv+gt3azHbAOV11EczhQuG+cM/berjUHLrPsgU8ZbjPAcxs3cy33pwcegA/ZZ3w5/kfAxyB1fDD3w+NJXb54tW8dPgwD5cGvRZpyV9HBisT9kkh9X8dWkPh5jQ79H/c/6opgs7bW+zvB1UCR3/vh2oWeZPDcgBM1ikMLW7Cti+sfS2sz190Er1pMtXFdffkCxFhQCUsjRGCryA3R3xSd5I17MT5HZqv6vhDlos9Q5s0h5hbQAGVet96rzRsW6dLNgFkSJrF4BhSp9U0n1s6BQXToRyfprmLMLub6C3uqK4vSQmK3F/Rye9Oliak2YmpPKBhZ1bW0wPHeZ91VBlDhrSbhGa4e7tg/0QijtMv7wIZJ8lNewVzdo6JpHMbPOxHobiugu3Kk/OIp/pTzWbZjHUZE2r+kZ0BLLCoeIQv482rOaraRkeJ2xEtGtuSDXtk3rUHLRdrR4jZWnAeHsM6IEGnXiEXP0SA8XfO1OdaZbOW9HNTE5TmVFgySivyhNWxEzlkmESwhPaNS2PeDzbYc/O+GIHXEvHHq7kFOEGxg8fgZRAS0lgypKQ/aN/k6Z8kjizvqY6D4crX25OisAHeEHvwE3GvKXuZKZJfZ5FxbXV7XwCxdbcrieHgCTKRLb55G7LIPSP7uqaydTllwelirb7VuB0saJDT7qRPMkfypQT6fwVL+uPYDpalBUviZbx0jmn5SiS0/BCuH8fVlqCMj4HuykBBy5HhzXXeL6NDeBh0leg9Ne6POXcNuRn8hjL9cXUPB8Pl2bFsyY2oFaY/hPHcJgHPWAbAxKMPsDStb1y4/BB5NsU5uP8497TTg/5bVHo5eq8o803pS21eZ+SaE5Xg3gIRNKpTk9566deCII0zFvA03tks+UZjx3iX5PRbQq07OXk9lNPK5Is8wfdOjqL/yG7L/SELrsR4FWqNYwpKkykpG72Y.box",
  "signature": "q5NwVJR3q0aToWQIHV3HBlS3Ibm2KJ/PVQVv7jk7jRY/oFcJolkgximTeR924qpF9gCw9IzHCvSPB1BLzhy4BA==.sig.ed25519"
}

{
  "previous": "%0vxai6ZkWWovpZjZLgrWn7/2i7pQX59At0PZh3rijAQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 936,
  "timestamp": 1535757843781,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
    "description": "Thinking about #hsdt, #bpmux, and [other fun stuff](%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256) to improve ssb.\n\nhttp://aljoscha-meyer.de/"
  },
  "signature": "6guVEivbQq7uIhmjfqP670kj9WkbE2hTUyGr24Idz8tvEdLVptORYr5gNCReLkhMk7ZvPULuEZ0m/QprAt8PBg==.sig.ed25519"
}

{
  "previous": "%fLv2UsLcmSUb+3F6H0j7okFkGLmDWAk/fWpP+dnjzd0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 937,
  "timestamp": 1535787624755,
  "hash": "sha256",
  "content": "H+dvkRWuBYkg+EoVKtvJQnvqiKW1qm81TcXIBikL0oMBSwC0xJnyuzMN0B3eBhSMrrIaL0Wu437uvqSCyEsyhGZZSuijSoyQqM15GLcszG+fxZ/fF5AdoTqddZ3FCbWIHkpoF2Zlk3Bqstp4eqZ6Syj2yW0d7QhbIHLV01VCcDtSI/Gruv2BqsJ9a655cFaCRRElsalJjRBBZB4nFcQH0zYp3tgIJaRb5wKnpeW4Supmuka+YsEtpy0hGd9gexQHQpC9ctptprjJq1fWB+TSgMqXsWQ4DfhGlRg8z6CJrPZKzpG4jM7wuwJmEI2u80vblD4gzLQ/1lVyOUbnpUuVakufijs4kI08e99ZGuEtzvrTEKCq98TOTgEF/P0UVrIWrBrXv0Ese9vfaklJzAqifuRY+tnPTrX6HjOZSa1HinrdJzfvH1g38AO7JgSsuatO/A5Tk5rrIsIFHPp/u53YfoAduQ4DulOydp9fMD4kSNEnh2knvUY5XfJJeF1abA1iY13IMFZH3+p3pm4xYdDc8ED45WF/WMJp4eXPDwI06ENCHiodFetG/0Q1KVXXK9bgD78HV84g.box",
  "signature": "lPWRPM+eguMFOyOfkBEIAZrr3n9D8o12uruY6mllDO4paLvlXWsH45SAFNL2Bb53uGccIo4SDI/C1co9zPUHCg==.sig.ed25519"
}

{
  "previous": "%VwqK5O+bSlGHelkNJvcJ37XrUOaUTmvRDt7GeDJBsR4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 938,
  "timestamp": 1535788535288,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256",
    "branch": "%0c5uxd1PVKoSUyJrM56qWnSBBvnhYXlnUrXgfuFFwi8=.sha256",
    "reply": {
      "%0c5uxd1PVKoSUyJrM56qWnSBBvnhYXlnUrXgfuFFwi8=.sha256": "@22YV3HX/BGClXH49ZebkcepqRpj7a9f5s0ddwhDSfxk=.ed25519",
      "%ACBaAauvRIiTDccY5Qp9qw0XTLf7ex0HLxW2CcfmINU=.sha256": "@/p4BBa/FUHYHJPOAXHXKZJ7SrmSB6yYY9V6GYPwBHiQ=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@juul](@22YV3HX/BGClXH49ZebkcepqRpj7a9f5s0ddwhDSfxk=.ed25519) I see. Yeah, that should work. It is a different trust model than ssb has. I personally think immutability and verifiability of everything tied to an ssb identity have shaped this place for the better, but that is pure speculation. And more of a social-network consideration rather than a database one. But who knows, ssb could theoretically support both modes.\n\nA nice aspect of dropping backlinks and trusting signed sequence numbers instead is the possibility for very efficient partial subscribable feeds. A message could carry any number of `tag, seqnum` pairs, and on replication you could just say \"give me all messages tagged with 'foo', starting at sequence number 42\". Backlinks would mean a substantial increase in message metadata for that scheme, because instead of a couple bytes for the sequence number, you'd have a full hash per tag.",
    "mentions": [
      {
        "link": "@22YV3HX/BGClXH49ZebkcepqRpj7a9f5s0ddwhDSfxk=.ed25519",
        "name": "juul"
      }
    ]
  },
  "signature": "F3ABb+cB4/NIuiNQnHVYXQVDzIlrrsgDHi8ma2Z4NFCpOEjQt4erMLrInVbsBImherVLlS6lH7EFB/GGKOp+Dg==.sig.ed25519"
}

{
  "previous": "%2h4GV6LSHSFQYWR1RbVSTEql1/awXduW4FFJlWRA9qY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 939,
  "timestamp": 1535793657261,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256",
    "branch": [
      "%2h4GV6LSHSFQYWR1RbVSTEql1/awXduW4FFJlWRA9qY=.sha256",
      "%ACBaAauvRIiTDccY5Qp9qw0XTLf7ex0HLxW2CcfmINU=.sha256"
    ],
    "reply": {
      "%uprLsJKHUPBrO22IhaKTM63JH7GEEbAk5Ti0fCMYF6E=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
      "%2h4GV6LSHSFQYWR1RbVSTEql1/awXduW4FFJlWRA9qY=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "A downside of omitting backlinks is that when a key is compromised, the complete feed is effectively wiped. With ssb's model, the integrity of the feed up until the key was leaked is still guaranteed.",
    "mentions": []
  },
  "signature": "izOOiIpu5wyt8FDVkNIVDt23l7DIMVmpvujR1plQ2FE/fBmRMCfT/WRXrrZoLcr58KX1Ssh/fmE44k4s/xopDA==.sig.ed25519"
}

{
  "previous": "%XIgVWW5ipxxy2cRcc4ricWWNet9j3bexzX71AP2EiMM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 940,
  "timestamp": 1535793922417,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%uE+SVzKey9mTH/stgVFRvSfQ+o3bupq3SQUfM4KUUW0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "sij63VpMSNGVEpDUNtsnNPeFMaGr9a779IY85ZqiH3XlICaOK4HYBtClzMkc2PhQcVK6CfNUvUjMHnYq4KUPBQ==.sig.ed25519"
}

{
  "previous": "%5+Pv+OLDtTz4PDs8JoTEnhspANT09oqgXVyQhwpKeu0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 941,
  "timestamp": 1535876121713,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%AzryR//U4hexD7Pcffn94UxegGsnGOpTT6egpQTKvz8=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "gz+kF/0R61wQQPigy70hots+Uj4E5RQhVxvhscPBBVI+IH/ghKWjKBW71WZSz25PZNqApXfNb8kc5etQhrxtBQ==.sig.ed25519"
}

{
  "previous": "%U33Q879pIqOWgI4jjotzitz8Z2uhBY3DtutgDyPfp60=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 942,
  "timestamp": 1535876607197,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%x2jtQAYPWxqjD/jI1BAUe0/sJvYq9yWRcD8zl4CDavY=.sha256",
    "branch": "%vsNieLoGTDfDvP3ppVp+CH5Y1iqOwiwhRzJ1rld2E3A=.sha256",
    "reply": {
      "%x2jtQAYPWxqjD/jI1BAUe0/sJvYq9yWRcD8zl4CDavY=.sha256": "@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519",
      "%vsNieLoGTDfDvP3ppVp+CH5Y1iqOwiwhRzJ1rld2E3A=.sha256": "@NeB4q4Hy9IiMxs5L08oevEhivxW+/aDu/s/0SkNayi0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "gifs don't have an alpha channel, they can't make a pixel partially transparent. You can only get fully transparent pixels.\n\n\nBut: Ssb is a small world - maybe the #ssb-clients devs could add support for [APNG](https://en.wikipedia.org/wiki/APNG), which supports both partial transprency and animation? I can't find out right now whether electron (the thing patchwork and patchbay are built upon) can already display APNGs out of the box.",
    "mentions": [
      {
        "link": "#ssb-clients"
      }
    ]
  },
  "signature": "WXyPGaov/upVrU0LWZmrCVLIzC8sOCaD5vWtS+2wXVi++VTtuz9ZRzM+Wf2Dx0jy/x0fp4GjIH3+Qg6TzZQtBw==.sig.ed25519"
}

{
  "previous": "%tKJdPBhIGPyi+IjEPNrIO51IRiUkOwrOPwz70bWodzs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 943,
  "timestamp": 1535878558785,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%x2jtQAYPWxqjD/jI1BAUe0/sJvYq9yWRcD8zl4CDavY=.sha256",
    "branch": "%tKJdPBhIGPyi+IjEPNrIO51IRiUkOwrOPwz70bWodzs=.sha256",
    "reply": {
      "%x2jtQAYPWxqjD/jI1BAUe0/sJvYq9yWRcD8zl4CDavY=.sha256": "@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519",
      "%tKJdPBhIGPyi+IjEPNrIO51IRiUkOwrOPwz70bWodzs=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> I can't find out right now whether electron [...] can already display APNGs out of the box.\n\nSometimes I'm a bit slow... Here is an apng, if it displays as animated, then your client supports apngs.\n\n![Animated_PNG_example_bouncing_beach_ball.png](&zgkF8zn0Q3DA/swibvS0IthvBqPsTxlOXPudC1Cq+y4=.sha256)",
    "mentions": [
      {
        "link": "&zgkF8zn0Q3DA/swibvS0IthvBqPsTxlOXPudC1Cq+y4=.sha256",
        "name": "Animated_PNG_example_bouncing_beach_ball.png",
        "type": "image/png",
        "size": 63435
      }
    ]
  },
  "signature": "l+Y+Y0tt7ipPAneAak2k1OugwjR1xv0bVOXLoHj1P46sU7kvfappd4TH8D0fxD7gp/muO3MoJaNoBy0laWH0DQ==.sig.ed25519"
}

{
  "previous": "%yDJkhvxsQ+9W3Tq8TVbsEdqsHI+ixdOlQ8jhvSf7RMk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 944,
  "timestamp": 1535968045201,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%zo/kMSae3jDwqghvGMcsFD2UEfxQoSPb2xP7dusivY0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "s0z6Zl4NoN7V1vjfkRLUVN6hT1rzHpppi8Yj/k3aFWFPUCUcamkPrchZr4id2EqomvCYvluwcgMCi07UmXisBA==.sig.ed25519"
}

{
  "previous": "%YUWfwydygPejkf3+vS9v3RW+2LPQWlUV3AZ+XrzzktE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 945,
  "timestamp": 1535968228700,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%x2jtQAYPWxqjD/jI1BAUe0/sJvYq9yWRcD8zl4CDavY=.sha256",
    "branch": "%zo/kMSae3jDwqghvGMcsFD2UEfxQoSPb2xP7dusivY0=.sha256",
    "reply": {
      "%x2jtQAYPWxqjD/jI1BAUe0/sJvYq9yWRcD8zl4CDavY=.sha256": "@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519",
      "%zo/kMSae3jDwqghvGMcsFD2UEfxQoSPb2xP7dusivY0=.sha256": "@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Angelica](@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519) Yay!\n\nI think [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) might be the only user who could have trouble with apngs, because [dillo](https://www.dillo.org/) doesn't support them (according to wikipedia).",
    "mentions": [
      {
        "link": "@eANNuLfzX/9rlGODXHYV8WJb+zw2h+d7YsT4vpYPvD0=.ed25519",
        "name": "Angelica"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "oCFQZZxuEme5fNS1lNWtvlg3ibnftaM2xBn4HC53gIytMtkSHEbCPwXt99YN6S7usgCjnmvyg1Hzi4nCvCfUBQ==.sig.ed25519"
}

{
  "previous": "%XbBpoRJRvNG0xbYWruJPdWIM6kdzHGPUpjKVUqP2clA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 946,
  "timestamp": 1536055548647,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%GN1uEDcWiGqbXBOwMzJ0zxNzybSrT3DoXN8+p1PJhzg=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%GN1uEDcWiGqbXBOwMzJ0zxNzybSrT3DoXN8+p1PJhzg=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Honestly, that seems like a lot of unnecessary complexity, I'd rather go with either always or never including it.\n\nWhat does an implementation have to do if we don't include sequence number and feed id in both the hash-encoding and the transport encoding? The simplest scheme that comes to my mind (and that incidentally would require little changes to sbot) is to look up in the database for the previous message. The db stores the feed id and sequence number of the previous message, so we get them. Add the feed-id to the metadata, increment the sequence number and add it to the metadata, then write the message with this additional information to the database.\n\nYou probably want to add in some caching for performance, but effectively all this does is a [reduction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce).\n\nWhoever is crazy enough to reimplement ssb, they will:\n\n- implement a handshake and a streaming cypher\n- implement a multiplexing system and its codec\n- decode all the multiformats\n- set up a database\n- write a gossip scheduler\n- recognize and produce a bunch of rpcs\n\nI don't think adding a reduce operation to that list will make a relevant difference in development effort.",
    "mentions": []
  },
  "signature": "SGSEo36gleeWiEAuWLxy42S82KO6dPzshsvLoXKNEEmFnUt6Xhb0hB2xM8Gy7QdVIcMXC0I3RGEIr1LEcc60CQ==.sig.ed25519"
}

{
  "previous": "%gHwVDcT2Soc5SnsnBx/4hn6idf7iZVJOALJr5LXLyV8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 947,
  "timestamp": 1536056814161,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
    "branch": "%kXrRuCJFJlKoylDvStKuwbDrar9bIdsX3t+hNqp82bg=.sha256",
    "reply": {
      "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%kXrRuCJFJlKoylDvStKuwbDrar9bIdsX3t+hNqp82bg=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519) [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519)\n\nCan you give an estimate on the additional effort it would take for your databases to support more values than just those provided by json? I'm especially interested in the sbot side of things, so we can decide whether to roll out new data types with the initial hsdt release.\n\nI'm currently leaning towards the following additions:\n\n- signed and unsigned 8, 16, 32, 64 bit integers (all supported by cbor)\n- 32 bit floating point numbers (supported by cbor)\n- ssb cypherlinks (not supported by cbor, but can be encoded via unassigned [cbor primitives](https://en.wikipedia.org/wiki/CBOR#Primitives_(Major_type_=_7)))\n\nThese give us the number types any modern statically typed programming language provides, and special treatment for cypherlinks seems appropriate since they have special meaning for the core protocol. None of these are inherently complicated, they are just simple pieces of data with a fixed length.\n\nDropping cypherlinks would make this a strict subset of cbor, but canonicity requires specialized implementations anyways, so we might as well add them. I will write a high-quality (robust to malicious input, handles out-of-memory gracefully, supports partial input/output) C library implementation for hsdt in any case, that can be reused by other implementations. So I don't think departing from cbor is going to be a large drawback.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      }
    ]
  },
  "signature": "oJnbvIK5O6rl2tlvWCYvbw1LMkhIxlnpqi4xh/di8zPgix5pVFPoXTMYcePBYTeSdEnMMKbezS3Ikn6rRRw5Dw==.sig.ed25519"
}

{
  "previous": "%urfag1KCw+gqNawrG5PigBmwgZjWAXwrBN4UOwYCIWs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 948,
  "timestamp": 1536090177370,
  "hash": "sha256",
  "content": "6Gi8KVwAiOmRK9rYQ36KawMrwwmqzWxaZHIA54XUhSAE1PWm/e9uWnm+jk90U5Vofud0itMKrXH1+ASrJNl7I2QjUbEABXMChE8he31xsqs3JKZQwtaVDE7YhU+cb66WJ8kfIegQ8hqOFqhMjWPi2JZd/RcA95booiKXsag2YcPZJvSyBLVFI2Eb/FjW8pa58K/52N41+IZNGBVV7PWgf71GRZBl13QlmAUcvP6JGzGgs8jEInaVpxhjjS8D0d9qS081s+hohyfP1euU+1/B40gqLUSMYFFS/9okPQQ44XQpN3FpdfBBPWqnOV/pM+tOpMx+i8RH0ILn/DH2lyRtKUlb1RW/OjZMFDUCLJZpU+DdlHKL4z9Lng7IzggDUdYoQ2IQ91gp8lwusHI1Lb0HyJoxP0XvzkEQATgF5K0nl7iE+Do8K8ASmBqQRY8BzXJByJPeWKxbK5HF2sOvN82nWxU60gQaJkjmirg/tI9mjhc9mCJWPM7xEtYpqidL1kWJVqmmHFMQ/BrrcHktr5zIGH3dAigwEZlNKc2wA4DJ4ZNyTbuFLyASPc4plZihn6ZoBtfF4xSM10sLiReG78eOA3xXxb8AKLXOhzaWUPXdwyASBbAv5/bs7BsGeHbLjoCwBJo1wGqtbhc11evpdWlMtOmJEcPbx8oH1VRVsTsNTiHX7ntgv6YwfS4OCYvJ1iSYp6sqsE2fbqWB0Q27G3UXFMxFFn5kl3xzWo0FSmM5TPaxTsz0dThetS2q2VR5MbQsbuGP6LouEB86tBoiFKpKRRWSGidA+votXth2spew9hIpNZPUZP5L96F8d1K4H3kP9aQSKiURCZpZ/7lZyMMmqztxk7xZosybVRjWN8u1gn4GAAAp8277VNxGEt+f6I1Jq9vUAuMrkWs+lgQl0N2haZyIOByfPrmxrSw=.box",
  "signature": "VvwSS3u8MV/ibz1x6+kQXIEm/z+89TADY+HZ+lnzMK//ZS/xSw9TbUNtPL/WWY082Euc0kCUKruZo7mAuT/nBQ==.sig.ed25519"
}

{
  "previous": "%1YsIzBmcPvjl0n6IwDiAu7lW81Z1cf05s+OC8nGbUwY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 949,
  "timestamp": 1536137077538,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%JdOdha2fW3pFSmPztOMmP5C5pb5cRBclHDcjmG+I+9E=.sha256",
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%JdOdha2fW3pFSmPztOMmP5C5pb5cRBclHDcjmG+I+9E=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) I didn't read your posts before writing this, will look at them later.\n\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) A few quick notes, quite unstructured as I don't have much time right now:\n\n- I prefer how cbor handles lengths (small values in the tag, else tag indicates length of a fixed-size int that gives the length) to varint + bitshift. Less complicated to implement, more compact for many values.\n- how do you decide whether some js/json data is an int or a float? What happens if I want some data to deserialize as a float, yet it happens to describe a natural number?\n- for all types of fixed size (what cbor calls primitives), this does unnecessary work, cbor handles those better\n  - especially bools and null, those only take up a single byte in cbor\n- Some arguments against length-encoding rather than item-count encoding\n  - when looking for something in an array or in an unsorted map (and since this preserves map order, we can not assume lexicographic sorting), you don't get random access, you still need to scan sequentially\n  - with default cbor, you can also do the sequential scan. You also have to only look at the first few bytes to get the length in bytes, just as with the proposed encoding. In an array\n  - when decoding into actual data structures (rather than random access as this optimizes for), having an item count is much more useful than the total size: you'll want to allocate some memory for a number of (nested) values at once, but you can't do that if you only have the size in bytes. Having played around with writing decoders for different versions of hsdt, this has brought me to the conclusion that \"binary length encoding optimizes for decoding\" just **does not hold**. It only optimizes for some cases of quickly seeking some data.\n\nSo when is binary length encoding an advantage over cbor? Only when skipping over whole arrays, maps or map entries. When does that happen? When looking for a specific entry in a map (most often the top-level one). Theoretically also when looking for entries of a specific type in an array, but I can't come up with  use-case where this is what you want to do and an array still is the right data structure.\n\nWith canonical encoding, it would be nice to be able to do some sort of binary search for map look-up, but that can't really be done without additional metadata - you need to scan linearly through the data to find out where the entries begin.\n\nFor quickly finding an entry in a map without decoding the whole data, I agree that binary length encoding provides advantages. But I'm unhappy with that consideration leaking into the signing format and the transport format. Fundamentally, your encoding is intended to be used for all three use-cases: signing, transport and database. Of these, the database use-case is least related to the protocol, in fact it is not related to the protocol at all. Implementations can handle data storage in any way they like, so letting that concern dictate signing and transport seems somewhat off to me. I won't fight over this (at least not for a transitional format). But keep in mind that decoder implementations will lose performance (and implementers will be annoyed) because of missing item counts.\n\nOne last, and serious, question: Why not a cbor subset with byte length prefixes instead of item count prefixes?\n\nOne more really last, not completely unserious, question: Why not a cbor subset with byte length prefixes *and* item count prefixes for arrays and maps? ",
    "mentions": [
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "tEF9zkqI9belKEhAufJauxo29WXJBronZCUsNzgLHsLrrCUXXe2QWL6s3aSegmpT57Sgc4Qdh9ZNEBGYdou0DQ==.sig.ed25519"
}

{
  "previous": "%LorKxaXJlOhDmNu2mbaH0WqvbC/oLtOoeGGFQ7ry9uc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 950,
  "timestamp": 1536141690749,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%JdOdha2fW3pFSmPztOMmP5C5pb5cRBclHDcjmG+I+9E=.sha256",
    "reply": {
      "%JdOdha2fW3pFSmPztOMmP5C5pb5cRBclHDcjmG+I+9E=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
      "%LorKxaXJlOhDmNu2mbaH0WqvbC/oLtOoeGGFQ7ry9uc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) I'm on the same page as you are: A db can (and should) use auxiliary data structures instead of relying on the transport encoding.\n\nThe main advantage of storing the transport format on disk directly is needing less code. Performance can't really be an issue, because\n\n- ssb has high latency for message transfer, adding a few nanoseconds on the receiving machine won't make a difference\n- when receiving new data, interested clients will probably want the deserialized data structure, not random access, so it is ok if random access is a tiny bit slower\n- I'd expect bandwidth, IO-overhead and crypto to dominate the time requirements, not dealing with the structure of the data\n- converting data into a db-ready format can be done in another thread, parallel to the hot path of getting live data to clients\n\nNo transport format will be as good for storage as a dedicated database with indices, so we might as well optimize the *transport* format for *transport* instead (shocking, I know).",
    "mentions": [
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      }
    ]
  },
  "signature": "VPqLDnG2PJHt0e7818hn4ZHtEXTn2rv2l2tyasrR5ZRZSftW9eReaYDUR4KLVN+aKCX6/5tEbQ2AfhMSXcVbBA==.sig.ed25519"
}

{
  "previous": "%APVU76FqKypC3YC3chA2wd8uXXO/ihxtn/UFtLymlN4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 951,
  "timestamp": 1536141914552,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%9VWASKdl78TVKP+Hn0bVqji6Avg0DpfSP4aUIT6rwJE=.sha256",
    "branch": "%kBmu1Br1/xPB4ykSj3ncw4VlV9Suzy0NE0q6IICvoOw=.sha256",
    "reply": {
      "%9VWASKdl78TVKP+Hn0bVqji6Avg0DpfSP4aUIT6rwJE=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519",
      "%kBmu1Br1/xPB4ykSj3ncw4VlV9Suzy0NE0q6IICvoOw=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519"
    },
    "channel": "ssb-protocol",
    "recps": null,
    "text": "More transitional encoding: %HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "mentions": [
      {
        "link": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256"
      }
    ]
  },
  "signature": "xPMrLOHsUD+oL4XWyLozyP/Ww7QP4TgM8grtxvVX5LFsbOFDYLVY58JqinDVyGpfwiF/pb/R7C6AMzJlXhvUDQ==.sig.ed25519"
}

{
  "previous": "%8bOMJaeyr7yQ7gknR4n6AUHmJfMlr26h/40F4/9zdCw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 952,
  "timestamp": 1536153543195,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%UwYCEb0LdZymBz0llz+QcqXd004x800DHiWJiYy+P80=.sha256",
    "branch": "%Qss9UHAeqL92K3NE9MJzwCvqi3lVzdd38K/SwvpsZS8=.sha256",
    "reply": {
      "%UwYCEb0LdZymBz0llz+QcqXd004x800DHiWJiYy+P80=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%Qss9UHAeqL92K3NE9MJzwCvqi3lVzdd38K/SwvpsZS8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "bpmux",
    "recps": null,
    "text": "Tiny update to the abstract specification: Credit for any single stream is capped at `2^64 - 1`.\n\nI'm updating the specs on github, not here (at least until posts support updating via diffs).",
    "mentions": []
  },
  "signature": "b5NAbLANxVJatCBylxA513a2jaf5spZ7oG+YAP5EDHOkXsBnTdUpwRgUCz34AnVR+qmHuq1UkJynrQ8m6kDcBg==.sig.ed25519"
}

{
  "previous": "%lWuqdIMjlGPkCfZP0RoaxnFHIhgvyR05+DIAlJrgCiw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 953,
  "timestamp": 1536174057664,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%eLHuD8QCn6ds4mb5J7hxmHvlHzCY+Z0wacO++8Jg0Xo=.sha256",
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%eLHuD8QCn6ds4mb5J7hxmHvlHzCY+Z0wacO++8Jg0Xo=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Sorry [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), I misread that. In general, that API looks good to me, but I'd also like to consider partial encoding/decoding. Of those to, partial decoding is the more important one. If you get some bytes from the network, you might not know whether they already contain the full value. The trivial strategy for dealing with this is to just try to decode, and throw away the partial result if there are not enough bytes. Then once more bytes arrived, try again. But this is obviously inefficient, so any \"serious\" implementation will have to provide a stateful decoder that can be fed input over time.\n\nPartial decoding is less important, since you can preallocate enough memory. Ssb has small messages, so that's not a problem. For larger payloads (at some point people will create blobs that contain the same data format as we use for messages) partial encoding is necessary. And in general, preallocation requires one more step of copying all data.\n\nNote that some formats don't strictly need partial decoding, if you can efficiently determine the length of the full object by looking at a limited number of bytes. But honestly, writing a partial decoder is not too much effort. You can't do a recursive descent parser that uses the call stack to handle nested values for partial decoding, but you can't do that anyways because you'd risk running out of stack space for (malicously) deeply nested input values. And if you need to handle recursion explicitly, you might as well put all state into a data structure and provide an interface that supports partial input.\n\nA few more details on the proposed API:\n\n- `decode` needs to be able to return errors (js can just throw them implicitly, but the API should document them)\n- `decode` should somehow indicate how many bytes were consumed\n\nFor partial decoding, the `partial_decode` call returns either the value, an error, or a special value to indicate that more input can be accepted. All three cases also need to indicate how many bytes were consumed.\n\n`partial_encode` can simply return how many bytes it wrote, and `0` once the value has been fully encoded.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "cPFRu9MelQaqvDydjJisHNzJAz3eaCJqgQpmP6J+WZeToIn7HafYWAoSwb1GnvDS/b5EBmGJgi0uSIouk+vgCw==.sig.ed25519"
}

{
  "previous": "%Gx5Q3P57ORf3VKBGtozU1NZLnKxuKwX3GvMjzcaBYo8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 954,
  "timestamp": 1536174067854,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%eLHuD8QCn6ds4mb5J7hxmHvlHzCY+Z0wacO++8Jg0Xo=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "MULy5Zh950Ui8deFCkS4ynU0LkshsSj4UoEl8lTZQ5Pl6IkcOJ9vyqZlZm3ATrMLRMTN1t8pEzCokPjY3reFAw==.sig.ed25519"
}

{
  "previous": "%v3LbNNdhboXx0RMPHbrc+07XYNA0XdbRIPn4TsXuAzI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 955,
  "timestamp": 1536174270022,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%Gx5Q3P57ORf3VKBGtozU1NZLnKxuKwX3GvMjzcaBYo8=.sha256",
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%Gx5Q3P57ORf3VKBGtozU1NZLnKxuKwX3GvMjzcaBYo8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Addendum: `partial_encode` returning `0` to signal that it is done only works if you disallow input buffers of length zero. Disallowing those for decoding lets the decoder skip that annoying check as well.",
    "mentions": []
  },
  "signature": "H9d2cbaFeH9+9rB7PytqMJq6Czph3haBXuXlWlKRgb7zOH9o0+qGNhgg2D2xQuNp1j98zROYQITsogLu5kMKBg==.sig.ed25519"
}

{
  "previous": "%MPdgeh9GRncEOutibqdSCvzvaLlQm7ieXBhkeWvG9Hk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 956,
  "timestamp": 1536229388868,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%Hvx2McUg/w87gLJM2R88kCvuybNCpPMMuRXzeZB2dnI=.sha256",
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%Hvx2McUg/w87gLJM2R88kCvuybNCpPMMuRXzeZB2dnI=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) About the additional data types: As far as I understand it, Dominic is discussing a drop-in replacement for json to send old (and current, but hopefully not future) messages more efficiently (and less painful to implement). So no need for supporting other types. As for future directions, check out [this thread](%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256) in the hsdt design channel. I'm currently favoring adding fixed-size integers, 32 bit floats (we already have 64 bit ones) and cypherlinks.\n\nAs for the partial decoding: I'm talking about the situation where a partial message has arrived from the network. The partial data might end somewhere in a metadata block, so you can't rely on being able to do path-wise decoding. This setting needs a fully general solution where you allow arbitrarily splitting up the data that is fed to the decoder.",
    "mentions": [
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "%f7tqoQpSfPXt+poGLGlI27DFqRXI2BsaC1CPhy4Rak8=.sha256",
        "name": "this thread"
      }
    ]
  },
  "signature": "Vo6H7kIdNKpgct+eaKFr+wfKcPiB/gmjLBDt1+Brv1wLuJzlbLYoJ5YQZvzH3kGUKb0ApxF+jiu0Mac2XWKgCg==.sig.ed25519"
}

{
  "previous": "%C3ijBEs8fSI/vVwqa81x256eNVPZKKEDzQirDEgaXsk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 957,
  "timestamp": 1536230238591,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256",
    "branch": "%q+aGwdKVqrMXIVo5EOQlEvU/1M93EVUI+Jo+8v/ILuA=.sha256",
    "reply": {
      "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%q+aGwdKVqrMXIVo5EOQlEvU/1M93EVUI+Jo+8v/ILuA=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "# Current Blockers\n\nTo continue moving forward with this effort, there are a few things that need to be resolved, and I can't do that alone.\n\n1. [Can I go ahead and add various fixed-size integers, 32 bit floats, and cypherlinks to hsdt](%urfag1KCw+gqNawrG5PigBmwgZjWAXwrBN4UOwYCIWs=.sha256)? [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n2. [Can we make timestamps optional, can the devs of the major clients estimate how much of their code would break](%IIakMBOFpmcxyUDnwtHkrVa4uLU3x8JLkBLf4wgg7ik=.sha256)? [@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519), [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519)\n3. [Can we drop feed id and sequence number from the metadata? I can work with any of \"yes\", \"no\" and \"negotiate as part of the rpc\", just need a decision.](%gHwVDcT2Soc5SnsnBx/4hn6idf7iZVJOALJr5LXLyV8=.sha256) [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n\nWith the first one resolved, I can write down the final hsdt spec and start implementing (currently leaning towards doing it in rust rather than C).\n\nWith the second and third one resolved, we can figure out a specific metadata format. That will open up a tiny digression about binary representation of cypherlinks, and a larger one about signing just a hash of the non-meta data instead of the full data itself. But both of these can wait until they've become unblocked.",
    "mentions": [
      {
        "link": "%urfag1KCw+gqNawrG5PigBmwgZjWAXwrBN4UOwYCIWs=.sha256",
        "name": "Can I go ahead and add various fixed-size integers, 32 bit floats, and cypherlinks to hsdt"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%IIakMBOFpmcxyUDnwtHkrVa4uLU3x8JLkBLf4wgg7ik=.sha256",
        "name": "Can we make timestamps optional, can the devs of the major clients estimate how much of their code would break"
      },
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      },
      {
        "link": "%gHwVDcT2Soc5SnsnBx/4hn6idf7iZVJOALJr5LXLyV8=.sha256",
        "name": "Can we drop feed id and sequence number from the metadata? I can work with any of &quot;yes&quot;, &quot;no&quot; and &quot;negotiate as part of the rpc&quot;, just need a decision."
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "D8CiurDEHuuHIdxTRQYa8AeuqJfXsunsrKzYgBokWfrbSzKYGFxpadPmES7JwnwFnSCLnBAUybgczmWCfnVECA==.sig.ed25519"
}

{
  "previous": "%XjFVZ8xJgT+L+OwWOWml5mBECjKFQwpfpp1J60ks0g0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 958,
  "timestamp": 1536231040694,
  "hash": "sha256",
  "content": "uhtwRHdXl6xxsqgBN7Ct0c8QB0kz0HP8DcGPCnDgbx5tx6bZPc8bd9cF8cBNHJzCD0zzuCiebUlJUL0g2dI8ogxZzdDOf8ZUf/hhJS21sz3fWHZJv2Pd+Cm+mPMJo+0xJmtwjn2u8zAgEbf/+/sOq3In+qct3zecxJ4qc3hbhsMjpdXxbBXJ6VzJkQMWivmCVN6dJmxeeyOKTS7aJtp6N1UM9W2KUtZ7FfVW1iQB8BhKm72JS+vEu5yw+982BJ3Za4XtVormwCV3YpW8cmLp2GtcyQxm/uAmlsCMaNAy9lx49iEoCOnn/oS8X+M+JMrDxV9uIJMmSprAvBS3aB3znaLZWs/sFansQ+GpjVJF9MKFVnfwtvIVPXNn2RGUsA3nO0fAJ+mB4Ug6BjNMnvAjFAXNsGEYo20s7vppKwCNfyf0WwMCLcYPFkEWvHho+0mo6qwoP36Tw8UW4ahTi4l5cJFU8KBHhdn+5oDfYn9d7FZW9GyTypkLrQdDDWvB4/xVezbrM5Ce0DJMpmLbp93VH0c/GjcoacmMlJISLMO/iVK0sdljJfB8wf+GwG1ZBoq6G3ItoGgbqD3u2e6og3frgjqOo0uCa/7ueC6ghcZPjerepU5rMV/+Yb4UHzG/OEMAEDqWcQ9DPOWIAQ5H5IOFwqnjlWQY2vOi4HzU0gGqn5sp2V/F7biAC+BZ4F1dtFtZfn8hV/SGeuvwxVF+Ct7QPi7lo98cCC/PWYBnZxvBH19op8geGJHpLHZcfZjJkm4A/iy+ZZOOSoKojIHIGHLNgBtHxsdsRUnCz29pEnDislprpZEqS26FzUOA6x6LEHj3iiUenvQfX7eT7oSr2UlkuM4nkP6JFalHWxoacskvflmjYMZm8LEykRJTAxlxupC4S8S2dSXaaMKDhbQWWQHKH/x8JEQgmpVNlsCgn/hFeAGjVqPVBbum5fsl3LZYrSuQLzVPKm4PIqeXgNC6B8tVlAXQYyOfgzqS/P3YT83gH2aX7jvRry2/bIzR9HBaXgIiuL3tJhTNZ4NYFcuRH50HkpKAo9occ8dGtOlrt7pSyy8AUvquLrre9YGjy5NJTkFrtEdyEVkUEvmqtI/tYRQim7Fxg8LwakI6m3x/jSe3n1MVq3TEzGQ8W8G7FFjH+pXqo8nrZ3j37PhsEfbNrK2LAptkB7XChlPxwoYHCZIEQwF5R4Ca1hSlvakRXsujdrO/sd55HXfgjwgBhKBC0hJRe1hENnj9G+T+E1/RdED7tx0JhIixJOcAq9Sh1wNYmub5/GRMkRkaPglWfpB5zFZdgGtGEg/Ty8tjef+Mxgx6+NKlBeQG/9q0rUwcNoIkFz/EeRkdYBPM9bp03Ff8f6f7Sx2R7YE0wklcafW6J9YwonE0DZRXCf/IUtk6XXeDkrzjhfsbkAgFnxQ5DFwHZQH9qGcTRa1bqWqsKV5e3AxV9Xq6tBa1KU9k1lE5fGKeOK4MXj4X1+lSch0sXcvBqiWdhWhxTlCVSw53YU1oqOV/G2zGx4ZNbc5b+/opbNNeFjk+AVrkOB3/9QuJNK2etNhuBGpD/MsHf7craWqKrA4L9UysSUkIvtoLQsNk9P3R9Fk2qNypvvOTQURw76LcIDYmgSvlQeiLIr2zsEFzR/rrHjd5BKw/Z8sVIM/TgUHaD0S+sVSkKqgauLsegKk7PRvAaDBfSv13FaphHNeT8y865lq3kbUmbiZbiJ17r0qAvF5gdJbLzafYAqQ67hXAiYSQSCRIBJBaDO+NDwmK5GIooCvxXAp5cvGH7AiTKBW6N3A8catz7XXRvxYPwZHme4cfSAUYDbgR+/fnJSVK66eq5GmAH+QgQZQ9e7KonY49K4jxuxWSclXP36vPky0V/0zGhpstxUWX36A+JZg8TWsfv+4nfkG3vEPcHSo0JEmkzCZKjID8yQtVqGNmsoUvXA9HGxB3ExgllqdlNOyUMIH/MikPWc12LbwUqmh/5B0+smCncNNynutmt/jNniZOKNW0NdcqUFPQntOO6RbH/cZDfE+ZQMeyaYOGnMF+InaMDxFG9KQ29R/JDX38qW9Zifu/8YiN9f483TEkEBqpnJWFadB/jX1bCsQZ/vqtMDBGyRK1OKxxwMmJ3kHkQZ8DixvP6IGJR1sTFTOLd0qqu8qxD2l/FWZO/0eob/miapMZuRMMJHVs0yCPb+Yz/ZB56x9/4N4VlO2Qo/rLclAaFr3AW1RqdV3tkP3txKb6xoUIgKVzjNZsJuD+cnRQRWbgXT8RJjevaPy0o62ngie1wlRdlxs0Io7hMj8hn57huTOL.box",
  "signature": "zI7sZNcMs4FSOaHWVWWnECOU5Ae2zIpbfbsupAMf3KJiMb1lNXzmH4JrZ0+DG1EkiXSAHedGBb5rMqOTJH0OAA==.sig.ed25519"
}

{
  "previous": "%v8aNuUZah+Fk1oi21e7NrtQYdGQC204wmLxkFl+Wkek=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 959,
  "timestamp": 1536236235378,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%eDvjrr9hOPNRYOdAi2Mey5AtLdpGqiLxZf6VvyjrfN0=.sha256",
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%eDvjrr9hOPNRYOdAi2Mey5AtLdpGqiLxZf6VvyjrfN0=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519)\n\n> You can't decode before decrypting anyway so you already have all the data before parsing.\n\nbox-stream is not aware of message boundaries, and it should not be. The decrypter emits chunks of bytes over time, and we have no idea when it emitted enough bytes to start parsing.\n\n> Also, we are talking about data structures of a couple of (16 or so?) KiB. Waiting for these is cheap.\n\nThat would force us to only decode data once we reach a multiple of the maximum message size. This can lead to deadlocks where you wait to receive more data so that you can start decoding, but the peer won't send any more until you have responded. You'd also need to get extremely lucky to read the last few thousand bytes of a stream.\n\n> but I would expect that decoding to fail because the data is not a valid encoding if half of it is missing.\n\nYup, and then you need to retry later, duplicating all the work.\n\n> Can you elaborate why you want this feature?\n\nResilience, simplicity, efficiency, separation of concerns.\n\nCompletely ignoring this leads to faulty or ineffcient implementations. Without partial decoders, we either need to send additional metadata for lengths (inefficient, not as simple as possible), or look at the metadata of the wrapping transport protocol, resulting in tight coupling.",
    "mentions": [
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      }
    ]
  },
  "signature": "bUoi6bJXX02m1ftw3uF4Gp9lc9ZnJAW8KFRfWaqFcSnS6tlHJchp+l2oBO26/+KeMVzk+Y8nJ+pKl9Vum7J5Dw==.sig.ed25519"
}

{
  "previous": "%iLod/gifE7lhLTz1XQrBarhHRS/blcwa9UHLclmbDFQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 960,
  "timestamp": 1536237881197,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": [
      "%A+iMi6z8ySzgcALs97uHX/0xg9kNL0+AkiMb41S6tuw=.sha256",
      "%iLod/gifE7lhLTz1XQrBarhHRS/blcwa9UHLclmbDFQ=.sha256"
    ],
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%A+iMi6z8ySzgcALs97uHX/0xg9kNL0+AkiMb41S6tuw=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) Some funky message delay going on right now =/\nNotification spam is not a problem at all.\n\n> You want to make partial_decode return the internal decoder state that can be used to continue the partial decode.\n\nClose enough. Instead of returning state, there's simply a decoder struct, and `partial_decode` takes a pointer to that state and updates it automatically. Once the decoder signals that it has fully decoded something, the state can be reused for a new decoding process.\n\nConceptually, such a decoder is just a coroutine (except for the reusing part, but that is pretty much an implementation detail).\n\n> Wouldn't it be simpler to pass the byte source to the decoder and let the decoder read more data itself, as it sees fit?\n\nThat's the high-level API I'd prefer as well. In js land, the decoder would take a pull-stream of bytes as an input, and would function as a pull-stream of messages. But internally, you still need to do the state-juggling.",
    "mentions": [
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      }
    ]
  },
  "signature": "REIbn4aeNBUykfpevqpSoMARNithFzfGL22TY0YGoB4HWpPQD5SZFpXJO4H4rnw21wBTitxpNswNlXZwoKktCQ==.sig.ed25519"
}

{
  "previous": "%zwkUS/qQQu/VEwNDRQunXDitfmVlp+Nuk0b37gOgbn4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 961,
  "timestamp": 1536237892830,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%x0tFx8oeb0Q5A6FzpnhbZu1z+fYuLIbyVjiGJp/JQLk=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "l3l5T24FRihFdCaFPmWnihC+7iKj50PvrCwawbxuxtR7evZ/gqudr8wWoPBui/mk4fkKNPS7kIoKFJ9fA5/qBw==.sig.ed25519"
}

{
  "previous": "%gq1DgVISNuMl9gepWdQUt16Rb/0XmzMtpXKUKXVaFQo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 962,
  "timestamp": 1536248198847,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%RotL9OWUoDGt36G2Vw5Dfuty05ld80A9oJuVipXqtT0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "nt4P3KnfFBw7fMx5xNmX2tuU2kwFASdKQy+zgFZWt7BxN/2sQQlOtHRcswV+m1n3FCV13p3q4owbjiO6m5tzDw==.sig.ed25519"
}

{
  "previous": "%XnLawKWA+75c+WAiZfDDrfCIZT8BuTkFPKO1ZSe6nv8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 963,
  "timestamp": 1536308339417,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%v6JR/8TxwUDsVopYaTbqSYTL38t9MWtFYS55r3K0L2w=.sha256",
    "reply": {
      "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%v6JR/8TxwUDsVopYaTbqSYTL38t9MWtFYS55r3K0L2w=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) Traditional vector clocks are unsuitaable for ssb. We have an unbounded number of feeds, and thus no upper limit on the size of the vectors. An no single participant can even know how many other participants there are. There are generalizations that deal with this, for example [interval tree clocks](http://gsd.di.uminho.pt/members/cbm/ps/itc2008.pdf). But these mechanisms tend to get pretty complicated. As usual, I try to push the inherently complicated parts into the layer that is least-tied to ssb itself, i.e. the database.\n\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519):\n\n> But I do think this would be really hard to implement efficiently enough.\n\nSummarizing the relevant papers listed in this thread is something I want to get to, once the message format updates are done. There's a lot of densely packed information in there, but I think we can distill that into an algorithm that isn't too complicated. I'm happy to take the title of \"Dude who reads through specs and papers so other's don't have to\".",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "QYfAauCWvolmWT9V3K/KXW5b+iYOSOn5+wkLNu7xyCmSzyDzGv/hNjzJL+HQr/EvqG4N5LzREi4GsqsRbrzLCw==.sig.ed25519"
}

{
  "previous": "%3moSS9xHmfYNPHTK0xKFEPMps2d51WKbsj8XQJVFDYQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 964,
  "timestamp": 1536309089607,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%VcB0Bt+MY88A6rL3dU/4nj/Y5wx/QjA6roRNQDuGbzI=.sha256",
    "branch": "%VcB0Bt+MY88A6rL3dU/4nj/Y5wx/QjA6roRNQDuGbzI=.sha256",
    "reply": {
      "%VcB0Bt+MY88A6rL3dU/4nj/Y5wx/QjA6roRNQDuGbzI=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "guild",
    "recps": null,
    "text": "This is a good idea. I did a [test suite](https://github.com/AljoschaMeyer/shs1-testsuite) for shs a year ago, but that one dynamically performs hanshakes (and is written in js) rather than replaying pre-recorded data.\n\nSome suggestions for test cases on the transport-layer:\n\n- shs\n- box-stream\n- box-stream with secret negotiation via shs\n- packet-stream and packet-stream-codec\n\nTo tie it all together: A really overengineered calculator: Test suite provides the server, which does a handshake, encrypts via box-stream, then takes muxrpc (both req/res for simple calculation and duplexes for larger calculations) over packet-stream and sends back the results. The implementer writes a client that sends some set of computations to the server and must write the received responses to stdout.\n\nThis is something that would have been immensely valuable to me when I worked on the Rust implementations of the transport layer protocols.\n",
    "mentions": []
  },
  "signature": "c0oG618XA8+ApvPD1MYWJp1dBEGTVzzJQ5EpQ2ZH5cDUCiku7FPJUrmkLmNvx4KOlvYir9t+Buo5fAYxuzQvDA==.sig.ed25519"
}

{
  "previous": "%krD3UpgzHed/lAT1fglty3qfx4yYZZZNdch7Rbj16lE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 965,
  "timestamp": 1536309545884,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%PJSLTxC9285oM1AlRuWEgb61BMHmHwoNMJgg/96FAHo=.sha256",
    "branch": "%PJSLTxC9285oM1AlRuWEgb61BMHmHwoNMJgg/96FAHo=.sha256",
    "reply": {
      "%PJSLTxC9285oM1AlRuWEgb61BMHmHwoNMJgg/96FAHo=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@christianbundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519) Message content as blobs is [in the pipeline](%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256), can't do everything at once =)\n\nThe idea is one that is pops up regularly btw, the earliest mention I found was in an ssb github issue from the early design stages.\n\nThis is fairly orthogonal to the json problems. We plan on completely moving away from json anyways, but there are other good reasons for only signing a hash of the message content (that is what it all boils down to). I planned a whole post on this topic, so I hope it is ok if I postpone a more throughout response until the issue comes up when the discussion about [general metadata design choices](%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256) has moved to that point.",
    "mentions": [
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "christianbundy"
      },
      {
        "link": "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256",
        "name": "in the pipeline"
      },
      {
        "link": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
        "name": "general metadata design choices"
      }
    ]
  },
  "signature": "sDXRzMNx7ygURk25iCNaxSZf3nYosm+V/2kbOHLNXhjvGtT/VGqKQFVaAlC0+Odr1a2z93KBtcvSTK4/gzG+AA==.sig.ed25519"
}

{
  "previous": "%zAIpeeATsnkzk6079zZrCpecgg27aEKUmli7ONKYdRM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 966,
  "timestamp": 1536309646471,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%PJSLTxC9285oM1AlRuWEgb61BMHmHwoNMJgg/96FAHo=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "iLMrxROBU7v96u3S91A7iAHjrTeg8v+0nEUi4HP1aeaaUonpTkYRunQzjaJRprgZ1wvtqrvutqqg0c4n76P2AQ==.sig.ed25519"
}

{
  "previous": "%JtejJ82QfKyAxXKoO0eJNdQ4zosps+aC7n9M1BWHwbs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 967,
  "timestamp": 1536310190617,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%zwkUS/qQQu/VEwNDRQunXDitfmVlp+Nuk0b37gOgbn4=.sha256",
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%zwkUS/qQQu/VEwNDRQunXDitfmVlp+Nuk0b37gOgbn4=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) Another important question about the (js-specific) API design: Would you be up for decoding objects (aka ordered maps) into [js `Map`s](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) rather than js objects? Maps guarantee preserving insertion order. But this would be a breaking change to the js `ssb-client` module, and would probably affect a bunch of internal pieces both further up and further down the js ssb stack.\n\nIt might be possible to wrap a `Map` with a [`Proxy`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) to keep the js API the same while still guaranteeing order preservation in the details.\n\nI kinda want to start coding up #rust codecs, and knowing how they would later be tied to js (planning on using [neon](https://www.neon-bindings.com/), might end up with [NAPI](https://nodejs.org/dist/latest-v10.x/docs/api/n-api.html) instead) might influence the design.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "#rust"
      }
    ]
  },
  "signature": "+gXfPPy/Kic1dN51MdhKQL54exCxokg0ucdLwQuJXgnKRCZdubCD3jUsvXv4Ryz5LDLTsBlO9Z3srErW2uQSCA==.sig.ed25519"
}

{
  "previous": "%+47DMUYvisGwmgDn1O78TOHIaSeK6SPCpSatPMyDljU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 968,
  "timestamp": 1536310282721,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%xuiPnE46k6V1nd+opSS3H1/Snonbxa5ef3dtcF3NcPM=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "F3r5Qf79WLa/YdCjPURqmD1sAkPXXYER8PePuiQC6TTPCaK5mnwDuu8k7fo8rg6C8YS3GdvF3dgoRv+ZtmfqDg==.sig.ed25519"
}

{
  "previous": "%/QkTu/lbEWHb0oK7XaWBO2BJxVWrkNA6/q1VyG5oGZ4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 969,
  "timestamp": 1536310826104,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%PJSLTxC9285oM1AlRuWEgb61BMHmHwoNMJgg/96FAHo=.sha256",
    "branch": "%zAIpeeATsnkzk6079zZrCpecgg27aEKUmli7ONKYdRM=.sha256",
    "reply": {
      "%PJSLTxC9285oM1AlRuWEgb61BMHmHwoNMJgg/96FAHo=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
      "%zAIpeeATsnkzk6079zZrCpecgg27aEKUmli7ONKYdRM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Oh, and a quick warning: Don't get too attached to the idea that content would use the regular blob mechanism. It might end up that way, or it might not. In particular it would be inefficient to do additional round-trips for fetching content-blobs after receiving messages, instead it might be better to have specialized rpcs that send the content directly, by simply concatenating it on the metadata. Or something like that, I didn't spend a lot of time yet on concrete designs.\n\nSpecific desgns are also tied to message size limit considerations (we could increase the content limit, but we also need to keep in mind that fetching larger messages will slow down transmission of metadata), as well as back-pressure for parallel data streams.",
    "mentions": []
  },
  "signature": "tlb1Tja/eRSSx2j/dd+orTezsv0HyBwCokvsUp9vBdkZNQP9h2mRJ3r6Mih5QU7ohQFO0lQ15DBWpmnuStwtDQ==.sig.ed25519"
}

{
  "previous": "%qRHGrEPohu7ksOu95ovbeiBU6BLje6aEtuNKFhggf5E=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 970,
  "timestamp": 1536347756473,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%yBTzhXhBHHAcHD0uyuu68a935VMc/AFTQDuTJA/nWy4=.sha256",
    "branch": "%vwsLhdFRmuxlN3N3uNUNxaOA+QiuyJcFUiNVcZVsktQ=.sha256",
    "reply": {
      "%yBTzhXhBHHAcHD0uyuu68a935VMc/AFTQDuTJA/nWy4=.sha256": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519",
      "%vwsLhdFRmuxlN3N3uNUNxaOA+QiuyJcFUiNVcZVsktQ=.sha256": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> And yet we're programming SSB sequentially in NodeJS, C, Perl and Go. Because we all learned to program in the dominant hierarchy of computing technologies and everybody wants to just use what they're comfortable with first, and perhaps think about refining or evolving later.\n\nYes, we are all sheep too lazy to think outside of the box. None of us know about alternative paradigms, and there are no good arguments for deliberately choosing imperative languages.",
    "mentions": []
  },
  "signature": "kitkGojHPM4HAaDQU2P44xBO/L7Rh8yoEUX0FZuxfVbhV1nvkOhR7Q3BAevIk4UbcGk+7mFONGTXPM4Ae+XhCg==.sig.ed25519"
}

{
  "previous": "%FYZ5e/H6zRdF0mTGS6QswLY2MJFFHzCZCPrvf7tfySQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 971,
  "timestamp": 1536354994105,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": "%Le/vG1HuyxVMaRvpgGjKr9ag5byDpMI2E642O8/H8Sw=.sha256",
    "reply": {
      "%Le/vG1HuyxVMaRvpgGjKr9ag5byDpMI2E642O8/H8Sw=.sha256": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@cft](@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519) I only received your posts just now, but we independently settled (mostly) on using a strict subset of CBOR. I'll interpret that as a good sign.\n\nI was unaware of COSE, it is nice to see an \"official\" standard for this, although it seems like not much of it applies to ssb.",
    "mentions": [
      {
        "link": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
        "name": "cft"
      }
    ]
  },
  "signature": "v0cJQCuI0zUpCratjcZIxx0BnRGhNgEX0Vc8WTdGm0N1oG1EJI/KQNFYcvFiZW4kzYZ8GrWkvIa5XMghp5hKBw==.sig.ed25519"
}

{
  "previous": "%3r6sjTBz6pcqF98lWRqavdyD+PqRzmcE+tlCdYKZucs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 972,
  "timestamp": 1536355521818,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256",
    "branch": "%AcZTotJE76L1M7AuUYBcCKfS8hbx3OEvYWlNMiXU1wI=.sha256",
    "reply": {
      "%iS8bnaM4s2w0do3zj6XCcQEaKcoezaUcYTV7NNcsRV4=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%AcZTotJE76L1M7AuUYBcCKfS8hbx3OEvYWlNMiXU1wI=.sha256": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519"
    },
    "channel": "ssb-clients",
    "recps": null,
    "text": "[@cft](@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519)\n\n> [...] which seems to have been overlooked.\n\nNah, just discussed [elsewhere](%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256).\n\n> With a cypherlink-only approach, the query interface in createHistoryStream would have to change.\n\nCan you elaborate on this? `createHistoryStream` only returns messages from a single feed, and on those backlinks give us an total order (irreflexive), with or without any sequence numbers. So I don't see how `createHistoryStream` would be affected at all by removing sequence numbers.\nNote that `createHistoryStream` is used for (legacy, non-[ebt](https://github.com/ssbc/ssb-ebt)) replication, not primarily as an API for clients.\n\n> get up to N causally-youngest log entries (the heads so to speak). Ideally only one entry exists, but better prepare for tangles where there can be multiple tips.\n\nSsb forbids those. A forked feed does not get replicated at all.",
    "mentions": [
      {
        "link": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
        "name": "cft"
      },
      {
        "link": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
        "name": "elsewhere"
      }
    ]
  },
  "signature": "I7+fFEOMxB9fAtXAY5nNDghcy3zTDx96TXNWi1MbgLFjr5ZE/41hyAsDxg+lCx7SLnG9S3np2g+OuJqg1VKkBg==.sig.ed25519"
}

{
  "previous": "%bIzh9OYwQYl7fpv94Qdi1TFMGDJt3+NpA0lk8FCuTZY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 973,
  "timestamp": 1536355685995,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%mqiKbk/Hc9A1pvR8gPx4ub5GPWSFP7QkRXHK3dRlOko=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "NPrWVOh644l7yo6S3+0ieD4TJ21FiiBQviC1xIa3/meHXXrEI3KJSQv8ij5SieB8y9Dy6R8kNZ5pSCX/adfjCg==.sig.ed25519"
}

{
  "previous": "%CKBnLakSeSpO1eQIHGE8ZHGJhWQ6qMjTm3z/Xl6Sj30=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 974,
  "timestamp": 1536394610661,
  "hash": "sha256",
  "content": "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.box",
  "signature": "Ep4A7WuTqZ+as+xg4b+V0iJrRqX5vH+PhR6E6NdlpImFPsXtJ6mawxsH5TIwpVhq1b5bBTqpPeuJKOxSuYrbAA==.sig.ed25519"
}

{
  "previous": "%6k07mggF7iB8MPLyZicowZcJT/AA1gcSHlmUChMInFE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 975,
  "timestamp": 1536394859501,
  "hash": "sha256",
  "content": "W7aud8N5ewjqAolPojquuzrxYrhmlRQJhR24t8Ht1h2AK4K4yBfNY5mTL6LbEByoTlW5eZBjMg1qczpNeaynmlboNM+hfyYLLJW69W4KVUH7mnXuEzv0dFw/CYF2aCUGquy4qg9LZtZGT/6ZhzwcWpy45A9lKUThvxNIJ+ijur0b+zOAcSYZVJhqs/0Ig2QIxNaHakESg8g4mlhmiIrkdvRbbsug7ZK4CEYspw0i+XrCu5tydjaXo07PQLbFiRZZOqgHrDfQ/JPG71sEKuGxMX35ylkGVyMrUIOXANYVs2jqBIkRrbjMrdo7N1ZWASwtr3s2a7yxYdtMkYSJrK5REBM2WSa8SdccHW+64jN0auaPC4Qp0aKiquD85Q+5JZAz8gp8nmu416HgoKOmEBV9zL0blw2BFcz5OB3vpbsN9h1pXTTMSh3VT3MH2sD+jlur+Ko6vzTweDBAALScZOH5cSC+UrFEu4S8cMxVDpHBYiJjVy0tnP4SHlI2YQVKuLz/5n0ST9hgYAfUnGN/VnWXb6sF1pq/lNRut9b8vHF6OLXE1A+zb+4AeJMB7585+UYu+EIbsTyunu3jV1/uv4JHfvJTBJ+JEOIGQb/Bz6tZ7cBRozoAXuzAGJnxrETJMmHbe5hR/K/PuREMJtQBbG4rvGvsAXEE0Z3lCSRaRmmOKEBsXA6vm2l3X6vNNUIrxn+3EF3It6gNAttYwJeZk2UcdmGIRglgmtstMcDOgukCQbl8PQRH78OroeOrVOzETYKbl6MYg6NRYz89bBx6aKDLGXvbERintpKSJKAyxcj9P16RHc/rWBmqaD1+BCRqXikH96iS6Jw8xLE7/N2bSerztCOqRhVukFsiKae74otaij01Xuos/Q1Mx7zKIpldQZIB/b3TN4GNECSAy5Vtknm7lm21Wg1bmHHpfgTZGOKZCXNgz5l8g8gmhbxyAavJm7HzOrTAQ8shLiGSbiOfYLGMjF0zOz1O9dGzF4Iv1a3jAW2vCv7vrGVMriPvzHHgNhdxDoIh7q9fjptA+UuN9rJE7d8af12ji3w7ijUOQamYjwMNf/xYRAtbn++SdBqAVQ6b+ZBBE7vhiuhS8J5nmAw3s9LG+YS7UY84aszLOY+knXEhyMU9es5mnJqPRsFUPyho14Md5B0fjK5iWoVUHStmYI/gjEr7Kxvu/a3/udGsc9MsgagpHUcmXvibhUZc7HIWa9fyjpfQrOM6qCN72Ik2bVqFRFAWkua9uoW6Xd3KEAbW5J6IxDaH8ztpP4DpNYNQ8LiMORcJxqKTjQwQxj6DQvD7nnJNW7m+USPnquCqfYJM9F+sZe3J03CneqMKDXns8m8OhKlZk1f86UGUE+PFNGQ1qLQ0ErMrdBvAzm8Wx9wWMU+l8qlHfMCoDVVMNERD3GCiPdgQQnJu+nVlCaxkKvJvBok0fMhsI+XeXaO/vi/PdOrtLDg0C4W+gVaZE15sRwvpNLX7OzR5UDwJJ3osv76TssCxY58svYNOZh/Tu7l8d6EcRMwt2eN3ybItX5eQCQ7qCsVhMBPwKczRADtIPnuqzrJblCIKfMgjeSzB/CoPyyDFByiUFhNUbwaUmwUjE4uVDhQQUE86Qo4S+A8NuadtPHBiZ31nDpZHzfGizmUp6zDPYEJR/wmcL2akVeOYJDTi4GV85J/2lvlE4aC8Pw==.box",
  "signature": "Jhvm2S3VLt+OmQXlqZ6e3hENMF+rgmOv586MbGJJ9bDSuG3G/8ZdGMVG1CqXDoMMw3VL2xV+xAZwIHhzf4xTDQ==.sig.ed25519"
}

{
  "previous": "%5LNnrml+mu1uYuMIlcvFpeOxatEaRz/f3IGFgOXT80k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 976,
  "timestamp": 1536395172927,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%DBQkzKH3ABr7KeqD0Cy1MBWPUzHV4brr/nxnjXd8SJQ=.sha256",
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%DBQkzKH3ABr7KeqD0Cy1MBWPUzHV4brr/nxnjXd8SJQ=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) \n\n> Maps guarantee preserving insertion order.\n\nObjects do not. If the whole point of the semicanonical format is preserving order of entries, decoding into objects defeats the point. For hsdt where map order is insignificant, I do prefer objects for the js api.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "R8YcPCCGfIzH4GqumSijwuUWGafsVWM3unDIfDJyN4pOvW524UWNMk7XBkLJuOUK4zOddVE6vghaqr/jEB+WCw==.sig.ed25519"
}

{
  "previous": "%mF9Ie3cr62FMKNnnPCF0OMof20afHRhZ3927JXa4CvQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 977,
  "timestamp": 1536395498761,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%uO1dDsilxwSm+gMb210WgDpBEGnWH0qnD2zSE5o3TF0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "/XxE8VfRzZ0bN5ifKiiCB5ja9vimWCkbmGl+lRp4eLpgBkNpkQERSeeb8P8x2o8z7fzGCdJjChcHVH6mZ3RAAA==.sig.ed25519"
}

{
  "previous": "%utSQC1CExQpuvmYqMzeM8mNI7HkZF/uofDatDldJrLc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 978,
  "timestamp": 1536396023014,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256",
    "branch": [
      "%A/FTHW8A5cEBS0T1BLMe2K3hJs9/V4wda/KBgZWDtXg=.sha256",
      "%xZqjcngpQbzRoKF2n8n+MJgZ9VIX+LcyPAXS0N0NEy4=.sha256"
    ],
    "reply": {
      "%FI3kBXdFD6j+uISXluhirJm70QZpJIYzc65OX1XPJ5c=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%xZqjcngpQbzRoKF2n8n+MJgZ9VIX+LcyPAXS0N0NEy4=.sha256": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@cft](@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519) Disclaimer: I don't *really* know what i'm talking about when it comes to crypto.\n\n- ssb does transport encryption at a different layer of the stack, not directly on the (cbor) message data\n- signing also needs to account for meta data, which will not be in cbor\n- encrypted messages completely anonymize the recipients, I don't think COSE supports that. But these are probably the use case most likely to benefit from COSE.\n- in general, mechanisms for upgrading crypto primitives are handled via multiformats\n\nI will definitely do a thorough read-through of the COSE spec when starting to flesh out metadata formats. But for the reasons listed above, I does not look like we can \"just use COSE\" directly.",
    "mentions": [
      {
        "link": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
        "name": "cft"
      }
    ]
  },
  "signature": "uZo50nu5rffI/FjxNbQTHGxXBdPpNrgrINixZIFTn8xhGa4Ywrt4IxItJzuKcjWrxvxzfI02R82slJsz+4HFDw==.sig.ed25519"
}

{
  "previous": "%DbNCQ5aBfR+p+5qGPcHY5NUcgic7Frem4DKCPUn33+g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 979,
  "timestamp": 1536396935171,
  "hash": "sha256",
  "content": "JaKWUE3VNe0bhTVMVKlBXZsHZjAI8Lx6c8VuocYNRFVkIeqEqVC+E1mDJ/IbbxR7Xw2mk4v5nSw9Xv7F8NaHsZ3H4vJvYjZxSEdT75CYHzUBdQxsHUJrwyPFvmPnXXKyToEaIFiXGFld+Kud2ipnQP6BxIeZiqOHOnZTBmNDIxCbs7SPDfifzUgjVyVrEJn3bnbpeA1XDej4F9O4rDdh5Vzvrj9kInbElMY+8zStHTTWND372LkGubuSFlQgp3LLvv91a/oyqXpmls6i1MLj4PkxR/7hm2r3kpSvUcDn1abR/CI3olUtMzrkDjEg23XICiuddcPozgOwGijE6qz1rSKh+8cY7RrbdXV7f+yEDP6PV7kW+oQcWih/a44LAOMqkSW5jaoUFnY32kNTfdiE5K4EEfzemHR/XfmKEExqf2askP8bbr4M7K8frRLDi4juUABFIOD1jbyBNQ51n+wXVW8XVarNHLd933/KCAOeRAbjtPdlszjxbm9APiAr9gtmgfwxkJ0nkCUkT6i181w+VReZRsOmJhq1N81/Z4u/3dvvkh6mVFEvsMsU+hxFPRTf2eWNNNZ/7Y5qGChW88lkxwrXUcEuhZ4A2bkW4hVIdiT5Y2obEGltdsYVfRcCjobU1IvzqB55H+Dl0FVE01WOYubXV9cGJcmYLlPH/9O85EMs7rPZfIBDstkYbDWC27QgRlbq3uHy+rvRmPAuGsjzXcww/ZOZyjNk7agINZloY4KJCmgOeTsf3vlWW05bACJ9FS6o+O01xy0iO+5HHwG3xnbwzA1pgYmYaQ9fC//KFtC89fGr5x3AbfnhsceqbfeWVJHKdheigdml7Er86CSG/XjWZHny4/zIC1ToIJG9Sh9gyF0opaaA5dNX9K2Go7KRAaNBAID1d9DUKBXErEok+XxCgWsuS1iI0prYwxshHSaq9AIZcQh3vTPex2cyHBEFmrP0QF7wNCKtF/v8BGy3AzCyBVl4lZDoeu0eMtrny+RSRdq7hm+qXjlbX14/gBnNm/ibA/ImrzJcgw+HbK6FXoNJplDr9Zbvt4KkEe8rkFbaimgwt5FbGEUsHbXdh6T6gSB5prV4LSqOajWdzCW18nzvudSyo+qUE+rKKj2d99wi/4uMuJ5NkQzpOYNjxrBdbFRfrFLETBAOmfv8RF8aMCkijWFHIMs32l1l0zViJF09P5/cHub6ijUPpOKjhxJvuGDs/tKI4hbXqEb5elEyMowkVTfmkBRRmoBqRiL2Ui5KzgI9OAW9I35hv7SNeXhNqJoa.box",
  "signature": "iz1Uhp+SRPh/vIcXtCFTYuYCziofABC1FRwCXxfXwbW6U1jGVjUcmg9sAgK+/0/gF3oY5m4f24Oc0y3C2IB1AA==.sig.ed25519"
}

{
  "previous": "%i/QR0tmihrNs0Mh4BalAvtR3WvTMGszSrNxR+l0bjwk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 980,
  "timestamp": 1536400065492,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%1QzUQSm2Pb7XEB6cPBZxzBH4s/dUsnZWB9Pr5o1z0o4=.sha256",
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%1QzUQSm2Pb7XEB6cPBZxzBH4s/dUsnZWB9Pr5o1z0o4=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "In that case I'd prefer objects and ssb code using one of the methods that preserve insertion order.\n\nIndependent of that, the rust implementation will define traits for maps and arrays, and the value type will be parameterized over which map and array to use. A pure rust implementation could then use std collection types, whereas node bindings could directly create js arrays/objects (whether they are normal js objects or foreign ones does not really matter to the codec itself), without additional copying overhead.\n\n```rust\n/// A type that represents the (logical) array type of the data model.\npub trait Array\n    where Self: std::marker::Sized\n{\n    /// The OrderedMap implementation to use together with this Array implementation.\n    type OM;\n\n    /// Create a new, empty array. The argument can be used as a size-hint to allocate storage\n    /// space. The fully parsed array will never end up smaller than `expected_size`, but it might\n    /// grow larger (because the parser can't trust the input and preallocate huge chunks of memory).\n    fn new(expected_size: usize) -> Self;\n\n    /// Append an entry at the end of the array. The parser will overwrite it, it does not matter\n    /// what exactly is appended.\n    fn append(&mut self);\n\n    /// Get a mutable reference to the entry at the end of the array.\n    fn get_last(&mut self) -> &mut Val<Self, Self::OM>;\n}\n\n/// A type that represents the (logical) ordered map type of the data model.\npub trait OrderedMap\n    where Self: std::marker::Sized\n{\n    /// The Array implementation to use together with this OrderedMap implementation.\n    type Arr;\n\n    /// Create a new, empty ordered map. The argument can be used as a size-hint to allocate storage\n    /// space. The fully parsed array will never end up smaller than `expected_size`, but it might\n    /// grow larger (because the parser can't trust the input and preallocate huge chunks of memory).\n    fn new(expected_size: usize) -> Self;\n\n    /// Append an entry pair at the end of the ordered map. The parser will overwrite it, it does\n    /// not matter what exactly is appended.\n    fn append(&mut self);\n\n    /// Get a mutable reference to the key of the last entry.\n    fn get_last_key(&mut self) -> &mut str;\n\n    /// Get a mutable reference to the value of the last entry.\n    fn get_last_value(&mut self) -> &mut Val<Self::Arr, Self>;\n}\n\n/// A f64 that treats all `NaNs` as equal.\npub struct StrictF64(pub f64);\n\nimpl PartialEq for StrictF64 {\n    fn eq(&self, other: &StrictF64) -> bool {\n        if f64::is_nan(self.0) && f64::is_nan(other.0) {\n            true\n        } else {\n            self.0 == other.0\n        }\n    }\n}\n\nimpl Eq for StrictF64 {}\n\n/// A value, this represents any of the (logical) value types of the data format.\n#[derive(PartialEq, Eq)]\npub enum Val<Arr, OM> {\n    Null,\n    True,\n    False,\n    Utf8String(String),\n    F64(StrictF64), // All `NaNs` are treated as equal.\n    Array(Arr),\n    OrderedMap(OM),\n}\n```",
    "mentions": []
  },
  "signature": "PP99UWYy5Rhm990DMiWlipL9nZ0YQBD7hCa27zu0nPBJjdq2QwmcJLXWd7YdVYLEZOygLYfWcB48WwWTKIS+Cg==.sig.ed25519"
}

{
  "previous": "%rgXCgZBnvtyfpKORNJuzevpQZ3Wt9x4ICSDat1LjHyM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 981,
  "timestamp": 1536401014895,
  "hash": "sha256",
  "content": "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.box",
  "signature": "gF+1tbvBgo3BMQxkk+yqjWRhJbh4vBm0vTLhRrf6A4Hv/R2JhuN3DkRRJkpx4eyyZ4LPRi31OQfxv/rs0CUKCg==.sig.ed25519"
}

{
  "previous": "%ckBQxcO3pIYnPhHK+8m8fp1TrZxx6Ajb9xo+wrJlCoY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 982,
  "timestamp": 1536404180245,
  "hash": "sha256",
  "content": "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.box",
  "signature": "cA3iSEnBl/mQ+nzepRoVxCsKzGznztg8zPbs/kYYDLrVwn/4hpBL4jZGNLUV7z0YbfXHG2KAd1Cb1o0WmG+nDw==.sig.ed25519"
}

{
  "previous": "%u3mfAlIcGI62LkNl0+CiKfGztRJfESAE3S0u1EXSuZQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 983,
  "timestamp": 1536404450554,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%n8hpdMJQCCDNdzeCEDh7MeIKOLBKrCO073418DW6tT8=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "8q2thtZDg8R1SBR0yH5VlQ4PA+WXhkw0I/5Ei+sxS7IUKLivvT4h/hTCNOsmW5pXJI0C31v6u6BkWVAC3i/RCg==.sig.ed25519"
}

{
  "previous": "%IvHtizb4kHZEMeoF/SILowinnBIo+euGUcZuVH0obJk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 984,
  "timestamp": 1536409679476,
  "hash": "sha256",
  "content": "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.box",
  "signature": "FH9enAKPUBRPqr1/vs6RT0oMAFaiuQtldD3l6P/lSTAM8cyaBM/xLn/iR+lumCOTfbn6IcvbvprF9VJjQKJxDA==.sig.ed25519"
}

{
  "previous": "%X5U+edzfliAhtk8zxcIciCx0hKrVOkTXIeqwm27mRWQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 985,
  "timestamp": 1536414196558,
  "hash": "sha256",
  "content": "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.box",
  "signature": "rTjlOFzKmbY5WP9TPcxt3DbgMo5Xf0Xl+67V5FUn9IDg2EsUI9VzhfdSoNeelboilde0midKdRHG17pu9rakDQ==.sig.ed25519"
}

{
  "previous": "%1z2c1CZT2tf7IdEYk8R64SbA3LrCTrp11Y1e4h0IdUo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 986,
  "timestamp": 1536422746121,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%I4DuXYTI7hBG0tJKz1IGG/uFTW/FCK5l+/Qk2HjvTsA=.sha256",
    "branch": "%wqt7GwBGbQeHTzPFH1gmMKghGq7zicc4/dunzsZcomc=.sha256",
    "reply": {
      "%I4DuXYTI7hBG0tJKz1IGG/uFTW/FCK5l+/Qk2HjvTsA=.sha256": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
      "%wqt7GwBGbQeHTzPFH1gmMKghGq7zicc4/dunzsZcomc=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "The [readme on tangles](https://github.com/cn-uofbasel/ssbdrv/blob/master/doc/tangle.md) will be interesting to those who [discussed](%+fBXl12aV1wpAdD62RMl1WRhwthDMuAuHH4iNWgB7jA=.sha256) the design of the post-message's `branch` property: CC [@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) [@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519)\n\n- - -\n\nCompletely unrelated: [@cft](@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519), have you by any chance interacted with [Uwe Nestmann](https://www.mtv.tu-berlin.de/nestmann)? I vaguely told him about ssb a year ago, but the group headed into traditional blockchain-country instead. Well, and it is still a theory chair. But it is nice to see a CS prof from the distributed systems/network community here on ssb. It would be a shame if bitcoin and ethereum completely overshadowed all the other interesting stuff happening in the wild right now.",
    "mentions": [
      {
        "link": "%+fBXl12aV1wpAdD62RMl1WRhwthDMuAuHH4iNWgB7jA=.sha256",
        "name": "discussed"
      },
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
        "name": "cft"
      }
    ]
  },
  "signature": "RcYCN1HacFhT7Q1ETEK8MUEWvMKIFo3wQF+D3FyNJRPgB/k0cwkg/c2Clf7TxUlNGBJ8MZjkW3ULXnb0JlFCCA==.sig.ed25519"
}

{
  "previous": "%vilcX6/hPk75h17ncEc4bRfSgJ8lmBvs2m9FWuCVKx4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 987,
  "timestamp": 1536426116599,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
    "following": true
  },
  "signature": "pEYY60o5z4t24V0+L0bz+dBLp6d6QxJONl5csDsMBKwcB1SXDnXCR0OrfNkeNvqAJCwfg/7JRzwn5/UxSdeMBg==.sig.ed25519"
}

{
  "previous": "%uLZBuuUCjh5MI2kbelLBL1PI1EoD1IkGiDsvPtd+BmM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 988,
  "timestamp": 1536432348271,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-tangles",
    "text": "Here is another use-case where tangles emerge naturally in ssb: Aggregation of entities. Github has both user accounts and organization. A repository could be owned by either, and since github is centralized, there are (relatively) few problems with that. Now compare this to git-ssb. Each \"user\" is simply an ssb feed, and repositories are tied to one specific feed. It is not possible to have an \"organization\" of multiple feeds that collectively owns a repository. A lot of code relies on the total order of messages in a feed, and an \"organization\" does not provide such a total order. Tangles are the natural way of restoring total order.\n\nAnother, very much related problem is that of multiple accounts of the same user. A forked feed does not get replicated, so it is risky to use the same keypair from multiple devices. Instead users are encouraged to create one feed per device. [same-as](%uB7DTsgCgOgH46vKrlzNQTP0DuLcIzIVOXy0ukIWwaE=.sha256) messages are a suggested ad-hoc way of approaching this problem, but they don't solve it on a fundamental level. Instead, each application would have to interpret these messages on its own, implement its own tiebreakers for causal ordering, and needs to deal with forks. Different applications will do these things in different ways, leading to an incoherent user experience.\n\nSsb as a protocol chose a design that allows very simple replication - a linked list of messages. The two (in my opinion) most fundamental problems arising from this are the inability to subscribe to parts of a feed, and the inability to aggregate feeds into higher-level, totally ordered message sequences. Both of these are actually two sides of the same coin: A partially subscribable feed could also be viewed as multiple independent message sequences that are aggregated into the larger feed.\n\nA while ago, I mulled over ideas for (non-ssb) protocols that support this sort of feed aggregation. The fundamental problem is getting a total order, and the conclusions I arrived at mirror the tangle structure. There's a very rich design space there. For example, with feeds not necessarily tied to a keypair, anyone could take any sort of feed and aggregate them. So I could create a \"git repos @Aljoscha considers interesting\" feed, and build clients that let me see a summary of them. As a consequence of this, there is no central authority on the \"one true way to see which feeds are authorative\" in any sense. Feed aggregation would not be a containment hierarchy, you wouldn't get a tree of feeds, but a dag.\n\nTaken to the extreme, such a protocol could allow arbitrary feed aggregation. Returning to the example of github organization: A user who is not part of an organization could simply create a new aggregate identity that includes the old organization and themselves, and could then start commiting to the repo. A more general point of view is that such a protocol has built-in support for forking any kind of stateful entities which are computed by aggregating messages. Viewed in this way, there are interesting avenues regarding CRDTs to explore.\n\nThis leads to interesting choices in tangle extension conformance rules. Whose contribution to the tangle do you accept, whose contributions do you reject? Anyone could proclaim themselves part of a git-repository owning organization and start pushing to it. A client could choose whether it considers this person to be indeed an owner of the repository, and either reconstruct it with or without those messages. There's a fun rabbit hole here about deciding whom to consider the core of an aggregated identity, and who does not belong to it. Or the protocol could instead be more restrictive, only allowing an aggregated identity to take in other identities, but not the other way around. As I said, a lot of design space.\n\nThe major selling point of this family of protocols would be the fact that applications could code against an interface that completely hides whether the identity it deals with is a \"physical\" identity (based on a single keypair) or an aggregated one. This would eliminate the need for same-as messages and give apps like git-ssb more power. And you'd get partial subscriptions for free (although only the person(s) creating the messages could choose the granularity of partial subscribability).\n\nThe highly subjective view of all data - deciding which identities to treat as parts of a larger one - presents some challenges, in particular it would lead to unfamiliar user interfaces. I'm personally fascinated by the possibilities of interesting stuff that could be built on this, e.g. the ability to switch between different views of reality depending on whom you trust. But this certainly won't be the protocol to overthrow facebook...\n\nThe largest drawback however is the loss of simple replication. A replication scheme purely based on \"physical\" identities would be rather inefficient. A very high-level aggregated identities could (transitively) consist of many physical ones. Ideally, the protocol would not get less efficient for highly aggregated identities. But the alternative would need to somehow compute which physical feeds to replicate based on some sort of efficient representation of the high-level identity. Combine this with the subjective views on whom you consider part of an identity, and you get a lot of inherent complexity. I don't think this is unsolvable, but it is far from trivial. But who knows, maybe sending bloom-filters of \"physical\" identity's public keys is efficient enough in practice.\n\nHmm, looks like I *slightly* digressed from the original point that tangles are a more general solution to multiple feeds per human than same-as. But I haven't written down these thoughts anywhere, and the #ssb-tangles channel is a nice excuse to do so, so I'll just leave this post as it is. Feel free to ask any questions if some of my rambling is unclear.",
    "mentions": [
      {
        "link": "%uB7DTsgCgOgH46vKrlzNQTP0DuLcIzIVOXy0ukIWwaE=.sha256",
        "name": "same-as"
      },
      {
        "link": "#ssb-tangles"
      }
    ]
  },
  "signature": "efq2Nb31IDcsA5gLRYjFgBbI6tvXw8ATuE6hnzVY/rGq4eIJ3WGOGkhQ0WKV3vOqtLGzS4Ut/vYrAOXnSmzfDg==.sig.ed25519"
}

{
  "previous": "%DiKg7pb5f8nK+9UXYkh0NFycwI4311vFpl7sJQQVV0E=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 989,
  "timestamp": 1536433417824,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb-tangles",
    "text": "A few remarks on (parts of) the [tangle.md](https://github.com/cn-uofbasel/ssbdrv/blob/master/doc/tangle.md) [@cft](@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519):\n\n> However, based on the available information in the logs, it is not possible to deduce strong happened-before relations among `about` events i.e. who committed first.\n\nThis reads like deducing the happened-before relation is impossible in all cases, which is not correct. Any cypherlink between any two messages gives us cryptographic guarantees about the happened-before relation. No current implementation tracks all of them, but it would [be feasible](%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256), and this is one of the blockers for completely removing mandatory timestamp metadata (the other blocker being people really liking timestamps).\n\nExplicit tangles in messages allow explicitly closing the gaps in the partial order, but who knows whether that is actually desired in all cases? And as there are no authorative message schemas, any client can chose to not store explicit tangles. Of course, other applications can require those and ignore messages without them, leading to some sort of fork where users choose which side to support. There are only few absolutes on here.\n\nAnother consideration is index building in the database. Decision on which cypherlinks to include in messages are often based on which queries to support. Flume, the db used by the js ssb server implementation allows plugins that create database indices. Most devs will primarily consider those, establishing causal order is just a side-effect. This may or may not be another drawback of ubiquitous timestamps.\n\n> In our SSB Drive design we have therefore clearly separated the tangle weaving from the fields that are relevant for the use-case alone.\n\n:+1:\n",
    "mentions": [
      {
        "link": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
        "name": "cft"
      },
      {
        "link": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
        "name": "be feasible"
      }
    ]
  },
  "signature": "OHIn6p+QYARTfZETvgPu7qJXOXjWLPnFsWG1fwwJ0FuUBnUv4csniPUu9LDqkRDSf4gqTHmxknSu794BLRPqDA==.sig.ed25519"
}

{
  "previous": "%2mcdZaQxyxImS1cesE29QPitWVd3cm1EIvfwOQmfi6c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 990,
  "timestamp": 1536433860328,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%IhsYSEFyynh7Tu0VYddiIylUmICawKSvIp7Akgp1W0k=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "J0s/P9zroDJM2YFyA3PV3hn4DTfp8aaYYaPE+sqKMBfhs4HFYK9LOQ14S8ZT5wMbN1EkX6BW+Oz6kJcRUDVjDA==.sig.ed25519"
}

{
  "previous": "%tf+QpiLZET7FpOmsevjsB/Qg08S+0nh2PAruLzxaAvc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 991,
  "timestamp": 1536434837641,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%YH6PDaakwNu0D83EBHBLuwSlVhr/5aezVoE8p0IaNf0=.sha256",
    "branch": "%mqiKbk/Hc9A1pvR8gPx4ub5GPWSFP7QkRXHK3dRlOko=.sha256",
    "reply": {
      "%mqiKbk/Hc9A1pvR8gPx4ub5GPWSFP7QkRXHK3dRlOko=.sha256": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
      "%jxEH4dy298BPMEM4oWm/bAUo7xJITE6uZINVpLrBqs4=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Just jotting down some immediate thoughts/questions on [this post](%mqiKbk/Hc9A1pvR8gPx4ub5GPWSFP7QkRXHK3dRlOko=.sha256), without yet having fully thought through things:\n\n- much much does the ssb vs ip analogy hold? Packets holding ip addresses are ephemeral, so at some point the last ip4 packet will disappear. Ssb needs to store all old messages, so we don't have that luxury.\n- each cypherlink to a message signifies some sort of trust, it implicitly establishes that the author considers the linked-to message valid. Does this trust vanish in an upgrade process that turns old messages into new messages?\n- how does this relate to changes in the message format?\n  - breaking changes (such as making maps unordered (yeah, this is a breaking change, we are kinda cheating by assuming that no applications rely on map ordering (let's keep being pragmatic please, we don't want to be stuck with ordered maps forever)))\n  - non-breaking changes such as adding new data types (e.g. integers)\n- how does this relate to updates of cryptographic primitives? Looks like somewhere in here is a mechanism to preserve (at least some of the) trustworthiness of messages whose cryptographic primitives have been broken.\n\nWould be delighted if anyone has more fully formed thoughts on these points or could link to some literature.\n\nCC [@cft](@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519) (This is the last @mention spam for today. Probably. Unless it is not. It's really unfortunate your feed got delayed and we could not have any of these discussions closer to real-time.)",
    "mentions": [
      {
        "link": "%mqiKbk/Hc9A1pvR8gPx4ub5GPWSFP7QkRXHK3dRlOko=.sha256",
        "name": "this post"
      },
      {
        "link": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
        "name": "cft"
      }
    ]
  },
  "signature": "/hUdgc0C+kMvKt8p1DWRsx17BhFUBRUVLu4lSUMZln6h30XxdN4j60qh76Hmt7cubk+Vtg4ATV9qvCMzKI7ODg==.sig.ed25519"
}

{
  "previous": "%Oa+reViWN5VtHd+JPb/CzJ7BM9Z//Hw/IErYlJ8CTeM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 992,
  "timestamp": 1536438843216,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebutt",
    "text": "# Proposal for a Simple-Validation Replication RPC\n\nWhen an ssb server receives a new message, it verifies its signature. The message may be sent in a different format than that used for signing, this is true for the current json encoding, and it may be true for future compressing encodings. So in order to verify a message, the server needs to know how to encode it in the correct format. In the case of json messages, this is [really painful](%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256).\n\nI propose adding a new rpc method to sbot that works like `createHistoryStream`, except it emits objects of the form\n\n```js\n{\n    crypto: \".sig.ed25519\", // the cryptographic primitive of the signature\n    signature: [0, 0, 42, 17, ...], // the claimed signature of the raw message\n    raw: [0, 42, ...] // the raw bytes that can be given to the signing function\n}\n```\n\nThe receiving server runs the signing algorithm specified by the `crypto` field against the `raw` buffer. If it matches the `signature`, the message is verified. Decode it, then add `signature` to the metadata of the decoded object.\n\nThis means that servers only need to know how to decode all signing encodings previously used by ssb, but they do not need to know how to convert from transport to signing encoding. The server implementation itself only needs to implement a single message encoding, which it can use for producing its own messages.\n\n*This is **not** intended to replace createHistoryStream, only to allow supplement it.*\n\nDrawbacks of this:\n\n- There are usually good reasons for having separate signing and transport encodings, this function ignores them. In the case of the json encoding, that means sending a bunch of whitespace over the wire.\n- A server that does not know how to restore a transport encoding from a signature encoding can only relay those messages via the same rpc to other servers.\n\nAdvantages:\n\n- allows new server implementations to quickly talk to the main network, fosters experimentation\n- reduces the work that each new format imposes on all server implementations\n- any implementation can still chose to support old transport encodings for efficiency\n- I will never be forced to implement the bizarre json encoding\n\nOf those advantages, the second one alone is enough in my opinion to justify this rpc. The first one will be extremely valuable as well. The fourth one should be completely irrelevant to the decision on whether to add this, but it is true nonetheless, and it makes me happy.\n\nA few more points on potential drawbacks:\n\n- any \"serious\" implementation should use ebt replication rather than createHistoryStream anyways, so this should not have a lot of impact on overall network performance\n- this warrants persisting data in the form it was received in, but iirc the go implementation currently needs to do that anyways (can't find a link though, I might misremember this)\n- implementing this should be rather easy, so this will place little burden on future implementations.\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519) [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) ",
    "mentions": [
      {
        "link": "%SauuZIie5mLHH2zKl1vZmBXCHI/aNNt0NjoMKDx37Vw=.sha256",
        "name": "really painful"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "9yi51Ha2j+FwuP9RL0/ClTFWVdgupbA3zf9LrNWQvxhNXVWXu5zjbCqgJEw4Ssgvc5qv88KsKU+R4RajMKDOCQ==.sig.ed25519"
}

{
  "previous": "%7FGRr9OvcCZE4ubo87Ai7qxV3yp7kekEUIgRJxyRDUc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 993,
  "timestamp": 1536439128385,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-tangles",
    "vote": {
      "link": "%sFpWV+kqNbuoWj9MYluuPm25MznBpIaz3CVUn9cpHPY=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "uBkqnxZnb4JAO8B/jiRL32GOvIa41XlqDpbbAHJQarl+2wVd0d8K0nJbGuVkMEHCKN3sVS54EDmGxM4u9hjPAw==.sig.ed25519"
}

{
  "previous": "%xit3y5jZ8yepSOA89DJ+uHKsAhaQRZRHbDSRPt+JaYY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 994,
  "timestamp": 1536440914658,
  "hash": "sha256",
  "content": "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.box",
  "signature": "Oozp+jYtJop1m7gVs16SI9KSPazc+hUYDALPnk+H08AuotW9XwQWWcIasDgQ1Yzne/RA3Hl9RqfSHOiTFJxjDw==.sig.ed25519"
}

{
  "previous": "%odrjOSRyZ3RhqTPNDdIW73bsK6d3rGIkEfi82nINgxQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 995,
  "timestamp": 1536477869554,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256",
    "branch": "%f00PrGMe66vEB10Yb54q2KDOM5usonuHsVIIY8dZjKE=.sha256",
    "reply": {
      "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%f00PrGMe66vEB10Yb54q2KDOM5usonuHsVIIY8dZjKE=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) Not even optional timestamps, which don't change the backend at all? We can wait until the client devs have tried out how much that would affect them. Pretty please? Well, ok... :broken_heart: ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "SHuehxAVNwJqGqfKo5/ggxN6X8ouUJ60AB8nvDsHHaTl3a8/Jkao/J5A1cg/mkWdFv6txLHWHXnL43TBT/rdBw==.sig.ed25519"
}

{
  "previous": "%NmC5u6cvQMvYMSmTkyX/k701TPjhi7ppKu2IGfjGmiM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 996,
  "timestamp": 1536485378703,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256",
    "branch": [
      "%5ipmWIYplwb00GjtaZYCkiYFjG4iC38o4VRhYKGCQgU=.sha256",
      "%9kF8rVltZLELRL3+ZPbs0/OOLRZ21RkoXxCMDbZ+riY=.sha256",
      "%PCVHU4Uw9osJOj6R2xR6isEpV/GcWzlBtFItYffD5Tw=.sha256",
      "%bhMMNZxnJqyiGtZ03ce2to1VnVRJ+0yY1Zh1zNfWzNE=.sha256",
      "%nHW7oPyZnFqmWn+RHJJSSKEJ7OvBM8Ra3u28pD3ocrQ=.sha256"
    ],
    "reply": {
      "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
      "%nHW7oPyZnFqmWn+RHJJSSKEJ7OvBM8Ra3u28pD3ocrQ=.sha256": "@RJ09Kfs3neEZPrbpbWVDxkN92x9moe3aPusOMOc4S2I=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Unpopular, unsolicited, and polemically one-sided opinion incoming: I think restrictive gossiping is a bad idea.\n\nWhy? It can not be enforced. Restrictive gossip is intended as a mechanism to keep data from being truly public, instead making it only visible in some sort of social sphere. But this a distributed system, once you send data to someone, you can't do more than nicely ask to not leak it. But at sufficient scale, these data leaks will be **constantly happening anyways**, whether it is through malicious behavior, well-intended efforts such as the public viewer, carelessness, laziness or plain bugs.\n\n\"But we have blocking, we will block these users.\" Sure, but that won't undo the data leak. And first you need to realize that data is being leaked. Somewhere among the thousand people of your foaf radius (which may or may not include popular pubs). And also, this directly conflicts with the premises behind out-of-order messages.\n\nNo matter what kind of promises any number of mainstream implementations make about publicity and crawlability of data, it does not change that fundamentally:\n\n- **every unencrypted message on ssb is public forever and to everyone**\n- **every encrypted message on ssb will be public forever and to everyone, not today, but tomorrow someone may break the crypto**\n\nTalking about restrictive gossip does nothing more than closing the eyes and hoping the problem goes away. It won't. All this does is to give a misleading sense of security/privacy to nontechnical users, who will then suffer the hardest when data gets inevitably leaked.\n\nA strong protocol should embrace [0] the realities of distributed settings, not willingly ignore them.\n\nCC [@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519) [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) [@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519)\n\n[0] In this case, this could for example mean using ephemeral public keys for replication to increase user privacy, or gossiping over a resilient random overlay network. But let's not get into that right now, I just want to bring up that there are indeed gains to be had from accepting the loss of control over data access that ssb inherently brings with it. ",
    "mentions": [
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      }
    ]
  },
  "signature": "l7RbLO9zPjO4Yd0WWYHmcQfanHSAsF49UaB2B0qhX3Yh+DLgaxm79WIHpRAc9+EQDuIOwcIjH4HT3SFf9570Cg==.sig.ed25519"
}

{
  "previous": "%frR3+PWtcNdnV8DBlMMjPSH6mSJFMQSU/FFzcJPFzs0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 997,
  "timestamp": 1536488442927,
  "hash": "sha256",
  "content": "VSk7z9O8hJmxTllr4wSQlbbNXuj3I4LnbBASm28U/LTPo33gWcvS3PjKZaJVPRXU7+FHeO1tlwy9Nuo/psMMNnUkdn5kglK/H7QnI81letqeJ9XTLK1IMJUsYo8eP+8A0usgS7LMQbgsKCdrtohocWTiz8GHYfBGvEQbpZ88m7iaDaZ+b7FSmxEyR9aU9qB+MR5wiBSQtPx2OXaf0UukFDa7Timjgl/Q9cI/4TfIxtfMZa1oAl91P80tghNVj32y5Y4DhVUvq8AIp0znP1miqCemNQDJuyVpDVcifcbmV/6PDfXQjXLhn213Z+eplRVSITpNOVnob2A+pfNfKnkc43NfxhxRTuMiphEuKRxhvaoNGvN43ozxQV6IhKFH0EnqMA+sifuZnX0ccpVw9IVdW2NkXw6eBE0ILOO3skuObqJR5UT4cTjhepkMb2BXGnRcZdWv6tlThFh9m6EPDsDkzX3EHJ/WSB1gdyEijmkWNJYUp6H4M0q1DivRqSjfpSftljV0USzO478wid7xr1cxiWAwyDglUVTxMv/XJaL9XqS16r5Ug/76/NJNvaxRLcm2s5Gohc3y.box",
  "signature": "/pnxa5KSJ047FquJ00GfhVc/uq9wma0G2wFg4s6JTtyOGx7/Y7RUb/pjfTVV3hh3kaqw/c/xF9EHHFgSX6wFAw==.sig.ed25519"
}

{
  "previous": "%1m2XSbtSdOF/jymJ4xfv46DKGm8tm91voe34ngibfa8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 998,
  "timestamp": 1536499592493,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "hsdt",
    "text": "# Fun With Cypherlink Encodings for HSDT\n\nHsdt will treat cypherlinks as special data types. So we get to encode them any way we want. Wheee, endless possibilities and lots of room for bad decisions!\n\nThe current (stringly typed) cypherlinks used by ssb consists of three parts:\n\n- the *sigil*, indicating what sort of entity it links to, currently one of feed, message or blob\n- the *primtive*, indicating the cryptographic primitive that computed the cypherlink\n- the *content*, the raw data that addresses the entity\n\nThe sigil dictates which primitives are allowed, it does not make sense to have the \"sha256\" hash function primitive on a feed id (which is just a public key), vice versa a message link of primitive \"ed25519\" would be meaningless.\n\nAny sort of cypherlink encoding needs to be future-proof, in that it supports\n\n- new sigil types\n- new hash functions\n- with arbitrary (but fixed) digest sizes\n- new keypair primitives\n- with arbitrary (but fixed) public key sizes\n\nHsdt is based on cbor, so how can cbor be extended to accomodate cypherlinks? Cypherlinks are simple (as opposed to compound) values, and there's a whole [major tag](https://en.wikipedia.org/wiki/CBOR#Primitives_(Major_type_=_7)) for those. Of those, the additional types `0` to `19` and `28` to `30` are unassigned, and hsdt does not use additional types `23`, `24`, `31`, and possibly `25`. Even if we leave open additional type `25` (cbor assigned it for 16 bit floats), that leaves us with 26 values to use for efficient encodings. Allocating multiple additional types allows to very efficiently represent currently known cryptographic prmitives (and even some unknown ones).\n\n*Side-note on hsdt extensibility:* It might seem reckless to use up all of these potential extension points for hsdt. But there is an interesting interplay between protocol extensions and canonicity requirements. Hsdt has to reject any non-canonical content. But suppose it also supported future extensions by requiring implementations to ignore certain pieces of data. An implementation could thus accept some message that contains an unknown data extension, but after the implementation learns about that extension, it suddenly detects that the included data was non-canonical. Should it now retroactively ignore the message? This problem basically means that there can only be very limited extensibility in hsdt, as will be used below. But fundamental changes will require a (conceptually) new data format with its own hash primitive. So hsdt itself can happily use up a bunch of cbor's extension points, as they could not be built upon after the initial specification anyways.\n\nBack to the actual encoding: The first thing we need to have is fully future-proof encoding of arbitrary cypherlinks. My simple suggestion for this: A (canonical) [varuint](https://github.com/multiformats/unsigned-varint) for the sigil id (these are small numbers, not ascii sigils), followed by a varint for the cryptographic primitive's id, followed by a varint for the length of the content, followed by the actual content. Basically a [multiformats hash](https://multiformats.io/multihash/) preceded by a sigil, and with our own table of hash ids.\n\nWith the general encoding done, there are still additional type bits left to concisely express cypherlinks. For example the tag byte `0b111_00000` (major type 7, minor type 0) could be a shorthand for `{sigil: blob, primitive: sha256]`. Since the primitive has a well-known digest size (32 byte), there's no need to encode, it tag byte can be followed directly by the content. Encoded this way, the cypherlink takes up 33 bytes in total, whereas the general encoding takes up 1 + 1 + 1 + 2 + 32 = 37 bytes and requires a bunch of varint encoding/decoding.\n\nThese compact encodings can also be pre-allocated for not-yet-used primitives, we could reserve an additional type for a hash function with a 64 byte digest, without having to know which one exactly it is going to be.\n\nMy suggestion for these efficient encoding slots are as follows:\n\n- `{sigil: feed, primitive: ed25519}`\n- `{sigil: feed, primitive: unknown_but32_byte_public_key}`\n- `{sigil: feed, primitive: unknown_but_64_byte_public_key}`\n- `{sigil: feed, primitive: unknown_but_64_byte_public_key}`\n- `{sigil: feed, primitive: unknown_but_128_byte_public_key}`\n- `{sigil: message, primitive: json_sha256}`\n- `{sigil: message, primitive: transitional_semicanonical_sha256}`\n- `{sigil: message, primitive: hsdt_sha256}`\n- `{sigil: message, primitive: hsdt_without_timestamp_sequence_number_feed_id_sha256}`\n- `{sigil: message, primitive: transitional_semicanonical_unknown_128_byte_digest}`\n- `{sigil: message, primitive: hsdt_unknown_128_byte_digest}`\n- `{sigil: message, primitive: hsdt_without_timestamp_sequence_number_feed_id_unknown_128_byte_digest}`\n- `{sigil: message, primitive: hsdt_another_unknown_128_byte_digest}`\n- `{sigil: message, primitive: hsdt_without_timestamp_sequence_number_feed_id_another_unknown_128_byte_digest}`\n- `{sigil: message, primitive: hsdt_without_timestamp_sequence_number_feed_id_unknown_256_byte_digest}`\n- all of the above `sigil: message` slots again for `sigil: blob`\n\nTotal: 25 efficient slots, plus the general encoding, takes up 26 of CBOR's primitive values.\n\nDue to the canonicity requirement, implementations must use efficient slots whenever possible. We'd define representations for all of these in the general encoding as well though, because future formats might want to use different efficient slots and would thus refer to these legacy primitives via the general representation. By adding all of these to the general representation even though hdst won't use them, we can keep the general representation consistent across data formats.\n\nThe main remaining question for me: Are the efficient representations even worth it, or should we simply stick with a single, general representation? The savings are a few bytes per cypherlinks as well as faster encoding/decoding, the cost is slightly larger code size (well, and someone has to write that code). I think that at the potential scale we could reach, those saved bytes will add up to matter (and I fully expect hsdt to be used for data other then limited-size messages, so even single values could potentially contain a lot of hashes).\n\nI'll post a companion piece to this on cypherlink (and signature) encoding for data with a well-known schema (metadata, some rpcs). That one will be a lot shorter, as the basic considerations apply in both cases.",
    "mentions": []
  },
  "signature": "9/Pdpa+xoWTW4zVss78kFLKaNfYNkus1xvrBAlRqe06+24R1zJRSDd/m11he3XFa3x9k5nNcGbrs93ZKyH80DQ==.sig.ed25519"
}

{
  "previous": "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 999,
  "timestamp": 1536501560890,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256",
    "branch": "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256",
    "reply": {
      "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "> - all of the above `sigil: message` slots again for `sigil: blob`\n\nHuh, that didn't really make a lot of sense, did it. Blob primitives are only determined by the hash function, not by any sort of encoding. So there are actually some more efficient slots that can be allocated. Oh well, but the general idea stays the same.",
    "mentions": []
  },
  "signature": "2dLIt8DUlqbWwBgLd4k1zgxCDw49HjlUwh+rhVzquec3Ojel5WgSqNsStv3J2ViZ0pChFtSTMzaATanyBPM3Cw==.sig.ed25519"
}

{
  "previous": "%R7+kN37P8H4kGoTek1DjzD2Nq2OK7x4tGwxChwyVkTs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1000,
  "timestamp": 1536518483209,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256",
    "branch": "%iHLgIYxkuhQ9Eabbaq0KEHcJ7L0mDhjIGFX6DUFDwQY=.sha256",
    "reply": {
      "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%iHLgIYxkuhQ9Eabbaq0KEHcJ7L0mDhjIGFX6DUFDwQY=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "> Side-note on hsdt extensibility: It might seem reckless to use up all of these potential extension points for hsdt. But there is an interesting interplay between protocol extensions and canonicity requirements. Hsdt has to reject any non-canonical content. But suppose it also supported future extensions by requiring implementations to ignore certain pieces of data. An implementation could thus accept some message that contains an unknown data extension, but after the implementation learns about that extension, it suddenly detects that the included data was non-canonical. Should it now retroactively ignore the message? This problem basically means that there can only be very limited extensibility in hsdt, as will be used below. But fundamental changes will require a (conceptually) new data format with its own hash primitive. So hsdt itself can happily use up a bunch of cbor's extension points, as they could not be built upon after the initial specification anyways.\n\n[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) Was that paragraph unclear, or did you miss it? Canonicity implies that we can't do non-breaking changes, that's why I allocated all of the primitives. Any future format that might add e.g. 16 bit or 128 bit floats would need a different hash suffix than hsdt.\n\nIn general, future extensibility requires ignoring parts of the data, and I don't think that can be reconciled with canonicity. And even if it could, what would the semantics of this be? Should a message signal to the client \"by the way, you are missing some information you can't understand, either because you are outdated, or because it is complete garbage, who knows?\"? I (tentatively) think disallowing unknown content is the correct choice here. And as a consequence, we get to allocate all those tasty, efficient values.",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "Sbaxn5r/Vg0TDfVVJys1uhZ3VH7SmW4+aIQtDv86jCRYObHh0iRn6hdqxtYrXa6EcRdDxY5u568esOh+G9bYAg==.sig.ed25519"
}

{
  "previous": "%1kJ2VFXzxkoeDfxYeyN6yBfHpS8+u5Si59C21gnM+J8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1001,
  "timestamp": 1536520447519,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256",
    "branch": "%h5/GN4X1B83fdrvLmlmhfqinp+9rLXIl832CTT4bWfk=.sha256",
    "reply": {
      "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%h5/GN4X1B83fdrvLmlmhfqinp+9rLXIl832CTT4bWfk=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519)\n> to loop back what i understand: once we create a data encoding protocol, we can't extend it because that would break hashes. if we want to extend it, we need to create a new data encoding protocol with a new identifier.\n\nYup, I fear that's about it. A protocol extension would not really \"break hashes\", but implementations that are unaware about the extension have no way of verifying canonicity, and thus can't confidently not-reject those messages. At least I did not find a satisfactory way around this.\n\n- - -\n\nHere are some other fun optimizations I toyed with along the way that did not make it into the proposed format.\n\nOne cute optimization is to interpret `0 < length_value < 8` in the generic encoding as indicating a length of `2 ^ (6 + length_value)`. This allows representing the lengths 32, 62, 128, 256, 512, 1024, 2048 with a single byte, and that's probably all we'd ever need. The problem with this are potential new kinds of sigils were lengths between 0 and 8 actually make sense. I can't come up with any scenario that could possible lead to such a situation, but I really don't want to be the guy who prevented it just in order to save one or two bytes on potential future hash encodings...\n\nThe other optimization is to actually disallow new sigils, in which case we could use bitshifted varints to store both sigil and primitive. This would consistently save one byte in the general encoding, as well as open up the previously mentioned optimization. But disallowing any new sigils seems rather harsh, I can actually come up with use cases (or at least non-ssb protocol extensions) that might want their own cypherlink types. There's a compromise of giving e.g. exactly four bytes to sigils, so that the protocol could add a couple more if needed. There's a really high probability of that being sufficient for a few decades/centuries. But again I don't think the savings are worth sacrificing arbitrary extensibility.",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "k9/zSq000WgosGVt8cZcEss47qSe/dC7T9q0JI2otxmTIc2B0JPrRuGXW97/E00DQvky4cH9MZ+GQ0bzyveqCA==.sig.ed25519"
}

{
  "previous": "%IVg2rLd8F/5cGPwGgZ34AqWC3fpODmsK5sGh7YMtzeI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1002,
  "timestamp": 1536522380961,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256",
    "branch": [
      "%XDZ4py7fUFMfZjHFOdQjJs1nTDuGNShHMFVJuE3KanU=.sha256",
      "%bGOnEObcav7JRDqYoYkpoTm1vk5u15xoDsLJQH4eoGU=.sha256",
      "%sHQC3rMFiCLr/+AdRTfT4gAxsyPynLvdwuCVTmdo2NE=.sha256"
    ],
    "reply": {
      "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
      "%XDZ4py7fUFMfZjHFOdQjJs1nTDuGNShHMFVJuE3KanU=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@keksdroid](@Q69A+yES3QBXmc2hEtbwAlOxXnobvnFEcqc8X5Lcpd4=.ed25519)\n> An then maybe did this maliciously. In that case we don't need to talk because this is not part of the attack model.\n\nSo the security story is \"Your data is completely private as longs as nobody evil tries to access at it\"? :stuck_out_tongue_winking_eye: \n\nMy previous post here was extremely opiniated/exaggerated for rhetoric, it stuck me as odd that those points have not been raised in the preceding discussion. I'm actually fine with doing these things, they are sensible and they will improve privacy a lot of the time. But I do stand by the opinion that the risks have to be communicated clearly. The moment someone tries to foster network growth by advertising the privacy of data in the scuttleverse, I will happily link to that post again.\n\n[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) Ssb has not yet found its preferred network topology. Maybe it never will - that might be a feature not a bug. But those things mean that we can not rely on protection through topology.\n\nIt is possible to design protocols that fully commit to creating a trustworthy topology. But ssb is curretly not one of them. While there is some vague talk about the relation between friendships and network topology, I have yet to see any clear indication that ssb plans to seriously focus on this (which would include making some sacrifices and increasing complexity). My mental model of \"what ssb is about\", built by observing application and protocol design, leans more towards open-mindedness than (borderline paranoid) web-of-trust enforcement. This very thread shows that a lot of people value the open-mindedness. But that means that relying on the trustworthiness of the network topology is risky.\n\nNature's solutions often deemphasize the value of individual entities for the greater good. But once we are talking about settings where the entities are fellow humans, this becomes tricky. We can't just say \"Oh yeah, a few people might <insert arbitrarily bad scenario here> because of our choices, but on average these choices make the system flourish.\". There might be die-hard utilitarians who don't see ethical problems there, but I'm definitely not one of them.",
    "mentions": [
      {
        "link": "@Q69A+yES3QBXmc2hEtbwAlOxXnobvnFEcqc8X5Lcpd4=.ed25519",
        "name": "keksdroid"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "mlk/Ica01Kl95DMmqvWBGOzu/hUTPL3D0CN9rJFVpnpsUYrqiJ5eOl+XfQOt5laiXx1yFhFZuXUkFNAX85qHDw==.sig.ed25519"
}

{
  "previous": "%8nCk6IP/m6rESKVpP3BcBkCCwmTyS4N8z0+6GDeVkCE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1003,
  "timestamp": 1536523819289,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256",
    "branch": "%IVg2rLd8F/5cGPwGgZ34AqWC3fpODmsK5sGh7YMtzeI=.sha256",
    "reply": {
      "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%IVg2rLd8F/5cGPwGgZ34AqWC3fpODmsK5sGh7YMtzeI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "On the topic of alternative ways to go: There's also the option of clearly separating encoding and hash function indicators in cypherlinks. The current proposal (well, it's not really a proposal yet, more an opinionated exploration of the design space) mashes these two together, an id signifies both the hash function and the encoding that was used to turn the logical value into hashable bytes. That's how we can introduce new formats in the current, string-based cypherlink encoding, too. But hsdt could instead decouple those completely, tracking different ids for encodings and hash functions. And now that I think about it, nothing stops the json-string encoding from appending two suffixes, one for the hash and one for encoding (with an empty encoding suffix indicating the default json hashing encoding).\n\nSeparating those would mean adding another varint to the generic hsdt encoding, so we'd get `<sigil-varint><encoding-varint><hash-varint><length><content>`. The cost of this would be a single additional byte, but we'd reinforce the conceptual distinction. And having to manually assign all possible combinations of (encoding, hash) pairs into combined ids would be really annoying, as would be the resulting ad-hoc disambiguation code in implementations. In some sense, the same arguments for giving sigils their own varint also apply here. The more I think about this, the more I'm leaning toward separating encoding and hash.\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) since this could be done with the json encoding as well.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "X8WZpNmWgwx9uDQRgktWhoiuAphHXsQf6v66pLff93vXzMSnHz87QJjwJfljawwhiOqBxCv6zPcyrGK1Od4GCw==.sig.ed25519"
}

{
  "previous": "%kFNhfPsphpeqoChT7BIuUFURbOzIRuJmcYzuOWpubGo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1004,
  "timestamp": 1536524353537,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256",
    "branch": "%kFNhfPsphpeqoChT7BIuUFURbOzIRuJmcYzuOWpubGo=.sha256",
    "reply": {
      "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%kFNhfPsphpeqoChT7BIuUFURbOzIRuJmcYzuOWpubGo=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "hsdt",
    "recps": null,
    "text": "It is interesting how ipfs did not face this choice, as they settled on canonical cbor at the very beginning of the design. This locks them into a single encoding, but being locked into cbor isn't that bad, the \"c\" in \"cbor\" is no joke. More interestingly though, it prevents any future extensions of their logical data model. Which again is probably fine, especially since they have arbitrary-value-keys for maps, not just strings, but who knows - at some point they might regret it. It certainly limits the possibility of \"subclassing\" the protocol for more specialized settings.",
    "mentions": []
  },
  "signature": "ssb/EeSwj5twE9I9ZV5V+hHzf1vM9f1yN3ueT2PFTKdtuloCsEENVQxBN/tD0181rWMjxEclq1wEGihiGr8+Bw==.sig.ed25519"
}

{
  "previous": "%+gs04DnW5XyfckqZH4rFSffL38MUytg9IUNm+mTyID0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1005,
  "timestamp": 1536525722750,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256",
    "branch": "%o5g5ItxEvPvUW1I8IGLVs8it9safdTz1x+TneAo5XX0=.sha256",
    "reply": {
      "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
      "%o5g5ItxEvPvUW1I8IGLVs8it9safdTz1x+TneAo5XX0=.sha256": "@uR5GhJwABZuZwhy9mI2hFYkTP0IMRG2LZkqpTkgcR1g=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) (happy to ramble along)\n> to me, Scuttlebutt has always been intentionally focused on small-world network topologies.\n\nTrust is highest in highly clustered areas (i.e. within a single social circle), yet efficient and resilient replication wants to bridge between clusters, that is it wants to follow the paths of least trust. There's an inherent tension there, and no optimal solutions. This is among the sacrifices I mentioned about focusing on maximizing trust during replication.\n\nI lean towards prioritizing replication resilience and efficiency, and so does Dominic, I think. Which makes me so wary about relying on the trust guarantees of the network.\n\nIf I were to break compatibility and redesign ssb completely from scatch, I'd use a [peer sampling service](https://infoscience.epfl.ch/record/83409/files/neg--1184036295all.pdf) on a fully random overlay network, and then use a quality metric (primarily) based on feed subscription overlap to prioritize replication connections (and also do some clever scheme of gossiping network addresses based on the quality metric). That is pretty much throwing all the trust overboard, instead optimizing for replication quality. Actual ssb is much more moderate, and that's probably a good thing.\n\n",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "rXgr6q0yOhEiHYDjnv91UOQ4BbnqvosUPGUTUcFEA98liUq1meAn+1wo2Ps0ejGKyX1Tto/ijP6YvM1h2NNWBQ==.sig.ed25519"
}

{
  "previous": "%hkdA7J415C6CuvQxaoE6xfnhAKF/njfbhWnnSQ0LpoU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1006,
  "timestamp": 1536529364717,
  "hash": "sha256",
  "content": "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.box",
  "signature": "LLCHrsaK3RqwqjkAXo73CVnf8zh5luV56OdB0hW6lYs1N1BcKVabWjdZvqtQjWxKMh1WZxaqGu/2EIx+Pt9CCA==.sig.ed25519"
}

{
  "previous": "%viN3+PFPjUSelsUMNvzgHQqnuvQU9GE5NvHrmtKesDY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1007,
  "timestamp": 1536562742060,
  "hash": "sha256",
  "content": "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.box",
  "signature": "bObBipCnRop2RGoLqlWNFDOTtbKt2D6kAGI0KaOUpfODkiSeqvFgH0OnKM27zfj4cYyv04vGO65jb/lRnYJKDA==.sig.ed25519"
}

{
  "previous": "%e6nOswBjEmUedUqpfAELO2AcI6HTSF19Lh4eqYwSeIU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1008,
  "timestamp": 1536563561006,
  "hash": "sha256",
  "content": "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.box",
  "signature": "SdVZieqosXRJcO5iLM1yQKR5SKGzK3tFzg/Nrjju+67DwklgRbjpouScmP+0pGIuCwIvbgUNY2KaXw8lY7YOCg==.sig.ed25519"
}

{
  "previous": "%8vZ+iliOTBUydqv0vcjmoBvef2E5AWaYPd/Ed1A3Qyk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1009,
  "timestamp": 1536565152054,
  "hash": "sha256",
  "content": "QeECChX7l/xPEVA/m8B+43+38UbGxRaQ6Q49X9PyeQP2gcNlZc/bZqTp1oOuRtiCMDImotQXz0CfcLo668KrDkpvq8i6DtL6cSK1U5Vo0SsgZlY51z6t3FR/hViZQaxGjyLDuAXLhA2+sFgelBgba699pjOJmRW3NqOj3jH619SWoPQvfsK+m32sK+WmWi1bzPYx/4FNq8fiCitSyx/k3h8SPCBZdQ2DaDsrmJue+F1sTsywS8RYaY9U4pF18gsmzDL3xguomzDul2KFyUvdd4tWozHgWi+di8gRjyQ7f7zCBSR8txHUI8lrDR43qxCcRjqY+7J0wcjWV9fsbRL74kpX6UJ+Xn7oiLNmol6GdziXRRAi9Xv6adjLAhg0s9jrak2z+I0iIXhAUF0M/A+8t5zI1FSEn+MY2cia7j0WOXcl/Y+6dpNUNHyei+41eqM6Z1nF4QYHD+DlbMhobft5SL+e83/U6Ra3YBSde9vD9U9pOPW9Sur4RMIgINueWP2Qxdwt3AixWWdc1d2Y1TVM9paw5Kx0Cop/g4BpnIOdVAxgBghFqOQRvmgxaPXIic9w+qfxTEFFLBsEFqR3d6lvh3gAJTP1Ky19exkwIkNI2EejMH1W/Vu5Tnz4YsurQ2NZhM51zD7MtOkadKogRS5ymuquXJkcWkYM8390sIzAr03TDPCZFOwNE+K5R5081KsYxRmWNnO130cfw6xW56CYzX4F/Ver0j6vyLAZKVNJN8BaI8qOixG7twZe8MoN6SX0eUlrLBVat9dCMPXVHLgnuYdYlBxxkd3/7jKmHTP9/LPatahEMhP6T84GusplrCEo6A6jlH6AXNeXn9puwdQRg3c2LkqbajeXyZ4S9UNx7TjujrjoPvU/at9pvCSKRVPEPU83O5PURVUrLK2TGqkw7Xhr3M063gHmUuZp6ZfF2fREf7UeRCN2TmvXGk8oeeINocL4C9wEZVYOeHaWIWZar8XYrNtuXv3iBYXwyQHOtHf9eZNhJB033U55emsMoNTKmgv/kpv1XSZHRa6wichJ5rSp+xQNbj8U5NyF8g055n7R6U2tFeqPQCFLBr2eTpf7Oy9dvIzs20+YQ/KnkBDV8LI3XyS3hjJ7BZBZJ5yUIm2ew2hKXR7/1Ou3FIOACChnC6Dfhmtiv6Lf6nEQ4qDRlzt0sknOlK4R2ZYXbb2Eq8PQpBqRlOkeWsgo2ezFF2sp1yIbZL899gmOgwaoQqP3F0VGtwhDIOWuDz6dcDBTLA3baydrLn23i9YFAAApA4FzZCaSRHJHP8KLT3Tx/arUwBXYXLHbAWs7P8/WdFIuewhl6s3M4mbWQYEhgXrECQBByhxOZJGR2YytxhdyyTCamPPEjh2+IDMz1C64F/YGCkjPbrfDkfM4spHPrYJBygcsrAwH5apW1l4cj7fuNW033rNcy/ek0ypQnCpvFOa1xR2G6GcCckW2tQ5kv+iEVfjRzxtbFnxIaSbvuxI5PVfu2HjT69zS6Z5lqjq7HNLxtwBvJRWw+LP0bpd1AQATcIEISz/lI5rbSfQsj9trleCoaWl2gOOhXK8SJaEMmWJDSfj2nThUIh8SOfs4Zo7vSuVj4OeDInxygDt72ifoOiHsWbIcCUafKQFSIXO/gON8cu8sCILp/cmLGNT6mHHDUDidhttk3C1ZXwxcxaAKLEON3Xvmk+kwX/vatTuLVpnMNivWuigL8u3C3F+hJmf0CTeG1TghwXgm86JM96oL07hJxkhxk6IaHY/urNio81cotEd24ehnITHatefkNEskmKwd60Von9go3rbek0C6gXG6FqBJ73KLTn1pPrS4JVbapxxH2elLzsX93IP4qGwNRlPVEtM6VmagCBQJ9lRXUxVzIZGdIQg8a+S/.box",
  "signature": "ySLFMT25WmBkpiztMCvyyPN1in9842KmvA1GJbMcG2pFIHCr5BpUYmMzuUsvxkQywKjqUfNCx/arRIJnc+6jCQ==.sig.ed25519"
}

{
  "previous": "%Ln6PUIQr9CPfLuH9dIsuBtotxKCZXf7ZsCF/3txeGoo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1010,
  "timestamp": 1536565431978,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@q68IdbW1X3mTYGyIp/Zt1NJtJLe61W5o6NFfmgvVMMc=.ed25519",
    "blocking": true
  },
  "signature": "Gtf6ywBP+fzzFEQJdeikxfNFw2LV34yod/F/R1JHYGC67hkFkJ+GctrXJQHNc66Ba4t2oujDfouC6eoRmrBQBQ==.sig.ed25519"
}

{
  "previous": "%F0Cyn1BhJf8x7K4lPGFUB/uXFeh2s9EnqMLPS8FHl3I=.sha256",
  "sequence": 1011,
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "timestamp": 1536565654660,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
    "publicWebHosting": true
  },
  "signature": "ywMNCCFAnY7jOvQ1hJP/93KFbMJIaBhXBwQDorNd0tIklfF3pDJyEpnM4sDPRpSzPrVrb/hMn3H0WJvyrXdQCA==.sig.ed25519"
}

{
  "previous": "%p82NkXD+zNqhTx5e8G+GDw/yqbzsSW9HVSkTLvzyeRA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1012,
  "timestamp": 1536572779149,
  "hash": "sha256",
  "content": "0jMwMgeINfzB3+1HJH5CiPB4R5WL2ph2zafI1MVT7dx7QgGcM1eHR6zfCHDEZXQS9lVLTPtjD0u3bNAsxQSScGgYKwUs6p9yQAm30gQBWQdYjiCbIPizFsLwBSsntbuEj5ET/fpRuj1XMu2u4QeUjbcuExSjc50cgQ7ci3kxmfbCd9wtdhkRnY+sGUM9Bm1A/H1w1FS53kBNE3iWD+PX3l/6AC2adKCb9ueSZ0pbSSVSGpMR3tq/wrIsnpOQuqUoIOt5aE07ykzMLiZ2lUJLLoNSPgaC9h6BVf4fgHsgYbxBuSfJ19+a6EosoMak6xYLRK1tgGHfakIFEgC9I/IU57Xzgc4aPfoh1rpj0ayOhK4r8REQld8epBnotI2j3KtY0Oi0v/f1pvrSZBS8lGPL9PsLZTQbBamnAx68U41uW2R2ZxfoINJxnqb09+g1oqZfw8+2yAceItpiP+gu1Eu3qGriIHCH1cgYg7k+UOt54/+g1mgE4puOj1peadmbqDOGO79AU9P02ldv8LnozNzN39zwzynhsfbdnTHn9SOVMzq9fhz4W74zaN0Zkga+hhUsc/JGmcRAUN/jqRe3OrRRSeDFyLO1c9YZ4+8E87EWS0le/wQsYV0zkR9yxgVsF0nE8xbRWguE91Uxz7UVa2sram8Z1aJQVXcwn0J+Eor5FpAa/RL/MN3MxMQqPCiD5iv8cR63LKUgCk3cBH69piUnKHEg0ZzFgNU8f1rYcTdGmXEHHUhEt+KiftV3yD1KsvmdhFqWfnyqkNBAt4SqhZJy8gr77y7Z02d8cpldO/RG64UD0N3R9wGVJVXSE5dDSJNDRi1kpO8hXO/Nb6x04B12Z76ysAmm8dSI3bfEAYTR9LpqCdyif6HJAWrRE+7TFlkkS3QLV65xc0J/iXLH6FrDwRuT9SiBGSuQ4VLLtlK/SKU1cLbGB/CCayBtnLjqbaCvCemi+jjXKdvaCdDEpEpiQ+XKdqeNv+QCXWWXi0wc2jNLX8yK4Bm6NaaVqxMt7OWWEJxRWvE+LgsCIVZU+jNqKeOqrBB9d+lxFPrxZVU3JeEQnOCWUw/855jMK4Kda0kAqUVIGImN11FsNJcPunSa3XCWm4MDrHwCMR1mVWRfLrXNBot7GbxIZmORY6Fd112bzFiO2KI1AabhDzXJ3DAOf3cI4tDDt613F4lIu6sR9E8AsZSrV2cmphkdI8xRqw8g4nPJsS3O+icFEBbaCpcgSwSOiw2/QvOG5WOm29TIpMJl8xLKEgtqxAbaB/J5Rg41r0ZMLL5e2PgdcjUVlxVKJtiMzfNwzgfjVQKzOuQ4I7J54rG1ZBQvXtXQhNE/HCN1bKHwwZUGQxVTgcvCw7KRUV9bfH0KpDNBd30txYikY9MwvmIlNoqYkX+3G0vTZMlBaDmU3pnkMqA786yOUh/ok/7uo38wYl5/NRjPfRPn3RP7G4rXKvaxkqPz+VkwCiUZ3VWWyC6pf+k3w2FqA1rwsvhr9uq/J9KCywjiiNh5SgVmAr6jry3XTr5A96XxVjDvT91c6GCBwo5xKj0zZGX5IhzdcPfjwp1j2IiU52U3gyyNKWDHWSK31yYsbfx6S83kIwzbK4oXkK4Z+VRiFcaf+s8w0BWQ3prwrIBsuk/Fb2g7yuMZNKFuWl63/sy2wy9hmtAsqw0YTYSkYMZkrVb7rcz2u7lFXrFKi5aaT5q6BScwlP25874h3eVYXEUD6JpkPbqLI43UI+A+iBdJPgOcHNGoMLCnE/UvwtIyVlaVDTGezVLKKImvemuCJ/gMcwT4pNkIKrbkx3ob2BPBFgfPTkUXq4J7YNehTa1Q37JSUu55qC2Rbr9cTBdEM035mK/3ycyx0PzTWjEU4Ad62DwiH1j95Z/FXk67fkXek4Ieu6Pv1f+3FX8TDIELJkkVyLJbQvwjDf3nYMxns39xgGc2YCOMdnOVMBlsA/7QynF1ipXFgpLbRLYJfUawnIxuoQebk2Wsc0NgwxQ68Dw6q8NnLrQc2NRqmu6RtPzeUj4XelNSoD2w5uCWuvL6tCfkI3bikvHcc9zFHY0JgcfdsTz04Vx4uGOuakSnCRXXxV2XAd8kfsmLdimqD331O9+slvoDnFqzTtnyPpbynIDTu9tW/OW19rX827aqhHiMpuWzuu+UmIiawf24uwgWailMAtfgberOiRoHiuhTuiMjWxV5bEokfyFnCuP8Pto8cdGai/dt7vkD+Cl2MRMHEpUBo6KWuRLoX1P9P3EjrIIfwSzJ6dknuYpmWJj5OXYuBIVYZjkI5TSAFK4WZq3zO5gdyHAN2TfvZCcRcMpAzAkbSN5OMDDYRYOr39jycfDJHNXU4xDH6apQrt/6FAhjhVc26DHezR5uQOlbtB09qKyhqydOeguVYMq/CcEnVyTH47nLkmy57yXKPgiYaDnFXy3Nj3w3S9OPDD29fmcSouYtfnhdfnlzf0sQAyAnz9c=.box",
  "signature": "HbVWgmV1xCGaaEuDWPgLJMjdFnnGPrs386Hc6Pa5gxfici1pPAac0JECOzRE40b8TIMpitb1PyEQ5IHMJvTiDg==.sig.ed25519"
}

{
  "previous": "%G0sz3wJmlOYiqc0zQvmGv5XtXUJgftqlCn+dYP6TADo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1013,
  "timestamp": 1536573038286,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZxRDefOR/8GGIQ413BOUbZstM2vlbpwvfrpPG6O6CkA=.sha256",
    "branch": "%/0DzAifDsbN+9d5ofH9ByzOqPFb0fCr+hEEZni48lPU=.sha256",
    "reply": {
      "%ZxRDefOR/8GGIQ413BOUbZstM2vlbpwvfrpPG6O6CkA=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
      "%/0DzAifDsbN+9d5ofH9ByzOqPFb0fCr+hEEZni48lPU=.sha256": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519):\n\n%bX7n9zbvmJU22NUMhxpT7h7NBjvYmV082LoaRSbA5nU=.sha256\n\n%ataBX7bquYkK1EWof5b5IgdTTsADyDW8q3eKlSEeaJ0=.sha256",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      },
      {
        "link": "%bX7n9zbvmJU22NUMhxpT7h7NBjvYmV082LoaRSbA5nU=.sha256"
      },
      {
        "link": "%ataBX7bquYkK1EWof5b5IgdTTsADyDW8q3eKlSEeaJ0=.sha256"
      }
    ]
  },
  "signature": "kUjkj7FsL+sLVwX4p1xq4cDAWFsmpdn//eL5PuR1noc6rJFT2mSjoBRLf2jCwpc0K2cEQjrYPzG/wXMBprCuAQ==.sig.ed25519"
}

{
  "previous": "%L9uxMh87WPVUhVk0rpJW5sjuP30J2KdEbXYQSWD4bKo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1014,
  "timestamp": 1536574118010,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256",
    "branch": "%Cp+7kYbwpfx9Jcuq5eWiWY+fQE/y7OxfT9kMQwuq7nw=.sha256",
    "reply": {
      "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
      "%Cp+7kYbwpfx9Jcuq5eWiWY+fQE/y7OxfT9kMQwuq7nw=.sha256": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) Those are some interesting thoughts. I don't think I will be able to take the time today to do them justice, but here are my most immediate reactions:\n\n> Is the following sentence true? *\"Every sentence that someone says in real life will eventually be recorded and shared to the whole world\"*.\n\nNo it isn't. But what about this one: *\"Every sentence that someone says in real life **can** be recorded and shared to the whole world\"*?\nThat is the situation you have whenever you write data over the network.\n\nAs a corollary:\n\n> So perhaps \"the problem\" that you highlighted could be summarized as \"the unintended consequences of unforgetable feeds\".\n\nI'd rather summarize it as \"the inevitable consequences of sharing data over a network without assuming 100% trustworthiness\".\n\n> To attack a cluster of high trust, you need capabilities that can match it.\n\nThere's another kind of attack: isolation. If network connections mostly stay inside clusters, it becomes really easy to create network partitions, whether through attack or everyday network failures.\n\nOne lens I'm using when looking at a gossip protocol is how it can deal with [eclipse attacks](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.124.3679). Trustless solutions are both complicated and resource-intensive, trust can help a lot there.\n",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "SsDfqtggeG/X5NRDYEyNFdnw4AaMe/jMfwUceBDqpwebs3lw58nGLQjE/8u1fWWLcXKWXziJsadA51sNP/XUCw==.sig.ed25519"
}

{
  "previous": "%2UwS8pstH/ZmPN7caVWJO/3or8ykN5ykbP20klY90po=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1015,
  "timestamp": 1536580968085,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%q7cRdWab9nAU6gWNnq4ziFeNREB5JiVem62wjDQzpi4=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "PSpnpNRHvGFuL8+1xCCSKd2zgy8r27em3BnSz0xdbMwBxEJmclXV+YV660C/y2VERapaevAtYESroTcXN1+9Cg==.sig.ed25519"
}

{
  "previous": "%ykKHTWHTITvBoGy6ystPs0Xw/DiUk3zGqkxY6xpVlYU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1016,
  "timestamp": 1536581676449,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%bQk+sjvORcUSPCrvvzKM3rv93ugcNWa3Lh6ryk1Bbp0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "TVfzVzoghO7+YxF038R6mxMpCXvUOKIcD1F2rUYUK76VBv2IcmbHHMDUK45LxiI+43hZmmqwKeQnafP8pqrhBw==.sig.ed25519"
}

{
  "previous": "%HbVTZSODhLOJwQJwSrImeCmL76UER+TebQtAahNHA7c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1017,
  "timestamp": 1536583723787,
  "hash": "sha256",
  "content": "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.box",
  "signature": "gMeZDBK0Fg8ZBbHEYSh1RacdfcOQtTZ+sMf9hEXJwrpmcWbf8KrFyKPwxuFNdbqdHGQLMgMnUHJvdHP+kep7AA==.sig.ed25519"
}

{
  "previous": "%OmtdxB0wnYuScC2hjpk+v50cVhzDayMGCvBIaGpz3XE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1018,
  "timestamp": 1536586318265,
  "hash": "sha256",
  "content": "5V9X4kTjbCQuZlpQh6asl6doL/qsdxz4JY2XVAbWmlEtP9ozrM7RoByAHo0T7fp3b9XRuVjF0Q2p+jV/h0OMOIivdsgHRXjhtqfjqssvDePfv/gjftiPzo2BziLARXjecPDR4GpRfQIA6Zxv8QoR7fus4nF9GxR/5RHPDOLYArvdIInMdGqeJ89pGPvi6cYY75eR7v8Kzakpj0+IUgRzJiGJbgmJnwKQbHojPldY/sF5ytMy3WNZqGKsXQp5ugR9vuQZipcO2U5Yz0GbRLOQ1ZQR7XJQIssYNgagviuNM7uVGpfxYHwJ90iOL2io8QwbHTY9dUU3g+Es3lpBC/fK6ti08WCM/XEqb81PCTH29SJc2ASMRdAFx3nnx9+y9MruxDURX+dYoR9Qw5uyhXLcMhPn2bryBlAyT0o018W9hl3dtQxH5/kgsinFdlMi1RhVHqzY9CPMl3pyQhiMbuNyxGu3bAWnIHaVsIdnPG9Q94CBg+n+C14K+kH6grXF9SOXTaxDQbkL/s3+6O5LjNDgQrFKU1wlN2TO/hLMAehO7TAa9OsJ5fkY2yBdu+EgHULpUTdz0QfqruTjr3kXrxnZGgOsz+ksXyGiGswWvxwwMjm7mef8XMdh/YumHmr6MQP+kUjUdzEzaVvzQDRNjuIOWj6dLPnWGIXvVT703h0mQ8lTVijpCVLV4xIVRYmF8k43/XtQL6uWR+Rr5EqvK3Lmqwff0XPvzM4clTvj92CXb6ahGXEj4fkGg+aLTriWkdzRpxxsT3sr4aBd02wob84ZaTlnMG/mqULZZJWfjuYu+mp81n7IxhaW1NmBBgDGmCMj2Zxe+tbQF4BlZSOI5y9AriJN5p6I05Cxch8KoxBWlLH/fjST5kRKdzb64OpYkTqJOOcUkQ9E3mqKgouAaR70JA8tE/a66i/VgiVtQ/RVcv7k+BLBwMsDa86c3nBWigWRXlffL6Z1h3iNLJpSIq0UWhS82i2RNSYb1GWDw4E5vhDkjV1M6xYW6NiCHoSP+I36W8xY4AybeNBJ7kgMbY+Vs0ue7NHDNkeTFmV/sYiER+x9NCZnBNiBs4H91nObSeJvKKb1oHbxcdPxPP4fdTneAESoOJE6catgQuFJlrsDGqqoLVgr0MslzHHSXOmS5TwXOJE7ySSPootpVY02JvBklKM6IKhZFc5uvvCmy+U7VziqS7T9QgaxgIN1/7VnZ6pdZMhW0F3coTn61x+Yi0iRUVEz+YL6KsMU5o1KMbQEEGjc3mW8FzRMAbU4M/1/aM4w3brPy3abx3nVOA6/DqvkpKbsbVtfFwAstXkxORPgoInpErVQw7IucabkZrAAMbwW87Z7ZgvM9eKYKVYPel4U/HmG2jQ3i0u9Q+w1dHdbOklMrw08u49qq6c8nAG7gcrCyQxvkPZs7wFdYDR5HaEtvrHhCnVuRhN6fdtUVOxkaKkJ5eRcONPIsSD2mC335fvjnkM5Oo0YxNkkpoK2J+22sydTcS6ziuwNYQX6whMgzEHrIJeeL8ioKE6HAsiBCNIUZ87fvMWiCGqi1GAfYrkn1z0jjzliJBE25H24VAVM/ONDEM/wSQ6BFK8kLfK596Yc1Oa15uTKkkQSPJDtg9cGH/IwWeHuAkJEWF+ysRW4XFKHhojzuh2E3FxXq6bjlB8vvdJCeFBDqml5ladjQo8BEB2CE6/7UTEttJjLAVWsKHy+Rnbvsn8sc31mgAO5333H50/5c4jsnZfltZr5Or+GltfFgxzhc07QxAdrWTjphDfEkLgS68ulHvwFDarbYOX9hc+yBVFZk7f5u6wP/ZvM+4x2JmZB43o2KrdGHle65IFuGTjdq5SfWbXCTT7l6mMMDXuG0iUVWbAeIPheL3AZ6BqPOuNymkhHqyis4mp+cpQEY/hpwS/o.box",
  "signature": "SkiLr/npMIzYA0TvFhG4n1mZt2GrGOFKoJMYrDYLA55A+7IboHP9prdxYrFF5W09M6fgvMKaMxZV8RkDimICCA==.sig.ed25519"
}

{
  "previous": "%u0nCPGA6P8MFobZESW4OUcjJn3A3qAPxVs33KBOuhKU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1019,
  "timestamp": 1536607532059,
  "hash": "sha256",
  "content": "6opgasVSd3ED8PY4Y7tI994MHPzfzSLFYL99QJZwktHyi4x+vG7eJOAG/BwL/efqPQBN4N1upWjXxYj3eGP6y9CJXpFMRAcIHkRx7i/pK4JEJarX/sng1wcv30/ba0cwVeFn5uRS5qoGV8CyWfaRht/SMhqDSpVPmSa/vVfDZKfVQB8elgg7gg6+oq51UtUGuzz8P9rgEPaIdINI06xLcvrl9F9zqWgihDfvFQre6UOstTNsGZsH78jVb4XqnHsgz/34qS2xc8sj6rdV60GmGFNBVeb0/D3e9cMm3EmDktr41S17Q+uPQ4YciO/QTTWB/5cX8S6clt91w2HnUfOSLQPuXPii4p5v0Yv3AiVHluy7e3aiSsCpj2h2hpqFjO+alZAtWK/CRoRQquf9qXIC19qp6sxkQc45Fz9XiurbfVadQJW56H5ynSLg4F9pj6CozZUWk6PD9V3sQHzNY2HUbKhYNl1s9C27Ofu5n1Ey6EuLYmMRE4K3/J3HC0TVsyaevzAA5e5L98A4d0/BEX988Nwz3d750k3tX5n2vfA+oH4kY+sO6EsEVMTzojJ4MtvX0DaxErz7.box",
  "signature": "WQuE3rmCmohYh+DY8Yjr0u2TXDg1RqWw4GBf/rxequBHrWIq9SjbB1regYHS7nFx14AECvX18o1+O2Sz0NdjDg==.sig.ed25519"
}

{
  "previous": "%s7L8oVpWmb7Lu7uWKEuUg44SNZVOru4bJJaWNgl9eEE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1020,
  "timestamp": 1536608306629,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%gHwVDcT2Soc5SnsnBx/4hn6idf7iZVJOALJr5LXLyV8=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%gHwVDcT2Soc5SnsnBx/4hn6idf7iZVJOALJr5LXLyV8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Tiny update on the metadata: I'm currently leaning towards prefixing the metadata with a varint id. It would initially be used to distinguish between encrypted messages and unencrypted messages. At some later point, it could indicate messages where the metadata does not contain timestamp/sequence-number/feed-id (otherwise we'd have to conflate that with cypherlink encoding indicators, even though this is not really an issue of content encoding), or encrypted messages that use an alternative encryption scheme (here the id gives us future-proofness), and who knows what other types of messages could one day become necessary.",
    "mentions": []
  },
  "signature": "toKugF+BiEYDFlYsLhSDH+TKGWHQ86lYubXxrMQDCGgjAqhrqUdvYFjtwqfQNysdJ/ZbGc+vLuWwDfkcRkM/AQ==.sig.ed25519"
}

{
  "previous": "%QVmprjsKV8vT6tCpCeZ18luAtSxVJU5gwe2MOHyfc9s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1021,
  "timestamp": 1536609547978,
  "hash": "sha256",
  "content": "BD5aIaEbleOu6OtVnT0K0EjC2rYV0EWD4cIiV2NyWv8y4I5CsfZjnC4+1p4GG5Yf8EzfCrdGtEIc7j9lfGGrG9qqGJOeGyiMicoU2WltKyfs0/CgBGAenrADrUYLUGbrdnQJf+3eeKQ/+KvwjvumnxRXw+r7ip9QmRrz47yZdcElNozkvmVHm6gZiRP+zTa9F6v8RONA9B2baeDsBR24eUR3uPk4469Lg4FBIk/CsENipzD8mp8pa/1z4+CFKdyoLEWM2cBhH3nuCRJuOmNCn0u7c9aUPcVW/ub8X0Z6Rd9580YDQlq8AX0Zp0JgwNditBE/tKZnOSON9/yND6SIuIqw+S8mOgS4ZIkB9xJxKUusG7S5QXX5G2vhzRQjZsUAxz0aBbB8gt4ygzk+aDl8MVfu9qOy6D4dlRzQ34wDGNXsYgp5urNd8hKMq3e7AXXHnL+m6/qVsiSO6iOiG9E5aJHkcFq8IRuKjKKmaLddmLNYuJPrA3wx2LgWOPWDXScSaX1S4Psxuf/nAOWO2v99sXN4nRdp0AEJ76NoBjMxnCPO7KOozFhpXm6EdO6UPc0zecgN/smBewcYrtRHctosPOAhXhtsemsQC46R111ZokkAa1Y0rAx2FiiXOY6aFJPLZE7duolrCSwdQQjSuOdx6e+oFlgpJ4t2kFQ1fMYekWw39Z7W7HVY9C4EcasCWL24cPNjfpahgXX2zB48tXuU+iYj/bHXJhOwzHHoEthkpgJiFP6v8WYFPO+P6ZndOvpv9w0VHR2vyOpaKXYDEfKmS3e0SPO7lFkwDLGspwWsfJJWqLJprIGZ3nMOs+kLnK+0AGnhaVdMsAvcL6DmksPcCUcWaI3I6su01tan51vibLU8ouqnP5JCrX7y4h3NPb+h3T/WUVL3VTg5f3JVOYSmMdjL9xuKbK33XACYADK4rvmt22HJx2EX+7bQwVifhZWEGOIyT4Q3TBKvUFm5EPvobu4aeUPl5Mp6bNWfWKIpfW7jCihUieizTUfLpMZ/igQ0YaygmTsx2+4sUFAeMoPF2iZISJctnAKMDXxqllUYmTrgYkAkZ++qEg5efSwRXu/bEq2FgyBslVAYSicfCmKXToyURyTUmQKjpezUntn9XQf3ngmFi1yKnuJoat71UCY3X0jJGa+1My+iH0FhWl9YUZiSR7/zOLeIWVN6e/9u63+RYLHTGuno/hbcJZO74WZoQkxQQicP5YfQlww4ba6PA4LtVMvAaxn6dq1UOFEcTJRsduHlw9ivRdMpbkmy841HXED5.box",
  "signature": "S+YcAjyYHcsLKuIMnMtk+9BJkPv4vKIsUiVleKXUTHOI5YvFM7DflYH1nVYvnb/y1pAyYCnBidejlQvRziahCg==.sig.ed25519"
}

{
  "previous": "%skQ2OcAE2BupqP3uZrAR+VjdfyLUGIIqqReJeZWezso=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1022,
  "timestamp": 1536614699649,
  "hash": "sha256",
  "content": "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.box",
  "signature": "c5LeGXoqGz3q1pCoFKCjZso+dlHmNgRYg9nFj1/++LPCYT/6ACTJ30iggSQ1wvFNDEtsqsLwCx7hmosOckOjDA==.sig.ed25519"
}

{
  "previous": "%1IPDLCiAo2VZz84l+4S1REdPOOUIo5LZokEGu+kT2Iw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1023,
  "timestamp": 1536616899915,
  "hash": "sha256",
  "content": "INq1kC9G3W9kMkQ+RmaHOq5GbI4rmiME0/JsYBRCId6mdT2fQpvao7L6ynWL2yKaNpUf7De9WW+03K2ixiRHu01dBlYnlsN5wrzUnuuX3QwmOURw4c74oAJ5DZ5ciyP2jX1XNV8ufOvN55BaQKLbRFhVr9r0LCSkfu/QVRNO4lltdoQoz1K4fUpJ9yfLh+SRMYFDqUsECAR6SrmDtCgadsKXcih/8jcKtw5xtPcrzpE80jaZaZL1WQge1erITKqiRULpJbUEtkbi0yINTi23E9FR77kBRgycn4ekDKwlVawwVaHYE3fKN5AMzOmVK6hUPsz4L0B3RMIzGTm2U7w2PH/fXV9ZFO5elJL56Zdp5vmNPj/zgsI1p+XLO+0m6DbBrvCerh+I2k1iZ709XsHvzPZUMyb2QldmFlNZg6/iSfv/6q1dI6gDg4woghGlJU28tER3gX2Fby5iQzgMjIY/h1KicET/dThaHm9SrVOB1g2FMpb1J1hq62UBNmE+1A5J6l3aSW1hgahNeExAQ5hB+cpaQgEjWoqIPso3iNnrFPnuvIWiUE+1P6FGWBWj0oNN54g+o+AsyhJMwh8mPX7wdY5fqCoqCesTuCVOQjyN3iGriTzMSO3dq7owZVfweaD2c2FuoIFJGINHkxYc9iAy4YtfEQN74zNOqHixWba3mw2LEemInDtJaIYy0hk+P/3snWkrrIjlDY5MW0qaZemuqbot0BR/4iK6pBbPBORJQT9Va5ZiKfjvhBxqyHThQVOkENIj7YlJG+9uOQb99uFYDRt1ehQX2OkSyCh53DaZJSR3dx/vP1QX9I2whY7uizA0w0RZmikNun1JlHTUhWWR4aSytjwNlEncWHxwEBcWfQ/qQQXOyOXnn0VwVx9VGb/cRiF02wL2DAC9mp5AI/dPMnjr27jQuqCFQFi7t5CFsdu4LafQKyYTIKCHs72YPR1x1fEFZw9UYZ2zUsAlX71CRfZpBt9mHur/+Km/qHSP9yqw0r9jSwU3sNnsIdYZTm1bUJFTu+NyygYt9eFlnT70Pcxdq45RSksMOq3MPUbPOJm2yFPyNXieq23RxcPJ8agmuybNLQoTD8L/te8FmO2Bwu2lYNR0EiLtedoRVw4gkz/szT2qOxdu9rVXc2fpu7Fs8p5mP9OYXsho8Ges2MMfC7Nfq/SSC5f595XqoxjbxulxRAw5G01kDpSbXfZOWWLEfiiQ6+0GBdK+baagPZaZlBeVRD+w8BR12wbtkvHVxXROixIIjYk5byu6EgDY1vW+VFUg1/jG3/EUY2zCq80O9mag3XQttSrKXJPB9Ts2sMpFMYmsR2nRoF9O3tNHBfk/PluY3yI7ijK4KkgQHhGZ2PcJ3Hf3NH5JMg1gfHL8ILvVf4+DxRLHLNzy+neBWqT+q/8nvBPDbm/RMdL1QSwoqnCZXJvQovLLcDSQxVll2uWKj9OUHXwwizOinAOeXH3/kMMlph+kgtL/+t9qYlFIiLEc8SrT1sC31CPtLbor1tFBlw3V8oBZIoBfJQ9fBrrIhF/90c7r8O0wHcP2YX8aslpa0m5pODrIhvimjDzV9w217C3EL7T2b5bh86T5o1NCAHQt1+XB0dIgcajXeZArDrvAS7nOZ3lLdwHzwndweDf6hKiZapFB0M+lU6W2OO77kF2OxkESXzPJxjss3ssOlU7pTQ==.box",
  "signature": "9rzcZ3kC+QmoBouCeiGs4G8pbHK4Mc7aFcL9f1HNs/GrDioHu3UqzEz267T0ZTyDRLoXFDXj1qEAaY43RukEBw==.sig.ed25519"
}

{
  "previous": "%1ImynBCX8LuhZpVRDt+otJTEgFlljdXYwBKn47jWREI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1024,
  "timestamp": 1536651712433,
  "hash": "sha256",
  "content": "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.box",
  "signature": "RISsnb+kcTYOg1xVQIbNNj+4bd74TXSFnuTHc62ysHYIKOhxUZ7x+mvSXjb3ZV/L4EoyqTSSvgz65GdxCFSfBw==.sig.ed25519"
}

{
  "previous": "%zo0r2naBk/VaYfXVoMaDUZWLbjpEHLv25ZSCRT1/s90=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1025,
  "timestamp": 1536652129414,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%80bWvl/olZV6V/3Ic7Ckeux2ycu+vnVW4iu/LbCQODs=.sha256",
    "branch": "%OdQsXskBt8gAoB7W+JROIkhhneX8uPzLAGod30FIkhA=.sha256",
    "reply": {
      "%80bWvl/olZV6V/3Ic7Ckeux2ycu+vnVW4iu/LbCQODs=.sha256": "@HjH7assXYIZ5ATQkh1CKtnt6lpVVDY24/NB29okNido=.ed25519",
      "%OdQsXskBt8gAoB7W+JROIkhhneX8uPzLAGod30FIkhA=.sha256": "@HjH7assXYIZ5ATQkh1CKtnt6lpVVDY24/NB29okNido=.ed25519"
    },
    "channel": "ssb-show-and-tell",
    "recps": null,
    "text": "Maybe not completely related, but there's a [unicode annex for hashtag identifiers](http://unicode.org/reports/tr31/#hashtag_identifiers). [@Josiah](@HjH7assXYIZ5ATQkh1CKtnt6lpVVDY24/NB29okNido=.ed25519) [@bundy.christian](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519), also CC [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519)",
    "mentions": [
      {
        "link": "@HjH7assXYIZ5ATQkh1CKtnt6lpVVDY24/NB29okNido=.ed25519",
        "name": "Josiah"
      },
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "bundy.christian"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      }
    ]
  },
  "signature": "dOkPX9cvvWeQ9DV7jYd5fM/lYlfjIFUABa9N7Uo/c1PaxlCQ/+VobcwHKnIx3uSfeF+xc5FmrJE+s+gJHQAHDA==.sig.ed25519"
}

{
  "previous": "%CiOcdQVmUTbvDOOe6KpIrwFPdq3j6MzHm3UTVNaOp48=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1026,
  "timestamp": 1536652224070,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%V3nJjBbljPujVuErde9/cMLVD10jurRhRf2bM+uFcQI=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "p0VJJ4RoN8MLNuAZyNyQeay1T2BO9WufS6KYQ27bdI7bmuPNV+TCYzvCWvadMuyc/FQYJIwXCXQc2jG2FDRgDA==.sig.ed25519"
}

{
  "previous": "%HJRf+F0O+kfsb1m9PUV+A590wUjVCBzXx2VSP5UMNss=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1027,
  "timestamp": 1536654296671,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%8L/kdTz2HcTrkN+C07YKRTvwhcrq1YFef/+xSUJ7Kr4=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%8L/kdTz2HcTrkN+C07YKRTvwhcrq1YFef/+xSUJ7Kr4=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> Also, with signed sequence numbers you can immediately know the total order of any two feed messages, but without, you'd have to traverse the previous links until you get one or the other (since timestamps are non-monotonic now) ... that's possibly thousands of messages.\n\nUnless you save them in the database, which makes it an `O(1)` lookup. I'm not advocating for implementations to stop using computed sequence numbers internally, that would be inefficient madness. Sbot could simply annotate each received message with the sequence number, and store them together in the db. Basically, what I'm saying here: [memoization](https://en.wikipedia.org/wiki/Memoization) completely solves this, and is easy to implement.\n\n> If out-of-order messages also send the sequence, it's now an untrusted number... thinking through all the implications of that hurts my head.\n\nNow, this is a counterargument I can take seriously, I'm looking forward to the head-hurting. OOO right now means putting trust about the validity of the ooo-message into the feed from which you took the message's hash. Since that currently covers the sequence number, you can use it. If the hash did not cover the sequence number, you'd have to trust the peer that answered the ooo request. So this is something where not hashing and signing sequence numbers is objectively worse.\n\nWhat does the sequence number of an ooo-message give us? On its own, not much, just a lower bound on the size of the message's feed, which is pretty useless. It becomes more interesting when multiple ooo messages from the same author have been received. We can tell causal order between those messages based on sequence numbers. I do not and can not know whether having that information might become necessary at some point in the future, or if not necessary then at least useful. But for a future-proof protocol, that just screams \"Stop optimizing and leave this in!\".\n\nFeed ids are also interesting, the peer who answered the ooo request could make up any identity as the message's author. That doesn't sound good...\n\nThank you [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) for raising that point, this did change my mind. I may be stubborn, but not immune to good arguments. We just differ in what kind of arguments we consider \"good\" :green_heart:\n\nI am very tempted to put seqnum and feed id at the end of the metadata, so that non-ooo replication can easily choose not to send them over the wire, as they are still redundant in that setting. I haven't made up my mind whether I'd want to make that mandatory (memoziation really is trivial compared to all the other hoops to go through in order to write an ssb server). But it is worth keeping in mind, saving these bytes (the feed id in particular) would make a relevant impact. ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "J1Puo/TBsCcNXHJvkAd3CpDDJ7lEnKBuuj+R2B4pAKgfvz+cIkCAY37W5KLImDhpTk5lDDgVL2PQQO3cmGZGBA==.sig.ed25519"
}

{
  "previous": "%yCfMJcM19PEN2vLdMxo5cDGFOwhqZlhLiybwBV7wdPU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1028,
  "timestamp": 1536655487694,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256",
    "branch": "%9cmtmRKSORrBj8CHFumcneCl4uJecOSrxmGXsYdl5xk=.sha256",
    "reply": {
      "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%9cmtmRKSORrBj8CHFumcneCl4uJecOSrxmGXsYdl5xk=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Imagine each sentence in this post started with \"In my opnion\".\n\nWell no, it is not exciting. It is a mundane, boring, technical detail, and it makes things *harder* for application developers, so they certainly won't line up lobbying for it (except for [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519)  maybe? :smiley: And [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519) if I get to be very hopeful?). But ultimately it improves the quality of the protocol.\n\nAllow me another weak attempt at an analogy: Advocating a healthy and balanced diet to your children is neither fun nor flashy. And your children will fight you along the way, because chocolate is so much better in the short term. They will be angry, and they will project that anger at you. But still you keep your stance, because you know that long-term it is inevitably better to not base your diet upon chocolate.\n\nThis is how I feel about timestamps. They are super convenient, but also completely [unreliable](%n8hpdMJQCCDNdzeCEDh7MeIKOLBKrCO073418DW6tT8=.sha256). You can't built a strong foundation upon timestamps, yet the protocol actively encourages to do exactly that. And people with privacy concerns are forced out of the community through social mechanisms. This is not healthy. In my opinion, the protocol devs have a responsibility to do the boring work and make the unpopular but correct choice. \n\nI have yet to hear a single counter-argument that is not \"convenience, fun, chocolate\".",
    "mentions": [
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      },
      {
        "link": "%n8hpdMJQCCDNdzeCEDh7MeIKOLBKrCO073418DW6tT8=.sha256",
        "name": "unreliable"
      }
    ]
  },
  "signature": "r5ki1zWCOAsAvKHYG8JFt/wz9xgz52eJ7KCuowpQ9VLsZpdHHx7KBMkGG5fVuB8ke2NTpf8aCgPaiRx5Ghj1Cg==.sig.ed25519"
}

{
  "previous": "%EEx6vwTiyJNCsrNimMah+MgOFCATrKNb25T/C1DoZRQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1029,
  "timestamp": 1536656992811,
  "hash": "sha256",
  "content": "NdC5FI+vWYlSZ2jmP/5gJIgV1Omjs8lV8c3oWaO8btOOzih6yEB5BPjarP7+JZBmI5W/t48Am3e0h03PteNSyfND3iuRCVgsokAnzBGMSd8QX7wedQKr6GiKcH5qYTyxjg6Tp8OdfT2CEdFBrjrIwpVVF38nZM2i2Lqb/WbJa1Jsojrw9gBRldwLpa3VxfG1Ed5K0HcL1fyTbwNGAryEEiurnjoCtXq0s4oXIT5oJOpCzuv72xUiivDQ5TmXt5fGBBdwF/EKi/x3O4Hk3BwXWGtTsXgkI7PE/pfAv8bo14zxBw8zPK3WBOGRGx5mP4C3w+LqFF+qp3/QMG46D3c9zFMzGkSAnh99HDsuyBb/Rp0dNVWU17MZ8VdT1W50l4jBVXmtz0LfiDjwJA/vvkmtaPzInYl0Ad5D8LYiHFpDaKPgkKs+QY+OXBDgQ5QSqmao98jfeJa8E7rqQxqZddna2W7bNmmRbcq7ROOas30ZmluRp/+gTeqG4vHO1LtlxNw/klNPfj4hdKCBh755if6RrhiJ0/jdSdcCsA/sDH3lwOSjd/G6BugVG8oU9C7q1dPrxq36iwnNy5S2pno+tXCkS4W9xgEvk9D1ciHuMkAol20JmHN9uzN2uHLBtFkjBnYpBBUhyNszS84Humlp7bXTmDye8EmnfczlOo7dysHkib6vPQY1zDiTN5grC+TCTs7I2Ot+k5W4MDV9K6tG06B//iaNOVoh01uaQHamIq7Hp4L+0Cw1St01/9AVbalrbZ14L0GfbJj6M8enOyFeIw+L/p4e62wf+gTVwwzwSl20L8rW6WTDeSDpySGj2vlXX3n3b1WZTfKSIGXYIOlCXDRcJd5iDa5bHxqTbNXdrVeqi/qf9cOB6g7q2L0/cdp0HtVXC10z0ul1vi3ZqlRdYZJ+Ax9NqDOVps9NONpQdKr1X1Mm0oUriX4w3svOpvHihIr6YOsoSudih8B8e0Vd3j3DwvywikzH2Evl89kOHObJnRX0E+LV20zmjNdb2NEjP+MPLHmeFvggHdVZN1Txrvnnt7d/J98UzexTZGNugGcBqv5N3EI/Q3Mqy5L1RJQCZNMljyKww0EJIFjjCJBeebrGV636zwuogXXwtrDZ+4ZUKt+psfukjJjzIZVu0dp0zzh9zsM7A9nIbOh4OH3t99im+xhZTGVpytjvS8NPqZ+DGxLGmwhIVrsRQ4OO/XSOJFZM0uiOKWf33+qqzjPnTeRCxwcKR8tB8cnYR8wwdxNTY+gya6WAcS4FGhurFJgr2YdG6OmSfGA8somBSBwP1LGbcGnLPaE14ualkc2YkBXzD+GitwFyoIk87fpUTvRxUJn4yMMtTyaiZlZ9LpBFZxSuTA/fDhOsCjgyDgnuEt4BLIuhccMDU/FVOh474z0G5WTZDZkhLT+r6C2crcrpzd9ctbX1YVs/Bowkf5mwSKECYTXsXpiSvTdJXLFG0Z6/3VCZeIKq/wsR8C7SJA/TN1xzwRM8mZ689xWnigtCV3tM9tjPuj2tVE7x5HcBm57C6LnnFM6CVbuSfNYUQWdJBJWkprUPI/JrRO+jlQEydIuR06JoMk7BmFvdoxgfbaypVFlkcUW5BM6CDxZ0VxtKLjQaO/aRAPDJDmW1q/rtPw2bbLo/dqwpUXKhKBe+XMmO6fhCtFxi20D47qucDKsss7oUsy7N86A59mMmG31bUzQBNfImN2LfSDjnfutmt5SHIkcMjVzeCKe1ML0HunhVsJz05Hlx3MngxPxeyAvVoA+Mgfbm/8vOWN0eLhrx0caSq9yU9Hsk9Zi82gV8CtrtfkeVvfStUr1z/sqprSoY+G/LcsWvnMJjsWqiBdOztcX20+dCuvr7c3XvehUj2lMb2XiT/dLJeogevL+nclVlDtOMPSEd6pXZgeiraY1irB8xBdnSloSJaSfCt+yJxxM1ACnlnculcyUKKG9MsDMMYxhOnKSZZD4vU0pl0MPwLWmyz0zgOcMBUeKU+TQEcSWNzrTiGll0VJoCUAuUZ3MNdVoAFHvbzrBFn8AT546WQJ/3Le5okkI1SqlYI9w9qzHuKV6nqdyizSBiBjM9dYpRAVhGy0JOBuj9/LvxZMjy/wIfvFwMj1Q90rehAy/54QIr6EWa8SiWA57RBd4perBNMjJAwpvepJdR57h88G3YaSPTK6j5kLPCNRuzZreK3cE5CrUMJFts5UaEWKbnj6fwdsQIBrptWAKK3cJO17hxG1VNmgnMuCV4DZVu7WgZx5SAXIuOirDc6bKhLTCXcKFppQNb91KbAKdFfJJ0K+vCrKr9UFzXdYrudGtMpUKVGoYTgwGQhnjlDQ/qmt3by2RXvIfkGJt5X1WdS1OtOJzczdWi/naa+zwWE4h4P8QyqYXFdAYzcRwTFqk812R/WVBlf+DRuKHcQ4TSQWQMBA/ZgbDDS1MM4LLbEnf5TRKnpeVfpqUf7Yzzg04DvmC+HrcX+T4keKYmWZUma2/fI05TPoRjZpPMUzQ8fAWltHpLVgo8hHlQ13QWyyeXP9Dx3CPt90Q/jmgnCstdutz9r/k0yaRX9L1k.box",
  "signature": "VuWPzzGXxmbd3xI9I1XzY9hyWPVifDcwFdEHhFPJgh25AlApEn9H6qn8Canm+DfIsArfoWgTPKn4Q0NaIDdCDQ==.sig.ed25519"
}

{
  "previous": "%uyqmGKRjimPCMe7DADkM+kTjF8W78+qEUH6v7XKsUzI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1030,
  "timestamp": 1536661804170,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256",
    "branch": [
      "%1c7uRu4f4uuzCOAWI6bUTXKJA+xWbNUs0npR0yob1+4=.sha256",
      "%KFuCEevuM1Vx9HylUsINAkgpt7xsYhCtUyD804rP6DQ=.sha256"
    ],
    "reply": {
      "%QOTRH1C4E0XrpawMrw3u4m6SwGC6GpZ3w9NyP7gJa0I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%1c7uRu4f4uuzCOAWI6bUTXKJA+xWbNUs0npR0yob1+4=.sha256": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> Btw, you know you could just set your timestamps to zero, that doesn't require a protocol change. That wouldn't be as annoying as random timestamps, because at least they are obviously unset.\n\nThat is exactly what I mean by optional timestamps: Use some garbage value that does not take up any additional space, but that can (or depending on the client API *must*) be detected by application devs. Whether that garbage is a magic number or signaled explicitly is fully up to the encoding.\n\n> because at least they are obviously unset\n\n\"Obviously\" to humans, not computers. And depending on who you ask, the \"obvious\" choice is `null`, `undefined`, `NaN`, `Infinity`, `-Infinity`, `0`, `-1`, `None`, or one of a billion other things. All I'm asking for is an arbitrary but binding choice on the protocol level, so that we get this in an interoperable and machine-friendly way.\n\n> I'm not gonna turn around and say \"sorry this is a chocolate free house\"... because these arn't actually my children! They can do what they want and I can't make them upgrade sbot if they don't feel like it! This is the whole point of ssb, even as the protocol designer, I can't force things on anyone.\n\nI agree with this in general, but disagree with specific parts, based on the distinction between metadata and message content. I don't presume any authority for a chocolate ban either - devs can (and in many cases should) include timestamps in message content. That makes them encryptable, keeps them out of replication or ssb-client APIs, and if things blow up, it is their own responsibility. Think of it as responsibility sandboxing if you like.\n\nThe `\"content\"` part of messages is where we give devs all possible freedom. But everything else is not part of the API. It should be possible to build upon ssb without knowing any of the metadata implementation details, all that matters are the abstract guarantees we give. And the abstract guarantee of reliable timestamps is bogus and should have never been given in the first place.\n\nSsb encapsulates all the messy details of an eventually consistent, decentralized database. Encapsulation is always a matter of trust, the application devs trust the protocol devs to do a good job with those internals, so they don't need to deal with them themselves. No need for the encapsulated details to \"feel good\". \n\n[@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519) thanks for voicing your support (same to [@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519)). Getting the db to support efficient causal order queries will be [some work](%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256), but it is possible. Besides all the complexity, we could quickly hack such queries together by choosing one of the trivial options: Either performing a breadth-first search on the cypherlink-graph on each query (slow), or storing the full transitive closure of the cypherlink-graph's edge relation (extremely fast, but takes up lots of space). Either is probably still fine at our current scale, and there are available solutions to get this efficient in the long term.\n ",
    "mentions": [
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      },
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      },
      {
        "link": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
        "name": "some work"
      }
    ]
  },
  "signature": "QS66ac8wZiOi7udW3txy2136B1sUsHx/URk4+sNuhD3Xpw0LsjtEU1nuaGLht5gZbF0yPegucStmyzBwsqtzCg==.sig.ed25519"
}

{
  "previous": "%JsPQu85HMOkm/m04Fn3b3h93yj88r5YT0DxkNzsAkK4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1031,
  "timestamp": 1536661819682,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%9eFliOYHe+GGaPcuLgYX+NlEnrx0xlyyARIrgqtMiMA=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "1hnG4/MkA+mHlHLf9hOsRCGoiXkT0klZgg3uexmAByagsJ70WxWKTC+sIs5uSZWSmhWc9Eo/8o0nuT7+lT+wDQ==.sig.ed25519"
}

{
  "previous": "%SlmqGYVDXWHYdtJbZcfTqWbvpJOh+TnsKvJMX3lRETY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1032,
  "timestamp": 1536661822395,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%1c7uRu4f4uuzCOAWI6bUTXKJA+xWbNUs0npR0yob1+4=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "ahxfuJgO6xJpKQIjw5Vit0eebIzQhPNzwAUvXuIEEp+bE01aNdHSxzXP8v1b4yoRI+q4nGCDeh1VNfEFDYy4BQ==.sig.ed25519"
}

{
  "previous": "%3IzSWde/AZXeQIbt7wBhHoieKxIUKJdrHcCIT+zLif8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1033,
  "timestamp": 1536661873424,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb",
    "vote": {
      "link": "%xtq/l+GovYpCmpLwFYTse1VGkkzfRIjGCbQvz5hcFbQ=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "uj82Kvrumo3G8cRPyHKclyLQWWZpV04L4Ucaa1re8S529mZP7GsElzyP7asiveYbq3L824Ce9ObOwkr68j3EAA==.sig.ed25519"
}

{
  "previous": "%l1qvvbp9SqyvfTtUXbrp4ZZMU4qOnrrRDByBYLPULrY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1034,
  "timestamp": 1536670751651,
  "hash": "sha256",
  "content": "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.box",
  "signature": "oJgXZeQR+uSEDLcoTQ8SlMie6YQbW3QraARZFagkDjDa/bAKp0A2odesrjqK3h2ODy7cxzArzDlW2mEOvfWzAw==.sig.ed25519"
}

{
  "previous": "%hBA43PmRQGFSOeJICLiiqYE4RsTaiH9CucjCwE7Rl64=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1035,
  "timestamp": 1536671292702,
  "hash": "sha256",
  "content": "Cx2ifq4NsXWxJ+kJau502hsc+WQ4J8A8ykj3Bk75UKKZ4lPYLtfT/jwqy2I7FEn0gVRMOwa7bUONn4eAgSYFo4cknV/QD45yimgu2A9zMYHsbXqxP/CNo3TNyc3wHe/gTy9/bUSJT5N1yFS083ZwJr4/e87XB98/5DS3lmda0S1/S506RyGID/JV3NGWt+Zag7/Z2QoxVVvBjWpBzquXg+kUedskkpq2YYRwnndOVi0mRhWhpF0WvkNcYJd3UnTRbI5Bl/EaLOYlngf4pGBKd85G5xTq2T+KcKo++Zc9NJBj/rRb6+RwQy/5KGq/S4Z2SaBkjhuwXnHjhl3t4C5GwMqiPWQJ1kkSvf2/g9BYrh2TmtCrSC/SeRSSCW7W/BBVXwEd3ukaauBcHH+ltbeKWIlhcJ57KxI0FE64nTlmPFHeZ+bYKrqthN8KSvwzXR1jR0Fn9mCwIe8WWZcsaev7ZqKUAQqlYLHU9MijP2SM5wFM3tcpdIlk+XOKyELbjH/ZCwxNTqGT8LQN0QI0+PbkFF4wZN9jEZyljo/J+3YFSbx5yQPhVTScl0xIZHBIGKQICTyDKkqHdv5BrvZCYUuQU3AOvU9o8yFTwUxtYPu4PizZZ0G4lDnq2V4dCYSSX7K+7G/8SoscWJagAFjUnZN2mvdZvKjP/JvbzKfMdQHOE8/ThSGMb2SWf2qGmYIkcqbeUk+4U3niENjLVUqLdpyB4NlqoLbXTaMkzQsvKO5Pr/c4gBBHpapbKcFxA5zsbZhNjYAC/kH8BoIxCjmTaaK3zdKUM41ciWgvU/g4VtIGGwyPQ+mNLgNDBHDxsZ7rqzrJhRok1SKWf/O3O7am7sgJdcpi+84ABKIJCXDBixiVNr4qMB44Dis0921txRJl+4TJBWb8TCoqnFHkl/iZOu3nPO85Oe+VgBTmZtvQG44dtTgkNzBLjERdJLYck92SSaBi0bzDLCpMNYb+eT8baN+Tgu8lBkOuLJl9LxwE7tFwvE6giNabYLID.box",
  "signature": "gLeQUTW+3dDv+mP986WKQo8JEBMYRzweFwsJIXiBAcWQ2v1E1iIuX+7O6XTwH04wEPwcyoghfL8BCEcm4bwbAg==.sig.ed25519"
}

{
  "previous": "%7BmIovdWjhzvM3/7brE12xccP8/JBA/iE9D4F7k2arg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1036,
  "timestamp": 1536675595415,
  "hash": "sha256",
  "content": "pZVO2gZO6IvezQprp8yCFHQaD+XoIeI/SAkUBRulzbe374FuBPVAOSRIM6kgJ+RaD8ZnTV7S3Hb2+rX3pj57Yv3cIarp7fNdmigD1UJ8KYrnicQPFAf3EDqUe+8wlna/EuLoRZxJJRdYBit2C9SMheUAzz4N7QBaJtW1/5pxd1cLzKEZSQdyaJocdG3toEilzjFUIH+cas9UQNLz19jjuJ0TGTKPARrX0MIyaAyCe2T5ASQJwKfqodB6QymsEPf09Qhj4iotwGxSNtx/NwNgRZN2bk1UjwJvsSh75eyLtajhdcwE0vE3XSEDe7i6BKOzkTTOzPu8ztcqWb1nM1FOBu7FBjbaZ9AamvN7EpSO7sOUzzpNaMkFQZKohaSpunF4BSDbc2oDvVsuE093a2nC6NDsmCdDmH8IggGOT8AuHQjelgCq61I9LghxaVHl4ujOjOJxLX7DFpeS0UHYXcrC1kdktl6eUqH1xAsXd8ixQNbQn/kuOdqhiYU2siGTdvBu2pg4nA8Fm3G28pct5M6Mws/pXL9MRNrke3tvSu+PadC8pYUNrdP8nzyGA7GxUe5UQTYFYp5C6PrNEmoG2t1Y+0Zj1Az+vvhx2C4MEGU+cM+aa7ELo8xlkRQHLwEzQ8VY6X/vRL+IIddpo6I2Jz3eDSi8A7uj6XopkIbA2DnPYNbGeoFyOn0uepyZViZGa4gEqHv3u7XXmSj8iQ9cJqvNRnF6alJSks/NUjbBme+zBHmnxIN/8ZIBbAZFTZCVtu0VPLm3TPjM80O504TLeYjDAI9GLorCVV2PZJefVA2+aLFASko6fNdlNlkoW/Darni9TqqnIjtsCN48LTSJnD0ulq5kye1YMAfzkShsKD2rv8j1BKO2adblCUJyK6DQTt9KY59iotUjv2nfEqAGdWBdG+ZB8cAo5ebSpOPtrVpK+ca2nd8a+hzIyxREzjtP92Gcg5NLWY6PMwZUrnjjw5c2F7Ho888go65KBtPcXsSQisjDb/kvWb1g2OvWS06EP+InmCHwksNO+ybFH8a4oRes+6o4xz6Iy4rTf8DmqjMbZWZ1HF/94gqTcE619skLX+L+kdieKdXSwqQtNB+IHyAWGytU3o/kuOG+CpPmq+HBBP7lM2+TA3HOVo7erj6vlicnFKPWAMxszeDHE06yFLcRv3oJ99iOOWYZpbT8wY7Ll+EoUjDAOBHcEuZAoxV9TRq/a2Bdc1rYIvyN00n50TWV5C0f6iJZ8DqRdf56Psuh9AlnO5JNpqQb88AWuX9wImEp+oSH3ekm0lYAFvoH8dkJhZq6OXWvixhnHKJAAzbnFXLxNhLpHJBCtXt7b7ye+z2oCx9VoER235L7SFEgpB9HYFtBwyquE+yes8N2ydQuLO+MZwFIo7UO.box",
  "signature": "mDIM0m4r8vJZq6Ru7p8qmXjfeje5iAFHlPQRV/udh5GCYLJctJM5kXW9rZrLQrtih129in8WQl5hnj11XjE0Dg==.sig.ed25519"
}

{
  "previous": "%UIrIv9tN1z1bdEpUouzHpEhbnj1oZYs4LQQ5defB/Y8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1037,
  "timestamp": 1536683388758,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%7FGRr9OvcCZE4ubo87Ai7qxV3yp7kekEUIgRJxyRDUc=.sha256",
    "branch": "%7FGRr9OvcCZE4ubo87Ai7qxV3yp7kekEUIgRJxyRDUc=.sha256",
    "reply": {
      "%7FGRr9OvcCZE4ubo87Ai7qxV3yp7kekEUIgRJxyRDUc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "I wanted to look at how much effort this would take to implement. As a starting point, I chose to see how `createHistoryStream` is implemented and where it gets used. After 15 minutes of trying to find its definition, I've given up. I'm not even sure which module to look in. Started in 'scuttlebot', then meandered to 'secure-scuttlebutt', which seems to load an object called `db` that refers `createHistoryStream` by name from 'level-sublevel/bytewise', which is a function that takes 'level' as an argument, at which point I decided to ask instead.\n\n- Where is `getHistoryStream` defined?\n- How does one add a new rpc to #sbot?",
    "mentions": [
      {
        "link": "#sbot"
      }
    ]
  },
  "signature": "MCiSm5HLiM7xPyK9Z1LDEmE5byXC19ml0WhqkvJzSUHn0k8RfP4+mCMsBauapj9b80p/UX2Jx+X9BPJEQ6IJCg==.sig.ed25519"
}

{
  "previous": "%tJEHP/JKQ96Q0lA8aYhby8Db8q17BKdeSOwnyOtSe1A=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1038,
  "timestamp": 1536683950459,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%P7B6o2keZ3UNVWqohSzTzGWzkt7Xum0cehoe6GpkZXQ=.sha256",
    "branch": [
      "%CGewcS8uenvsmw7J8NXCEm2U5/N1cdEArdYYLV+u4SA=.sha256",
      "%S/HvkfEgvUqIjlsvV2g5PsDahbdSHGhH9VdaEhaF+4E=.sha256"
    ],
    "reply": {
      "%P7B6o2keZ3UNVWqohSzTzGWzkt7Xum0cehoe6GpkZXQ=.sha256": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
      "%S/HvkfEgvUqIjlsvV2g5PsDahbdSHGhH9VdaEhaF+4E=.sha256": "@rGGlF9/6AAMuxpEhznHTpG8XTS0TJHGJ1k4qfgfJCwM=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Accepting.",
    "mentions": []
  },
  "signature": "j8c4DHUHViyeMxPyjk7hQDknrRJEmOob/hJf2VCuJKtcqA9bDMJCB0j1QEq+KMGIPietImM9c8t0Fc0rv+8iBg==.sig.ed25519"
}

{
  "previous": "%1W1LywDx1vFgynxybYTgpPX4grSuA8rINDFol//DLXk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1039,
  "timestamp": 1536684189231,
  "hash": "sha256",
  "content": "uRm+KznXSNnhxM7apryVqaVGTQmDU6pp1rT3kf3gJdNeVyYbJJQtS0ys9f1s8MzcjsnKdySkpDqpF4GL7puykA/CoFCyjqA2ifiUEgid4UqYF0wy0Isfat5gbrVm1adj/SDrlwnyZ3B9WDt39Bnb6SuWp++xHs5jJfgctWg4XW6CGC8CA82Q4g/GGWb37T9TXrjMzZzzTQUyOmjIuEfTteyrqbFeSGy8yvpD6UoagwasaZs34nXRHG28Dy76guF3qkokJVuk9li8kt/78phtXIHDXm3fP7Vy6FFw6LuZn/aYVsuN9bJu0EWBOSUaAGmb/0UA0t62Sl/9Vmq2gI5u8zbI3CjA42gimIaYbHT9FI5//Bgo5khAXmLsGaXwbBbm/szqeNmuxBtl6XTqKVyYP+al0fLirFus4PaloDp+aeFJmF3YLdKk4Gtr0z2ol2MpLvwz99aTVJAZzk+EGgDQiw1ugQY4qRFaTX7VyAeeA/LZThJ4iSjKonNdOtrTkaqeNczfFLnWe1795UZq7K0jJEHAAfiMm+Ec0mn9Cr1VP8ftC2CGlYxwtaEnIxxGIOkfz5cJDmoDMXAP2ikUzX9Rlo9C6A7Bb4dhid7ko9DeR7zVquV1/49/kkwrO98uKWNL7K9ybvA4lNFQDECrJnoqoBKywDLfocLD4p7526ae4bcu2Qc/av6CABP8il403WEEYKLDnC6XBHoV79HaredqcdpR79IXHJx6V0Rd9EpDT1/FVMM04sYq2L16pynlU2FdV5k5tHhJh2V19ncrqfyIN7oh8lGgN0vCIs2yeHZJQri7zCqcr9nKJyllhq4sqIznkp3OtPck/l0vHwMtrcuK6OaJmf5YxInJWxFvnD5nVVp5adkdnJ0/e+y0Cx4hTVYldPfCKqZ+pD4H7ha9OITNS431dpE+o0swds4AUy7wfZfKdm4OUlX+asO9woiPrsQKJsRO7xDOWFDuIpcUhMpN3mSE+Y3qKEZzQpW1kgmWjWsW/ZQQ7GGEHDQnGyZa3Cx6oEdnuz1leCYoYgQX2bAJ//ZQY/ZjmmOISdRO3Rr0yKROlUqNwVPhlFa84gWSx7m4BLRstJNryLRYyZvD2jnv/BILLYidCPztAUFf6nNLlkYT4YplXUDb20HmASY/nvbTW7VmLmIqC0wL+RuSOk1Cl5gHY1WGfxEbs3DQLFOzeTwj8kwjQu67iNe7J8ZA1mNjaT8w0x4DW4sKhs9adJMy1MZ+QBV3nhJ/GffWtBhTmTtXsuaj//02R/oW57wSXbruoSFUaxo8EvsTEjSf++C+O0o0SCQdWF9cY3Q9S+kfKheQWgge/B/ZsZMXOtpXfGqkuF0/kjyxboMYWJP2ZhyGLJMhf1KIAwXxE2n48aLVa7M7wn39HSfzN14tsgb1cp9lrr52Wh29QyGWVuDgjbP/Fmj7v1KlHEKpfrjQBZNkV3qh/jsN5BUQWll7SuRc3IcFF5FLjdrAH1u5n04+dObr83dNtUYyaRQaTH/TobWJX+HnQyA6SXP6Ssmyy3j8MTpuVvZwIy3bC9auIOQsvRvgL2iNVSCQza9t6nxeVPCZ55hHRPt+Bxw5RB8GNxhwP9SFZqs4ckebyDtSmK9gmWI30NrCWs+KwRp7YGbrmwAVV17SwnDKXyyhFqSpgqGwvLJ0GgbQPjA0zE7fwxBfIf94KNVmx5bYcvg8Vdoex4fFJDGBM93pssbimHEuf5xQh0U9HoHICSYNnKeCBIDb7uJ+rMVN2REPly7ZLTYgCY50qrYb1+s152yPAiVqLklYezNHvAKAfs2EpmACWQWtp/3GGH2O57i42INdZqXJ/SuqMXEXl/UpuP2xerhrN92DWDGx0A0=.box",
  "signature": "aeQoRnmlUGfPsDt3mJQP49gfFNzJKoeCDX2oAAz/i5eXOGwfVgP5cI3mEqYKeZfQ11RWcGuThk2AxEqTc1sgCQ==.sig.ed25519"
}

{
  "previous": "%bNKvQtbL8RzlRdnkYCxAGDzotP8MWk+RjJH4k5GKVHc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1040,
  "timestamp": 1536701950798,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "offchain-content",
    "text": "# Moving message content out of the sigchain\n(aka #offchain-content aka #blob-content)\n\nThe building blocks of the scuttleverse are the user's sigchains. Each time you post a message, it is appended to your identity's sigchain, a sort of personal blockchain. This is accomplished by running the whole message - both metadata and content - through a hash function, and using those hashes as the cypherlinks that build the signchain. This post talks about a possible change to that scheme: What if instead of running the message content through the hash function, you'd only use a hash of the content to compute the message's hash? This suggestion has been brought up independently at multiple points in the past. In this post, I'll summarize pros and cons of this alternate approach.\n\n*A tiny parenthesis on terminology: The #blob-content hashtag has been proposed to refer to this concept. The actual implementation will very likely not involve blobs at all, so I'm using #offchain-content instead, which is descriptive of what precisely the proposal is about, rather than referring to implementation details.*\n\n---\n\nIf ssb only wanted to do efficient data replication, it would not need a sigchain, any linked list would do. What the sigchain gives us, is data integrity. Given any message in a feed, ssb can (and does) verify its authenticity by traversing the list of previous messages, checking that all cypherlinks are indeed correct. These checks necessarily need to acces all the data that was used to compute those hashes. In particular, this currently means the content of all messages. All content has to be stored, else message verification can not work. But if the cypherlink of a message only depended on its metadata and a hash of its content, than you'd only have to store the hash of the content to preserve verifiability of the whole sigchain. From this observation, we can derive the arguments that support offchain content\n\n## Pros\n\n#### Selective Deletion\n\nSometimes, you may want to delete a message, maybe because it offends you, or because its content is illegal in your nation's jurisdiction. But under the current system, you can not delete message content, so you'd have to delete the whole feed. This is not always appropriate. With offchain content, you'd get that ability. You could give a list of banned hashes to your ssb implementation , and whenever it receives a message whose content hashes to one of those banned values, it does not get saved. You could even get fancy and store socially curated banlists on ssb itself.\n\nUsers can be [required by law](https://gdpr-info.eu/) to delete specific content. Right now, that would mean blocking the whole feed, so these laws would wipe out full ssb identities, even if they only posted a single message that violates these laws. offchain content fixes that.\n\n#### Faster Initial Sync\n\nWhen downloading data from the scuttleverse for the first time, or after a longer offline period, you need to wait a long time for all downloads to finish. In many cases, you might want to look at the newest messages first. But ssb has to verify their integrity before displaying them, and thats a good thing, let's not optimize performance by forfeiting security guarantees. But to verify the new messages, we first have to download all previous messages. And in particular, we have to download all previous message's content. With offchain content, the total amount of data needed for verification would shrink significantly. When syncing, the ssb server could first request all the metadata (including content hashes), and then the content in reverse chronological order. This could drastically reduce the time needed for apps to become functional when performing a large sync.\n\nThis proposed replication scheme is not appropriate in all cases, but there's nothing forcing us to always use it. And we could do clever rpcs like \"Sync in chronological order, unless it is more than `n` messages, in that case send metadata first and then the reverse-chronological contents.\". Nothing forces us to implement any of these at once, but there is vast potential for speeding things up.\n\nAnother useful potential replication rpc here: \"Sync in chronological order, but skip all message contents larger than `k` bytes, I'll get those later on demand, if I really need them.\"\n\n#### Lifting the Message Size Limit\n\nThere is currently a hard(-ish, unicode and ssb are weird) limit on the maximum size of ssb messages. That's the reason why I will have to split this post into multiple parts. The makes sense, a reasonably-sized sigchain is essential for ssb to work. But if we only stored a hash of the content, then the content size would not affect the sigchain size any more. For most user of the current ssb applications, the practical impact will be writing posts without having to worry about hitting a size cap. To developers in general, it simplifies the API for sending messages, without the need to handle the case of messages that are too large.\n\nWhether it still makes sense to enforce a new limit, albeit much higher than the current one, will need more careful discussion. Blobs also currently have a size cap, even tough they don't bloat the sigchains. I think #bpmux will make it possible to completely lift the limit (or rather to set it to `2^64 - 1`), which in practice amounts to the same as having no message size limit at all, since the operating system would terminate any application that would deal with values of that size anyways.\n\n#### Feed Compression, Garbage Collection, and Forgetting Content\n\nSome feeds may get very large. But you probably won't be constantly accessing all the data from years ago. With the change, you could locally delete old, rarely accessed data, and simply download it from the network again, if you do happen to need access again.\n\nNow, there are risks involved with this - if everybody did this, data might get lost. So doing this on all devices might not be a good id. But just having the option for doing this on devices with limited hard drive space expands the range of settings where ssb can be useful. Looked upon another way, these very risks are a feature in the case of illegal content.\n\nAnd maybe, you might want some content of yours to disappear from the network. Ssb is a distributed setting, so you can't force anyone to delete it. But you can ask nicely. And since ssb works by surrounding yourself with trusted \"friends\", there's a good chance they will respect your wish and delete the message content and add its hash to their local list of banned hashes.\n\n*continued in the next post...*",
    "mentions": [
      {
        "link": "#offchain-content"
      },
      {
        "link": "#blob-content"
      },
      {
        "link": "#blob-content"
      },
      {
        "link": "#offchain-content"
      },
      {
        "link": "#bpmux"
      }
    ]
  },
  "signature": "WcqHYErP7dHzoUhHfJSfO9497zSTvKSJaBmK1yUhc4tcDa7UgqCSD7LHHTNtOBbp25HQR8XmAbNiViSRF9t+CA==.sig.ed25519"
}

{
  "previous": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1041,
  "timestamp": 1536701989518,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
    "branch": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
    "reply": {
      "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "offchain-content",
    "recps": null,
    "text": "*...continuation of the previous post*\n\n#### Deduplication\n\nA database might choose to store content completely separated from metadata, and look up content by hash. This results in a very nice property: If multiple messages have the same content, they are only stored once. Currently, an application developer has to use blobs to achieve that effect, which means giving up upon the nice logical data model of messages, as well as the ability for plugins to inspect the content (e.g. to automatically create database indices for cypherlinks). With offchain content, devs get the best of both worlds.\n\n#### Conceptual Clarity\n\nThis is a fuzzy/subjective one. Basically, the sigchain currently stores both metadata and data. Blobs are also data, but not part of the sigchain. With offchain content, the sigchain would consist purely of metadata, and all actual data would be stored off-chain. I personally think it is more elegant that way.\n\nTaken to the extreme, you could argue that in such a setting, having both blobs and messages is redundant. If messages have no size limit, deduplicate automatically, can't we drop blobs completely? (For the sake of the argument, let's also assume that message content is not forced to be a map. The details of this don't belong into this post, but it can (and imo should) be done. Also for the sake of the argument, consider that #hsdt allows byte strings, so a message content could simply be the binary content of an arbitrary file). There are still some differences (messages have a mandatory `type`, blobs can be conjured into existence without a corresponding metadata entry in the sigchain), but it is interesting how much these two would converge. This won't really influence the decision on offchain content, but we should keep this in mind for later.\n\n## Cons\n\nAs I am clearly a proponent of offchain content, this section may be lacking. I didn't conciously omit any arguments to be more persuasive, but I may have missed a bunch of arguments.\n\n#### More Data Overall\n\nThe total amount of data stored/transmitted/hashed is increased by one hash per message.\n\n#### More Hashing\n\nOne more hash per message needs to be computed during verification, the total size of bytes that needs to be hashed increases by the size of each content's hash.\n\n#### Yet Another Change\n\nIn particular, this would warrant new replication rpcs. There's a simplistic #blob-content approach for implementing this, where we'd use actual ssb blobs to store message content. The old replication methods could be used as usual, and you would then request the content blobs when clients want to display them. But that requires more roundtrips, as well as flooding the network with blob request, undoing the efficienty gains that messages get from ebt replication.\n\nSo #blob-content just doesn't cut it. Instead, we'd need to implement replication rpcs that explicitly deal with the new situation. The most simple ones would be \"Only send metadata\" and \"Send each message's metadata followed by its content\" (well, and in theory there's also \"Only send content\", but that one is useless in practice). Another reasonable one would be \"Send all metadata, and send content in a separate stream with independent backpressure\". And then there's the potential for more complex ones, as sketched in the \"Faster Initial Sync\" section of this post.\n\nYou can look at that and remark that clearly offchain-content makes replication much more complicated. But in some sense, it breaks down replication into two orthogonal components, metadata and content. The current system complects them, the resulting replication is rather crude - all or nothing. With metadata and content as orthogonal vectors, the rpcs can combine these two to address arbitrary points in the spanned vector space (it isn't really a vector space in the mathematical sense, but it gets surprisinly close on an intuitive level).\n\n## Concluding Remarks\n\nSelective deletion alone makes offchain-content worth it in my opinion. We can't ignore the laws that mandate deletion of certain pieces of data, and staying compliant without having to delete and block whole feeds is a huge win. Compared to that, deduplication, the message size limit, conceptual clarity and the possibility of feed compression are mostly nice extras. More efficient initial sync however is another big deal, especially with mmmmm's struggle to get a reasonable mobile experience.\n\nThe overall increase in data and hashing would most likely be offset by the use of clever replication rpcs. And as usual, I remain blissfully ignorant of the fact that these changes need to be implemented. Sbot is a working ssb implementation, so from its perspective, these changes mean reimplementing a bunch of stuff that already works sufficiently well. But from the perspective of future protocol implementors it really doesn't make a big difference, especially if all legacy messages can be handled by a [single, easy to implement rpc](%7FGRr9OvcCZE4ubo87Ai7qxV3yp7kekEUIgRJxyRDUc=.sha256). And I care more about the potentially large number of future implementors, than about the current javascript implementation. As one of those potential future implementors, I may be biased though... =)\n",
    "mentions": [
      {
        "link": "#hsdt"
      },
      {
        "link": "#blob-content"
      },
      {
        "link": "#blob-content"
      },
      {
        "link": "%7FGRr9OvcCZE4ubo87Ai7qxV3yp7kekEUIgRJxyRDUc=.sha256",
        "name": "single, easy to implement rpc"
      }
    ]
  },
  "signature": "AGw+I/sXFSv+AAh1Nc/8eVuqVXFU/F5McCdIAIN86w2vLHzfOFSX+bdDwyo14CPtv7TLOQorm0fF/7CKYE0yCw==.sig.ed25519"
}

{
  "previous": "%w5aLKFIuTttR8o6QB8SNOb/iqhiWDbAzmwaJIZQBjSA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1042,
  "timestamp": 1536702493955,
  "hash": "sha256",
  "content": "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.box",
  "signature": "JmF0BG8g8Yw+duB4fSVLQO3Frbu4Mw5zqOxPpHnGI2SnaS5FFALEdM7+j2zc2u4pPQpmW7pak9v6w6Zka9fDAw==.sig.ed25519"
}

{
  "previous": "%FzjI7+IEWDbwho9bM4s0E1XKmscZtwoaOqbuW3gWUn8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1043,
  "timestamp": 1536702697561,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%72W8T3xNHfbx3D/DA8+R39zfc8nZMFCZlgna2HJKaf4=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "gixnH4I0aT+1yr6Q/exYQ1IeYckTHjsy3mJlL8ncLTvfkb3gc6eKgPXOT5RyLZBgRvUM6PuXC0QHPCPD7c7pAQ==.sig.ed25519"
}

{
  "previous": "%t5Dr9U90kJN5qMgeBOfjuUX5HCSvF0bZxj7fNC954hA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1044,
  "timestamp": 1536703028274,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%7FGRr9OvcCZE4ubo87Ai7qxV3yp7kekEUIgRJxyRDUc=.sha256",
    "branch": "%72W8T3xNHfbx3D/DA8+R39zfc8nZMFCZlgna2HJKaf4=.sha256",
    "reply": {
      "%7FGRr9OvcCZE4ubo87Ai7qxV3yp7kekEUIgRJxyRDUc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%72W8T3xNHfbx3D/DA8+R39zfc8nZMFCZlgna2HJKaf4=.sha256": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Wow [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), thank you so much!\n\nAny recommendations/opinions on whether `createSimpleValidationStream` (also open for better naming suggestions btw) should be its own tiny plugin, part of sbot, or part of secure-scuttlebutt?",
    "mentions": [
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "vylhVU2EiGbmJjUFqF+v/9LuG6LyxgCZwER3r2FNaUXm24//fSR42iExHVS8KtDqWUPxqTkthjGzxWXjBr7cBg==.sig.ed25519"
}

{
  "previous": "%OzlbFysKfBklJFdeTUKbkyOV7sodGen/rnnWrJNG3+w=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1045,
  "timestamp": 1536703541138,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%9VWASKdl78TVKP+Hn0bVqji6Avg0DpfSP4aUIT6rwJE=.sha256",
    "branch": "%rtIrZaiG6z6ydoWZnsrcClZwhm0EmXIZGonMgPGfh+w=.sha256",
    "reply": {
      "%9VWASKdl78TVKP+Hn0bVqji6Avg0DpfSP4aUIT6rwJE=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519",
      "%rtIrZaiG6z6ydoWZnsrcClZwhm0EmXIZGonMgPGfh+w=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519"
    },
    "channel": "ssb-protocol",
    "recps": null,
    "text": "Offchain message content  \n%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
    "mentions": [
      {
        "link": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256"
      }
    ]
  },
  "signature": "d05Yq6j+/yZFeftrA8lcdTevWx5H9/jvpQ3phWhix8V/hnm8VWzIa/rGoP2dTpvnJCgcLHhfx3llz/azliRuCQ==.sig.ed25519"
}

{
  "previous": "%kNANwGsKklrZO6zAduNua6AM5OhS9tPm+s9aHgctCXQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1046,
  "timestamp": 1536747945601,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
    "branch": "%FEQnvdFPqDPDonvyyt15Pa7EI9ULQ8u9czikYsz7YQw=.sha256",
    "reply": {
      "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%FEQnvdFPqDPDonvyyt15Pa7EI9ULQ8u9czikYsz7YQw=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "offchain-content",
    "recps": null,
    "text": "Ugh, I forgot to mention another relevant counter argument, I really should stop writing these things in one go just before going to sleep...\n\noffchain-content **adds another failure mode**: it is possible for the server to be aware that there is some message at a certain point in the chain, but to not have its content. That means a breaking change to the ssb-client API, the `content` entry would suddenly allowed to be `undefined`. Clients can currently rely on it always being an object (with at the very least a `type` key). This is a big one, forcing all application developers to adapt.\n\nThis also mean that replication rpcs need to be able to account for this situation, but that's just an implementation detail to keep in mind, not really an issue.\n\n---\n\n[@moid](@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519)\n\n> Messages aren't that large on average, for the most part folks aren't writing lengthy multi-part posts.\n\nIn the larger picture, ssb is an arbitrary database, not just a social network. I can imagine lots of use-cases where all of negligable size limit, deduplication, and indexability are extremely helpful, e.g. storing the dependency graph of a decentralized package manager, or messages that represent directories in a file system.\n\nConstantly having to worry whether your messages hit an arbitrary limit can be a showstopper for certain kinds of applications, especially those that interact more with machines then with humans (who are able to split up their output on their own). There'd probably come a point where different applications develop different, inefficient and ad-hoc ways to get around the message limit.\n\n> but I can't see lots of regular messages that would be duplicated.\n\nAgain, that's just if you consider social networks.\n\n> [...] you'll pay a lot for it in terms of greatly increasing the number of calls to fetch content.\n\nAs I stressed in the original post, this would *not* be implemented via blobs, but rather as specialized rpcs. There would be no additional roundtrip cost whatsoever.\n\n---\n\n[@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519)\n\n> I think we could implement deleting messages with current messages/feeds\n\nThat is an interesting proposal, but it does rely on fully trusting your replication peers, something that both Dominic and I are [reluctant to do](%8L/kdTz2HcTrkN+C07YKRTvwhcrq1YFef/+xSUJ7Kr4=.sha256).\n\n> About hashing message content without metadata: wouldn't it mean a message id would not point to a unique message?\n\nNope, I guess I was unclear on that one. The offchain-content would the compute the hash of a message as `hash(concat(all_the_currently_hashed_stuff_except_the_content_field, hash(content)))`.\n\n---\n\n[@frankiebee](@plo0t5t1G3h4Y+Zaxw2q5NNE+SsensLDx0TbcYhj8WY=.ed25519)\n\n> Why not just write a client that implements many different protocalls rather then change ssb to fit a large use case.\n\nI honestly didn't see this proposal as expanding the scope of ssb. It doesn't add new functionality to its API, it just improves upon things that are already there. And I won't stop trying to improve ssb details just because they are already kinda working.\n\n> in any distributed system selctive deletion sounds like a lie.\n\nI am [well aware](%2UwS8pstH/ZmPN7caVWJO/3or8ykN5ykbP20klY90po=.sha256) of that. But this is not about deleting data on other machines, it is about deleting data from *your own machine*, while still being able to verify messages from the author.\n\n---\n\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n\n> there are some indexes where the order of messages is significant\n\nTrue, but the order this depends on is the order of the sigchain, not some arbitrary replication order. If the current implementation relies on those to match, than this will mean additional work for sbot, but it isn't a conceptual problem in general.\n\n> There are lots of other complications this would introduce, that would need to be discussed,\n\nAck, this post was only an introduction to the concept itself, not about actual implementation and roll-out.\n\n---\n\nIf you posted a response but I didn't @mention you back, then you are outside of my replication range and I didn't get the response.",
    "mentions": [
      {
        "link": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
        "name": "moid"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "%8L/kdTz2HcTrkN+C07YKRTvwhcrq1YFef/+xSUJ7Kr4=.sha256",
        "name": "reluctant to do"
      },
      {
        "link": "@plo0t5t1G3h4Y+Zaxw2q5NNE+SsensLDx0TbcYhj8WY=.ed25519",
        "name": "frankiebee"
      },
      {
        "link": "%2UwS8pstH/ZmPN7caVWJO/3or8ykN5ykbP20klY90po=.sha256",
        "name": "well aware"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "wL4KEUUzgvRLY2Ss/3vnNcF3pH6bttjuRvdnoQyEZWPW+O7XFQrSpMoZZIpNzuzuelHFbUQkouvlik+IBOdnBQ==.sig.ed25519"
}

{
  "previous": "%El2y48D2qLtqg8hf9G70SiQuHB69K30tJ+RS3xd3NsQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1047,
  "timestamp": 1536750409467,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256",
    "branch": "%bQk+sjvORcUSPCrvvzKM3rv93ugcNWa3Lh6ryk1Bbp0=.sha256",
    "reply": {
      "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
      "%bQk+sjvORcUSPCrvvzKM3rv93ugcNWa3Lh6ryk1Bbp0=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Continuing to ramble (cc [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519), [@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519)), here's a small idea for handling trust in a gossip protocol:\n\nPeer discovery happens via view shuffling as usual for gossip protocol, that is to say: A pair of peers with a direct connection established between them will occasionally exchange the ip addresses of other peers they are connected to. That way, both learn of the existence of potential gossiping partners, this process builds the overlay network (this is simplified, but provides the gist of it. In particular, ip addresses are just a stand-in for more realistic connection information). Now instead of solely exchanging ip addresses, you'd exchange triples of `(public id, ip address, trust byte)`. The `public id` is something like the pubkey of a feed in ssb. The `trust byte` signifies how much trust you put into that public id, the lower the value, the more trusted it is. This trust byte gets modified as follows:\n\n- when sending a well-known id, set the trust byte to whatever trust value you associate with it. Examples:\n  - your own id is well-known to yourself and you fully trust it, thus send a trust byte of 0\n  - if you happen to have built a follow-graph like most ssb servers do, and the id known to you because it appears in the follow-graph, set the trust byte to the distance from between yourself and that id in the graph\n  - if the id is in the map of temporarily known ids (see below), retrieve the associated trust byte and increment it (saturating at 127, not wrapping around)\n\nWhen receiving an id that is not well-known to you, add it to a map of temporarily known ids. As the value associated with that id, put in either the trust byte associated with the id when you received it, or the trust byte of the peer who sent you that id, whichever is *higher*.\n\nThis little scheme has very low overhead, but established a nice, distributed, and fully subjective notion of trust. In particular, any attempt to \"cheat\" to make something look more trustworthy only works on those who already trust you. But as an untrusted peer, you don't get any shortcuts to get others to trust yourself or some other id of your choice.\n\nOn top of this, you could do all sorts of useful stuff, e.g.\n\n- only replicate with peers below a certain trust threshold `t`\n- only pass on data to the application layer that comes from an id below a certain trust threshold `t`\n- strive to always keep up at least `n` connections to peers below a certain trust threshold `t`, guarding against eclipse attacks, while at the same time using the other connection slots for less-trusted peers to reduce the likelihood of network partition  ",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "HNMASQ3DLooGkDor1ZOfpxuS21wtO85IZOuIFX7fWbmOhfuGB81XgJj+MEajrQVH9ldtB04Ma1l0bV7geZUWBQ==.sig.ed25519"
}

{
  "previous": "%dh6USEfPso9uZpB1iJrPX7kQHTYzcJyCU5lpSfRkhWY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1048,
  "timestamp": 1536751890461,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%xtq/l+GovYpCmpLwFYTse1VGkkzfRIjGCbQvz5hcFbQ=.sha256",
    "branch": [
      "%eQ0vSgouqx0EEOYQJmggcEvtVLggzc/RIv4+pZ3TLDo=.sha256",
      "%ta/DRNbeVsCG1iVQq1dQCjtqRWBZcMLGZNMEoW9Xixs=.sha256"
    ],
    "reply": {
      "%xtq/l+GovYpCmpLwFYTse1VGkkzfRIjGCbQvz5hcFbQ=.sha256": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
      "%ta/DRNbeVsCG1iVQq1dQCjtqRWBZcMLGZNMEoW9Xixs=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "ssb",
    "recps": null,
    "text": "In a similar vein to dropping encryption on trusted connection: Does ssb-client currently verify the hashes and/or signatures on all messages? Adding a way to disable that, would free some more precious cpu cycles for applications, if they trust their server to have already verified all messages.\n\nNote that this should not be tied to local, unencryption connections, those two issues are completely unrelated, a non-exaustive list of examples for all combinations:\n\n- untrusted connection and untrusted server: regular replication, nothing new here, move along\n- trusted connection and trusted server: Client talking with a local sbot, can disable both encryption and verification\n- untrusted connection and trusted server: A thin client that connects to a trusted sbot in the cloud, e.g. running patchfoo from your phone. Needs to enable encryption, but can skip verification.\n- trusted connection and untrusted server: Replication over cjdns, needs verification, but can skip encryption because cjdns already provides authenticity and confidentiality. That one still needs the shs handshake to confirm the identity of the peer in a secure way, but the box-stream can be skipped.\n\nCC [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519)",
    "mentions": [
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      }
    ]
  },
  "signature": "Qx/7NwooSEnJbnTIBqGhab4rLwt4jy5PO70qAxheUTkN6L5Vm9MVXW5Ko06YAlXpEnIgG8C3p6GMDBeSz2QMAA==.sig.ed25519"
}

{
  "previous": "%Tb/Ie7qRJ9Onc2beelc2Sp56GEGYdIgwPFSvNNqg1wM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1049,
  "timestamp": 1536755808663,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%yCfMJcM19PEN2vLdMxo5cDGFOwhqZlhLiybwBV7wdPU=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%yCfMJcM19PEN2vLdMxo5cDGFOwhqZlhLiybwBV7wdPU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Getting out two more thoughts on metadata: One on the type (as in \"string\", \"map\", etc.) of message content, and one on the actual implementation of optional timestamps. Both are somewhat connected by their usage of a [varint tag for metadata](%QVmprjsKV8vT6tCpCeZ18luAtSxVJU5gwe2MOHyfc9s=.sha256).\n\n---\n\nAs alluded to [here](%w5aLKFIuTttR8o6QB8SNOb/iqhiWDbAzmwaJIZQBjSA=.sha256), conceptually there really shouldn't be anything forcing the `content` of a message to be a map. Nothing makes maps inherently more special than other json/hsdt values. But with the current ssb design, there are two aspects that restrict the type of the content field:\n\n1. [private messages](https://ssbc.github.io/scuttlebutt-protocol-guide/#private-messages) always use a string ending in `\".box\"`.\n2. Each message must have a type, which is currently stored in the content - that's the thing that forces content to be a map for unencrypted messages. It also forces the encrypted string of a private message to decode into such a map.\n\nThe first point is a somewhat hacky implementation with some [unintended consequences](%TPs53tQ65rgZiRRm2bokbKrVMDhf7sGx45/BvL50mgg=.sha256), a metadata varint tag can clean that one up. If the tag indicates that the message is encrypted, it does not have to reuse the same metadata structure as unencrypted messages, it can simply include the cyphertext (or its hash if we implement offchain-content) as a binary string.\n\nThe more interesting case is the type field. Since each message has a type, it is conceptually part of the metadata. But the type should be encrypted for private messages. But those only encrypt content, not metadata, thus the type was moved into the content. Which - again - is more of a hacky shortcut than a clean solution. But again, tagged private messages allows us to change that. Encrypted private messages can encrypt the type and yet keep it in the metadata. And with that ability, regular messages don't need to put it into the content, instead it can be moved into the regular metadata (note to future me: argue to make `type` a binary string and to increase the size limit to be able to contain 512 bit hash digests).\n\nAnd with those changes, everything is disentangled, and the content is not arbitrarily restrained to be a map.\n\n---\n\nThe other point are timestamps, in particular their optionality and their privacy. This part of the post makes the *assumption that optional timestamps are allowed*.\n\nAs I already wrote about above, private messages do not encrypt metadata. And even though ssb explicitly hides the number and identities of the recipients of a private message, it happily attaches plaintext timestamps. That's kinda weird. By the same mechanism that can encrypt the message type, I propose to also encrypt the time stamp. A non-recipient of such a message could not tell the timestamp of such a message. Currently, this is a problem, because ssb assumes that every message has a well-known timestamp. But if we are in a setting were timestamps are optional and private messages encrypt them, non-recipients can treat all private messages as timestamp-less and no further changes are required to any code paths.\n\nNow for the concrete representation of messages without timestamps: I'd simply use the message tag varint again. Messages without timestamps then simply don't include one, saving 8 bytes. Even if an actual API like ssb-client might want to signal absence of timestamps via a [garbage value](%JsPQu85HMOkm/m04Fn3b3h93yj88r5YT0DxkNzsAkK4=.sha256), there's no need to send any garbage values over the wire.\n\nTwo more quick, unrefined thoughts on these timestamps:\n\n- should an encrypted message hide wether it is timestamped or not? If that is signalled by the tag byte, than that information is public. I don't really see how that would hurt though.\n- users should be able to set whether they want to attach timestamps to their messages or not. But in some cases, devs might want to have full control over timestamps, so they'd move them inside the message content. If they do so, is it a good idea to allow them to signal that no metadata timestamp should be included? Saves space, and more importantly will prevent a lot of ambiguity and weird user interface behavior if metadata timestamp and internal timestamp differ.\n",
    "mentions": [
      {
        "link": "%QVmprjsKV8vT6tCpCeZ18luAtSxVJU5gwe2MOHyfc9s=.sha256",
        "name": "varint tag for metadata"
      },
      {
        "link": "%w5aLKFIuTttR8o6QB8SNOb/iqhiWDbAzmwaJIZQBjSA=.sha256",
        "name": "here"
      },
      {
        "link": "%TPs53tQ65rgZiRRm2bokbKrVMDhf7sGx45/BvL50mgg=.sha256",
        "name": "unintended consequences"
      },
      {
        "link": "%JsPQu85HMOkm/m04Fn3b3h93yj88r5YT0DxkNzsAkK4=.sha256",
        "name": "garbage value"
      }
    ]
  },
  "signature": "UvEiQm/QW81Xg9GUJ1apkw3GBqygcXLc/7Cyf88AtE+57qLavpXYKHia3aoEL0TqDLgN+DpVq6fu3bJL37G8BA==.sig.ed25519"
}

{
  "previous": "%dn7ucXaeyjozlAE2Ma5gsPd2mpi8an4hmgGGk83QaqE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1050,
  "timestamp": 1536758956353,
  "hash": "sha256",
  "content": "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.box",
  "signature": "0VGnKk5L/n06cO6bvbFc0YNfiwkmTO+I8Wa24eWYHk1WOYggnC6ZF5l0DSC+hAWQSggN+0Npbi2pCfw6eiS5BQ==.sig.ed25519"
}

{
  "previous": "%zm8SFkSC39j90j4dG0ZmEbA8tQ1M2aXrjkfYYem8d/I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1051,
  "timestamp": 1536763811752,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "shs",
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) and/or [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519), could you take a look at whether [this change](https://github.com/AljoschaMeyer/shs1-crypto-js/commit/43172effd26f6badaee73a4ce487a7484c588ca3) correctly fixes the [mistmatch between the shs paper and the currently used implementation](https://github.com/auditdrivencrypto/secret-handshake/issues/7)? Just want to make sure I understood the problem and how the protocol was originally intended.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      }
    ]
  },
  "signature": "nHUZuZblTzWoMetjNdcBo/GEjPki2CdpQ8nm2538LArqqvU9drrPNiuNtiJ8E43NyzUxg25Mgi1n2Fe3driTDQ==.sig.ed25519"
}

{
  "previous": "%XmmbqFNvnyo0jgrvEy7NBIGP8pbJrL62o7TdVLu29vs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1052,
  "timestamp": 1536785148734,
  "hash": "sha256",
  "content": "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.box",
  "signature": "L64ZCDc6XKIg/xtpU/0BINKvW4E08Li6yOb181V1fR9TcDLbldcMKeEhZHpSc9H7jAXHUrhffBbXFatq39F6Aw==.sig.ed25519"
}

{
  "previous": "%Y8saev7nw8QvpJJzmsBlefcqBZZPOuzCrctlQeLyZSE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1053,
  "timestamp": 1536786077910,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
    "branch": "%Gaz+3sKPuVRWH7wTQcBlTZZMXXi7VQQgr4JL7W54OXI=.sha256",
    "reply": {
      "%Gaz+3sKPuVRWH7wTQcBlTZZMXXi7VQQgr4JL7W54OXI=.sha256": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519"
    },
    "channel": "offchain-content",
    "recps": null,
    "text": "[@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519)\n> [...] trusting the external info about what message the banned message followed.\n\nThis is the part where a malicious peer could trick you (if I understood your scheme correctly). Say our sigchain is `m3 -> m2 -> m1 -> nil`, and m2 is banned. When replicating with a malicious peer, it could give you `m3`, tell you that `m2` is banned, and then give you some `m1'` in place of `m1`. Since you don't receive the banned `m2`, you trust the peer that `m2`'s backlink pointed to `m1'`, which is not true.\n\nDue to signatures, you could only lie about your own feed, but that is still enough to to violate the guarantees ssb currently gives.\n\n> The interesting part is which messages to consider banned - which would be common to any such implementation for message banning, I think.\n\nYes, that's a super interesting question. But it should remain in user-space, not leak into the protocol. The protocol does not need to know about this, just like ssb does not inherently need any sort of follow graph. We can't possibly find the one and only correct and optimal approach that works for all use-cases in all settings, so the protocol should instead remain completely agnostic and just provide the building blocks for custom solutions. In all likelihood, a de-facto standard plugin will emerge, just like ssb-friends. But nobody is locked into using it.",
    "mentions": [
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "8TIhRt9KJbM1A84cHIhkmupKFcwEe6r0KYPar0mw7kxvDHli7mWS0CaKoMJ9Yk2OfWEu+rTqUGRndMJVIXMADA==.sig.ed25519"
}

{
  "previous": "%P4Hb3N6IMpKrwkGa9efmQcuvyXuuHmX4AxXzQGY+IHI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1054,
  "timestamp": 1536786507221,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb",
    "vote": {
      "link": "%m2uoRd/tP+slZd4jabS0V8t3tZOhDBmuzaGya6Bzgq8=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "1M4NlF7+4zS6Ar6muNs4qkXQBWeI3u4CDYJlZzEXjcLsZucpkKXixu3jKzBP8jUP0uV/DdSIf+Sn90mLxrwBAw==.sig.ed25519"
}

{
  "previous": "%+dcNT079A3shgHzMlrICiOn6eRGfYxBKt/Zm2uB40iU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1055,
  "timestamp": 1536788582204,
  "hash": "sha256",
  "content": "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.box",
  "signature": "367bBmmJnMaLhzd0oGHZi/VXfptxRt39QfPJneG7QnxU76QXjGrC1tYVuXo6FbmwektkdpxV5ZUARE2kRYo4Dg==.sig.ed25519"
}

{
  "previous": "%sUGrGYm+IVaA96leKZoXIfPaU+EJIInMuuwt6Kn4GPE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1056,
  "timestamp": 1536825715956,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
    "branch": "%v4PDc1MrUCfjIjIyC35TH4idK1wtQ8ZfLPVcdBjFFIE=.sha256",
    "reply": {
      "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%v4PDc1MrUCfjIjIyC35TH4idK1wtQ8ZfLPVcdBjFFIE=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "offchain-content",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) I didn't dare going down that road on my own, by I'm open to explore it. Maybe we'd want to add some sort of type tag to feeds, similar to those I'd like to see on [messages](%QVmprjsKV8vT6tCpCeZ18luAtSxVJU5gwe2MOHyfc9s=.sha256)? Then we could have legacy feeds, offchain-content feeds, and possibly later partially verifiable or even partially subscribable ones.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%QVmprjsKV8vT6tCpCeZ18luAtSxVJU5gwe2MOHyfc9s=.sha256",
        "name": "messages"
      }
    ]
  },
  "signature": "WkLYjy2JA+IEbw7l5BfGhRuob4uJYQu+r1GCzWJGEbiGheSLNesX4cpCGB+rVTRp1QKR9OWZ6d+AV9yw5Ya8BQ==.sig.ed25519"
}

{
  "previous": "%T/OsKkgosORjseDBjtIOibXLPi8oegoNkZ7FLKl9v60=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1057,
  "timestamp": 1536825849641,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%PSxVT0tHuo0fGUUPn7AMWOiZCy705YU2KQ7qdmMI0zc=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "jdA2NcB5BHUUoMVR6GgWgzjzvx3VPDPz98+AAQp3Sv0zjIix5JrKLvg4OBpvJH7ZfpQYWJbSpTl+Z6ApFac0Dw==.sig.ed25519"
}

{
  "previous": "%wVa4Vd7UYEqXuSyfSf0JXoZwSu9s3A9dswk4NBC+ASU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1058,
  "timestamp": 1536826280230,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@2l2DptBNWlUG/gCO4LJBXvqMZ8106WTwmXqlbh1kMuo=.ed25519",
    "following": true
  },
  "signature": "PDyNpIQ0Tdt58ViZlHBSZT+6bZAjEvNZW0xDuBNsCgW7W2peaZAaLYg5eFizahfwISh1Dxe34/Uyj169DFyDCw==.sig.ed25519"
}

{
  "previous": "%kjEWEZCpyUL+dn9q3WOLF1crmnPFbFuQrfBRl+JTrMs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1059,
  "timestamp": 1536834421061,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ssbrs",
    "subscribed": true
  },
  "signature": "ekbEQ47F/NsHccThKFbTWi9z4Ww37c9TvRKL9KbAUoeJxni4y2WFGvZO9dqZeC8CPyTj4R7MVRPd3JtSH4XUAA==.sig.ed25519"
}

{
  "previous": "%GROZe6xUl6smaNANHU0c0aEiwDarjGMb7YhcSymHwus=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1060,
  "timestamp": 1536837612153,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssbrs",
    "text": "Re using riker.rs ([@commandocrypto](@2l2DptBNWlUG/gCO4LJBXvqMZ8106WTwmXqlbh1kMuo=.ed25519)), with the caveat that my background knowledge consists only of general familiarity with the actor model as a theoretical model, and reading the riker website. I'm somewhat skeptical, for a few reasons:\n\nfutures.rs is a more solid dependency, in that it has a large number of users and contributors, some of them paid. Depending on futures.rs is a very small risk compared to riker (a more mature actor framework for rust seems to be [actix](https://github.com/actix/actix)). Also, riker's API is still in flux, we planned to commit to futures.rs only once it has reached 1.0.0. The futures team is actively working towards that goal, with support from Mozilla.\n\nRiker adds a lot of overhead. Not necessarily in actual computational resources (I'd expect tho to be negligible), but conceptionally. If I want to write a parser that ayncronously reads data until it pared a full value, do I really need [this](http://riker.rs/hierarchy/)? All I want from the framework for async computation is an ability to signal \"hey, I can't finish this task right now, I'll tell you once I can continue\". That's what futures.rs provides, and not more. Riker does nothing but providing opiniated functionality on top of that. And I don't think our implementation will share all of these opinions - I definitely don't.\n\nI'm not sold that we benefit from the actor model. There's always that premise that code written in the actor model can scale to many machines without changing anything. Leaving aside the fact that this rarely holds in practice, we don't even need that ability. The goals are going to be a client library, a minimal pub server, and then a fully functional server that regular application clients can communicate with. None of these benefit from this automatic scaling accross machines. I guess you could build a cloud-native superpub that manages multiple independent pubs with a shared database. Even then, you'd need an enormous scale to warrant distributing anything but the underlying database itself. And such a setup would go against the values behind ssb, since it is inherently centralizing.\n\nUsing actors makes us pay a cost in conceptual overhead and (a little bit of) runtime overhead. And the promised returns such as automagical [state persistence](http://riker.rs/persistence/) and distribution [clustering](http://riker.rs/cluster/) don't really apply to us. Neither do we profit much from the fault tolerance provided by [supervisors](http://riker.rs/supervision/): If one of our parsers returns an error because it received malformed data, that's not an exceptional outside event outside of our control, but a regularly signalled error. The only exceptional failures we will face are connection drops and db failures. I don't think those warrant structuring the whole stack according to an opiniated actor framework.\n\nThe closest thing I see where an actor-ish approach will be useful is handling of connections to different peers within a single server. We'd want those to be able to fail independently and have their own limited set of resources. But again, that can be done without the strict abstractions prescribed by a framework.\n\nIn the spirit of kiss and yagni, my gut reaction to actors is \"nope\". But I'm happy to hear more compelling arguments from somebody who has practical experience with actor-based implementations.",
    "mentions": [
      {
        "link": "@2l2DptBNWlUG/gCO4LJBXvqMZ8106WTwmXqlbh1kMuo=.ed25519",
        "name": "commandocrypto"
      }
    ]
  },
  "signature": "RXBus7EapkZPr2ux8yKMHZFTgKsmBz31ehh5WSodshBZ71AmyEyG5sWvvK/uYdqg+QaAJfbJEpND/sDUufwTBg==.sig.ed25519"
}

{
  "previous": "%edeDEbS99CB2jdfiOVf+XIygz544UB/cTXVnlo83Hec=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1061,
  "timestamp": 1536838441136,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%H+x7CTkmG9eJzBfy0KOQhATk7KCPanlZkbAdKN0K7HQ=.sha256",
    "branch": "%H+x7CTkmG9eJzBfy0KOQhATk7KCPanlZkbAdKN0K7HQ=.sha256",
    "reply": {
      "%H+x7CTkmG9eJzBfy0KOQhATk7KCPanlZkbAdKN0K7HQ=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": "databases",
    "recps": null,
    "text": "[@moid](@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519) I really like that viewpoint of kripke semantics.\n\nWhen I'm talking about ssb being an arbitrary database-thing, I'm usually not focusing on the \"database\" part, but the \"arbitrary\" part. To many people on here, ssb is just a social network with some unusual properties, when in fact the ssb protocol is not inherently restricted to serving as a social network. The data model is much more general, and there are way more settings where connections between humans matter than just social networks. It is easy to accidentally apply arguments which hold on social networks - but not necessarily in an arbitrary setting - to the core protocol, so I try to call those out.\n\n> [...] and it's eventually consistent only with a god's eye omniscient view of the universe.\n\nI guess each node can consider it eventually consistent regarding only the feeds it is requesting. And those are the ones that actually matter (to that node).",
    "mentions": [
      {
        "link": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
        "name": "moid"
      }
    ]
  },
  "signature": "bQHnLglsySDyPjklXq5mQ/kwQAbDF4BxHxcpQanrLCVXJdTeASPzt55PtmpZ+oNR/Yk4n4p0xk7jWRUYnYVWBg==.sig.ed25519"
}

{
  "previous": "%T9lfuNCRP7Z2ppQVSLFmyTrx0taJvezKqLmC6nN6qCc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1062,
  "timestamp": 1536872068185,
  "hash": "sha256",
  "content": "qkwM+2N+m3CZ+ojXYlq05rfaYYHwQtJy8sox4ZdwsBHHTbB267WSq0d08UmMovZHQTVNwIdPsXXyKW2qTCZnrJY0kNLrGtHGnVbbXkaPJZ7NZ/ojiEoueJ+5voxJsce8ABkmmQCf455UratZ50cVkLASXi1dLS6/LTAionzilaKpJ5/gmOfvFYxQnfgX6Nm8YrLlxh6SxLgLHi4k4tD27mNItNFnlECiXyVh56VOOkkcl4RWGVqVg1mr8sH+UYTIWdZae7oU6zJVDOxhWz06s/bcaJkt5rY+gk/K4Svwrv9g9Peo94QmaGAB2NNkzNGUOICVC2QWuey12Ucx6AUo8r+OTx7laKI3Sljckie3EJ9h67kJd8oliTCm5BRqzJ3ckPIQ2nn7nUa/6lCX9Q5GAqiCTiSzjCAflikEdX20SGQY/16kMSekpR5fk36Oe1+SZ7c1ltBzq/CEbavcC5xdqeBCqLmDqyFy8MoypPNXxSWAahj6hYlYfXZOtyybmvEFSpqF1/MoMo0384xZsNb/28SjCFp30CL7T3ih0D88xz4T0hmNzIduYJF3tsxLVt5ddI9rsnXz/reXRsLOFZyh46uCOy62vp9SWvuFOu74WldtUBCRFT2C4j56NllVVQtEEUWzlfIg62f+ICNkFxY962qLI/PV+y/zorwLZaOAxvUMfxorp2S5iQSiFQiWV/eVLOQ+7HlDG2c4zV7TSz7VRzo/yc4jaayYY8dvDHFH2G0w22sYqXHMUEsHCcf2WUT0Nr0ITcSbTEjlwkBvGdpXGYgP2/dGxxULqcFIyNW4f6jXxwICtgz0IK6vtVGLXzcivWxsLgP+BzJe99ijIV/2g+8RxGMOhpPZ9dLqymMHPe5xJAr4Chp+Mn7w0H3eO3/NvOPwpFfgBT600nCJ379tSxW2Jj+7dsKTGDM6K3kApWXlEyasSd9iFkl1mn+y0mziETHOlkUVRd3Y+jWsQl0VI8YJbzWPqWVqnpRkd5PMzy90hbMj6ppezPsdn3XKcsVEHs/dDpdW9pBNcpuwBOGVgabk0W7REPvwf/xRz6cineSnj4kFSwabdnHSfBzv+Dyqu8cRPZvvR6CRhGk01E1tOyxOaemVEr7pnqTO9jpPZEPpL3todihBJO5NFimpq1ywJKQsfvOigVcUq1K9gCrY/EMzZqvpqVkdbQgrx7PowqNvgoD0eVbgWBwF+d1VuFOPDZjYA4KykkkTsb22Iv453ieTlQC6cRMEXL/PDyZlZno21CiWWaFJf8bH9nXBkKlXMNIg9AoHVEC/o5lUBuApaFpsOyZrQ/EzqBPqwGflZl0ocB3FWhxKGju4EaHGvL2zB3zPv9dkOfrUyfxSWpFqqNMaI9NknDuN+sECD7y93/5JBKjRKycUeg3PB0Ua8qqJCpfDZSm8MvPVQpozQyTezf+4aVAO4Xwic/oGZ9xzeXBFeXdO7sCDnwjZOEserhIUZ/B2RwGdv5Va2syGKM+82e+DmJacBcRd7r7aAn29fj/eXwSzSRQ/v8DiiSfxZ68SrEnbyAPYXpMaGTCBP+Eh+iceN6kEjrniv+BhZN8xP4ApiCHqsqF59lbtFshMdeFKaqp+3qDZD0P4wAwTWM+TLpHuOOk0ZXNxNr6k6d/nsgs4LOzhw92mGSxr2KsrproaeRSr/eJ+LNkxUABzGExaFAQi8no3LHCdNvQAAwD42AlEyIUsuHBRtucRRU0LCjXGMebiegxFYnOHGfUresEIPxPymOzVNqT+OI099eZ7UAM1WDwNZyOQ9ROIMn5SAmgkLRe7jTz60w==.box",
  "signature": "9+262uVye2Lm6kzhNEFPVRnArhXCpbZm0QDbPfW+ZD/ZVC+/qhBbEngGtfOC7UZ10TT/uiYyiUJuk779CFvpCw==.sig.ed25519"
}

{
  "previous": "%5Hlf7vn0k9PY4WmN0yLBVHYRQwb1N7vNZl528LLprmw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1063,
  "timestamp": 1536872228218,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%zv56AbEcR1+XKcOF3E7J+HNoKrxsd+0MQ/eVPQanfb8=.sha256",
    "branch": "%4tGwIDB4pTZvtvgt3Qqzp/B+vOJjc6+EJy4/2CvItaM=.sha256",
    "reply": {
      "%zv56AbEcR1+XKcOF3E7J+HNoKrxsd+0MQ/eVPQanfb8=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
      "%4tGwIDB4pTZvtvgt3Qqzp/B+vOJjc6+EJy4/2CvItaM=.sha256": "@Vz6v3xKpzViiTM/GAe+hKkACZSqrErQQZgv4iqQxEn8=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Powersource](@Vz6v3xKpzViiTM/GAe+hKkACZSqrErQQZgv4iqQxEn8=.ed25519)\nBeware the state of the current rust implementations, they are in limbo between different unsupported versions of the futures crate. We might be able to build on them, but it will probably salvaging rather than reusing. ",
    "mentions": [
      {
        "link": "@Vz6v3xKpzViiTM/GAe+hKkACZSqrErQQZgv4iqQxEn8=.ed25519",
        "name": "Powersource"
      }
    ]
  },
  "signature": "ZYcwudeeYEN0UdLhXAZzkqVj3+N1gVsw984c9Ufj5WY22yBMossrYqAcAaPg0YI6kepcXf9N/sS8a41NPdo+Bw==.sig.ed25519"
}

{
  "previous": "%pJ5jaqTd0V7oJzs44RRcshVS4kIwu9Fz8c522ILkTds=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1064,
  "timestamp": 1536872665804,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
    "branch": "%T/OsKkgosORjseDBjtIOibXLPi8oegoNkZ7FLKl9v60=.sha256",
    "reply": {
      "%T/OsKkgosORjseDBjtIOibXLPi8oegoNkZ7FLKl9v60=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "offchain-content",
    "recps": null,
    "text": "Addendum to the idea of adding \"some sort of type tag to feeds\": Feeds are not really manifest entities in the sense messages are, so you can't really attach metadata to them. They only exists as the target of cypherlinks. But: We have sigils (or sigil ids in a binary encoding) on cypherlinks that describe the kind of target, those could serve as some kind of distinguishing feature should we need one.",
    "mentions": []
  },
  "signature": "7TrkifeBnr2mIeBovtkgHqMlvIXRRnR3rUskiV0v0ec4iG1GnMQ5b31S+cQ7HGYOrJiOXVOcqP1+RPKnyg3FCA==.sig.ed25519"
}

{
  "previous": "%vUgqP0gVONU0L9RZSmLt25ckqXlofa/4bXNEELUBi4I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1065,
  "timestamp": 1536875196133,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
    "branch": "%GDNTWCfnsT8pu2rfVU/CpRwidu4NJIwUopeIB8QfPqw=.sha256",
    "reply": {
      "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%GDNTWCfnsT8pu2rfVU/CpRwidu4NJIwUopeIB8QfPqw=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "offchain-content",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n> But, all these things are extras that would be cool to have, but that we can work on later.\n\nFully agreed, all we need to do for now is to keep things extensible yet compact.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "Ta/XXOVvNsDP6pYbroU989+67bVZTx+t5GorAmnvChnLqYLVbJNgkjr5t6aHhnzvt41enDB6TjF8Fie8osKuBg==.sig.ed25519"
}

{
  "previous": "%QIzhknNB67FFH5w9Wjv+d2dKVN/60HPLJkKggMn7PqM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1066,
  "timestamp": 1536910851886,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%+nTQ9Gjg56IoGN+xiFRddEmZKwWPUlKN3KuKsRsw1cY=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%+nTQ9Gjg56IoGN+xiFRddEmZKwWPUlKN3KuKsRsw1cY=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n> I think a maximum of fields should be inside the encrypted portion, and that portion should be as uniform as possible. having two separate encrypted portions would leak metadata, in that the length of the type field could imply what sort value it was.\n\nValid point, but not a show-stopper. The encrypted message can simply be created by concatenating the length-prefixed type and the content, then encrypting the whole thing. Same for the timestamp.\n\nTo be honest, I don't have a concrete use case for non-map content. But allowing it strictly expands the set of possible messages, without any real drawback. And viewed from another angle: As we change the metadata anyways, we have full, unconstrained freedom to chose any format we like. How could we possibly justify to emulate a hacky and entangled legacy solution, if there is a cleaner one?\n\nIf you insist on a use case: The closest thing to a blob that is still verified to have been uploaded by a certain id at a certain point in the causal order, is a message whose content is solely a binary string.\n\n[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519)\n\nI'm not so sure about protocol awareness of tangles. Not every message really needs these, but everyone who does need them has all the tools to build them. Also, the desire for a tight partial order is opinionated, not in itself better or worse. And due to arbitrary network partitions (the most common case being an offline peer writing data), branches/tangles can never give us any quality guarantees anyways.\n\nThe thing I found most interesting about tangles are the conflict resolution rules. But those differ form use case to use case, so that won't benefit from being part of the core.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "OlgCy3v0YYCAJfRd0OdTxRUgkzIGtcR9P3LPvqURo21JsKJW1t1Gwg7nn/pbRW3B9qw9UFuwEkCAEnoFHeuMDQ==.sig.ed25519"
}

{
  "previous": "%LnYxFFRtIlgNMPN8SjIY1nibQpf9jgsPeLG7Nf98jpc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1067,
  "timestamp": 1536911542214,
  "hash": "sha256",
  "content": "eCmjqT1Eim4myp1M73yRQucb3KllyRIgaqLFIVu4SraTrnvU/dURES2iZefVbqjj0Ygkbg1sR0KZMCfK+afVd4CJo+YuhJPPpdUDNdCmYfhYVNkUhFelXb03S/OqiwcDgFR3F5iCH2GPNOeiooCMAert5DNzaoD+JKKiGwjaRashL8EPdl0VJWPV3fLURC45u7IA99G1gULQxxijePKxfCjtb2VpsJHBbdfckGkelSm0RLYep8YFyMrT8Hd8NS9QjK44fOa1xFjIZdroEhutD8dEUmiaQ5DhrnOGzlDApZYFd7oGvOqob/476qSP+Sli4wdxsHPgfaIT5ySc6BEqLQ3JtDeY9khrD1bAt92s78IRsfuSxKxG8xLUdYhk30Y/wzDfI6EdU6dEEnmgXHOSmQVCIS1V0aGYoUfwLBPkIMtS8Au/nMwBjv4i3QO5s5RQAitcqFVYBCqzVty9imyyS2Sfrl5PgfZHHArinPE4INxzpTyeGti0P/wJbKaHVMlHrySDt6ifdVkESu6BTo2au4apmMVLrXdR1VXJsySxtMMd8q+cap1tKFaKttgnTjYEtZxd+eWVzTL/41BiTVDFuKQo77r4FFp9VU+qnk9CSZKQ1iB95tW+3/C2XOp+77G5Hra+QsgeY8i/XPLnc+lwNZAeM9qaUJi0N8dBUjAYU9VFuHNQvZ1sVyrHxFaBOVaGgdZSKNBwzNWxgIFtOOvtHqp7WSscIB/+VqNkQbCJW0dyiO+mtHoozrMuYJKhaVaFp0YVkiBodB0H0uWJo8NIB3IxmiZF7XKrg/32t3LjPrJKUD/Yh5pNY10cojp85pMZ2rRHLaZHWUo+D+Tfi/4JvJtvZYtO5SBM3pR+uGbXsV6pmc2L/l60QqPiKkCXwObTGJwKRqQpibKY6UCTiEfWvqY0y5pRH6OYCbSm43Ev2D+x3Ko31nS1U08zzAuLCL6cldm2DZiPpskAIugHp6Rn0pXe5plvHiwAiSRTkgdnF4spFXGQ4Zo1KBci8S90OMcVDUy0gkJJAAHxbChFoDJBqG10bPWpq+Bu99sBhFgcGxKG51+fh8jds8KE2Axv6T5twlixI+fZj/Qq2VMZE4LYUWj0jJR+ld7RUlfxiuFWSq/aUvfB0sEFRyH6YxrEECpJYLAgXnvLrAqFzgXz3WpTm/lKAXpF6vBpYV3V9aUsszpvE1uL5ZknSM+uBgDq8VZM3QczSBLUnRGXV9JlRYu5by5cdLW6CiuK2QUJCCREdIuvVIBtEkX6br+QjIrJJ7Kj2PESSXfukvyn1CeV751uUYNIzOy97iCScyo//AtjvcfZLT4iY5PnZt/dMtTQ/y7DmwtT1oj7oBIL9+/G.box",
  "signature": "zg347jL0bs5N8pSMvY3Ef14jDPcmuItl02mI8Sjsk8FIKU+LckIhV7vwtAtdtz2fDjHCo63e6IAt4Z4ACWZhBQ==.sig.ed25519"
}

{
  "previous": "%W2cmeCWUIvSGrIx1ABeV0VKDMSKZZBzoIyhUaF6oDLM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1068,
  "timestamp": 1536922961955,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QJEpN8LN1t3BrIkUQ3WoOMWRsMArbVUZCpTeBYcuqfw=.sha256",
    "branch": "%GDNTWCfnsT8pu2rfVU/CpRwidu4NJIwUopeIB8QfPqw=.sha256",
    "reply": {
      "%GDNTWCfnsT8pu2rfVU/CpRwidu4NJIwUopeIB8QfPqw=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%QIzhknNB67FFH5w9Wjv+d2dKVN/60HPLJkKggMn7PqM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "offchain-content",
    "recps": null,
    "text": "> I think I'd keep '@' to id a feed, and just append something else to the other end .\n\nAck on that, analogously to [message cypherlinks](%kFNhfPsphpeqoChT7BIuUFURbOzIRuJmcYzuOWpubGo=.sha256).\n\n- - -\n\nAnother pretty valuable replication option enabled by offchain-content: Only fetching the content of messages with a certain type. That way, my non-coder friends would not have to download all the data that e.g. a package manager app could add to my feed. They might still choose to do so anyways, but having the option to opt-out in resource-constrained settings is nice.\n\nAn advanced mechanism you could build on top of this involves all applications registering which types of messages they deal with at the server, and the local server then only fetching those. Or if storage overhead is not a problem, it could still fetch all others, but only after the directly useful message contents have been fetched, improving perceived performance.",
    "mentions": [
      {
        "link": "%kFNhfPsphpeqoChT7BIuUFURbOzIRuJmcYzuOWpubGo=.sha256",
        "name": "message cypherlinks"
      }
    ]
  },
  "signature": "0FFNH1Rr+dokjrYdDAgbnCQOfPJ8xS1R99NCE0vI654PzQCHCnt7osqvhTjfg8gaHzkUiRevnfiRSz6tR2ApBA==.sig.ed25519"
}

{
  "previous": "%i5c3ZSLEfE7Nco3Nkkxfnts3BYAT2c9hVUUblR72jwg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1069,
  "timestamp": 1536924681979,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbrs",
    "vote": {
      "link": "%4fb0uwokUxjdjjGm31AWIKgD570rZ6+t+QImJy0R/uM=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "lbpbcMu/gKvTNNrS6jYnfN3AH9W/wgoiFG+DAeQDAAZ4rqe8hsxqTEsZhfqHdBe7RP8QnLhuL7S01E8bnkUvBA==.sig.ed25519"
}

{
  "previous": "%LXfTIdXUa/deStpGXSddxJSLAm2iKONTd+bi0AyjTG8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1070,
  "timestamp": 1536928350443,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%edeDEbS99CB2jdfiOVf+XIygz544UB/cTXVnlo83Hec=.sha256",
    "branch": "%KiqC50kZED2HBcXS+TGdoXAU0HUbkHHiTnjYf/VsAas=.sha256",
    "reply": {
      "%edeDEbS99CB2jdfiOVf+XIygz544UB/cTXVnlo83Hec=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%KiqC50kZED2HBcXS+TGdoXAU0HUbkHHiTnjYf/VsAas=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519"
    },
    "channel": "ssbrs",
    "recps": null,
    "text": "[@bobhaugen](@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519)\nI'm not an \"actor-model skeptic\" in general, it is a great model, much more readily applied to real-world settings than e.g. the [pi calculus](https://en.wikipedia.org/wiki/%CE%A0-calculus) (and don't get me started on the inadequacy of petri nets for describing truly distributed scenarios...). But I'm not sold on the idea of fractally using the same model to structure the whole stack. In theory, that's a really nice approach, but our hardware is still modeled on register machines, not parallel process algebras. Even though activity pub as a whole may conform to the actor model, you can code an activity pub implementation just fine in an imperative language, and it will likely run faster. But often you don't need to care about performance as much, computers are scarily fast.\n\nAnd there are clear advantages to structuring everything through actors: Only a single set of abstractions to learn, a single conceptual model to evaluate things, no arbitrary jumps between formal systems (note that I view programming languages as formal systems) when reasoning about properties, and many more. If you decide that you want these advantages, Erlang/Elixir actually deliver them (plus a lot of other goodness such as resilience, hot code swapping, or syntactic abstractions (in the case of Elixir or lfe)). But if you decide to work in an inherently imperative setting (such as Rust) anyways, these benefits are greatly diminished, and you need to jump through a lot more hoops.\n\nThe BEAM ecosystem is a very impressive one and a solid choice for many use cases, just not for a performance-oriented, embeddable ssb rewrite.",
    "mentions": [
      {
        "link": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519",
        "name": "bobhaugen"
      }
    ]
  },
  "signature": "a+DgKlpoh5US8nvim+5ySXeLJe08xCAiwXaX4svIYZdPHMECfLeB4M/sBEUZnRhX5snVfEC8arQCB30ea71IDQ==.sig.ed25519"
}

{
  "previous": "%Q4yNlEkqlFxd3Aqj9YxUZkeiQU+AbdEf4RtES2phZz4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1071,
  "timestamp": 1536998183217,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%LqNgWFBetS4q3tMtD/FNCGf1wUC0fBTIq1xK6uxBuC8=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%LqNgWFBetS4q3tMtD/FNCGf1wUC0fBTIq1xK6uxBuC8=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n> @aljoscha I think it would be more elegant to just drop the enforcement of the type field, if there was really a need for messages with absolutely minimal overhead.\n\nBut why? What is more elegant about forcing somebody who wants to send a single value to wrap it in a completely useless map? Why not do fully general solution that also moves the type where it belongs - into the metadata?\n\nAdditionally, optional \"type\" would be a breaking change.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "NOqz25Ns0+k7gimWO9xWKTs/qfvmzcZKVkIqEtYdQE+j3CjQFi5O5p0BQsV6IPASBswzD+LXh0DlmtIVUV+lDg==.sig.ed25519"
}

{
  "previous": "%LDtyPsdzt0QMFXL9fPRhBNzMF8rqGmLaUc196cjluu4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1072,
  "timestamp": 1537001787935,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%195n5UHHG961upVVXkDNAPMuG/We7ESmAbxff+aggX4=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%195n5UHHG961upVVXkDNAPMuG/We7ESmAbxff+aggX4=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) Ack. But we still want to keep type in the metadata, right? It may not mean much, but everything fundamentally relies on interpreting it.\n\nWould you be open about changing the \"type\" information itself to be an arbitrary byte string rather than a utf8 string? That's trouble for the js API, but it allows using hash digests as types without any annoying encoding. The js API would have to use a buffer for the type, so it couldn't be a regular key on the content object anymore. That's a breaking change too, but it would reinforce that type is metadata, not content. Also, are there any reasonable arguments against moving the size to 512 raw bytes, to allow larger hash digests as types? Or maybe even a few bytes more, so that such a [scheme](%yMH4cssbTHFgb0IIChSmvuTAGBBkzgjDoujZYCihquA=.sha256) could use multihashes?\n\n---\ncc #ssb-clients\n\nI don't think we will get around a breaking js api change anyways, so we might as well try to put as many of those changes as we can into a single major update (I'm open to splitting those up depending on how we end up rolling out the underlying changes):\n\n- move type out of the content, make it a buffer in the metadata, with some size cap (say 512 + 8 = 520 bytes)\n- allow the timestamp metadata to be missing (if we do optional timestamps)\n- allow the content itself to be missing (#offchain-content)\n- We'll have to use some sort of non-enumerable properties to introduce the [new hsdt types](%urfag1KCw+gqNawrG5PigBmwgZjWAXwrBN4UOwYCIWs=.sha256), otherwise they would be indistinguishable from regular objects. Not necesarily breaking, but clients need to be aware of those to not accidentally treat them like normal objects.\n- change to [Object.getOwnPropertyNymes (or similar)](%1QzUQSm2Pb7XEB6cPBZxzBH4s/dUsnZWB9Pr5o1z0o4=.sha256) for hash computation (I'm unsure how doable this on is, also not sure if this really is breaking to the client api, but it does mean that some things might get ignored that previously affected the message's hash)\n\nI'm probably forgetting some more breaking js-api changes.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%yMH4cssbTHFgb0IIChSmvuTAGBBkzgjDoujZYCihquA=.sha256",
        "name": "scheme"
      },
      {
        "link": "#ssb-clients"
      },
      {
        "link": "%urfag1KCw+gqNawrG5PigBmwgZjWAXwrBN4UOwYCIWs=.sha256",
        "name": "new hsdt types"
      },
      {
        "link": "%1QzUQSm2Pb7XEB6cPBZxzBH4s/dUsnZWB9Pr5o1z0o4=.sha256",
        "name": "Object.getOwnPropertyNymes (or similar)"
      }
    ]
  },
  "signature": "1bcECPNjWf1nmxG05Nl1N/hNDSiBPpRbwvNMzdJyM1tJRnRUfCc8jqrM8TbHQcvUwFBZVAlx4N8yuGR+V1zxBQ==.sig.ed25519"
}

{
  "previous": "%1WWeVo4Ji3VujjzGPa4VeBAyxlXtJTPOp/qhIFhbsr4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1073,
  "timestamp": 1537041981847,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
    "branch": "%fKbGBW8xKB410ZVWtnIihtA0FnY9YU+Zq+0ze6uw/u0=.sha256",
    "reply": {
      "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%fKbGBW8xKB410ZVWtnIihtA0FnY9YU+Zq+0ze6uw/u0=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) I'm not quite sure how this is any different from moving the type into the metadata. A message cypherlink currently points to a tuple of `(feed id, seqnum,  ..., content)` (pretend I filled in all the metadata and the order magically matches). By moving the type into the metadata, we get a tuple `(feed id, seqnum, ..., type, content)`, which is exactly the same as `(feed id, seqnum, ..., (type, content))`.",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "8w9z2moOumXWsZOPrmyN38/phZsp5WcbbZlJmT0G0o0BsGQZJnf68YToT/8tL3Z5cM/Oo/Q9dAupXR2hT1mnAg==.sig.ed25519"
}

{
  "previous": "%lyLRaTtjLfmI14jYP04UHauw1zDxLAEznfj8paXt3SI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1074,
  "timestamp": 1537115199072,
  "hash": "sha256",
  "content": "xWEL1pM1OyB0hPEAJuA+Lts0jBLacNM8+T7TgS3DpbE5OZ1H5uthuF3G+i3gIqGqrU0Z3r9phwb4d5Uh/vmIaPOEzasMnL49VPKaeWqYAEtVPyYl6XhNfPyEbWcM8kYETfMwyHEvc9XDQlwP6aprfothg33fW/ioBaBM1bGDjP/sBZdbOkviSxJK2mW7bQDYGg/GIbn+lNMDZL/qV51r0BMJLgQPA2eQas1ijaXkbfrFDTRnolfC2w3A+xJvajM3ctUgidqyfOJ1R1+mo5TF9OAVnEwToVxcF65DKbLBDsfeBEkMmssRXpd1HjvKnIlpaKH5QK9O15+LILabH8yXT2AGSjSi3Zn913HhnKl5OrCdA4ZoKyJEnrKVWNL3sjvxVSE5nfItKBjCKdt+7c6f8Psgw/ZSjrbl55xYEiTrQ9ECOXByJjrat2V9EswN/Y1R87LMWTudUYZoUgMxm2b+dA7i94LGZ2WjVItt10Wa9kOIiStJw7uyM+4BKt/3ktHOYLkRuyYZrZWAgIRD8mvGMjXBhoKCP0WyHiCnR/5zKGKyS2P9v5Oqe9SvIzPQDBvWoUcY1ywnjJGbu9Y9E2Tj9yCY846rrGxDbWoDYNsZeSFMDcnXOHm2MX/TI7uumZYDSp5qXngPb1Da0BbKz3q+rwlXRwCZYc/ltYE5NYiwwRnKXwcCSe1bRKNcej2vtqrIdsyoEXtSe6Laoz5Lbp2NMVs4rE1oXr/Z79rWt1YglPdUTzUYre9kUVFehidNOg/z1KxpkVIW49l6pf7QrHG4jC+I872x7K/mZPYPxMvTPSiC1qE9Fz66ufuzcVb9xMzBRH8QCkJpbTb44EjreVQ+l34yeCw37LP4pI7pUWXFmwcx1+2dygsCMALCHeNUL6Z8WOq+Spwrzqw8o+MqR5lsQus4FbFs6p1YiFmw0iLESxRy4fzjUU6PO6btaUeyEoQTdqMjWBAMrgG7Akq3ugTxzLm/PNheMPAlTy2IsLr0mZhki0t7WZdYBhpEmIt2Uhq3fTSLcVsF316BH1OKQIevBF0K75DCVWX5v1AXVBuJYTUBsLdme35e2GNM45DahsKSYaQX+kQWMSQoHzm+rE8n3sRLP/mgTNnSMtn0mQrjjdIOLaGurXfoJOkkpPEG3FtsVOgNjKyfDmJpGRuYochXIhyAZjjVOC2GN5FrLEx2FyZtReN+sz6GAvCxqIkuEoEHtMajPq1P2Xpl2Q==.box",
  "signature": "p6pWRLJcKWY+e/WqZ8Mw5kbmU2y2oYjp20f3FziStegTWH15Az6yzFJSBDaCB+RkTtRwJSg/qypj5EIW6v2ACA==.sig.ed25519"
}

{
  "previous": "%Ft4udTxpDxYacmHWI22S9LeVZAL/v6CsW3N9pq/C5tI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1075,
  "timestamp": 1537170799635,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%JGrXQcUUFi9aYzUlN/efBIRdupa4wgwKdr8vtnN1ELU=.sha256",
    "branch": "%8qp8gn5hGQ+lGnXyhVvoYP9lY6A+hdorW1zB3nbydow=.sha256",
    "reply": {
      "%JGrXQcUUFi9aYzUlN/efBIRdupa4wgwKdr8vtnN1ELU=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%8qp8gn5hGQ+lGnXyhVvoYP9lY6A+hdorW1zB3nbydow=.sha256": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "And perhaps also whatever-some-as-of-yet-unknown-plugin-thinks-of-as-local localness.",
    "mentions": []
  },
  "signature": "qlWUUOpsLoq/Nbadk6n+oQQMtMEBtrAArW5JKjUP0SN8unodeWzYqAF0PtePvJB5PQYuYpw2K+H0gTKZVVTNDA==.sig.ed25519"
}

{
  "previous": "%Ka+At37xNwIazb8/BIE3g8sNWQ9BLYRLT6xUmzWIeRQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1076,
  "timestamp": 1537267844930,
  "hash": "sha256",
  "content": "ktZ2ncsoOPW+OX9jY4deJeTJXSd8aMWyPlaOFGqZxryHqQPC0WHKDCkALmkTPiFI5qbEbid4HlcZ5ko48GVAeFWWg70+/Lu3XHRpr+pzLR29IgfuLe39/TDlqF/IPwHCfO4QugXASAccifjutOde4ugtXdtO/1LaUWiA5eUzSosapp+yeF1b6aBjv2+2VILPiXgDHjrMBkGmwA2KEjlFAE8WBOmYXYDs3cnMSegnVyMwH2IqxSxyOYBHHgOeHO4BoqzI4X1AN5hhijFHLNMNzNm9axoFtIPpsEcYGiHbfB8Yufna/lm4QeuAhTb3HIcmadox/3jkMbVQMzzcgObPhci/EE7bEhjQw6xyba1G1McUgylrC3hUqKa1UB31cQkm5uC9jtIuJfXN3zBd7+vfFPoCVCO1bReSRMZR4zkYxgtn0pr/BmbjW9halCE2JDchbksmByOsYNnPkVBhEm5pLk7/aq86pW8sBeN7/DcrXdPI1O9YqjIgkPLSR9KRR9n8OUxscP2iS10mQDGO8yRKPj573Z8RdbCGmb0hNUyzymO+oJMYJNqf4t28AWcWC5lz2nSZwTLohIqcQv2vZwhrQBNXzCLImpG+/fJxsozCK/EPmP+x5xlO0FGdHCW6FUo55Vdig07lhWz81JwydAqMpvxetlxAsspo01XReFfwP/yblOY9Tscl1utLQVZlz/8Yn2oHEueIiPKsjwI++a9o6TNRgRSxLIFDSXcFyC8vwPrfb4eg0qcZA6J/KD/4hZmol4/6Zx4yz630BG9ZDm/PFVyF3eVKMJRl1N22oMemjccNzG2pRHFyI16b9RGSj5hQ/myilcceHfKqeMS5NFPmHWsvS+wtSewf9F2vTjt8Six16lp4wmtFV/e2pXAiWU7Kg6UtugTbJD8IVl1CcpdVFYhxIPYFHh9pBBLvvMaH8AYDV3KB9b+qRZaJHkITy0dU9UxcvyDZ+V6v6o2L/cNtnjlyWPqRexDFspNTXpxQnaV4Y+f8rOZlJRtxSpBOPKADTwQ1FyPP0XZPQ2DNJpR799fqjnXRH6nr54r/zo2lTftGLtCuVlqu5TFl+1TeN1TABkp8oc3I33bLQXtqxl488XJ3UlN7md1pYLq26dn30VRUK5XikteOcuxUk18HH4g+xK7hDJ2R4cEli50x5F0tZS0CGBhFGuF14HxU+UiGTgflN4HBdZ22J+fmoOooO7e+H7+Zb13AphHGcgVjGAa2Qxomu+Q=.box",
  "signature": "GkG0oFEPyqcka3j+B4Nkhag6LzrN/LhiztTBID50U7WTB2RsoCNSf2TDSCJSqF8edwxnlwOFiaXUZ9QvGY7bDg==.sig.ed25519"
}

{
  "previous": "%29FDO5wQMnmly5dE9VYxDzo4C1bkDRc1C5ZVNr/1Nzw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1077,
  "timestamp": 1537355681967,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256",
    "branch": "%Osa+no8tcL7eX7meShSMGynjiXpMy6VroWKXjqrmgCo=.sha256",
    "reply": {
      "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
      "%Osa+no8tcL7eX7meShSMGynjiXpMy6VroWKXjqrmgCo=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I'm thoroughly impressed [@Christian Bundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519). This is horrible on so many levels at once, I've been literally laughing out loud while reading that post.\n\nHow do you signal errors (blob can't be fetched, or blob is not json)? Just return a content object with a special type field (how about the empty string) and no other entries?\n\nCongratulations on the creative act of bringing together seemingly disparate ugly hacks, combining them into an even uglier one. This approach could actually work, which is amazing.\n\nPlease don't merge this, ever.",
    "mentions": [
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "Christian Bundy"
      }
    ]
  },
  "signature": "SKWqQIJPgb+D1jgBVFmE0q3NCb04AfC+BlQexlqOrFjhaNDwx9xmxhGOnCaw1EAgBQY9h0/zvttPBJ3Bd6PMAw==.sig.ed25519"
}

{
  "previous": "%xtSX3Iu0Cxlg1/GYEDU5sJqyL0Nccn6yJJ7CQMetIP8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1078,
  "timestamp": 1537356142420,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "+XZM+AjA56SeJj61vH4lUoK8FTLOQlKaThZfD670HfTub5/6qq6dLlQ5OgNrNanrNuLeLTJZRHAQMQ+ND/UYBw==.sig.ed25519"
}

{
  "previous": "%+zNgt24byW2JcLuXDGjUGV84BmpVIP+Mu8fBa2zKxcU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1079,
  "timestamp": 1537357536981,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256",
    "branch": [
      "%AxcZKy3Le9MFegWYzl8mNLGbq3WPJfyMmmlONg2Cak8=.sha256",
      "%xtSX3Iu0Cxlg1/GYEDU5sJqyL0Nccn6yJJ7CQMetIP8=.sha256"
    ],
    "reply": {
      "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
      "%AxcZKy3Le9MFegWYzl8mNLGbq3WPJfyMmmlONg2Cak8=.sha256": "@+UMKhpbzXAII+2/7ZlsgkJwIsxdfeFi36Z5Rk1gCfY0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "You are right, my previous post reads rather harshly, sorry for that. My point of view was that of somebody being actually impressed, and very amused (or maybe \"flabbergasted\" is the right word here?). So please read it through that lens - lighthearted and jokingly - if you can.\n\nThe question about error handling was genuine, I'm interested in exploring where this approach leads to. And I really do admire how [@Christian Bundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519) saw how this could be done without any protocol changes, and then went on to immediately implement it (and uncovering a bug in the process).\n\nThis can serve as a valuable starting point for figuring out which backend-changes might be needed for offchain-content, and what challenges are involved in implementing them. Ideally, those could be worked on without relying on details of the actual offchain-content implementation.",
    "mentions": [
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "Christian Bundy"
      }
    ]
  },
  "signature": "qLrSgu/HmkzOF96eFhLUbYXnnkPSLFvkwAKWva4+Yc0FU1dNE4zl5ow0IvPaNE2cCdzr8jWZsh9meg9b2eSrAg==.sig.ed25519"
}

{
  "previous": "%dm8Fi2UEiGGpEgXoLS9AkNeZj0GIXRH0x0n5F0bi6Ig=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1080,
  "timestamp": 1537357546626,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%AxcZKy3Le9MFegWYzl8mNLGbq3WPJfyMmmlONg2Cak8=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "NnVjy4Rv8xock06Xr5ab4StubBCr7FMp6Rwjd065WcYrDqe3LfFBBepQuMjpFyIbwEVihlNH+T5esvvK1dLSAQ==.sig.ed25519"
}

{
  "previous": "%zX5Qk+WqpNaEvitfSsYTfO1xQeU1R+3vSrjfiVfRw4o=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1081,
  "timestamp": 1537371694812,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "comics",
    "vote": {
      "link": "%NoQz2Kly5dew17uJSbQ7ittw5lbHvObdfWUCO/27Hmg=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "UqOCNXh8QybNZsuwm6jzorQqf1QiVs5bDI9sR1pYb7MunjfHxa4i5JMlLapLS6E5Xrq4l8xvORBncN1VzbmQDQ==.sig.ed25519"
}

{
  "previous": "%fJOV5fsSON7fuwqDHTp03Kq51h7lozyDMdWePh+XVoQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1082,
  "timestamp": 1537422449379,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256",
    "branch": "%f4U9CyAqlSFnazDUmkAYBZU7u9OquLhmIq5jUcn7nBE=.sha256",
    "reply": {
      "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
      "%f4U9CyAqlSFnazDUmkAYBZU7u9OquLhmIq5jUcn7nBE=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Isn't the whole point of blobs that the protocol can treat them as opaque? Indexable blobs sound like an oxymoron, and somewhat unnecessary if we end up lifting the message size limit.\n\nI'll take the conservative opinion of leaving self-describing data to messages, opaque data to blobs.",
    "mentions": []
  },
  "signature": "pMtTJvs0xf6OWqncYzcrxs2VJXef/w/YMqtGYruaRPLZRRiaX9VJYxthggbYZ2c7IYAD/CAAJQXvu477GXsDBw==.sig.ed25519"
}

{
  "previous": "%eA3JFhootBuIHxFScFWinZaHDkN33QiT12497/YCFO4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1083,
  "timestamp": 1537423458575,
  "hash": "sha256",
  "content": "aiRKyB5gpCxI1sxSF7PaMBVRq67pB20tyQ81nZn7tjvEmE0GHD8RaIYNfQTwt3RxW4jaUopmo3yQ+9CyouWh+S+3zmNtM5T/0G2X/6O6wmFTlPmyf4159jvv+JEs7VkNC97Q05QIhBQ2HDn85Fi12Zyv/Qp/bDYHj8aKbe88SV9pyiuVJ8pjMGbjOHBIRXM3pN4HDxEYe1Mew0mP3dn0oP3ML1kLa+5t7ceA3Xd56QR/yat4SKj6lfkF+Og9gngup0n01deXJPJCgGwi3OfhQz64ypDYe1NuGblO8VRmaRhNCVFmJMJ6DJDKR8GsoKZ9dTfRnho4MiHmxdC8HOCVesFVGGGJckxTnve7SmrG33O8gqZLs+l1jqcIweExEpGhrL/OtuKcmyp3/FOLGJcB0iiV49tAcJd2CFN92AbehfmSh5KBJvEi4Uy2ahd5hqMiDygJzVtgDh74/gfllBnJjppzkMI4g1ORmEyu/PotwfBIsBl9vy7Rotok8kjvIzROje8B0Rheo2NxLLtKkg0d2Mmd6rpt4UgGWJMRfPz77S/cJXgsXk4BRxcYJ9Sdnno3Mfg9C/IjiRWlg7AKLVjTaitE4PEOskke9hICLZMeG4dpXk9aFJR0PJfW7d8xrsmX1asjsVpr54iaqiL8wf+g49fBa/S/4VCo3Ixr4uOM0ZGg62g5SPt2cek+nEAd472W+8xX9ObXqE98+YbuZuEghLH1tGerNMUkeoo0lCFysQCmnYLtiNDhMgaSomeqvQn8qGdcb5b4vRmIevPYTdjzw4bFnEfGhSm7OPXIU/xUeOK4d5Vm6AdPZhulTSlcGaBe4PiuxoCKDGQY2eNc3LaeggjQGfpY3Ss2vPs2dEdAnnBSR2hZabAH4PtMaYaCttdFJQC/pPMWaS8tIVcPYbHqgdg7j/Wkn97qUnPmoPx9YZc1ax3LtzKqXbgGyteHQsiKHHmwGjwotLTfCRfQiU17Evj1JZs/fWV+9UqujCPgLpOHQ+JR/KEFzJCclhmDiRW/VAmk+7P8w/mLx+oAcb8UYRfw9MbBFvPkks6p9HuBtnx/yMne0gxMxaI7O8j1bGzBVzHJLqXwPtibYnGYXgTMaPhdsI5oo/Zz0+O9iEyVwfz7akXq0sA05fCElfIsOqgaAk1dC5AcyyBnw2/sGYfhzY7i4B2HxBQkNARseOzXcA3Ev50Q/xkGq6bYcxLjLC7J2O/SYo+I2+nOncRd.box",
  "signature": "AgDDow0ewkh/9lDSW+9BXzsraEdRHrSMYWhg6u3GTbciOTDQsSCp+cFbMxIy4DVdUWfbXVoZazPE82/u5PMjAA==.sig.ed25519"
}

{
  "previous": "%JuCb/tghKkAKvDX4fSrsqy8wRWv0eblRTDi6hPGT4WE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1084,
  "timestamp": 1537423806518,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256",
    "branch": "%TN6HsJYmeBTQ2Vd13x/ym9FKy16ZWtjEMhrpojcsh4c=.sha256",
    "reply": {
      "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
      "%TN6HsJYmeBTQ2Vd13x/ym9FKy16ZWtjEMhrpojcsh4c=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> I messages have a limit for a reason: so you can know bounds on how much you are committing to when you replicate a feed.\n\nWith offchain-content, that's not a problem anymore. You can always resort to replicating nothing but metadata. Your peers can't know whether you even have the content data or not.\n\nTo get the current behavior, we can do offchain-content replication that says \"give me all content below size XXX, send me other blobs on demand\".\n\n> Also, searchable blobs is a pure feature - it's not removing anything, so we don't have to change how something works to add that.\n\nBut if it ends up in the protocol, it is a feature *everyone else* is going to have to implement/support as well.",
    "mentions": []
  },
  "signature": "L8rRI0dO16gGUL+8rHmEJwqZMff7NOUGXy9/yhfCqCnKsNCZJZAUrta3cHrGMKOCe8jKOETm8yFNuAo+R/XoBQ==.sig.ed25519"
}

{
  "previous": "%dWbw9cYZroN8CF16RQF0XsLfKQ/PYObPtkjpPliA2aY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1085,
  "timestamp": 1537438184964,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256",
    "branch": "%tnSKEQfkwfQCDdkmUgs51RTjINRmZ7OEEju3iDR32Eg=.sha256",
    "reply": {
      "%HGumETo50pIjEAexqPTifsT5t6LZi4NyWdh+cu8oGWc=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%tnSKEQfkwfQCDdkmUgs51RTjINRmZ7OEEju3iDR32Eg=.sha256": "@t5iZ/IQAYnYsGzQdpTKvbLpZnlmUML408BrjsvlwRew=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@jiangplus](@t5iZ/IQAYnYsGzQdpTKvbLpZnlmUML408BrjsvlwRew=.ed25519) What are the advantages of this scheme over just storing the entries in the correct order?",
    "mentions": [
      {
        "link": "@t5iZ/IQAYnYsGzQdpTKvbLpZnlmUML408BrjsvlwRew=.ed25519",
        "name": "jiangplus"
      }
    ]
  },
  "signature": "FvlIbegDoVimxRXbmeslYAnxuGmSPhdR1gMEyq0qUry9mZAeK8Pa6JFOEVB4Ynnr7Y+YAEOcuj1roYg7dZ0nBg==.sig.ed25519"
}

{
  "previous": "%A0hH7t+d5/qO+RHXK/06hI/7/5JGOEyi8UWQ57Wh6gY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1086,
  "timestamp": 1537441359556,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%oxtXLx0AdZgcQpLlLYjDfrgzMJw1j8zv0YSwEtFAep8=.sha256",
    "branch": "%EexVyz6bKSpBdokM11Y/rRh625m/ukwLqMYKZV3mNhA=.sha256",
    "reply": {
      "%oxtXLx0AdZgcQpLlLYjDfrgzMJw1j8zv0YSwEtFAep8=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
      "%EexVyz6bKSpBdokM11Y/rRh625m/ukwLqMYKZV3mNhA=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519"
    },
    "channel": "ssb",
    "recps": null,
    "text": "[@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519), [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519): [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519), [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) and me briefly brushed on this topic in our first sunrise choir call. While we can code up pub replacements in Rust, Go, or C, this is an area we will need to tackle in order to decouple clients from js-sbot (and thus allowing truly independent, fully fledged ssb server implementations).",
    "mentions": [
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      }
    ]
  },
  "signature": "2s7VVlHfn7sjB06KnFYhioAqn5pOEKNd+MhrPy+/DbZVtbIbkRtrb6i0q9cSq4cFYJish1pUA1R9eD5o9Wa9Ag==.sig.ed25519"
}

{
  "previous": "%hPoq1tAX/IalDUGKSQ4kbvjI9dxQ7NEXKKvlMtl+ls0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1087,
  "timestamp": 1537442531369,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%oxtXLx0AdZgcQpLlLYjDfrgzMJw1j8zv0YSwEtFAep8=.sha256",
    "branch": "%TyBR48sdw6V0z0x2YouAzX2oHt+WoXlh3cV4ml0zeU8=.sha256",
    "reply": {
      "%oxtXLx0AdZgcQpLlLYjDfrgzMJw1j8zv0YSwEtFAep8=.sha256": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
      "%TyBR48sdw6V0z0x2YouAzX2oHt+WoXlh3cV4ml0zeU8=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519"
    },
    "channel": "ssb",
    "recps": null,
    "text": "[@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519)\nNo call notes on that. We didn't discuss specifics, only identified this as something that we'll encounter in the future. Piet maybe sooner than me, but I'll certainly chime in once this gets (re)discussed.\n\nAs for muxrpc, we want to replace it with [bpmux](%UwYCEb0LdZymBz0llz+QcqXd004x800DHiWJiYy+P80=.sha256). But the \"calling feed id\" sounds to me like an application-level concern, not a protocol-level one. Pretty sure we won't need to modify the protocol to implement this.\n\nI designed muxrpc with the use case of an endpoint transparently forwarding messages in mind, so that's going to play pretty well with out-of-process plugins. For example, it allows heartbeats on a per-stream basis, which can be relayed to the responsible plugin, thus allowing plugins to hang without the system getting into an unstable state. ",
    "mentions": [
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "%UwYCEb0LdZymBz0llz+QcqXd004x800DHiWJiYy+P80=.sha256",
        "name": "bpmux"
      }
    ]
  },
  "signature": "pq6qJO2xnSpTcae45vf2DnPiuf4NKp4gweH8aR0uUz0HFCN5fFbrs/nfTWwhn3oTvk4q+c6sP7EocHQOOgBBBw==.sig.ed25519"
}

{
  "previous": "%KvZn0kJMNntapWvZ/8eVL6J8VNE5sFVUwPJzbSgWYV0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1088,
  "timestamp": 1537442543759,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb",
    "vote": {
      "link": "%TyBR48sdw6V0z0x2YouAzX2oHt+WoXlh3cV4ml0zeU8=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "J2B74WJ/nuNhPWE/+D5gan8HXsSnpmmqTJc2UHRz5exaWabFzMMaqgt4pEIviUwPAEE8OUuxR01/RvnEqCleBQ==.sig.ed25519"
}

{
  "previous": "%U1ieKTGLvGRDaPOsNNPQIvAqAxHXXZKsGDrIJT4urgc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1089,
  "timestamp": 1537443389996,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256",
    "branch": "%8ebUR0K+PWALf0YJ+H2v7S0FojKJIHje04jaJm/WJug=.sha256",
    "reply": {
      "%rciFuVmIAi6WxamBNcF+EYSnJtngAbHwxxmtudsz3v4=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
      "%8ebUR0K+PWALf0YJ+H2v7S0FojKJIHje04jaJm/WJug=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n> then what happens if the peer you are replicating has chosen a different one and you don't have that?\n\nUnavailable message content is something we'd need to handle in any case. It could happen for all kinds of reasons: Garbage collection of rarely accessed messages, or just a server crashing during replication, at a point where metadata has already been transmitted, but (part of the) content has not yet. This is a problem we will face regardless of any message size limit.\n\nYou wrote that the message size limit gives \"bounds on how much you are committing to when you replicate a feed\". Offchain-content can do even better, it lets you chose your own bounds, rather than having to accept the prescribed, arbitrary ones.\n\n> To answer that question, we need to experiment - and the nice thing about that particular experiment is that it doesn't mean changing anything that already exists.\n\nSure, as long as those APIs are clearly marked as experimental and unstable, so we don't force ourselves to support it for backwards compatible. Having to attempt parsing of all blobs and creating indexes if parsing succeeds would be a huge (computationally) commitment.\n\nThe whole question of how much of the server-client communication is part of ssb is one we will need to figure out eventually, just like the [plugin story](%hPoq1tAX/IalDUGKSQ4kbvjI9dxQ7NEXKKvlMtl+ls0=.sha256). That'll be a lot more effort than the message format changes.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%hPoq1tAX/IalDUGKSQ4kbvjI9dxQ7NEXKKvlMtl+ls0=.sha256",
        "name": "plugin story"
      }
    ]
  },
  "signature": "rOd+W2/7wDHp8GEsrMZXpYh4is7r/MBd0Ra2ChSXIpRfsLephjBrqeXkw8kW0pJZaIZ8bKdkm2GbUAjAG5LmAQ==.sig.ed25519"
}

{
  "previous": "%ZdAiHrpK/Z36RzjCTmFlyuVRwHVZBGsi65q1tdr9vno=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1090,
  "timestamp": 1537458616378,
  "hash": "sha256",
  "content": {
    "type": "post",
    "text": "Why does my brain keep doing this? I promise, I didn't want to think through this stuff... But I might as well write it down now. CC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519) [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519)\n\n# Thoughts on ipc-based plugins\n\nThese thoughts are guided by the desire to\n\n- move as little work into the server as possible\n- move as little decision power into the server as posibble\n- make the server know as little about the plugins as possible\n- allow sandboxing\n- provide a standard mechanism to facilitate plugin-to-plugin communication\n\nWithout the last point, all of this becomes nearly trivial, we could mostly treat plugins how we currently treat clients. But the last point is also the only one in conflict with the other goals, each proposal will inherently be about making tradeoffs between them.\n\nThis discussion will also involve the distinction between [server-to-server and server-to-client](%76QoBmeB07QADgIX+LFNLOfz8KSOlkTFSJ+SVw+/DsQ=.sha256), and where plugin-to-plugin fits into it. Aaand there are encoding considerations about sending short integers as rpc identifiers rather than utf8 strings.\n\nAnd a final warning: I don't care at all about manifest files and what they claim regarding permissions. If you talk to another process, you might send or receive any messages (or bytes actually), no matter what some sort of manifest file says. And as for permissions: Either the other endpoints does what you asked for, or it does not. Again no ties to any sort of magical file.\n\n---\n\n## Plugin-to-plugin communication\n\nSince this is what all boils down to, I might as well start here. The basic idea is that plugins expand the range of rpcs an ssb server is capable of handling. There are a few rpcs in the core, and then it might delegate other rpcs to plugins.\n\n### Addressing plugins\n\nI basically see two reasonable approaches for making sure that an rpc reaches the correct plugin: *Anonymous* plugins (or *globally scoped* plugins) and *named* plugins (or *namespaced* plugins).\n\nIn the case of *anonymous* plugins, the server would receive an rpc (which contains a well-known identifier), then check whether one of its plugins is able to handle an rpc of that identifier. In the case of *named* plugins, each plugin comes with a well-known identifier, and rpcs specify the plugin to which they are addressed. The server just delegates based on the identifier.\n\nAt first glance, there seems to be a big advantage of the anonymous approach: An endpoint does not need to know whether a certain rpc is provided by the core, or a plugin (or which one). But on closer examination, this does not really hold. Any rpc mechanism only works if the communicating parties agree on the same, well-known identifiers for the rpcs. But if such an agreement is necessary, then they can just as well agree on the well-known name of the plugin that implements the rpc.\nBut named plugins actually reduce the burden of coordinating to find well-known names. They are effectively namespaces for rpc calls, as long as two plugins use different names, they can identify their rpcs however they like, including short integer identifiers.\nAnonymous plugins also need to handle partial naming conflicts. It would be unsatisfactory to reject a whole plugin just because it uses the same rpc method name as some other plugin, but everything else (e.g. first come, first served) could lead to problems where the peer expects a different plugin to handle its rpc calls.\n\nWhile I described the named plugin mechanism as sending the plugin name with each rpc, that's just a conceptual model. In practice, we will want to use bpmux/muxrpc channels to bundle all communication to a specific plugin. And those automatically use short identifiers rather than having to resend the well-known name each time.\n\nSo overall, namespaced plugins are easier to coordinate between different developers, are more efficient, and leave complete freedom on how the plugin interprets what kind of rpc a message represents. In fact, the server does not care about the wire protocol of the plugin at all, the plugin could use protobufs to communicate if it wanted to.\n\n*continued in next post...*",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "%76QoBmeB07QADgIX+LFNLOfz8KSOlkTFSJ+SVw+/DsQ=.sha256",
        "name": "server-to-server and server-to-client"
      }
    ]
  },
  "signature": "O+xMIR9Bno9At2IaZq9lL+n8jj8DOKFpXQysuyDGJJNtptJVmIAIZpFBzllE0nBt7gNziXsv91cL+2zugJjnAw==.sig.ed25519"
}

{
  "previous": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1091,
  "timestamp": 1537458653504,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "*...continued from previous post*\n\n### Connecting plugins\n\nPlugins need to be able to interact, for that we need to ~~reimplement dbus~~ provide a few basic facilities. Each plugin should be able to:\n\n- query which plugins are currently connected (by well-known name)\n- be notified whenever a plugin connects/disconnects (by well-known name)\n- create a bidirectional communication channel to another plugin (you guessed it, by well-known name)\n\nThe last one is the big difference between name-spaced plugins and global plugins, and I think it is the cleaner solution. Not only does this allow plugin-to-plugin communication to use any sort of rpc protocol they want (in particular, a fully-fledged rpc protocol might be overkill), but it also allows direct connections. The simplest implementation for the server is to hand out a logical channel to the plugins, which first sends data to the server and the server then reroutes it to the other plugin. But a more advanced implementation could instead mediate creation of a direct channel between the two plugins. On the same machine, that could mean creating a unix domain socket and would save a few memcpys and syscalls. But for plugins living on different machines then their server, this would mean a direct tcp connection rather than (literally) rerouting everything trough the server. This is another advantage we just could not get with anonymous plugins.\n\nThere are a some details to work out for this, and there are some considerations regarding the capabilities required for querying connected plugins and establishing connections, but overall, this is surprisingly simple.\n\n### Plugin startup\n\nIf the server has to start plugins, it needs to know a bunch of things about them, and it also needs to decide *when* to start them. What is a design where the server doesn't need to care? It can expose well-known sockets (unix domain, tcp, whatever transport you want to use) where processes can register themselves as plugins. \"Registration\" sounds fancier than this needs to be, at the bare minimum the plugin would just say \"Hi, I exist, and I go by the name `plugin_foo`.\" and the server would respond \"Cool, here's a bidirectional communication channel we can use for all remaining stuff\", while notifying subscribers that the plugin connected.\n\nWe'd probably want to perform a secret-handshake first, so that the connecting process (which may or may not live on the same machine) proves that it has the capabilities of a certain identity (i.e. the secret key corresponding to a feed id), which may or may not be the same as the server's identity itself. No need to encrypt the connection if it is on the same machine, but it still makes sense to identify via shs.\n\nDoes this sound familiar? It is how clients currently work, except for the part where a plugin specifies a name.\n\nWith that done, there's a dedicated, bidirectional communication channel between the server and the plugin. At the very least, the plugin should be able to call all the rpcs that a client can call. But in addition to that, there's the plugin-to-plugin communication as described above, facilitated by the server.\n\n## Unifying clients and plugins\nWait, what? Well, with this approach, plugins are basically a generalization of clients. A client is simply a plugin which not offer rpcs to other plugins. That's why it does not need a name. So all we need to do is to allow nameless plugins which do not show up in the plugin query/notification mechanism. To the server, there's no distinction between clients and plugins anymore, which will simplify a lot of things.\n\n## Remaining thoughts\n(Jotted down in a hurry)\n\nI brushed over authentication details: When opening a channel between two plugins, they should each know the public key of the peer (and the server needs to enforce that they have the corresponding private key).\n\nAlso, it would be possible to take a much more opiniated approach, forcing all plugin comunication to happen via bpmux, etc. This *might* help with consistency, but overall plugins still need to come to agreements, so they might as well agree on the encoding of the communication mechanism. In practice, prettty much everything will likely default to bpmux anyways, and those who don't - well, they'll have good reasons and be happy that we didn't enforce it.",
    "mentions": []
  },
  "signature": "cR3lJ0UXeGH6aaI1IqsNGKhNfjsJukdqNjNvsL9Rb4QLI1vira4i3lEwM27oBQh+F0VAMiBbALAME4OGLia5Aw==.sig.ed25519"
}

{
  "previous": "%9uXPB2EKsj2DAHhWvX/hyNnlJvkkIyMnr62atdlTVaI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1092,
  "timestamp": 1537458757904,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%9VWASKdl78TVKP+Hn0bVqji6Avg0DpfSP4aUIT6rwJE=.sha256",
    "branch": "%vjMSI5+9Hy24KmweS/TIDA6pDNGFXa4SEsNoT24TDso=.sha256",
    "reply": {
      "%9VWASKdl78TVKP+Hn0bVqji6Avg0DpfSP4aUIT6rwJE=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519",
      "%vjMSI5+9Hy24KmweS/TIDA6pDNGFXa4SEsNoT24TDso=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519"
    },
    "channel": "ssb-protocol",
    "recps": null,
    "text": "Thoughts on ipc-based plugins\n\n%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "mentions": [
      {
        "link": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256"
      }
    ]
  },
  "signature": "NjFaGaqgDZKq9WNY14yyZb3ejAvDG0Eedkmt4jJogNlobyeLTRxV1iVe1ArXoZGIdfC2i7sZC7+YrBlQ9NVFCg==.sig.ed25519"
}

{
  "previous": "%TVHvOAtY1sVJmV9l9BqG+vn+EqJ1kpGGu+XXwPj4gFw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1093,
  "timestamp": 1537517240362,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%9uXPB2EKsj2DAHhWvX/hyNnlJvkkIyMnr62atdlTVaI=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%9uXPB2EKsj2DAHhWvX/hyNnlJvkkIyMnr62atdlTVaI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "A few more thoughts:\n\n- this approach would greatly simplify [this invocation for modular clients](%evFWDkc/iLCnjB32J0o4QOQ9pkOGWHQiSXPIKSGqJVA=.sha256), to implement it, you'd simply need plugins (for the communication between clients) with a UI (for the communication with the user).\n- each plugin should be able to decide who gets notified of its presence, for example based on the following modes:\n  - explicit permission: Whenever a new plugin wants to query information about you, you are sent an rpc with the name and pubkey and get to decide whether that plugin is allowed to learn of your existence. This is the most general mode, but for efficiency (remember that plugins might live on a different machine) it makes sense to provide a few more:\n  - always: Everything is allowed to query information about you\n  - trusted: Everything with the same pubkey as yourself or the server is allowed to query information about you\n  - server: Everything with the same pubkey as the server is allowed to query information about you (I think this is called \"local\" in current muxrpc/manifest parlance?)\n  - same: Everything with the same pubkey as yourself is allowed to query information about you\n  - never: Nothing is allowed to query information about you.",
    "mentions": [
      {
        "link": "%evFWDkc/iLCnjB32J0o4QOQ9pkOGWHQiSXPIKSGqJVA=.sha256",
        "name": "this invocation for modular clients"
      }
    ]
  },
  "signature": "HVqIvThqE3WNDhcc0nUj4cudbsToZnhmjk234qPoGbAptFrpvKa8gtjvHSXCJ+qDKy2y+fteEZzHQD5XpQymAg==.sig.ed25519"
}

{
  "previous": "%K2Tt1mww4VVi0eGUYiQOa0VaEm8k7iycK0+UubblqPU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1094,
  "timestamp": 1537552181879,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "ccc",
    "subscribed": true
  },
  "signature": "kXETQ7V7WeNrwvlmnsNGTW28G5IrBfZPeq+iQJmVM77ID13Fp3hDx7s7UDPaHY8RESIKttlsfHEOtzXwsQxLBA==.sig.ed25519"
}

{
  "previous": "%NL4KcKMohEveE8Uppj7aE/vG4+YjlgXxjQyaehHyKGE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1095,
  "timestamp": 1537558154350,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@NeB4q4Hy9IiMxs5L08oevEhivxW+/aDu/s/0SkNayi0=.ed25519",
    "following": true
  },
  "signature": "xqVKJT7XS6tTl08s7AmUoU3d5hWDpRW8Yn1qQDYbgprfzBAiRJFjsWXDBfkW9qKJW3S/C/BLQkgPBn9wcPc0DQ==.sig.ed25519"
}

{
  "previous": "%HoGF9gRZrH/qBYgHNcR+R4IyKoeFVqkn85liMQLkMSI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1096,
  "timestamp": 1537600651779,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "scuttle-shell",
    "subscribed": true
  },
  "signature": "Jr80mX+dQY7MU5L0Q3LQ/5Z0afG6kS5eU8uwagqhjpkK3viTfgpt/egAf1ysyd/nwcLw5XlFT2tVMpvfe07BCw==.sig.ed25519"
}

{
  "previous": "%zEuN70PtgBPYFf+5Z70fcDEGxHMKYC1SDZQTL39oUGw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1097,
  "timestamp": 1537648764226,
  "hash": "sha256",
  "content": "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.box",
  "signature": "DJy62PWe4hJ3lgErowLrdx8a2DY0Cu0guHfN+mHswmDVrb4ud24AaX7DuLiWFp7UOZA9IE5vU+YufUZK97rRAw==.sig.ed25519"
}

{
  "previous": "%gDWq8+cRy8RBdFOLQU97Eadd7qZ3nAGdKh/hz7VIII8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1098,
  "timestamp": 1537690182107,
  "hash": "sha256",
  "content": "elzqFgzoppu5lzwbwO0dxSGQhnH8rU5ruLZN7yEkoH9uY1WLm8r+YPbkSEcA4tUhXyvVzSoH1VJCaHoC1+2L+1KGmagf1VeGiRIHCLPrNfj4BRlYPmMxmEWjem5gw2Z3jJFuPNBLOJEooCb0N6UJc4/7ygyG+WRK98hrbBC6evI7j+rOwxeFRB9Cil4iGLD/ce1RN2zX7yFJVYSE9A6SKf6JLCtV2dogvdQJSd6SuoyKCmEWBo3IjML/GCxxNJ/j5X1789F+/JP49dhtC7pVqluh27vpYwBF3BhxzTKrQBw0f/RaYoHyLmGK0l9VF8dpLEU/s21XbgD6VrC2y3YMGxD+LYe0ZvKijQf0suC7ncrIeZK/IyHk4dhjGCg89kEWFocu49ALe9iV2ZR6h/OrrZPyciB4Bp0wOsGfmlvmuN6s3TMUtAgB43V1JUYaAXjHI21Ds+f3DtsER1pqK+gGSibVZVew2zySOeZvdAvpnI6zoUXT+Xbxv5dqsluRTN54liYd3QYuid4Xp+DtfcI5qpVOi+FYiqh+oe+X/TyaS+FO6hf1EF87iHhXfdleMWC/mLwx9BYKnCTsHJvchTbD0/QUfrBte3RgfzASgS9Y6DNzvNPNbTqrYRwRA6EC1B04DFcrJKw0NwGV/kzN5r2gd64H8+vkP/tY3Qj2qPDkAckwd1d9voXD8tK9Dt1tRWKFDljdtCFuAi9BJShlmWBCtA/ofh7AaR0uCebyg/84lRZbuNDNnU0FykbE1SXO7XKIaE9nEDZmMaRISzTYP3ZNjxw7busQBXQhA0YvcY8ZTaPk1W+9xofpG+ADr3kpVwI8sqaN6A6MNWrQDoaY6rLjxEhA28nLo0p//xruB/lSaPCGg8na9p4iySrKclm7/bkgpmOWprI/wbqWgVo81snxx9oEcokT1u8K/82GFZK6WDnd3js2Sn7XaWUn3FGXUIy2+VY2bbHbeRbuN57nCMPiPcz5sWlffbCIy6ysGG8FUWWDj7u094McUSuOHckEAQu/W7VFxEz/CTUZX4oOHZavYJobYwb90GNocjMIsenbsH4EGE9NmGinDznPwwmANrqT8mTMgCIm5cV0MnquY/cTNYQQONodNSHIavH48JARZ0aPoAJqZTPgzyNnkAaHPqoobc79peNDta2m2TrBLZsJSxih8P5U+yZGBxD1Dk2JmX0JTzeup22akne7KmG+aGmvte4L4dviutSxlmckRCHZhBlOarUFjvvRMjfNNI4p51jtugMaeu+rVmk888YMwavQ/872.box",
  "signature": "G6zWFjnwcpRAHbY9jUDes6ttxB7x3ZpW5PyTdDE1xOZ375GpVPOxemvusf26a26rqeupuD0Hspt+SgofPE93CQ==.sig.ed25519"
}

{
  "previous": "%hbmjlX/qdczHSJSCVQDgtz26fV9aZN1WbeuihKJzIiE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1099,
  "timestamp": 1537698583082,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssbrs",
    "vote": {
      "link": "%tJ0TncWpTVauQXYqNjQ4NPdjvR932+JqLfKjgI097e4=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "3FK0b9s9ALm3x3p54hOzitbe/ff1SIvjzuZ3zFUwmtbQDFGYZP2y2w7NMbmZS/XdA2BN6xu3Tk0S+VgF4Ds4CQ==.sig.ed25519"
}

{
  "previous": "%mjYYL+AYubwWcwHFolPeNJRQI23nlGgI0ozYGwepUx8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1100,
  "timestamp": 1537707176216,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%3moSS9xHmfYNPHTK0xKFEPMps2d51WKbsj8XQJVFDYQ=.sha256",
    "reply": {
      "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%3moSS9xHmfYNPHTK0xKFEPMps2d51WKbsj8XQJVFDYQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "This writeup suggest a few simple heuristics for storing reachability indices leveraging special properties of ssb. They are not yet suitable for real-world application, but can serve as the basis for more fully-featured indices.\n\n CC [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) [@moid](@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519) [@Jan van Brügge](@ZdKcwA/aQ96HRzvD7hyAMmsSzXx5kGzWRBbZJnNkXKI=.ed25519) [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) [@alanz](@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519)\n\n---\n\n# Causal Ordering of SSB Messages\n\nSecure scuttlebutt (ssb) is an append-only data store, where all messages form a directed acyclic graph (dag). The messages themselves are the nodes, and references between messages (by means of cryptographically secure hashes) form the edges. An important problem that arises in dealing with this data structure in the context of ssb is the question of causal ordering: Given two messages, which one is older? Message `x` is (strictly) older than message `y` (written as `x < y`) if there is a (directed) path from `y` to `x`. Since messages form a dag, it is never the case that both `x < y` and `y < x`. It is however possible that there is no path in either direction, in which case it is impossible to say which messages are older. Mathematically speaking, the causal ordering relation is a partial order, not a linear one.\n\nThe main focus of this writeup lies on describing strategies how an ssb database can efficiently answer questions about the causal order between two messages. Other, related questions, such as finding (and possibly filtering) all messages older than some message, or computing topological sortings, are discussed briefly at the end. This writeup describes multiple approaches, starting with very simple ones, and advancing to more sophisticated methods. All approaches stay rather simple, they serve more as demonstrations of basic concepts rather than real-world indexing schemes.\n\nBecause causal order is determined by the existance of paths, this problem is nothing but the [reachability](https://en.wikipedia.org/wiki/Reachability) problem on dags. This problem has been widely studied in the database literature, for a survey of existing approaches, study the related work section of [Jin, R., Ruan, N., Dey, S., & Xu, J. Y. (2012, May). SCARAB: scaling reachability computation on large graphs](http://www.cs.albany.edu/~jhh/courses/readings/jin.reachability.sigmod12.pdf). This document does not recapitulate the previous research, instead it examines how some unique properties of ssb can be leveraged for simpler and more efficient solutions than the general case.\n\nA word of warning: Almost all big-O complexity claims in this text are very handwavy. The exact worst-case complexity often depends on many factors, including the total number of messages, the number of edges, the maximum out-degree, the number of feeds, the largest feed size, etc. So take them with a grain of salt, or better yet: Ignore them except as a nice intuition to have.\n\n## Basic Reachability\n\nThis section gives a short overview of the problem space.\n\nGiven the message dag, it is almost trivial to answer whether some vertex `v` is reachable from from another node `u`: Simply explore all paths originating from `u` and check whether `v` is eventually reached. This requires no database indices, but it is too slow for a practical implementation (worst case `O(n + m)`).\n\nTime complexity can be reduced to `O(log(n))` by precomputing the transitive closure of the edge relation, because `v < u` iff `(u, v)` is an element of the transitive closure. But the full transitive closure can take up to `O(n^2)` space, which is too much for practical implementations.\n\nIn practice, instead of storing the transitive closure as a complete reachability matrix, one can store at each vertex `v` the set of all vertices reachable from it (`reach(v)`). We will refer to such a set of indices as `ind(v)`. This is still in `O(n^2)` in the worst case, but it is a sparse representation. Since ssb message graphs are relatively sparse as well, this scheme will serve as the basis for the indexing schemes described later.\n\nPrecomputing the transitive closure is the solution that minimizes lookup time by using as much space as (reasonably) possible. Exploring paths in the message graph however is *not* the solution that minimizes space usage. To minimize space, you could store the [transitive reduction](https://en.wikipedia.org/wiki/Transitive_reduction) of the message graph, rather then the full graph itself. Reachability queries would then again be answered by following paths, but on the transitive reduction.\n\nIt might seem silly to store fewer edges than the original graph has, because those need to be kept somewhere in the database anyways. But at least in this discussion, we will assume a dedicated datastructure just for handling reachability queries.\n\nAll solutions are basically interpolating between storing the transitive reduction and storing the transitive closure. Or viewed in another way, all solutions choose a different degree of compression of the transitive closure. The more compressed it is, the less space is required, but the longer it takes to answer queries. Ideally, we'd like to find a solution that allows answering queries in sublinear time, while needing only quasilinear space for indices.\n\nQuery time and index space usage are the two main restrictions, but not the only ones. Another important one is the time complexity of computing the indices. And yet another consideration for ssb is that these indices need to be updated often. It should be possible to do so incrementally rather than recomputing indices for the whole database from scratch.\n\nThis concludes the short introduction to the reachability problem. The database literature provides approaches for efficiently handling the case of arbitrary graphs, but ssb can rely on a few special properties.\n\n*continued in next post...*",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
        "name": "moid"
      },
      {
        "link": "@ZdKcwA/aQ96HRzvD7hyAMmsSzXx5kGzWRBbZJnNkXKI=.ed25519",
        "name": "Jan van Brügge"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@ZcjYF92reFjUtEYdoJ8ulOI6N6klwAAaIkghEEHdvSE=.ed25519",
        "name": "alanz"
      }
    ]
  },
  "signature": "RQpm6ErnKhe1CNYJ1JBbGQcf2WEnXFBZU7WSJE62GAkXqDQ7mSn5vJWHsQe6X8kCI8dnNO+F7f96tE8kXnPsAw==.sig.ed25519"
}

{
  "previous": "%wtCU/eSLEGcIDvDeWDAajS0kzWgTaheOwKR8h9hNi+E=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1101,
  "timestamp": 1537707232152,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%wtCU/eSLEGcIDvDeWDAajS0kzWgTaheOwKR8h9hNi+E=.sha256",
    "reply": {
      "%wtCU/eSLEGcIDvDeWDAajS0kzWgTaheOwKR8h9hNi+E=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "*...continuation of previous post*\n\n## Feeds and Sequence Numbers\n\nEach ssb message is published by an identity, and appended to what amounts to a blockchain, called a *feed*. As a data structure, this is nothing but a linked list of messages. Any message can thus be uniquely identified by the feed's public key, and its sequence number (the index in the linked list). Notation: `a_i` refers to the `i`'th message in feed `a`. Every message belongs to exactly one feed, and the causal order inside such a feed is a linear order. This is what distinguishes ssb merkle dags from e.g. the ipfs merkle dags. And this partition of the vertex set into totally ordered subsets can be leveraged for compressing the transitive closure of the edge relation.\n\nA first (and somewhat trivial) observation: Given two messages from the same feed, causal ordering can be determined by comparing their sequence numbers, which is much faster than traversing the linked list. This is an optimization every implementation can and should perform. Another, still rather trivial observation: Any backlinks from a message to another message of the same feed does not need to be stored, as the causal order is implied by the sequence numbers anyways.\n\nA generalization of the latter observation can be intuitively formulated as \"A very new message in one feed linking to a very old message in another one often provides no information regarding the causal order\". Put formally: For all natural numbers `i < j` and `k < l`: if `(a_i, b_l) in E` and `(a_j, b_k) in E`, then `(a_j, b_k)` is not part of the transitive reduction. Proof sketch: There's a path from `a_j` to `a_i` since `i < j`, and there's a path from `b_l` to `b_k` since `k < l`, these paths together with the edge `(a_i, b_l)` form a path from `a_j` to `b_k`.\n\nThis has far reaching consequences, not only for index creation, but also during dynamic recompuation of the reachability relation. When computing the set of nodes reachable from some message `a_i`, it is sufficient to only store one reachable message per feed, namely the one with the highest sequence number.\n\n### The `full` Indexing Scheme\n\nTaking these observations into consideration yields a very simple indexing scheme: For each vertex, store which other feeds can be reached, and store the highest sequence number at which they can be reached. The above observations allow to quickly restore the full transitive closure. A query only needs to look at the data stored at a single vertex, so we get optimal time complexity (`O(n)`).\n\nWe define some terminology to make the following explanations more succinct:\n\n- a vertex `a_i` *shadows* a vertex `a_j` if `i >= j`\n- a set `V` of vertices *shadows* a vertex `a_j` if there is no `i` such that `a_i in V` and `a_i` shadows `a_j`\n- a vertex `a_i` shadows a vertex set `V` if there is `j` such that `a_j in V` and `a_i` shadows `a_j`\n- the *shadow set* `sh(V)` of some vertex set `V` is the largest subset of `V` such that no element in `sh(V)` shadows another element in `sh(V)`\n\nThe above indexing scheme thus simply becomes \"Each vertex `v` stores `sh(reach(v))`.\n\nTo create the indices, first compute a reverse topological sorting, so that the vertices can be iterated from oldest to newest. For each vertex, the set of indices is the shadow set of the union of all its out-neighbors indices. This simple computation can be used when adding a new message to the database, resulting in efficient incremental updates.\n\nThis approach still basically stores the full transitive closure, so space usage is fairly high (although already much better on typical data sets than naively storing all reachable vertices). The following section introduces an indexing scheme that has slightly worse lookup time, but needs less space for the indices.\n\n*continued in next post...*",
    "mentions": []
  },
  "signature": "NBjPXiJsDvHxJnJZg466r+FkPUoP3hdYVHXYuIB4YtnLTjyoD2+T5kbShWaORKvMXnCSzoyEl91UJY8Y/S4HBA==.sig.ed25519"
}

{
  "previous": "%6UJXY6pNwSArXWSksLdj8jl5j0euQB7c7sh+E2xlUEs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1102,
  "timestamp": 1537707287235,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%6UJXY6pNwSArXWSksLdj8jl5j0euQB7c7sh+E2xlUEs=.sha256",
    "reply": {
      "%6UJXY6pNwSArXWSksLdj8jl5j0euQB7c7sh+E2xlUEs=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "*...continuation of previous post*\n\n## `O(sqrt(len_a))` Indexing Schemes\n\nSuppose `a` is a feed of length `len_a`. In the previous scheme, the vertices store the *full* (shadow) set of vertices reachable from them. The central idea behind the new scheme is to only cache a subset of this information, and restore the full reachability information via an iterative graph traversal. For this, we need another definition:\n\n- the *shadow difference* `shdiff(V, W)` between two vertex sets `V` and `W` is the set containing all vertices `v` in `V` for which there is no vertex `w` in `W` such that `w` shadows `v`\n\n### The `sqrt-1` Indexing Scheme\n\nThe new indexing scheme: Each vertex `a_i` stores `shdiff(reach(a_i), ind(a_(i - sqrt(len_a))))`. Just like the previous scheme, the indices can be computed by iterating in reverse topological order. Instead of computing the full `reach(a_i)`, it is sufficient to use the union of the index sets of all outneighbors of `a_i` as the first argument to `shdiff`. This also works for incrementally updating vertices.\n\nOnly storing the shadow differences can greatly reduce space usage. Answering whether `b_j < a_i` is done via the following algorithm:\n\n```js\n// Return value of `false` means that b_j is not older than a_i, but not necessarily\n// that b_j is newer than a_i.\nfunction older(b_j, a_i) {\n  let current = a_i;\n\n  while (current != null) {\n    if (shadows(b_j, a_i.ind)) {\n      return false;\n    } else if (shadows(a_i.ind, b_j)) {\n      return true;\n    } else {\n      current = get_message(a_i.feed, a_i.seqnum - sqrt(a_i.feed.length)); // null if second argument negative\n    }\n  }\n\n  return false;\n}\n```\n\nIn the worst case, this requires `a_len / sqrt(a_len) = sqrt(a_len)` iterations.\n\nWhenever the feed length reaches a new square number, all indices need to be recomputed. This yields amortized `O(sqrt(n))` incremental index update costs (every `sqrt(n)` messages, all `n` messages need to be scanned). Where this is undesirable, the scheme can instead use the current sequence number for determinining how much data to cache in some vertex. Vertex `a_i` would store `shdiff(reach(a_i), ind(a_(i - floor(sqrt(i)))))`, the query algorithm needs to be updated accordingly.\n\n### The `sqrt-2` Indexing Scheme\n\nNow we will introduce another concept for significantly reducing index size, while keeping roughly the same average-case query time at the cost of worse worst-case query time. The core idea is that not every vertex needs to store index information, instead it suffices if only some deliberately placed \"cache vertices\" store indices.\n\nThe \"sqrt-1\" scheme is modified to only store data in every `sqrt(a_len)`-th vertex. Intuitively, to answer a query, you first traverse the feed until you hit a cache vertex, and then you traverse the cache vertices. Finding the first cache vertex only takes `sqrt(a_len)` iterations in the worst case, so the overall time complexity stays the same. The total index size however is divided by `sqrt(a_len)`, which makes an actual difference (`O(a_len)` turns into `O(a_len / sqrt(a_len)) = O(sqrt(a_len))`).\n\nThe previous paragraph omits an important fact that worsens the query time: In addition to finding the first cache vertex, we also need to consider everything reachable from the starting vertex up until the first cache vertex. This can include outgoing edges to vertices on other feeds, which might not be cache vertices either. To answer a query, you need to recursively compute temporary index sets, i.e. shadow sets of the union of all out-neighbors's index sets (which may again get computed on the fly). In the worst case, this can cascade across many feeds and messages. It is even possible that reachability information for multiple vertices from the same feed needs to be computed.\n\nThis scheme of scattering cache vertices is thus only reasonable if we can assume that message graphs which result computationally expensive queries are unlikely. Which they are, they only happen if a large swath of new messages from different feeds reference each other, and the new messages also have to happen to not include any cache vertices. So high query times are unlikely to happen by accident, and they would require a high number of malicious feeds to use them for denial of service attacks, which could be mitigated by simple blocking.\n\nThere are also a variety of mechanisms to improve these queries: When choosing between different out-neighbors of a vertex, implementations should prefer vertices with a low distance to the next cache-vertice, to increase the probability that the query can be directly answered from that cache (and its preceeding caches). Additionally, implementations can explore the graph in a breadth-first search (rather than the depth-first search you'd get by the obvious recursive implementation) to minimize the probability that the same feed needs to be visited multiple times. To protect against malicious input, it might make sense to include some randomization. And finally, if answering a query has required traversing many nodes, the implementation can simply add the newly computed shadow sets to appropriate vertices, speeding up any subsequent queries in the same area of the graph. This last point increases the complexity, but also makes the whole approach much more viable.\n\nDue to these considerations, any indexing scheme presented in this document can be modified to only store indices every so often. Since this is an engineering concern rather than a real design question, we will ignore it from now on.\n\n*continued in next post...*",
    "mentions": []
  },
  "signature": "1C5q9z8/1n9kxoBfgiYGk0+L/yZfUH2sIct6MycOOhsgRsKqAJkVu3Hdy2RYrd/j5gc//aAQNznNc2pzzUhGCQ==.sig.ed25519"
}

{
  "previous": "%2g/bxlJjCjnehn+K9b9cLH4Z9iay6iPm8S0owMgo4YE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1103,
  "timestamp": 1537707341092,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%2g/bxlJjCjnehn+K9b9cLH4Z9iay6iPm8S0owMgo4YE=.sha256",
    "reply": {
      "%2g/bxlJjCjnehn+K9b9cLH4Z9iay6iPm8S0owMgo4YE=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "*...continuation of previous post*\n\n## `O(log(len_a))` Indexing Schemes\n\nThe previous schemes saved a lot of index space, but the query time complexity dropped to worse than logarithmic. In this section, we'll propose two indexing schemes that can answer queries in logarithmic time, while still taking up much less space than storing the \"full\" indexing scheme.\n\n\"sqrt-2\" worked by storing shadow differences to previous vertices in regular distances. Choosing any distance other than `sqrt(len_a)` gives worse results: For smaller distances, more iterations are needed to hop between cache vertices, for larger distances, it takes more iterations to find the first cache vertex. Even for \"sqrt-1\", larger distances are a problem, they incur larger cache sizes. Intuitively speaking, there's redundancy among the caches of successive vertices, and the distance hops serve as barriers against that redundancy. Increase the distances, and much more redundant data is stored.\n\nTo design a scheme with logarithmic lookup time, it is thus not sufficient to simply store shadow differences to `a_(i / 2)`, as that would bloat indices. But still, logarithmic lookup time requires skipping over many vertices during the query. To solve this, we choose a scheme where only a few verties allow jumping far back during queries, and all other vertices jump towards those. It can be thought of as the traversal of a binary tree from an arbitrary node towards its smallest leaf, which has a worst case time of twice the height of the tree.\n\n### The `log` Indexing Schemes\n\n\"log-1\": Each vertex `a_i` stores `shdiff(reach(a_i), ind(a_(traverse(i))))`, where `traverse(i)` is defined as follows:\n\n- if `i` is a power of two, `traverse(i) = i / 2` (i.e. a bitshift to the right)\n- else, `traverse(i)` is a bitshift to the left: Shift the binary representation of `i` one bit to the left (inserting a `0` as the new least significant bit), dropping the most signifiant bit.\n\nIndex creation and queries proceed analogously to \"sqrt-1\". Unlike \"sqrt-1\", the \"log-1\" scheme does not require any reindexing when appending a vertex to the feed. Analgously to how \"sqrt-2\" is derived from \"sqrt-1\", you can derive \"log-2\" from \"log-1\" by using every `log_2(len_a)`-th vertex as a cache vertex.\n\nThere's really not a lot to say about this scheme that hasn't been said about the \"sqrt\" schemes, except that it is surprisingly elegant and powerful.\n\n## Reality Checks\n\nEverything written so far assumes a very simple model: Append-only dags where new edges are only introduced as outgoing edges of a new vertex, and no queries other than binary reachability queries. The real setting of an ssb database is more complicated.\n\n### Blocking and Selective Deletion\n\nBlocking a feed means removing all the feed's messages from the message graph. Selective message deletion (enabled by #offchain-content) allows removing arbitrary messages from the message graph. Both of these affect indices. It is simple to remove edges from the graph, but the problem is that their reachability information stays cached in other vertices indices. When querying infomation about new vertices, they will iteratively ask those same caches, so the information would linger in the system forever.\n\nThere are two trivial solutions two this: First, you can simply ignore the problem. As long as those indices are only used for causal ordering, the additional edges don't hurt - they only tighten the partial order. The other trivial approach is to rebuild all indices in the background, whenever a vertex/feed is deleted. This approach is expensive however, making vertex deletion at least `O(n)`.\n\nA smarter solution would start by deleting the vertex and its edges, and then checking locally which caches are affected by this, updating them as needed. The computationally expensive aspect of this is finding out whether removing an edge really removes a vertex from a cache, or whether it can still be reached along different paths. Also, there can be many caches affected by a single vertex deletion.\n\nIf blocks/deletions are expected to be rare events and to primarily happen on messages with relatively few outgoing links (such as human-readable texts), it might be ok to keep the indices simple and have deletion be somewhat expensive (especially since it can happen in a background-thread). Otherwise, it can make sense to increase the space usage of caches by storing information about how many paths there are that allowed reaching any particular message. Or you could use bloom filters to store the set of messages that refer to each message. There are probably more sophisticated approaches for leveaging ssb's properties for simpler vertex deletion, but this document is already getting long enough.\n\n### Out Of Order Messages\n\nOut of order messages are messages for which the full feed is not known. These would need to be handled differently than normal feeds.\n\n### Dangling Cypherlinks\n\nMessages can contain cypherlinks to other messages that the local database may not know about. Once such a message becomes known, it may provide more reachability information, complicating incremental index maintainance.\n\n### Topological Sorting\n\nThe database should be able to efficiently output a topological sorting of the vertices based on causal order, which the proposed indices do not support out of the box. Additional considerations are around storing backlinks, which may make it easier to efficiently compute topological sortings on the fly or reverse topological order. Incidentally, this sort of additional information would also speed up vertex deletion.\n\n### Custom Indices\n\nIn addition to reachability data, these indexing schemes could be used to store custom indices, such as reachability via only certain message types, or only via certain entries of a message. If the database exposes the ability to create such custom indices, it becomes more important to correctly and efficiently handle vertex deletion.\n\nAnother possibility for such custom indices is k-reachability (reachability where the shortest path connecting two vertices may have length at most `k`).\n\n## Conclusion\n\nAs the previous subsections show, the indexing schemes presented here are not sophisticated enough for a real-world ssb implementation. But they demonstrate how feed structure can be leveraged for efficient indexing schemes, and can serve as the basis for more complex ones.",
    "mentions": [
      {
        "link": "#offchain-content"
      }
    ]
  },
  "signature": "0tSfBdyVI3Y3oR8u7WT/iPsDSa0m2qMwtEVXEmWJmm6f/A+5KW8HtCYWb8MQP3IM9M+uVkborHo9wgXXxyALBg==.sig.ed25519"
}

{
  "previous": "%WpD965FnDSGXxBoWous/kepl1JcG9VqhlKnpINmUydk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1104,
  "timestamp": 1537734722935,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%K2Tt1mww4VVi0eGUYiQOa0VaEm8k7iycK0+UubblqPU=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%K2Tt1mww4VVi0eGUYiQOa0VaEm8k7iycK0+UubblqPU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "More vague addendums:\n\n- If the server is to mediate direct connections between plugins, it needs to know what kind of direct connection a plugin supports. Since a plugin might live on another machine, the server needs to know, whether that server has e.g. a public ip address, or whether hole punching is necessary. This can be solved in a very simple fashion: Wen a plugin registers at the server, it specifies a set of multiserver addresses that can be used for setting up direct connections. This way, it would even be possible in a setting where two plugins share a machine but the server lives on a different machine for the server to mediate a unix domain socket connection between the two plugins.\n- When two servers connect, they'd then query for each other's plugins, and then establishing connections between those plugins based on the result of the query. As an optimization, it should be possible to send messages saying \"If you have the foo-plugin, please use one of the following multiserver addresses to establish a connection to my bar-plugin.\". That saves a roundtrip before the plugins can talk to each other.\n- Just as a clarification: In a setting like that described above, if plugins live on the same machine as their server, instead of setting up a new physical connection, the connection between remote plugins would be multiplexed via bpmux over the original connection between the servers.\n- With this plugin architecture, pretty much all functionality of an ssb server except for plugin setup itself could be provided by plugins. This would reduce the pressure on us to figure out a set of \"core rpcs\" everyone has to support, instead there'd be a few orthogonal core plugins. Since servers exchange information about which plugins are present, this would serve as a kind of feature announcement. This avoids roundtrips just for finding out that the other endpoint does not support ebt, because you'd only be able to send rpcs to the ebt plugin if it was available. If a server finds that the peer does not support any plugins for them to replicate with each other, they can simply drop the connection. As a consequence of this, we would not need to specify mandatory core plugins, this could instead evolve dynamically.",
    "mentions": []
  },
  "signature": "btKlmUEiKnV8db+l7Gtf7/95FGoGQe8hwRiYvWbuQSYP2fV85okkOelNxn+Ug36kX7uFq3T+N8nD34M8ijufCw==.sig.ed25519"
}

{
  "previous": "%nEaa8t8kg2oXKLgii8yJagYwWbnIEm/JfFmsye97VDo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1105,
  "timestamp": 1537737687437,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%nEaa8t8kg2oXKLgii8yJagYwWbnIEm/JfFmsye97VDo=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%nEaa8t8kg2oXKLgii8yJagYwWbnIEm/JfFmsye97VDo=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "- Versioned plugins: Instead of just exchanging plugin names, exchange plugin names plus a version varint. All new versions must be backwards compatible, so if a plugin wants to talk to to `(\"foo\", 4)` a connection to `(\"foo\", 7)` is ok, but `(\"foo\", 3)` is insufficient. For breaking changes, use a new plugin name.\n- This whole plugin architecture (bpmux + multiserver + plugin management rpcs) is completely independent from ssb. Ssb would just be a loose collection of plugins that utilize the plugin architecture to exchange hsdt messages.\n- A consequence of this: Plugins can be application agnostic. You could write e.g. a gossiping plugin for creating overlay networks that could be used by ssb, but also by any other sort of application built upon the plugin platform.\n",
    "mentions": []
  },
  "signature": "Pe8a0IVdmCqx4KeqQFonD8c17j/AtpNcSpQewwiKRJIW/+RZXYytT2we/r7QP0CCaUxR0FUFwmalKmM3Ab98Dw==.sig.ed25519"
}

{
  "previous": "%AHqw230+Hlh/pg70nGrU+2SBPcDnOW97wVA8r4gwmZU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1106,
  "timestamp": 1537777068398,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256",
    "branch": "%ysnVKaE4uIb0YaUKYwXiWx1OBnHJrfi+blOdWx6Wurs=.sha256",
    "reply": {
      "%uJX/grT0vK9opXvlmf0eQB+SCrpWirZRzkrCcCxmQU8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%ysnVKaE4uIb0YaUKYwXiWx1OBnHJrfi+blOdWx6Wurs=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@moid](@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519) One intuition I utilized to think about this is a sort of feed hopping. Within a single feed, you can quickly find all information, the hard part is finding a path to a new-ish message in another feed, which is done by traversing other feeds. Once you do this dynamically, you get pretty bad running times, so the indices cache all of that. I thought a lot about what you were suggesting, but couldn't find a good scheme. It amounts to dynamically iterating across feeds, rather than caching everything that crosses feed boundaries. But since a single message can have many outneighbors among many feeds, you don't really get a useful upper bound on running time. And it is trickier to place sparsely place caches.\n\nThe best I could come up with were randomized schemes where there is a certain probability (dynamially adjusted depending on factors like total vertex number, feed number, average feed length) that instead of adding information from a cross-feed link to the cache, you'd instead have to follow that link.\n\nThere's a lot of room for engineering/optimizing here, but it didn't make it into the introductionary post.\n\nQuick aside: Instead of the follow graph (which is not really a core feature of ssb), you can simply impose an arbitrary order on cypherlinks, e.g. lexicographic order.\n\n---\n\nBy the way, I think the conclusion that these were not suitable for real-world settings was overly pessimistic. Handling dangling cypherlinks is somewhat tricky but fine complexity-wise (time and space), for topological sorting you only need to store the set of messages without incoming cypherlinks (bounded by the number of feeds), for reverse topological sorting you'd need to store backlinks and the set of messages without outgoing links (again bounded by the number of feeds). While the reachability indices can ignore redundant cypherlinks, it can still make sense to store them in the same data structure, to allow the usual queries like \"Give me all messages linked to by message foo\", they just wouldn't be cached. And as for deletions, when only using this for order queries and topological sorting, ignoring those (except for some obvious optimizations) really is a viable option.",
    "mentions": [
      {
        "link": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
        "name": "moid"
      }
    ]
  },
  "signature": "TSWMVuwT7sCoQ8W2+cWcj37lB3cgUzMireMo7ZO3/ymWnbYuHYzRAWI9XWcEgJ9rbdtxnq4ISGXOCdft6WT7AA==.sig.ed25519"
}

{
  "previous": "%nV/58IwSCEniUelpp0I7nUzjF/IgM4FepQhgxJennXI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1107,
  "timestamp": 1537801572975,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "yamf",
    "text": "# YAMF-Pubkey\n\n**Y**et **A**nother **M**ulti **F**ormat - Public Key Edition\n\nA future-proof binary encoding for public keys, for use in non-schemaless (schemafull?) data. Expected initial uses are in:\n\n- [message metadata](%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256)\n- [plugin protocol](%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256)\n- gossip\n\nThis is fairly unexciting, but it needs to specced out somewhere. Note that it is conceptionally distinct from encoding feed ids, as those may carry [more information than just a public key](%GDNTWCfnsT8pu2rfVU/CpRwidu4NJIwUopeIB8QfPqw=.sha256).\n\nRelated work:\n\n- [the conceptually similar ipfs multihashes](https://multiformats.io/multihash/#the-multihash-format)\n- [ipfs tackling a broader scope](https://github.com/ipfs/specs/issues/58)\n- [some considerations on url encodings](https://tools.ietf.org/html/draft-farrell-ni-00)\n\n## Requirements\n\n- Support different cryptographic primitives\n  - which may only become known in the future\n  - of arbitrary key length\n- Be efficient for machines do deal with\n- Admit a human-readable representation\n- Allow infering data length even if the cryptographic primitive is unknown to the implementation\n- Admit a bijection between logical values (`(key_type, data)`) and valid encodings\n\nNon-goals:\n\n- Encode what the public key is used for\n- Encode whether the crypto scheme is symmetric or asymetric\n- Any of the other stuff that kept the ipfs people [busy](https://github.com/ipfs/specs/issues/58) for nearly three years without settling on a format\n  - type, length, value is all we need\n\n## Binary Encoding\n\nReuse [the multihash format](https://multiformats.io/multihash/#the-multihash-format). Done. I told you this would be unexciting.\n\nOk, maybe there is a bit more.\n\nTo keep things unique, varints must use the shortest possible encoding (yeah, the ipfs varints are ambiguous...).\n\nAs an optimization, we can omit the length for well-known primitives. E.g. the type tag that identifies ed25519 keys does not need to give a length, as all ed25519 public keys have a length of 32 bytes. We can also omit lengths for future primitives by preassigning lengths to certain type tags. I propose the following scheme:\n\n- if `tag >= 128`, the bytes following the tag are a varint encoding of the length of the key\n- else, the length is `2 ^ (5 + (tag >> 3))` and the tag byte is followed by that many bytes of key data\n\nThis way, the 1-byte tags are split up to represent keys whose lengths are powers of two from `2 ^ 5` (32 bit, what ed25119 needs) to `2 ^ 20` (enough for large [post-quantum keys](https://en.wikipedia.org/wiki/Post-quantum_cryptography#Comparison)), with 8 different primitives per power of two.\n\nThe only currently assigned tag is `0` for [ed25519](https://ed25519.cr.yp.to/) keys.\n\nSo the overall format is `<canonical_varint_tag><varint_length_if_tag_smaller_128><raw_public_key>`.\n\n## Human-Readable Encoding\n\nEach well-known primitive is assigned a short, descriptive `name` string consisting of alphanumeric characters. For ed25519, this string is `\"ed25519\"` (surprise!).\n\nThe human-readable encoding is `<type>.<data>`, where `<data>` is the [rfc4648 Base 64 Encoding with URL and Filename Safe Alphabet](https://tools.ietf.org/html/rfc4648#section-5) encoding of the key *without padding `=`s*, and `<type>` is obtained as follows:\n\n- if the primitive is well-known, use its `name`\n- else, use the decimal representation of the tag, followed by `\"~\"`, followed by the decimal representation of the length (even for tags below 128 - the human-readable format strives for simplicity rather than optimizing space usage)\n\nThis choice of encoding is fairly arbitrary, but it is ASCII, url safe, mostly filename save (some legacy file systems might complain about the dot or the tilde), and covers all cases.\n\nNote that this encoding is not future-proof, since a decoder of this format might not know about a `name` string. Hence the next section.\n\n## Canonic Human-Readable Encoding\n\nSame as the default human-readable encoding, but always stores tag + length rather than using names. This is actually more of a machine-readable format rather than a human-readable one, for use in URLs, URIs, file names, and other settings that disallow binary encoding, where it is important that the same key is always encoded the same way and that future-proof encoding/decoding works.\n",
    "mentions": [
      {
        "link": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
        "name": "message metadata"
      },
      {
        "link": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
        "name": "plugin protocol"
      },
      {
        "link": "%GDNTWCfnsT8pu2rfVU/CpRwidu4NJIwUopeIB8QfPqw=.sha256",
        "name": "more information than just a public key"
      }
    ]
  },
  "signature": "MkBGDFVDJNGYTL8AAZbNvbNWHKmOZ9QnrjxyrRDQ+SRvLe9/L3tF/TYvsjZ6p7WAPaCAouVcnLnIfc5A0q+8Dg==.sig.ed25519"
}

{
  "previous": "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1108,
  "timestamp": 1537865675337,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%tr82vmrplCxXQNxQsl3vbIzg+EjT0ZtT0jZMF5ZiHqM=.sha256",
    "branch": "%JN+e6v313aKZS/eHCc33rxTwHsspU3sSn5hS6F0FaqA=.sha256",
    "reply": {
      "%tr82vmrplCxXQNxQsl3vbIzg+EjT0ZtT0jZMF5ZiHqM=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%JN+e6v313aKZS/eHCc33rxTwHsspU3sSn5hS6F0FaqA=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Taking a highler-level view than just the current, stringly typed encoding:\n\nAdding new signing keys is easy (or at least it should be), that's why there's a key suffix after all. As far as I understand it, the current js code assumes that only this one suffix exists though, which is annoying. But well, at least the rust implementation never made that assumption =P\n\nThe relevant binary encodings ([here](%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256) and [here](%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256)) only need to assign new ids for these key types, and that's it, so now trouble on that side of things.\n\nThe remaining question though: **Is it worth the complexity?** Introducing new crypto primitives means relying on more security critical code from outside parties. It might be easy to pull in a dependency, but that does not change the fact that the overall complexity of ssb inceases significantly. So I'd personally want to see a much stronger argument for secp256k1 than just \"a marketing bullet point\". I'd appreciate if [@dan hassan](@NeB4q4Hy9IiMxs5L08oevEhivxW+/aDu/s/0SkNayi0=.ed25519), [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), [@noffle](@C3iYh/12sO1uvKq1KcZXLFxSySzxOkHxXN8rtNB5MGA=.ed25519), or anyone else who has an interest in this could elaborate on why ssb needs this. As for bls, I'd prefer to wait until it is absolutely certain that its properties will be needed.\n\n> There are lots of modules that use ssb-ref to check whether some string is a ssb type (message, feed, blob). We could change all of those modules to call something on sbot... or we could just add a function to ssb-ref to accept additional extentions, something like ref.allowFeedExtention('secp256k1') and then @blah...blah.secp256k1 is now a valid feed id.\n\nWhy not simply a minor version bump of ssb-ref which then accepts the new key type(s)?\n\n> ssb-validate would need to be refactored out a bit so that you can have custom validation for different key types... or is it just the signature that needs to change?\n\nWouldn't each new feed key type get a corresponding signature type? Such as `blablabla.sig.secp256k1`, analogously to `blablabla.sig.ed25519`? Btw, why does it even have to say \".sig\" in there, isn't that redundant?\n\n---\n\nRegarding the 'utf8' suffix: Again, this will be something all future implementations have to support. They'll need to deal with the legacy quirk anyways, so this will only increase overall complexity. The json signing format is messy, whether there's utf8 hashing or not. I'd argue to accept its messiness and fix things with hsdt, but not include a number of partial fixes that just bloat the ssb spec overall without really changing anything. This is a more fundamental decision than just quickly patching up a format, so if we disagree on this, we should discuss this in its entirety, not only over this tiny symptom.\n\nIf you do insist on this, I'd prefer a more structured approach where a multihash of a message has three parts: The data, the hash function indicator, and an encoding indicator, as suggested [here](%kFNhfPsphpeqoChT7BIuUFURbOzIRuJmcYzuOWpubGo=.sha256). The encoding would handle both format changes like json to hsdt, but can also distinguish between latin json and utf8 json. In the stringly typed encoding, absence of an encoding indicator would default to latin json.\n\nThis amounts to exactly what you suggested, but it should be documented as a meaningful pattern and separation of concerns, for future changes to follow.\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)",
    "mentions": [
      {
        "link": "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256",
        "name": "here"
      },
      {
        "link": "%a5c/BWCeraIb6ET40XQtPWnmObOmhX3wVLwr8ZgixSc=.sha256",
        "name": "here"
      },
      {
        "link": "@NeB4q4Hy9IiMxs5L08oevEhivxW+/aDu/s/0SkNayi0=.ed25519",
        "name": "dan hassan"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@C3iYh/12sO1uvKq1KcZXLFxSySzxOkHxXN8rtNB5MGA=.ed25519",
        "name": "noffle"
      },
      {
        "link": "%kFNhfPsphpeqoChT7BIuUFURbOzIRuJmcYzuOWpubGo=.sha256",
        "name": "here"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "J+YDPVsGg7HfiqmUMY2I996wt+bwSaennb3qXo0zPnWZaY8+jx7r01rhkZnvgN7xKWCj/Grqg5aSlqtrY8+yDA==.sig.ed25519"
}

{
  "previous": "%6xDjaCQ1DIDvhIxqulZ6JsvxDp2LkYX/tvGWv1HL68g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1109,
  "timestamp": 1537872318082,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%AHqw230+Hlh/pg70nGrU+2SBPcDnOW97wVA8r4gwmZU=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%AHqw230+Hlh/pg70nGrU+2SBPcDnOW97wVA8r4gwmZU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I've been mulling this over a lot, and I feel like my thoughts are slowly converging on a coherent proposal, but that'll take some more time to write up. For now, just more notes to self.\n\nIt's hard to limit the scope of this plugin platform, there's the temptation to stay completely unopinionated yet provide all the useful features. [Libp2p](https://libp2p.io/) is a cautionary example in that regard. Reading the website, it looks like the silver bullet that solves all problems. Until you dive into the spec and see all the open problems, partially or underspecified aspects, the bloat (why is there a pubsub service on this protocol layer, isn't this the protocol that pubsub should be built upon?), things marked as TODO, etc.\n\nA realistic, actionable proposal will need to make a few opinionated choices about which use-cases are out of scope, to keep things manageable. I think direct connections between plugins won't actually make it, as these come with *a lot* of baggage. Different pubkeys per plugin might be ok, I think, but I'm not sure yet (the more restrictive approach would be that each plugin must have the same pubkey as its corresponding server).\n\nAnd finally there's the question of how much the plugin-server should be aware of connecting to other plugin-servers. There's a few approaches here:\n\n- Don't specify this at all, resulting in a plugin architecture not tied to p2p systems in any way - p2p functionality would be given by plugins.\n- Transparently handle p2p connections, maybe giving plugins the ability to adjust parameters. This is the easiest one for plugins, but the most restrictive/opinionated way to go.\n- Give an opaque set of primitives for connection establishment and address sharing to plugins, but leave it to them how they use those\n\nI'm currently leaning towards the first or third option, but haven't made up my mind. Either of those three would be suitable for ssb, it's just a question of where to place the inherent complexity, and how much complexity to shave off by reducing flexibility.",
    "mentions": []
  },
  "signature": "TPuLa5ewK+lSwtx4iaT9Jqy3u3bj2OUKTMJGdSd+8IeOfSWNCYVG79DUbqdef+esk8nLWthTxs9tFBGVI/C5Aw==.sig.ed25519"
}

{
  "previous": "%IvITUUle7mAZyTybO1FFe1Z5j3+Uxpy5XnHmcJSkrc0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1110,
  "timestamp": 1537908985957,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "%m7ysFxWOZ5m4RhltZI3WviZ6LU3pROhcMXw3dUtr1OM=.sha256",
    "attendee": {
      "link": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    }
  },
  "signature": "44rKJpx3VIKqAIGH+xAWSal+gXAQf/EV+oQ51yi3TidIKGrs0BO8jMu6EUdl3daJUsRKFAvfhyC7qjugYJ16Ag==.sig.ed25519"
}

{
  "previous": "%Q8JWCB+ERMJ8e0WY/ncccKErccI6ixcaO9mSJUlltW8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1111,
  "timestamp": 1537975596867,
  "hash": "sha256",
  "content": "vLpHGsIdmBYZlaPd0lnpxlaGiEVcGZ+H0qNM0wTWcYV9o9IS+6YKlH09dptaVxYkOk+vd8n7YzwcCqd2qaz9SGLLp3R/+DLXJSsZHdzmE0AX5GPn+OqfOe/IQriSLDCKLfzG6I7PQGCepFP9+4ziCHlaA0VAb/Ic6QjAbJNLpLe+q28K3hO9kpYGwnxjB1l7fYVrK/K7AF+9vXQUpekp8fwJ4ozn2tUllOa8F62k2NNutNn5fr6JB6PepeZ6n7WrtwfjZtMoKeIc8Wb9ZXOwfCL1aTrNexszxxKBYG8HDbE8eSRUNRplmNYaglYGcNJhSnrtJqlVW7mQpsK5yzHF082PmAHS8wbX4eengWvVxmZdnZIkF7RC9sWvCH+aEUL9egAiuJW6+M/I9oPNqOpCEFKhTyfNqGeeibwgvwGUGzQd4HsBcKVlskY6Ns/0xsw/m4rewirJSL/R+jM2ySB7rhdcqZbr4zDhoDSRW1pAW1FUGNumx+d+9KNSa0Agcm6/z4kFy7+C7L6xFOeTVYWT4AfwELH7cD+XAeIAJq5C/U0aoSzrIKF0yQ4YDUwduxiSMaFvv12HW/3dLsKCaBz7hD327Rw0+NfMAgCfqCJ4R+7PEVXslervLdSRG2zWD2KPp3USYHRI0zNpHRKtLAOPs1u69O9m++N+9g+rz29Gta81WQoWsuiWB5op5h3tGKzpgxacLxKX2hhMbyiICWWJ4+mh73w6JRODa/7DbX5GaO9GuZ7F368rzjTxbaeYeENRY7rU/GiND0APlyaXpEThfbTF0BkQEKzr5IX8v1w6R95DsmMmGLbhKooi+YwQT+LVzxLuuZek2bPkQxlAW91vzyv3MOytDYUlzmR92U44fo+9wZUTmJ4OZABrBdZq+DHanAuTRKvPzDZ9UdirE8PFNmsBSqsMFtm4B1QnCfYU6ZfiuRn9U2gYdNog7+k+0ncRn8ecKEnCrXJkaMbbGv/REFmhz1eu7UDhEQmJJ3qo4Ppm8lM0s+siLnLrXSql8/OezGwWaCvUwvWSCDEZKNSqK0L8bNz3pTItXJU+eM9SzXEcKHSHoWQu8Bfv1oCGyH7kwDBbMmlBbU6n7gw8TE5L7DTOADZnFFYfbiEXamywkLH0x2xYQpNH5Qh8Yjy3YtWvqfEUefiw15gPSL79/SOV7WvbpdEq8sliSgNvEmRC/VlVl1Mv5kjvvY/BpyXBpIOJUaoCwDdEiRminzO2tVYZ41pRoyvMikooUsDdtLKTpSTc/V//6WBBHl/3xTkhYLzYuA+qlgVSbwxboeap4gFikaqLPB0Vu0vNVuAey5qEd1yTS1J39tMIs3O6f0aOVs6T8xfxYIZN7kBS9ukgB2s9+/cThacN2PpE6ls5nAHfdgRh2YkY5prr9fJgsThJpzeRP9B0RgUw2/k+H7OGwYbW6LHJ8RxrhDo+monNGXoBwKRYRqLEHaHNBvmvUHTJfgmbBu/j581UXUi5C2HRetM0nM4rYzNgcFWpC8EUI9EHW10YHBQp03ZU0uZODMY6KNZRm3CFuOcleZM01OEoEZoLktGCTf/5LxxN4QTHLTxEJig7wA==.box",
  "signature": "2bqt/er4oD4Vy9uYWVemuwMo88lK7hhOCImtfZtou2FOXpBvAD8UmeWoZ6FdlGxVz+upCVWuHa/kULhediKZBA==.sig.ed25519"
}

{
  "previous": "%e0PjSef5xzk2TJUbQZWSsLLeuMxYYKXcZbCZZ2vTeCk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1112,
  "timestamp": 1537996506135,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%IvITUUle7mAZyTybO1FFe1Z5j3+Uxpy5XnHmcJSkrc0=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%IvITUUle7mAZyTybO1FFe1Z5j3+Uxpy5XnHmcJSkrc0=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "**This is not a proposal for ssb.** This is just me synthesizing a few thoughts on plugin-based architectures in general, while completely avoiding the open questions, namely the notion of (un)trusted identities, and handling p2p connections.\n\nChanges to this spec are published on [github](https://github.com/AljoschaMeyer/min-bus).\n\n# Min-Bus\n\nA somewhat minimal system for coordinating inter-process communication.\n\n## Abstractions\n\nMin-Bus is a system that allows different processes - called *plugins* - to discover and talk to each other. To do so, it provides a *server*, where plugins can connect to. When connecting to the server, a plugin must specify a *name* (arbitrary byte string not longer than 255 bytes), and a *version* (unsigned 16 bit integer). Connecting succeeds if no other plugin with the same name is currently connected. Versions signify non-breaking changes to the API exposed by a plugin. If a plugin performs breaking changes to its API, it needs to change its name.\n\nOnce the connection is established, the plugin can perform the following actions:\n\n- query the currently connected plugins (name + version)\n  - this opens a stream where the server first sends the list of currently connected plugins, and then sends a notification whenever a plugin connects or disconnects\n  - the plugin can cancel the stream at any time\n- be notified of other plugins that what to connect to it. It can either reject the connection, or allow it.\n- ask to be connected to another plugin (by name). If the other plugin accepts, both of them are given\n  - a bidirectional, byte-oriented communication channel to the other plugin\n    - with an explicit, credit-based backpressure mechanism\n    - with heartbeats\n    - either plugin is allowed to close/cancel it\n    - plugins can use any protocol they like to communicate\n- disconnect\n\n## Implementation\n\nA server implementation is free to choose any mechanism for plugins to connect to, as long as there is a [bpmux](https://github.com/AljoschaMeyer/bpmux) implementation that runs over that mechanism. For example, the server could listen for tcp connections on a specific port, or it could use unix domain sockets. A server is allowed to expose any number of such mechanisms (e.g. both a local unix domain socket and a tcp socket with a public address), all plugins can talk to each other regardless of how they connected to the server. For public-facing ports, it is recommended to enforce authentication and to encrypt all data.\n\nAfter connection establishment, all communication happens via bpmux. The server should should always supply the plugin with enough credit so that it can perform queries. The server should also respond to any heartbeat pings. The server may send heartbeat pings to a plugin and disconnect it if it does not react after a well-documented, implementation specific time.\n\n### Registration Message\n\nInitially, the server does nothing but wait for the plugin to send its registration message. This is a message that consists of an unsigned 8 bit integer, followed by that many bytes as the name of the plugin, followed by a uint16 version of the plugin. If there is already a plugin of that name, the server simply terminates the connection. Else it notifies all subscribed plugins that the new plugin has been registered and goes into the *connected state*.\n\nAfter sending the registration message, a plugin can send any of the following to the server:\n\n### Disconnection Message\n\nThe plugin sends a message with a zero-length payload. This is not strictly necessary, the plugin can instead directly terminate the underlying connection. But in case of connection types where this can not be directly detected by the server, it is polite to send this message prior to disconnecting.\n\nUpon receiving this message, the server does all the cleanup necessary for disconnected plugins (see section \"Server Behavior Upon Plugin Disconnection\")\n\n### Connection Query\n\nThe plugin sends a request with a zero-length payload. The server sends a response containing the repeated `<length_uint8><name><version_uint16>` tuples of all currently connected plugins, except for the requesting plugin itself.\n\n### Connection Stream\n\nThe plugin opens a stream with a zero-length payload. The server immediately sends the set of currently connected plugins (except for the plugin itself) as a single message to the stream, containing repeated `<length_uint8><name><version_uint16>` tuples. Afterwards, whenever a plugin connects, the server sends a message containing the byte `0000_0000` followed by the `<length_uint8><name><version_uint16>` of the plugin to the stream. Whenever a plugin disconnects, the server sends a message containing the byte `0000_0001` followed by the `<length_uint8><name><version_uint16>` of the plugin to the stream,.\nIf a plugin opens a `connection stream` while it still has another one open, the server must immediately cancel the new one (with a zero-length payload).\n\n*continued in next post...*",
    "mentions": []
  },
  "signature": "IV9cLHiOkwE1jERJmQL3sYsxqxSRrbtlnxUk7mcWVY7186KSJZoFfLHzCtkPChhy/6U2k2XdevXfUMEGySBADg==.sig.ed25519"
}

{
  "previous": "%WGtKxqEDLTxnpnyeS+DnGFOeMfN1PGMsMaCbTtGExYQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1113,
  "timestamp": 1537996535421,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%WGtKxqEDLTxnpnyeS+DnGFOeMfN1PGMsMaCbTtGExYQ=.sha256",
    "reply": {
      "%WGtKxqEDLTxnpnyeS+DnGFOeMfN1PGMsMaCbTtGExYQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "*...continuation from previous post*\n\n### Connect to Plugin\n\nFor plugin `a` to establish a connection to plugin `b`, plugin `a` opens a duplex with a payload consisting of the byte `0000_0000` followed by `<length_uint8><name>` of plugin `b`. If `a` has already established a connection to `b` that hasn't been closed/canceled in both direction, the server must directly cancel and close the duplex with a zero-length payload. Else, the server must allocate enough memory for two 64 bit integers and two buffers of bytes for caching data, each of size at least one byte. If it fails to do so, it must both close and cancel the duplex with the byte `0000_0000` as the payload. If memory allocation succeeded, the server then opens a duplex to plugin `b`, with a payload consisting of the byte `0000_0000` followed by the `<length_uint8><name><version_uint16>` of plugin `a`.\n\nAll pings sent by `a` get relayed along that channel. All credit given by `a` is buffered into one of the 64 bit integer the server allocated. Likewise, pings by `b` are forwarded and credit given by `b` is buffered as well.\n\nPlugin `b` can deny the connection by closing and cancelling the duplex with a zero-length payload. In that case, the server must close and cancel the duplex with `a` with the byte `0000_0001` as the payload. Plugin `b` can accept the connection by sending a zero-length message down the duplex. In that case, the server must send a zero-length message down the duplex it shared with `a`. It then sends all buffered credit to `a` and `b` respectively. The logical connection between `a` and `b` is now established, consisting of the two duplexes.\n\nAfter the connection has been established, the server forwards all messages, heartbeat pings, heartbeat pongs, and credit along the duplexes. To the plugins, this looks like a direct connection between them. There is a situation however where the server may choose to not directly relay all credit. Imagine a setting where there is a very fast connection between `a` and the server, but a very slow connection between the server and `b`. Furthermore assume that `b` gives a lot of credit to `a`. `a` sends a lot of data, but the server can not relay it fast enough to `b`, so it has to buffer data. In this setting, `b` would effectively determine how much data the server has to buffer. To prevent this, the server can simply put an upper limit to the credit it hands to `a`, and store any excess credit given by `b` in one of the 64 bit integers. When more data could be sent from the server to `b`, it can then send more credit to `a`, removing it from the 64 bit integer. The server should use a scheme that is more efficient than sending credit whenever data could be sent, as that might result in a lot of credit data being transmitted.\n\nIf one of the plugins cancels/closes parts of the connection, the server prepends a byte `0000_0000` to the payload before relaying it.\n\n### Server Behavior Upon Plugin Disconnection\nWhen plugin `foo` sends a disconnection message, or the connection to the server is closed or errors, the server must perform the following cleanup work (only once per plugin):\n\n- notify all connection streams\n- for any connections between `foo` and other plugins, cancel and close the duplex between server and the remaining plugin, both with the byte `0000_0001` as the payload.\n\n### Handling Unexpected Messages\nIf the plugin sends any data to the server that does not fit into one of the flows described above, the server must do the following:\n\n- if it is a message, ignore it\n- if it is a request, cancel it with a zero-length payload\n- if it is a sink, cancel it with a zero-length payload\n- if it is a stream, close it with a zero-length payload\n- if it is a duplex, cancel and close it with a zero-length payload\n\nThis allows backwards-compatible protocol extensions. Clients can use these to check whether some feature that might be added to min-bus is unsupported by the server, without disrupting the connection.",
    "mentions": []
  },
  "signature": "V8vwh+2rR7SBL7PyQQO1aYoCEPJJhXWr5ZeykNGwP4JEQ5As/FXl63zWVeLsT9bDRJT6oSpG+KI5lE1OsDIvAw==.sig.ed25519"
}

{
  "previous": "%H2gIVty6N6Y/fr/vfHYsFLdlMSVht1UkRXQpmNaHa10=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1114,
  "timestamp": 1537996735122,
  "hash": "sha256",
  "content": "EBDruD9uOYlO7A5tjaTuSPB3cYrWZtq4pBCvUAWjjgz1bk/KcJ4Ozw6szmwnWI+v8qnMy+2YwVB42++ywPK56O5KWPuNVGIEqegs3QFlbPYzH/+xIqsF+wppK/D0JSDaPK5vtDiHiGfTSe1WxSyjvy4+QeHUKMgPNWHc6wp4tbtR/rDPmSubTu7WJvccNFxhAhlwIRqros/d6i2i39/xEQArWDtxM8BDmH+csPjudYRMMjfp854oOEJL4a3LkTANeNF04Fc1SuiUMzy9B9uzQU98WapJOPVvd1w5HQ4DJZElndL8eyDgRTAhApZQI++Imts+4wMmQLJ5gDbo69bZIeN29xYsyVoEiiUMAiUGGQBqFBWNirb62ueYa2LKkl0f1L/ZMRIE28SifAs0mSAkr8syNf/VjwLdOvddCRyLPgFmy354aOYI6PvGXIW9bSsUHWrNfcE/n/Kb8/dW0j3uqu6+UsTFLu791uS3biqe+lCMExNLFyc9lF0Wbj+4/lgPI+kt6RD2KmqOHhLOihyCyf43cwc/abjWgp8RYb4kdqgILsW9dV6WCcXAxutaOX37L7fSjUox3TJUvW8NRM46BtH8C+gujl9mXHQcg10lAlfPawnpCGz7nThbo2tJ6ATq4qXCi797nqUgHXHu3023XC3HD+yBs+DwgXKoyCQaQlygdWXg/v418wHfb5S8wr+ZeP1hOp16ISjIf9gQ1m0hCXqyV5jiqGD2vz0vczl51cQ9pHC3FHG/nA5TDvzEYX+Ds60bVLVOknJTeRfC4uIqA/sIbRHITABvysbiR3C3knLxlyw2Mk2X70URXHNf38vIrjUhfMEEhoMtpQ2LfmWmgx0OW5yU7sy1NMfKksouloQoNgBk6HYiPBr8HQIvw85a7mzH+HtRBIyWBIWpoaASGwNbnaM4zCtMYLt58v8OL9raV7dqNbNyrZPOQE8pqjqShRw/yLLdU/+58sNCvCOjroIZotHtpRXmdSIHOqK79JsB8hxoMcQs/li7fxhK2HG9oNhbeTp9GRVto7d3EipeM0dXew9Eou22JSMz+Ln9S7gTGwFb8auzGfvfelC8i8/jO3prpEAg75u+JNNJWHkBYBWkJWQGTksVWhUIElFS+tcvm+34pIctQpJz7BP+xTEL2zSIGNjomYOV/2/qX/C4eq9sJCocpY3wZ35huE7kaEnBOHTr8C+DQUe+BAiDTb4E4gQxLjw0QeoGH2K4uFpnW8PxLY+dDT7di3fjp59WtQTfQ/eBmjTX3Wcp0iGHUvtDwPnkwe+S7xCObDKOsUFuid+4EHqWfCIHBPmHRfQYpS14XBa5YX6Rg4NlaCA=.box",
  "signature": "/KBVu2qrGlGOMjhWmYcn1PDN6h+1VFCXK/x2Qaco+bgKvDa7ngydpvIP8AnNLDYlk80TH53tk8KQur6pL6TBDQ==.sig.ed25519"
}

{
  "previous": "%O7GffQbjkIjdZbvhq6TMFNaricp665qWyruSQE5H70c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1115,
  "timestamp": 1538033832621,
  "hash": "sha256",
  "content": "OqfwIZG8sZRg5sebobXy1ZuTWS8LOI3jR4BkAAqaPshH/HoCuI51Unjt7yOehy6helQypLE6qz9mT+0RSWhY/e03M4BXfOhu23RmN6PSlMOsG1PYyFBZKaybSjaJEQPpk2d7/Dgwc4/cnDQR50oFmb18N8YIko1q3E9T0pEv+hc0bCrBLZo3sNVNgFgdzcO6KNP9yu+bL/eHn46rQlOIgspnpkGSSHRoi+Hxmp7ngS5tvv2cO2f4BnbIXJA9ldVuQtj4cdbZitNwSBh8EyLLrItKXbk8yZg64LumO7j7vv0OrkLzn7vtcJ7crqOw7VNvgzofZYuQ0b/M4n3Vho79+nbP7JE7hQY89inQJ64/Tnq8909lLoPso+k9F6AS1Qrj/pg67x6yQT5+hPTlr4p+TbuVIFuqT2H8vBGB58qsvsj6VZprBktB2jaerwtcRg01lMJUyN0JermlVvZw2lAqrK+fjnwRfZgZr3A+0sVqJwUjEjvWbfgGVJ312XGhlbJE67v5ZgF1HiDgzt+I/bpFWDCyvglsksczNvEGy/pvqaEqlm+wk+Q+3gcUqNfDcFDV3YiOSI/5tWZwnOptXjGW3SX8hJWJGaZHrcklB/fud6wHs/l+m2xDGS0hU52DZhzthutNLqONEWiSnUNGr5GfBXMU0U3xu4QtyhmCzjaEJH6beJTFuvzD4GsCbqNAN6E7Wzc4jbuWaCCNLGdAf5DVR7PWkWyI9RUmndvBmUNtgZ/T7x+u9GV3DTd5U3xJSxOontax37bg04lDCnIX3Ig9sRcbOWD4zos+5PlfjEO+2aNzpBLv1v2xEF0yaqxJVr5TnkhR6tEVpOz+as3GsYHf/XjfOxr16kYK7uVjypjkxwfVzDTGksSwo5B0vwwy4PhtTLblwX/YqKnY8psirlwyCKoDs+NiwtwR3dWGARq0iVk1rnBZF5x0D6gTxKU/rlVTNPqfoiDKOWwOBxAo2OTe0xjg21GrjZh0AE9kmtK6cGODZrtCqhpbmw943rCHsKBg8FgrDkenGpuL91t061jCMHHbTsB8v3gkLFmMTOOdMvpYc7fMIwn2TX907n7yCw==.box",
  "signature": "U0lcv84dKU+NfCSgDfrc4+g3co6C0wUGegBDuYcBZ5uhpiyCSE7GYlqI25FauQj9HRwIUJ6O23mg6Mm/jHtDBQ==.sig.ed25519"
}

{
  "previous": "%iEL/5HjTZudRn3UJFUyLc+Tb0UEhs2l4kA786bVeAig=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1116,
  "timestamp": 1538034892827,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%p57RpBZjtCL65TDvhn4++WSdriYmtfQw1DWV2aShmkc=.sha256",
    "branch": "%2SA1og/+fACjZFgbSlfmHwBoxD0vNLsyzuAzw+6EbJs=.sha256",
    "reply": {
      "%p57RpBZjtCL65TDvhn4++WSdriYmtfQw1DWV2aShmkc=.sha256": "@pbl3z06ULvRK2lykFmtvDdb5dvquKO0wrmTHIHXlt48=.ed25519",
      "%2SA1og/+fACjZFgbSlfmHwBoxD0vNLsyzuAzw+6EbJs=.sha256": "@GqsSW1pLJq5qUbJuDAtm7MwwOhpf+Ur6BfDH0kZKCJc=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@xj9](@GqsSW1pLJq5qUbJuDAtm7MwwOhpf+Ur6BfDH0kZKCJc=.ed25519) I wrote a [dithering implementation](https://github.com/AljoschaMeyer/image-dither) in js (coffeescript actually) a few years ago. The implementation is cringe-worthy in retrospect, but it works, is sufficiently well-documented, and can do some useful stuff like changing dithering matrices, creating n*n \"pixels\", and working with arbitrary color spaces. So if anyone wants to do some js dithering, here you go. ",
    "mentions": [
      {
        "link": "@GqsSW1pLJq5qUbJuDAtm7MwwOhpf+Ur6BfDH0kZKCJc=.ed25519",
        "name": "xj9"
      }
    ]
  },
  "signature": "PFYrCCRthPzZ7w5kXUUIoyIuGvmtehfL6zOVsTatHkgqIL6NywvZRbF6iYtkaR91vprXg6n/xv3m6ZvYpZnICg==.sig.ed25519"
}

{
  "previous": "%grDLlOzoPNdC47g9iu0CPqrWB0Gxm8b3VTyyJZXpuzg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1117,
  "timestamp": 1538035103358,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%JB7GoEW9QxuP6DDNPpMKA7oX23RWZVJty9VTANlZO7Q=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "fVB2CEqoKmChBu3NBx0dXxrjEanuCcKquxnIs0uuHHTpJacOUxXdp6gpiMTlwMxie2O3K0lOUoguFZbAgirMDg==.sig.ed25519"
}

{
  "previous": "%bjW/39IusSY/wCURIDgRo7bOXCgKnzC3R5mN/DKG9q0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1118,
  "timestamp": 1538046659583,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%H2gIVty6N6Y/fr/vfHYsFLdlMSVht1UkRXQpmNaHa10=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%H2gIVty6N6Y/fr/vfHYsFLdlMSVht1UkRXQpmNaHa10=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "To get from min-bus to a plugin architecture for ssb, there's a few things to tackle. First of all, there are some engieering concerns/optimizations for reducing latencies and round-trip times. But more importantly, there's the question of how much the system should be concerned with p2p stuff.\n\nThe absolute minimal extension would be to add identites to min-bus (I guess that would yield the \"minimal identity bus\", aka *mini-bus*...). The server has a public key, each plugin connects with a key, there's a handshake to confirm them. Keys are transmitted in addition to plugin names. You could call it a day and have a plugin system that handles identities, suitable for ssb. But that's not enough, there are merits in making the whole framework more aware of the p2p/distributed nature.\n\nFundamentally, in any p2p setting, there's the notion of trusted (local) computation, and untrusted computation done by peers. Simply adding and enforcing identities to plugins does not capture that at all. Instead, the cleanest solution I could come up with, is to distinguish between two kinds of connections: plugins, and peers. Plugins are the trusted building blocks of the application, just as in min-bus. Peers are not necessarily trusted, but expose (not necessarily the full set of) their plugins to each other.\n\nTo implement this, each server has a keypair. When a process connects to the server, they perform a handshake (e.g. shs). If the process uses the same keypair as the server, it connects as a plugin, else it connects as a peer. In addition to the features of min-bus, plugins can also query and subscribe to the connection/disconnection of peers. Peer information consists of the public key of the peer and the names and versions of the plugins it exposes. Plugins can establish connection to a peer's plugins similarly to how they can connect to other plugins.\n\nThat's the high level overview of the kind of system I think would be suitable for ssb. Discovery of other peers would be done by plugins (or simply out-of-band). There's one last problem I have with this approach: Any reasonably sophisticated gossip protocol should not conflate gossiping (exchange of peer network addresses) and application-level logic (such as synchronizing feeds in the case of ssb). Usually there is a larger number of connections for gossiping purposes than for application logic. So it should be possible for two servers to connect to each other, but not yet announce their presence to all plugins, but just to a subset of them. Maybe those plugins would want to delegate the connection to some other plugins, but still not open up the full application-layer connection.\n\nI'm unsure about how to handle this, there's lots of possible ways to go, interpolating between ignoring the issue or taking a lot of control. But once that's figured out, I think I can finally a proper writeup/proposal for a plugin-based architecture for ssb, including some engineering/optimization work.",
    "mentions": []
  },
  "signature": "a5i5eGGTrFMmQszHcKgHE8w1VzpMS7Thn45Utl4pDSB+MSKS0Zz4kP+zaju3EsAE5+mF12/rWhwVyw31QdXNDg==.sig.ed25519"
}

{
  "previous": "%LTkLo1qs+bsDJrka/vEixQq/+pOy5eN85aJpoVfIBAc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1119,
  "timestamp": 1538049855045,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%LTkLo1qs+bsDJrka/vEixQq/+pOy5eN85aJpoVfIBAc=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%LTkLo1qs+bsDJrka/vEixQq/+pOy5eN85aJpoVfIBAc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I should probably clarify that the last problem is something of an optimization rather than a real conceptual limitation. It is totally fine for plugins to connect to other processes on other machines that happen to also be plugins under the same architecture, to negotiate connection details, and then tell their servers to connect to each other (a necessary capability of plugins I forgot to include in the previous post). But creating a new connection between the servers incurs a bunch of overhead (connection setup, handshakes, giving credit, querying plugins). Ideally, the servers could reuse whatever connection the (gossip) plugins already had. This would mean adding some complexity to the architecture that is not inherent to the problem space itself =(",
    "mentions": []
  },
  "signature": "COvKHFOwJktXtsFwJhIy8YGa6D/a6p8Aj1qrl2//N1b3Nd3aHWfCBeSFUHHKiRSC5CrnD1v+S9FtvKMrk/jPDA==.sig.ed25519"
}

{
  "previous": "%7BNtLbCeeJ15Bwpcfa/10T6qUIpC7Qe2qcPhlCS1yx8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1120,
  "timestamp": 1538058748572,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%7BNtLbCeeJ15Bwpcfa/10T6qUIpC7Qe2qcPhlCS1yx8=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%7BNtLbCeeJ15Bwpcfa/10T6qUIpC7Qe2qcPhlCS1yx8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Here is another fun nuance to think about regarding min-bus. Should there be a difference between a connection between plugins `a` and `b` and between `b` and `a`? Under the current draft, these are indeed different, and both can coexist at the same time. It is difficult for plugins to ensure that there is only one connection between them, because of race conditions where both might simultaneously open a connection to the other one. It's possible to work around that, but both plugins need to cooperate. And to at least one of the plugins, it would look like its connection attempt failed. So here are two alternative approaches: An asymmetric one, and a symmetric one.\n\nThe asymmetric approach is done through a tiny yet fundamental change: When plugin `a` wants to connect to plugin `b`, the server never tells `b` about the identity of `a`. Under this model, the receiving side of a plugin is fully passive and must treat all incoming connections the same way. This actually simplifies plugin implementation, as there are fewer decisions to make. A plugin just offers some services to the outside world (not caring about who consumes them), and it can anonymously consume the services offered by other plugins. Proactive and reactive behavior are neatly separated. There's no need to think about consolidating connections `a -> b` and `b -> a`, because it's impossible for the plugins to detect anyways.\n\nFor the alternative, symmetric approach, the server takes an active role in race conditions where both plugins want to start a connection to the other one concurrently. Suppose `a` tells the server that it wants to connect to `b`. The server opens the appropriate duplex to `b`, but then the server receives `b`'s wish for a connection to `a`, which `b` has sent before the server contacted it about `a`'s connection establishment attempt. Under the current min-bus draft, the server does not care and simply relays `b`'s connection attempt. But instead, the server tells `a` that its connection attempt succeeded, and it also tells `b` the same. Now,`b` still got that connection attempt from `a`, so what happens to that? It was received by `b` after `b` sent out its own connection attempt, so `b` has all the necessary knowledge to just silently discard it. The actual plugin code of `b` never gets notified of `a`'s connection attempt. There are some more details regarding credit and heartbeats, but overall that's how the symmetric approach would work.\n\nWith the symmetric approach, the server must only allow a single connection between two plugins at a time, no matter which one initiated it. When a race condition occurs, each of the plugins thinks its own connection attempt succeeded. So in general, plugins can not rely on the information of who initiated the connection.\n\nSo these are the three different options, and none of them are strictly better than the others. You have to accept one of:\n\n- plugins not knowing who connected to them\n- plugins not knowing which of the two initiated the connection\n- race conditions upon simultaneous connection attempts\n\nI haven't even made up my mind on whether anonymous service consumers are a drawback, or actually the better model (in which case the asymmetric approach would be actually superior to the other ones).",
    "mentions": []
  },
  "signature": "L951Cn5S7UoLUzjsLyL8mQQNjww7QemR9yC06hvAWHHllhguwGCgwJY2ib53r8VvuePhoBvn2osBLXl8U/YBAQ==.sig.ed25519"
}

{
  "previous": "%gmMPsWzvA5hVt4IQhWVd3TFCEkwGGsipI81AWAhjOqQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1121,
  "timestamp": 1538072564669,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%gmMPsWzvA5hVt4IQhWVd3TFCEkwGGsipI81AWAhjOqQ=.sha256",
    "reply": {
      "%gmMPsWzvA5hVt4IQhWVd3TFCEkwGGsipI81AWAhjOqQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%+QW+Afdaza4wReHXpZp5rF17IUp6qwG06MBoY928wbY=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Ok, I think the symmetric approach is a pretty bad idea. It results in two bidirectional protocols simultaneously running over the same channel, which leads to conflicts. It is possible two design cooperative protocols that can handle that, but you can't rely on that (and it would violate the principle that plugins can talk to each however they like). So scratch that.\n\nWhat remains is the decision whether a plugin receiving a connection should be given the name (and version) of the initiating plugin. Not sending the name results in a strictly less powerful protocol, so why am I even considering it?\n\nI think relying on the name of the initiator leads to tightly coupled plugins and should be considered an anti-pattern. The whole point of the plugin architecture is to decouple different aspects of application logic. If two plugins rely on each other, then they really are one plugin (note that this is different from one plugin relying on the other but not the other way around). And if plugins really want to treat certain other plugins in a special way, they can still encode this in the protocol they use for communication. But in my opinion, the framework *should not encourage* this bad practice.\n\nThere's a performance impact of not using a single logical channel between the two plugins, but two. Plugins that only use one channel are more efficient, but plugins can only negotiate that if they know their names. But the cost and  performance impact of not having an additional channel is negligible, not really justifying the tricky shared-channel negotiation and the necessary compromises for the communication protocol they use over that shared channel.\n\nSo I'm leaning towards plugins not knowing who or what initiated a connection to them, even though this is the less general approach. I'd love to hear other people's opinion on this (CC e.g. [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519)).\n\nNote that this post only dealt with min-bus, not with a p2p-aware framework. For cross-server communication, there will always be the need to include some information about who initiated a connection (at the very least the public key). But the same core decision needs to be made.",
    "mentions": [
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      }
    ]
  },
  "signature": "s6Phw16AuC6swcZFLz6VdOxVX428MPDvc1v1JqfiII+j/V9y38tRF8SRVn7p6xKebWxGQdtXm11NZ71gUPCPAQ==.sig.ed25519"
}

{
  "previous": "%aaNbXI0ltSc5bG86S9NS7wEjxvtGUXuq89W8VuIqetA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1122,
  "timestamp": 1538075137665,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%+QW+Afdaza4wReHXpZp5rF17IUp6qwG06MBoY928wbY=.sha256",
    "reply": {
      "%+QW+Afdaza4wReHXpZp5rF17IUp6qwG06MBoY928wbY=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519)\n> @Aljoscha with regards to plugins, what do you think about doing a depject-y approach where each plugin has a \"manifest\" that says what services they give and what services they need, then the server connects everyone up. i think this would work best if we assume plugins are specified upfront, including how to start the process, so the server starts each plugin process and then connects each plugin to another as desired.\n\nCaveat: For now, I'm just exploring the general design space, my opinions are still forming and I've been mostly considering an abstract setting rather than an ssb-specific one.\n\nI'm not a huge fan of a manifest that specifies what kind of rpcs are offered by a plugin, because that ties the whole thing to a specific communication protocol. We don't need to do so, so imo we shouldn't. More interesting is the idea of a dependency specification, where each plugin says which other plugins they want to be connected to (and a minimum version). This is effectively what the models I've been exploring here do dynamically, rather than tying it to a certain file format. I like keeping it dynamic, that keeps open possibilities like having preferences of plugins, e.g. wanting to interact with an ebt plugin, but falling back to legacy replication if no connection to an ebt plugin can be set up.\n\nSpecifying what services are offered by a plugin seems rather pointless to me. If you don't know a plugin, you won't be able to interact meaningfully with it anyways. If you do know about it, then you already know what it does. So all such a \"manifest\" should contain is really a set of dependencies.\n\nThe most interesting point you raised is the server starting plugin processes as needed (and by extension shutting them down when they are not needed anymore). That's a very interesting point, and one I definitely haven't made up my mind about yet. In the models I've explored in this thread, you'd somehow need to start all plugins you could possibly need up front, and potentially many of them could be idling without anyone ever connecting to them.\n\nFirst of all, I don't think idling plugins would be much of a problem, processes waiting for IO are pretty cheap.\n\nPutting this into the spec will greatly increase the complexity. How do you start plugins on another machine, and how do you establish the connection between a newly started plugin and the server? There's a lot of detail hidden there that the server would suddenly need to be aware of. Less problematic, but for completeness' sake: How do you deal with failure to start a plugin?\n\nAnother consequence of this: Plugins and processes become arbitrarily tied to each other. In the general setting, a plugin is simply something that connects to a server. There might be a single process that creates multiple connections to the server, and that's totally fine. The server doesn't even need to know about this. There could be some complex logic for determining which plugins to create and how they should connect, plugins could be created dynamically, etc. There are a lot of options that would be prohibited by making plugins server-startable processes.\n\nBut my main argument against this: There's no need to do this in the server, this can be done by a plugin. You want declarative plugin management? Go write a plugin that does exactly that, and use it by everything that wants to be part of your declarative world. It can be as opinionated as you like. But everyone else who doesn't buy into your ideas of the perfect declarative plugin setup can happily ignore it, and they don't need to pay the price of an unnecessarily complicated server protocol. This sounds rather dismissive, but I'm not saying that declarative plugin management is a bad idea. I might design such a plugin myself if I think ssb needs it. But I don't want to force my ideas of a good declarative system upon everybody else.\n\nA very related discussion is about some sort of introspection mechanism. D-Bus for example chose to include self-description as part of the spec, thus everything needs to pay the cost (as well as resulting in a much more complicated spec). In exchange, there are generic programs that can e.g. visualize all processes connected to D-Bus, and the services they offer. But you can also get that without bloating the protocol, by creating an introspection plugin. All plugins that want to be introspected could register themselves with that plugin, specifying whatever that plugin allows to specify. There could be a family of plugins that all use muxrpc, and the introspection plugin could allow to share manifest objects, etc. But that still wouldn't preclude other plugins from not using muxrpc at all. If the protocol itself wanted to enforce introspection, it could do so by forcing everyone to use muxrpc and specify manifest objects. But what happens if muxrpc turns out to not be the best format ever? This is what happened with D-Bus, even a tiny D-Bus program will have to supply a bunch of xml manifests. Even if you want to do something conceptionally very simple, you have to do a bunch of unnecessary work to satisfy an arbitrarily opinionated protocol.\n\nTLDR: I'm a fan of kiss (no, not the band).",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "AeifrmNa9gnBMbmG3qWcZ6oq6MK6m6rKeHjOgeXXMdBv4qMRSDbov0JJcukaFku4wPVlLs5BCLDDpk/IAgdcBA==.sig.ed25519"
}

{
  "previous": "%IjJz4ANfe8ZTgyJQvyKBV18zyGahgCZydZFXRIWAdyU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1123,
  "timestamp": 1538077653265,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%Rpe7vYXeOk0bKSQbjlFy6CdyGHuvwv8d0aCLo/Mpo9o=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%Rpe7vYXeOk0bKSQbjlFy6CdyGHuvwv8d0aCLo/Mpo9o=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> rather than saying \"i need plugin X\", you say \"i need interface X\" [...].\n\nIsn't this the same? A plugin name is nothing but the promise of speaking a certain protocol. When you talk to a plugin, you talk in that protocol, but you don't care how exactly the plugin does its thing. Caring about it doesn't even make sense, because you can not know what exactly the plugin does - and that's completely intentional.\n\nI get your point, I agree with it, but I think my approach already does this, in a more general way. Just adjust the granularity of what you think of as a plugin. And keep in mind: Multiple plugin names can all be handled by the same process.\n",
    "mentions": []
  },
  "signature": "oMAx9Q/xXkeAKnA+TrbtImHCkp57g1pC7w8KX/5KwzpeFfGX/M2c2I+YDRtz74tj6ZpATzFInqJGpOigjc+fAg==.sig.ed25519"
}

{
  "previous": "%UW2m/C5HrbHkjtMAmiflHWPP25ZG2SnPxMZvCqXirkw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1124,
  "timestamp": 1538077684710,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%Rpe7vYXeOk0bKSQbjlFy6CdyGHuvwv8d0aCLo/Mpo9o=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "hzVmH+OwTHEVmp7X7Bl4SWSfSqBa0TjhoDaNrQCZmKLLP92yRgOupZlmcsTr0MTh1XiCW7kMy5gKY5I2Xia0AA==.sig.ed25519"
}

{
  "previous": "%CbTvF4yxOd0IMfhq5TQj3W6Rdbn75qK5DqZ5JNeVXt4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1125,
  "timestamp": 1538078992949,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "go-ssb",
    "vote": {
      "link": "%fiaTryj/EAPDbthBSukiSt1LwTbAYQZBhJr/0mzYWDM=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "pW+ZuwnUxZJPPVZDUiDg1RjFxg5azkqKaDiROkpXYyiuaNRXnNED9Cknipws0wczc3bSX3497GUsp9xwPxaOBg==.sig.ed25519"
}

{
  "previous": "%SI/2p9FA1Eg9FzD2rJ497NSHOIDvGsLIt7/yWNqMHms=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1126,
  "timestamp": 1538079752617,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%UW2m/C5HrbHkjtMAmiflHWPP25ZG2SnPxMZvCqXirkw=.sha256",
    "reply": {
      "%UW2m/C5HrbHkjtMAmiflHWPP25ZG2SnPxMZvCqXirkw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%5soBjMJs1oDmmQDm0ojBlGRdw8fUuk+3OxYI41ee+KQ=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> I get your point, [...]\n\nLet me rephrase that to \"*I think* I get your point\".\n\nAnyways, there are a lot of nice features we could build. But in my opinion, the question we should ask is not \"Is this a nice feature?\", but rather \"What do we gain by making this feature part of the specification instead of implementing it in a plugin?\".\n\n[@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) ",
    "mentions": [
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "OpWIr+m/NlJRzq6NP2NB0qvvBHFnzwX0UKPGATngxEcERnw4zY1hw7RN8Sl0LUpVqS4Mrv09eayPyWo656FzBA==.sig.ed25519"
}

{
  "previous": "%7jAnGX1a7klbRIZDgxjnMjLvi+8Ay/AC/fi1/swA+xY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1127,
  "timestamp": 1538079818774,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%5soBjMJs1oDmmQDm0ojBlGRdw8fUuk+3OxYI41ee+KQ=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "MmqCALu/tvGISfI5r5hDwpBfORl5CAv+wIwphAmdloneR5/eAO/szPXDxzevckXeJHBcrj4VR0gdWwLeQt0sBQ==.sig.ed25519"
}

{
  "previous": "%A+rlawsiYcA9qbNE1G6G2ass066ibnZxxZKmC9RlKN8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1128,
  "timestamp": 1538081305792,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%5soBjMJs1oDmmQDm0ojBlGRdw8fUuk+3OxYI41ee+KQ=.sha256",
    "reply": {
      "%5soBjMJs1oDmmQDm0ojBlGRdw8fUuk+3OxYI41ee+KQ=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I appreciate the reminder, I guess we'll sketch out both approaches and compare. For now I'll ponder the question of server-to-server connections some more, and how that relates to making things more declarative.\n\nThere are a few more arguments for a minimal system though that I feel your post brushes over:\n\nI'm very keen on keeping the ssb protocol as simple as possible. Everything we put into a spec is something everyone after us will have to live with, reimplement and maintain. Also, everything we put into a spec is something that becomes difficult to change without breaking backwards-compatibility.\n\nMoving things into plugins, even if we know that we will always assume existence of those plugins (at least at this point in time), means that ssb itself stays lightweight and flexible. I want to avoid specifying core interfaces, we won't get them right anyways. Putting stuff into plugins also eases the burden on implementors. They don't need to implement everything at once, but they can gradually replace components at whatever pace they want. A monolith has to be replaced in one go.\n\nFor application architecture (such as patchbay) it might make sense to err on the side of cohesion, but for protocol design I'd rather want to err on the side of decoupling.",
    "mentions": []
  },
  "signature": "0t8hDtlvA2RBNUT/KKxkllz1+YdLBKJ2yTzKdmBZbdQUPG5XfXdCUTpJflKG09e/9YgIN0jvZuA4HCo0IIyoBg==.sig.ed25519"
}

{
  "previous": "%taNXV6KDPmSFKVxvTUwiKRtG1m+U1Wori5HUU0b7DxM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1129,
  "timestamp": 1538122842849,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "sunrise-choir",
    "subscribed": true
  },
  "signature": "qUHCx7UpZCuv4mHAm8KSEp+vnbSVdcdVqi9IWJ+QAWLlv3Id+iWdH3bQIeI9m0JeR1FqFR8tcooNppmMLDEsAg==.sig.ed25519"
}

{
  "previous": "%05tAVA2MuXeI+mEao2mCN9L7f+IMw1Lh749t8NIyJQw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1130,
  "timestamp": 1538124110818,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%UyEnqEkxk2Sgl5467GRY1JyyWxYScWH+XhC9n4wsSEo=.sha256",
    "branch": "%ZHexEnGZO+V1l0+8r6CtEyBSGFw61X7kFX8JEue6TqQ=.sha256",
    "reply": {
      "%UyEnqEkxk2Sgl5467GRY1JyyWxYScWH+XhC9n4wsSEo=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%ZHexEnGZO+V1l0+8r6CtEyBSGFw61X7kFX8JEue6TqQ=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) I think we actually agree on a lot of points, or at the very least on the goals. My main ask is simply to not rush this.\n\nMy [thread on plugins](%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256) is mostly me thinking out aloud while exploring the design space. I still don't feel like I have a full grasp on a lot of the details. My mode of operation is to figure out the most general way of doing things, and then use that as a foundation for making decisions - which will certainly involve restricting the scope. So I guess I'm asking you to humor my explorations, knowing that I am open to reduce the ambition of the current drafts.\n\nThis approach may lead to the same result - sandboxed, local plugins that declaratively specify their api with constraints enforced by the server - but I want to fully understand how to reach those conclusions, and what the alternatives are. You clearly thought about these things longer and much deeper than me, cryptix and keks did, but we can't look into your head.\n\nTo give a vague, mathematical analogy: I'm trying to find linearly independent vectors that span our whole problem space, before settling on a set that only spans part of the problem space. Because who knows - maybe there's a really sweet spot outside of what a more constrained approach can find.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
        "name": "thread on plugins"
      }
    ]
  },
  "signature": "jTe++XDRoZwwYNRJkf/VzsF9MXIw7Op5rqjg7I5DadMQw+CZrqFjw4ILN1gSEh0ywnLnCKV0N9bGDuucm754BA==.sig.ed25519"
}

{
  "previous": "%wX4oyw3D8n+rY21tnt5Bk247GCKtj3CcbFpWUA3e0js=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1131,
  "timestamp": 1538127531956,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%oWXAAmNHyqadjFA866VXkybPkXq6pQoexc1GLBp3bPY=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%oWXAAmNHyqadjFA866VXkybPkXq6pQoexc1GLBp3bPY=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Fair enough, the microservice comparison is justified, and I agree that ssb would not really benefit from it. To give a short background on where the idea of plugins running on different machines comes from:\n\nServers need to connect to other servers, so some part of the protocol will end up to be network-aware in any case. There will be something like multi-addr or multiserver addresses to handle connections. But if we already have that, why arbitrarily restrict plugins to only a subset of those connection modes? That's actually the more complex way to go, not the simpler one. This argument does start to crack once you take a closer look at things. For example it would be very simple to implement an optimization where two local plugins communicate directly via a unix domain socket, but connections between remote plugins could become tricky (NATs etc). So remote plugins are not something I absolutely insist one. I've just been considering the most general setting, so that's why they still appear in later posts.\n\nI fully agree that in a setting where the server has more control (enforcing sandboxing, etc.), it makes sense to distinguish between plugins running on the same machine or not. But in the most general setting, the protocol does not need to care about that.\n\n> I can't really think of uses of ssb plugins that would warrant that.\n\nThin clients come to mind. If clients are actually plugins (and I'm pretty convinced that that is the right way to go, or at least the cleaner solution), then the ability to e.g. run patchfoo on a resource-constrained device while connecting to a more powerful server over wlan would be lost if plugins are forced to be local processes.\n\nAnother use-case is something like a really index-heavy plugin (e.g. full-text search over large ssb datasets), or a computationally expensive one. It may make sense to host those on a dedicated server, possibly exposing them to multiple users.\n\nIn any case, these could just run a local plugin which then talks to the remote endpoint in whatever way it sees fit, outside the scope of the plugin architecture. That would require asking the sandboxing mechanism for permission, so it involves some complications, but it isn't unsolvable. So these situations are not really sufficient arguments against making plugins local-only.\n\nSo overall, I'm open about restricting the scope of this. I'd still like to explore server-to-server connections in the general setting though, before doing so.\n\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), I'm curious about your opinion on clients being nothing but plugins that don't expose an API. That's a pretty fundamental decision, especially if plugin-startup ends up being managed centrally.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "r2QSAQJ7UCRiNEhhojAd3g/UKYWqWjLuJbMwcZuFUSL9f9C5Uhume7jWq1QiHKZzjoQVYHHJOzZ4H0jHTbsLAA==.sig.ed25519"
}

{
  "previous": "%G3GloyymkBpCuimLbD7/An8tH1mRe23zUHvowuk9Hxc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1132,
  "timestamp": 1538141912423,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%G3GloyymkBpCuimLbD7/An8tH1mRe23zUHvowuk9Hxc=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%G3GloyymkBpCuimLbD7/An8tH1mRe23zUHvowuk9Hxc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "### Making the Plugin Server P2P Aware\n\nFor this post I'll retreat into my bubble of the very general setting described in [this post](%LTkLo1qs+bsDJrka/vEixQq/+pOy5eN85aJpoVfIBAc=.sha256). I'll post about sandboxing, plugin startup, and related concerns later.\n\nI see are four basic options regarding a p2p-aware plugin architecture:\n\n- ignore it\n- all-or-nothing connections\n- scoped connections\n- opaque connection management\n\n#### Ignoring P2P\n\nPlugins are turing complete, so no need to make the system itself deal with p2p stuff. Just handle it in plugins! That's a valid approach, but certainly not what we'll need for ssb. The main draw back is that a plugin would need to reimplement another, nested plugin framework. It needs to mediate connections between plugins connected to different servers. But isn't mediating connections between plugins the job of the framework? Also lots of sandboxing concerns with this approach. So from now on we'll assume it is a good idea to have a p2p-aware framework.\n\n#### All-Or-Nothing Connections\n\nTo recap the setting from [the previous post on this topic](%LTkLo1qs+bsDJrka/vEixQq/+pOy5eN85aJpoVfIBAc=.sha256), each server has its own keypair, and servers can connect to each other, allowing the plugins on one server to call the plugins on the other. Plugins can choose whether they want to expose their functionality to the other server, based on its public key.\n\nThat's the abstract idea, but there are a few details needed to realize it. How does a server know when to connect to another server, and which one? When do they disconnect? A server would need to allow its plugins to start end terminate connections. The plugins would need to specify the address of the server to connect to. Addresses would be given in some format like [multiaddr](https://github.com/multiformats/multiaddr), for this discussion I'll just assume that some suitable format exists. Plugins would also need to be aware of the address(es) of their server, so that they can send them across the network.\n\nThe main takeaway of this is that the server needs to be aware of both an addressing format, and how to establish connections using that format. Plugins can just pass along (and possibly manipulate) those addresses, but they don't need to care about details of how connection are actually set up.\n\nThere are some problems with this approach, including but not limited to:\n\n- all plugins have the capability to set up network connections\n- all plugins have the capability to terminate any connection\n- what happens if the plugin that was supposed to terminate a connection crashes?\n  - Did I mention anywhere that the server should periodically send heartbeat pings to inactive plugins, to detect unresponsiveness and treat it like a crash? Well, now I did. Heartbeats are awesome!\n- no support for connections where only a subset of plugins is allowed to talk to each other\n\n#### Scoped Connections\n\nHere is one (but definitely not the only) approach for dealing with the above problems. When a plugin tells its server to establish a connection to some other server, this does not create a globally scoped connection. Instead, the connection is only accessible to the plugin. To establish such a connection, the plugin must also specify the name of the remote plugin that should handle the connection, and on the other server, the incoming connection is only accessible to the specified plugin. If no such plugin exists (or the version is too low), the connection attempts fails erroneously.\n\nThe plugins can then talk to each other, however they see fit. At any point, a plugin can make its side of the connection available to all other plugins connected to the same server. You could do this more granularily with a capability system, but I don't think that's worth it: If other plugins should be able to influence a non-public connection, that can be done via rpcs between the plugins on the same server.\n\nEven after making a server-to-server connection public, the plugin that initiated (or accepted) the connection is still responsible for it. It is the only plugin that can close the connection, and the connection is closed automatically if the plugin disconnecs or times out.\n\nIn this (and the previous) model, it makes sense to think a bit about the opacity of network addresses. Since the server implements the connection logic, it is possible to expose connection information (e.g. a mutliaddr) as an opaque object to plugins. But plugins might want to manipulate it, e.g. to not send locally scoped addresses across a network boundary, or to filter out certain connection types. It would be possible for the server to offer these operations. What this gives us is the ability to tinker with address formats without requiring plugins to adapt. But that might simply not be worth it, most likely we'll settle on a particular multiformat and fully commit to it.\n\n#### Opaque Connection Management\n\nThe fourth approach is radically different: Connections are an implementation detail of the server, the server gossips as it sees fit, and plugins can subscripe to connection changes. This would probably be paired with an all-or-nothing model: Once a connection is established, all plugins get to use it equally.\n\nThis approach is the one that results in the simplest plugin API, at the cost of moving a lot of complexity into the protocol. It also reduces our flexibility in changing gossip details, and it would mean that the whole plugin architecture becomes tightly coupled to ssb. I currently think that the scoped connections approach is not so complicted that those sacrifices become worth it. The increase in plugin api complexity only affects those plugins that wish to deal with connection setup, all other plugins can simply ignore it and effectively code against the same API as under opaque connection management.\n\nNon-prescriptive connection management will leave open the door for future experimentation. In particular, since the friends graph is not inherently part of ssb, there might someday be other ssb-based applications with vastly different replication needs than our current social networks. As for other arguments for leaving connection management to plugins, the same arguments as those for [leaving plugin startup to plugins](%taNXV6KDPmSFKVxvTUwiKRtG1m+U1Wori5HUU0b7DxM=.sha256) apply.\n\nAlso note that due to connections still being established by the server rather than \"out of band\", the scoped connections approach plays well with sandboxing, although it will slightly complicate it.\n\n---\n\nI think this mostly concludes the open-ended exploration phase for me. I'll engage with sandboxing, declarative apis, restricted access between plugins and declarative lifecycle management next, and I'm pretty optimistic we'll be able to find common ground where nobody ends up unhappy.",
    "mentions": [
      {
        "link": "%LTkLo1qs+bsDJrka/vEixQq/+pOy5eN85aJpoVfIBAc=.sha256",
        "name": "this post"
      },
      {
        "link": "%LTkLo1qs+bsDJrka/vEixQq/+pOy5eN85aJpoVfIBAc=.sha256",
        "name": "the previous post on this topic"
      },
      {
        "link": "%taNXV6KDPmSFKVxvTUwiKRtG1m+U1Wori5HUU0b7DxM=.sha256",
        "name": "leaving plugin startup to plugins"
      }
    ]
  },
  "signature": "Yv07fayDWcvfY6g9lBnpDiioiiGJciwTAF7avUhzE98LmluZXz42uSDDkbzTQjI9sarRDywa9j1HRDgLNUvMBg==.sig.ed25519"
}

{
  "previous": "%sB3Aq9+/e5K8JyxkohLYaXyiWWGLJpNykovmjTBWXPQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1133,
  "timestamp": 1538150451392,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%sB3Aq9+/e5K8JyxkohLYaXyiWWGLJpNykovmjTBWXPQ=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%sB3Aq9+/e5K8JyxkohLYaXyiWWGLJpNykovmjTBWXPQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "So let's talk about [sandboxing](%UyEnqEkxk2Sgl5467GRY1JyyWxYScWH+XhC9n4wsSEo=.sha256) plugins and plugin APIs (mostly ignoring managed lifecycle for now, as that's fairly orthogonal). I'll first sketch an approach that gets around an explicit representation of plugin APIs, and then argue why I think that might make sense.\n\nSandboxing works through capabilities. By default, a plugin has no capabilities other than allocating memory and maintaining its connection to the server. The protocol defines a set of capabilities, including but not limited to file io, socket io, reading the ssb database, writing to the database, telling the server to establish a connection to another server, talking to remote plugins (possibly filtered by pubkey and/or name), and so on. A plugin specifies which of those capabilities it needs, and if the server grants them (as ultimately instructed by the user), then the plugin is started in a sandbox that only allows those os io actions for which it has capabilities (and the server disallows rpcs for accessing the ssb db etc if those capabilities were not given).\n\nA plugin `a` may only communicate with another other plugin `b` if `b` has no capability that a does not already have as well. And peeking into managed lifecycles: The same condition holds for plugin `a` starting up plugin `b`.\n\nThat's basically it. The big difference to what I read between the lines of [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) and [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) comments/proposals/drafts is that the whole system is agnostic to how plugins actually talk to each other. They don't specify an rpc api, and they don't specify capabilities needed per rpc. A short list of nice things about that:\n\n- fewer stuff the server needs to know about, fewer security-critical stuff the server could get wrong\n- does not impose any specifically structured protocols upon plugins\n- no need to declaratively specify an API (that needs to be manually implemented anyways, so there's no simplicity gained through declarativity)\n- inter-plugin communication capabilities do not have to be specified explicitly, but emerge naturally\n\nIn an alternative setting with explicitly named and tracked rpcs, you would get the additional expressive power of assigning different capabilities to different rpcs of the same plugin. That is honestly the only advantage of such a system I can come up with (ignoring introspection, which is orthogonal and which we can discuss at another time). Well, and upon closer examination that advantage disappears, because you can not reliably do this. The plugin as a whole is granted a single set of capabilities, so to fully function, it needs to request the union of the capabilities of all its rpcs.  But then, if we don't trust the plugin (and that's the whole reason for the sandboxing in the first place), we can not trust its claim that a certain rpc won't make use of undeclared capabilities. So we end up with a single set of capabilities for the whole plugin, just as in the system I sketched above.\n\n---\n\nThere are a few possible ways of extending the system: Rather than binarily either granting all capabilities or not starting the plugin at all, it could be possible to inform it of the subset of capabilities it was granted. The plugin can then decide whether it wants to shut down or whether it can operate in a restricted mode. Note that this is does not fix the issue about rpc-level capabilities not working: If a plugin is granted all its capabilities, than less privileged plugins still can not be allowed to call methods for which the plugins claims that it does not need some powerful capabilities, because we still can't trust that claim.\n\nAs a final note: It could be possible to do dynamic capability (re)assignment, and to define capabilities for talking to specific plugins on the fly. I mention these for completeness' sake, but I think these are bad ideas. The security enforcing parts should stay as simple as possible.\n\n[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) I'd love to hear your thoughts on this approach for dealing with inter-plugin communication restrictions, even if it is just a simple \"ack\".\n\nI'm not fundamentally opposed to enforcing some sort of introspective rpc protocol for plugins (although I would prefer to not do that). There are some good arguments for that (consistency, introspection, stability of the ecosystem), my main point is that capability-based security is not among those reasons.\n\n---\n\nThis post was powered by [Felix Mendelssohn Bartholdy](https://www.youtube.com/watch?v=Ny4yzZy-9Ps). I should listen to music more often =)",
    "mentions": [
      {
        "link": "%UyEnqEkxk2Sgl5467GRY1JyyWxYScWH+XhC9n4wsSEo=.sha256",
        "name": "sandboxing"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "lBeJvCAaaW9aRR+5S+/EMrtTVgsdz1X1T4iBs2g6d2Kmktkw9AK2ryCpG02ubXt63H+fvZvo7xEuhTmfo3eNCA==.sig.ed25519"
}

{
  "previous": "%CNHU+g/n2fc6Y2BMyZtpme4mpMq8mz44x3gOEKGIgkA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1134,
  "timestamp": 1538151579142,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": "%CNHU+g/n2fc6Y2BMyZtpme4mpMq8mz44x3gOEKGIgkA=.sha256",
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%CNHU+g/n2fc6Y2BMyZtpme4mpMq8mz44x3gOEKGIgkA=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Maybe I shouldn't be listening to music when trying to think after all... There are some serious flaw with the previous post. Automatically allowing plugin-to-plugin communication based on capabilities is sensible in a setting where you don't trust any plugins at all, but why would hand out capabilities then. If you hand out a capability to a plugin, you trust it not to misuse it, including not indirectly giving that capability to untrusted plugins through rpcs. So in some sense we could actually trust the claimed capabilities of rpc methods. Placing this trust into plugins allows to give access to some functionality to a less trusted plugin, using the trusted plugin as a filter.\n\nSo yeah, much of the previous post is garbage... Sorry about that.",
    "mentions": []
  },
  "signature": "K4pEn1h7c32G1RV+kiNpeLVMYQXOeyTm05dOzZPayVGgq8JalgVcczMlnNPDneWCfxhvY05STWT9LXxQlydHAA==.sig.ed25519"
}

{
  "previous": "%gJ6y5QSFx1TmmmBAPv75mfyr92InvwucXNAIvUvbqtU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1135,
  "timestamp": 1538166208168,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%vF0hCveyya77xRJslY8a6ori5FVz4bDusy3FSz7NP7g=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "bTHrkR/gjA9eqmjo0MUhq35KeY8vpmYdbiKpI1W4ENa+JOD2jMzMBtYUP0HFYRtLDoWOr8liQ/tLz/jqDByNCQ==.sig.ed25519"
}

{
  "previous": "%NaUaU3Js2605cfSdM3zCP7nrz7ACRwZN7JIUd152EG0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1136,
  "timestamp": 1538214063298,
  "hash": "sha256",
  "content": "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.box",
  "signature": "T4/bS5uGoHPbMoasnzwkDtW0QGNqU5N7nspCpgDhkgG7Is+9DGMojBUD34H8sYIdhZMZy7mqRUhCiBnREuPjDg==.sig.ed25519"
}

{
  "previous": "%R9/2FIc+z1NCzaw1PVHFypHPHgAuf8Do+7CClkt7Jh4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1137,
  "timestamp": 1538231850043,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%bSZ/D8VqTYcuqqeTcZ6uNm08F4V+NBdUzCwLiN4gDyo=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "8P9vBdjqcdr0fREi9B3P6uhCRPXdGubWUD/F6RKDLUQ6GkgvRKhYz1ua4AtXBjvRZ4dGc/4ySiu8ROT5WuD0DQ==.sig.ed25519"
}

{
  "previous": "%NMezoWFtafEVbTUARjjKIYEIAHfXfGtCwKcWrs/oyEE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1138,
  "timestamp": 1538304534328,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256",
    "branch": [
      "%QbE9P7Mjk7O9LmnjonwYQAOBRwfmgYzBudqg0pEkG7c=.sha256",
      "%bSZ/D8VqTYcuqqeTcZ6uNm08F4V+NBdUzCwLiN4gDyo=.sha256"
    ],
    "reply": {
      "%eOgrGRIfPCkK9x8lrW5gS5fwSysMBGc4EaOfz0IDScc=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%bSZ/D8VqTYcuqqeTcZ6uNm08F4V+NBdUzCwLiN4gDyo=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Tomorrow I'll begin with the #sunrise-choir work, and I'll start out with message formats. So I'll stop exploring the plugin design space for now, but here is a list of open question any solution we'll come up will have to answer:\n\n- are plugins and clients the same?\n- can plugins run on different machines?\n- should a plugin know the name of another plugin that initiated a connection to it?\n- who gets to start connections to other servers? Who gets to close them?\n- can plugins run any protocol they like, or do we enforce some sort of muxrpc-like protocol?\n- how does automatic plugin lifecycle management work?\n- which plugins are allowed to talk to each other?\n- what are the cross-platform IO capabilities?\n- how do we grant access to the ssb database (capability-wise)?\n- which core rpcs are there (gossip, replication, database reads, database writes, blobs, private messages, where does it stop?)?\n\nA few of these are not directly related to plugin management (such as deciding on capabilities and the core ssb server functionality), but they depend on each other enough that we'll likely need to introduce them at the same time. All the message encoding stuff is fairly independent, but rpc protocols, plugins and core ssb functionality are interdependent. Reaching consensus on how to do all of these at once, will likely be the most difficult step in what the sunrise choir set out to do. But also one of the more worthwhile ones, since that is what we need so that clients can code against a spec rather than (j)sbot.",
    "mentions": [
      {
        "link": "#sunrise-choir"
      }
    ]
  },
  "signature": "iPM9rqdg/OqU/m+p8WmRz+N6z8sWRjLD94jY3hqhXBqNuIxGwxnxYn/DNWioDWsTAUjLAHiwL4ypcLsCgayzAg==.sig.ed25519"
}

{
  "previous": "%/UsKOI1+092JMvaNUABfYWNnhVABeLug689SiPNMjYI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1139,
  "timestamp": 1538320795010,
  "hash": "sha256",
  "content": {
    "type": "channel",
    "channel": "inktober2018",
    "subscribed": true
  },
  "signature": "oMoEzz6qzTqw0ZkYF09tZreqceM/cxqXiqKB0e3yXRPTd6BnpeD93MBXRBQ4yVeomzjMl3Ofhuz8nie9DGHHDg==.sig.ed25519"
}

{
  "previous": "%T8qXbi69lx3sl7RjBHivryxLPpCa83smOZh99V0MhfQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1140,
  "timestamp": 1538395533293,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebutt",
    "text": "Took a closer look at message signing, hash computation and length limitation today, as part of the beginning of a precise and comprehensive ssb spec. The results might be somewhat surprising to a few of you:\n\n> #### Hash Computation\n>\n> To compute the hash of a message, you can not use the signing encoding, but the hash computation is based on it. The signing encoding always results in valid unicode. Represent this unicode in [utf-16](https://en.wikipedia.org/wiki/UTF-16). This encoding is a sequence of code units, each consisting of two bytes. The data to hash is obtained from these code units by only keeping the less significant byte.\n>\n> Example: Suppose you want to compute the hash for `\"ß\"`, the corresponding utf8 is `[22, C3, 9F, 22]`. In big-endian utf16, this is `[(22, 0), (DF, 0), (22, 0)]`, in little-endian utf16, this is `[(0, 22), (0, DF), (0, 22)]`. In both cases, the sequence of less signifiant bytes per code unit is `[22, DF, 22]`. That is the byte array over which to compute the hash.\n>\n> Note that this means that two strings with different utf-8 encodings can result in the same hash, due to the information in the more significant byte of the utf-16 encoding being dropped.\n>\n> #### Length Computation\n>\n> Ssb places a limit on the size of legacy messages. To compute whether a message is too long, compute the signing format (which is always valid unicode), encode that unicode as utf16, then count the number of code units. This number must be smaller then `16385` (`== 8192 * 2 + 1`), or the message is considered too long (16384 is still ok).\n\nI'll set up test suites to verify that this is indeed the behavior of the js implementation and for other implementation to test for conformance. But it'll be some time until I reach that point. My next goal is to spec out the encoding used for signing without just bailing out by referencing the ecmascript spec.\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) (the last posts I read from you on these issues talk about utf8, even where things are based on utf16 instead), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519) (is the go implementation compatible with this?), [@duncan](@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519) (useful information for the protocol guide)",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@Wbmkx0zKN/zFC1Li7Mz3IEQlcnHT7gAQ38i3hRCqyp4=.ed25519",
        "name": "duncan"
      }
    ]
  },
  "signature": "gRkerG2MQYsgC40AGtx3M6W3eaSORnHKkHqcWv3sXDQR030vMeDmYxjrpGdTfJoMGdPyblfE+s6K/f+n6agTBA==.sig.ed25519"
}

{
  "previous": "%4NlIadM1NOwaooGFKXNpOTsfvrZ207nATooGpEWwwhg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1141,
  "timestamp": 1538399180685,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%tW5iy9tD/RaAKKiwmqu3zsPPYo5s/jsM1Gu1Bp2W9dI=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "DklT7MjPJXXC/GLCDInmtW5oYKtmsbQTGZPmbvML1ELdmcm8BRFsuGK0VztW7EfmPN7rMBbXpki4gCSF1yu+CA==.sig.ed25519"
}

{
  "previous": "%TPxJbt7aR83mT7XAwqtgYittnxTAzb2/abPanCvBDaI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1142,
  "timestamp": 1538411259582,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "dev-diaries",
    "text": "This thread will serve as my dev-diary for the #sunrise-choir. General goals:\n\n- specify the current ssb protocol\n- specify improvements\n- implement stuff in rust\n  - with a focus on readability and correctness, not necessarily performance\n- get the improvements rolled out into the wild",
    "mentions": [
      {
        "link": "#sunrise-choir"
      }
    ]
  },
  "signature": "3vMfCzfjFwAayL2vH3gVQzklpgFaNHFwnA8Xonok/SyECilAa+2HXD/2RMK0KsO8r38vxiOfjH04gwgPSJ/DAQ==.sig.ed25519"
}

{
  "previous": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1143,
  "timestamp": 1538411323194,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 01/10/2018\n\n- created ssb spec repo, wrote introduction to legacy messages: https://github.com/sunrise-choir/spec/blob/master/spec.md#legacy-messages\n- specified the legacy message's abstract data model: https://github.com/sunrise-choir/spec/blob/master/spec.md#abstract-data-model\n- started a [serde](https://serde.rd) clone that uses the ssb legacy data model rather than the [serde one](https://serde.rs/data-model.html): https://github.com/ssbrs/legacy-msg/tree/master/src/abstract_\n  - Is this a good idea? Only one way to find out...\n  - Currently lacking Serialize and Deserialize implementations for std types, and lacking automatic derive.\n- you know how every once in a while you need to look up a unicode (encoding) detail? Today hat a lot of those \"onces\".\n- specified hash and length computation for legacy json messages: %4NlIadM1NOwaooGFKXNpOTsfvrZ207nATooGpEWwwhg=.sha256\n- specified the signing encoding for legacy json messages: https://github.com/sunrise-choir/spec/blob/master/spec.md#signing-encoding\n  - caveat: there are some open questions regarding floats:\n    > TODO: Check whether float handling is really what nodejs does. I just applied NOTE 2 of the [ECMAScript spec](https://www.ecma-international.org/ecma-262/6.0/#sec-tostring-applied-to-the-number-type) without knowing whether node actually applies it. I also specified the rounding for the `s * (10 ^ (n - k)) === m` constraint to be round-to-even, without checking what node does, and without knowing whether rounding can even occur. Will check this once there is a test suite, or maybe I'll just ask the v8 people.\n\nNext steps:\n\nDeal with floats (I really hoped I wouldn't have to, but oh well...):\n\n- Read up on the representation to figure out node's behaviour, do some math if I have to (I'm fine with math in general, it only gets annoying once it involves numbers)\n- Check whether there's a sufficiently configurable rust implementation for float printing. If not, I'll need to implement one myself.\n- Read up on and fully understand the [Dragon4 algorithm](https://lists.nongnu.org/archive/html/gcl-devel/2012-10/pdfkieTlklRzN.pdf), check whether the current [state of the art](https://dl.acm.org/citation.cfm?id=3192369) is viable.\n\nNext steps that will be actually useful:\n\n- implement legacy encoding, hash computation and length checking in rust\n- use afl on the rust implementation to generate test cases\n- check whether the js implementation behaves the same way on those test cases, iterate until they match\n\nBut yeah, tomorrow's dev diary may very well end up being \"I read some papers and scribbled down a lot of notes trying to understand them\". Hopefully it won't be more than one day of that.",
    "mentions": [
      {
        "link": "%4NlIadM1NOwaooGFKXNpOTsfvrZ207nATooGpEWwwhg=.sha256"
      }
    ]
  },
  "signature": "yj03uvdtunzXOJMXJ7Y6VplbBzDitBaoV3T6WiiNOCBs912dpzC2jgm7vty/9gdLUsNQhHSypwwuXhbvhIk2AQ==.sig.ed25519"
}

{
  "previous": "%SNbftBoc4Mbq22hbezl5goKOEfoAiHTPN6avqvwRLAg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1144,
  "timestamp": 1538464343486,
  "hash": "sha256",
  "content": "o+NMvmkJGai+ElFWNZ9PGIi4iRyYQgTVHt/BT4P/Mk6VsxyCLn2DDLLwreXXcns4Bf3xOFyfDSusavlvq8wYlzTDy9r6v/9O/AepFzkQDszlvRSIS6n6D+eaxXHJvpGD7gBXdw6+Qvjb7f34wZjnxyhdkXvLPCaZ4aaGBk8uUfoi9b9yWvrrBvF2EFQH8PdN0c+bch5CMb2FWT58CDnwDN9gI3Fsrhbu1n73Whz2x3zC00XREcNK/opqXkjbzrKPU3+4A/Z1YJ+Wjt0JKBExUbNcjLEjOBpi5GIP52dbNLy6fig7PVaAC1TJ4Zn2RHtAEFqrIuf/4WW2qVLCKhMO40obRVD2gDaQQvf/g+C48K0GFloqZh79YI0zrYOE7G2vOAIt1+ZmHY8D2EzAFy0NKVzqGwW7HEqXwycSw6cfYKPCgx8PWk8At47o3F8Xyqqo8EMqWZDBYPluk47ZHEOuwCgN8N2DffgZASFzGiCQFK2cqpyZ2eTFL9jLZAWWACqLezkhbtLqpUEH7g3AOXiq9ckU5Xq74l8Kaw17uiK2YFvE8HYJ8AXi1w3FGZe2nmNJG1y4w2RaiYmZwbnPiz/Z2CkfjBGRtRBwXzyRPDESTSAwIrc+fZzr/GRSN9q9AydZTWAe9ZyZvSJn9AapLkRGpH535sQe0E+PxBnvGponTfCSzvWRgmPRadzrzUAgxS7KDy7XGrDTRcJG4wqbo6dMR7VYyMjoqXy6z1LBEuE8zmmyCXEhahVYZI0RYniLMaf3SqqJeu8kUhiVctqj+X7N+RXh45zk1ae5xgnty9d4mVx8UDAvpq04daq+mNNYjGSfpMkhOSAG7ftI+VWPr/TvUYefRNkS0LLQRgYI8a9Tzh7WpKMQEaBLQymSq1zWGDNDrx9nopBhIj+U7GQP5oZZwRL9CvCf/XSUcDXqVfazywKSnf6BCaUnV0LdFbvjVYtopUgn/ssTNrVtcVoi9384izHzW9lznOO5280+NExfZpc7WW5bjcdf0xHugDD3UiRsMl2VDdkLhXh5wYCfx01zpMHTfsXPiikbFuyd9YYBQ/YXnKPTATy35T5L17IZHcEUbRjPzR1l9eYTR7fPtOTTMz7vDtKMD/XqFTUWISMVdlLfVrxbYr7l1VM0MTV6z53fwASGTUJwEAV5JecEY532OmBGGRdM/TiQs/HVeXHalNX7D+jugxVR4Vv4MFLLyLz2pWF8Gld20XjewJJU1IDpJ0ZznwrYWLKCvsJpPvmVeBZj/bWuc28Vmyo+YI6dKvOJHp+CAXBOHWVaQIfOe58Dz07AHlRhr+eSxyVin23r9962Ac5OMfqkW65ZZ5S0nf493fSVcwCAqxSW9UTib9gbxFJTssaZ/40dW7fqHrNp1AZZQ4ME0lqYZnutrNovVbgHcOeWTHOZenmUucNph6Y0gPQpZ7yKGc+QBHi75JLo0Lr9bbsSx7Tnzt9Lk7oLRQK3b9fZ54a/QevDTYa/HPsbO+wGvTUrQcgXQB9TLTaGKGGYZccVVNzJHYIO9jpzRdMFr87JGL8eJSRXBl4Wlow7PvLfg3B5EJq3EMCalk8fgbObiO1iV9XXBig=.box",
  "signature": "X+zNRwiGLrg10cgnklH7pV4x38AtF6fr8Gi9Jt7dbbAmvJeBD8CRDjIFNfPDqTeXDA9AxF8/5Ct83IirQOOVCw==.sig.ed25519"
}

{
  "previous": "%t962awh+az5kT38bRd1cnaoAPfXYihQQ0HDeaDGZ+qI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1145,
  "timestamp": 1538511076008,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%SNbftBoc4Mbq22hbezl5goKOEfoAiHTPN6avqvwRLAg=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%SNbftBoc4Mbq22hbezl5goKOEfoAiHTPN6avqvwRLAg=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 02/10/2018\n\n- forked a [rust implementation](https://crates.io/crates/ryu) of the [Ryū](https://dl.acm.org/citation.cfm?id=3192369) floating point printing algorithm and modified the formatting to implement the ssb legacy float signing format. Most of the work was renaming the crate and modifying the tests. https://github.com/ssbrs/ryu\n- implemented a serializer for json-encoded legacy messages, supporting both the signing format and whitespace-less compact output for replication: https://github.com/ssbrs/legacy-msg/blob/master/src/json/ser.rs\n  - this was the hard part of the whole legacy message stuff\n- decided I won't implement legacy (De)Serialize for std types, and I won't provide derive Macros for these traits. The legacy format should only be used for verification/cypherlink computation of old messages, and that is done through a generic [Value](https://github.com/ssbrs/legacy-msg/blob/master/src/json/value.rs) type.\n- wasted a few hours trying to reuse the serde_json parser\n- started implementing a json parser. At least that minimizes dependencies and gives us full control that the parser does indeed recognize ECMA-404 (minus numbers that are invalid for ssb), the popular rust json parsers don't even bother specifying which standard they implement...\n\nNext goals:\n\n- finish the json parser\n- implement [Deserialize](https://docs.serde.rs/serde/trait.Deserialize.html) on the [legacy Value types](https://github.com/ssbrs/legacy-msg/blob/master/src/json/value.rs)\n- implement legacy encoding, hash computation and length checking in rust\n- use afl on the rust implementation to generate test cases\n- check whether the js implementation behaves the same way on those test cases, iterate until they match\n- specify legacy metadata\n- implement legacy metadata\n- hook everything together for message verification\n\nBonus goal:\n\n- js bindings to the verification function",
    "mentions": []
  },
  "signature": "eBHxxnxcK+VJiIh0FJQAy/cDHkKXgm88BbSFuq2BUriQYqyo5lzEaJBnoEo1I/fviiTRjzGeCXVl7jsFBqB5AQ==.sig.ed25519"
}

{
  "previous": "%ezmzK85DZ5mbG2bQcIFEl7a1kam1IPLM9FCSBfmmq8Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1146,
  "timestamp": 1538599801227,
  "hash": "sha256",
  "content": "mpYmQ7xlRhPJlKVw8BNQdM5buKItQZ/96WVr+zyjsyHlJMciPCj33ebrGIy2H7mr3jQBsoUm3hRev8l2gYEuXzHMoCtxAg4zc9dAa1D+kGIwyDtUso6ZQ54J6v7XjuDJiCeagp52glXuH+XhBMLsHco/IxPRltjxdx1DVVVl4vTTThB9zWMZskzVMmO3e0N4v2JyfrSiLnW8yKw0jpIA8DQ8AI7PknM/9utDWpEvMTYPLgm+eOwhnDLxZEH1olufpHe9a23ovp38R/YyjilsemUfyFl/OGDdTFqhyt4OT5rWTEy/39tPNCsAl2qPcp8tHpgD68iJtkRkZVf/arMuRU4FKVTtftQvWKeABmdn6w3o0TEzwPp5uDymwTJZ8QQopK9tYa1FcRhF3QM2eTSdsBiNn2eATJOGQt5DQv1nkIx0FudGvBpVQmfL7o/7LwwJfdaLx2r3jSdimaqLMbHgFi7//Jp8uS9+ZqgKv10EHn0m8/TMVX1UZz+lyWau0/BHqxtyDEfil5Z9TpbqALyttCaNQYMghDpjrqvv9wZyDcx+GBMIdSPpImWEsXbPaXHzCUjXYtjPe/EpizjO2Qz9yXmdAzF5/SZLiDl1U4tkZr9IZlwDAFz6saniMMJano3mW1+KcX7uostAYILXrZaeV2cHIffVWb/EoKNP4hM8H00tv2vJ94cQC1CQ9jsC6x0lkjUsi+36Y0Fkkr8BSBQDEaRDWDuhVFBKOyTpkNIqUmGRH4bhbeE9j0b87u/sf9AgavKLV5tgqLGe49LJQVsLgomMNhlYq2XPMaIV2x9AIFER6ewCMf1aLtN3A8O6Z4OgRAX2hGZiAsbTyKBgk7UGBhzOTRrsn+PST0PLVJZsCrwoERTJwLmyicaXnjn2Y/qzQabwDO3baaR2sn59RYxT42TABAt20fH4hgmjzzt2C5/joHR2b3asdaw0psowsPiQOsuDd39BdUUckafZHU0PtLY3HypXYRYQbEnWt5t8Mvjt+XVAeDywh5YTtyag3aWAHz1WLXGm1CismrXMP14RDr3iCQ0evw6RolZivFWzzyIqHzpXPGMPFIJrANv/.box",
  "signature": "Z1VPxggNjZ9nzHOsvGw2uBPLVvt79kVYVip79Xywd1MXxepwTsn6UpDzLfn8Z/3n+brHhTyrCq/7E+MA7XlJAg==.sig.ed25519"
}

{
  "previous": "%BxscMwMJMF3xB1OiOje6SymoTC6DKsEIs09/xNsxofI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1147,
  "timestamp": 1538604540134,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%ezmzK85DZ5mbG2bQcIFEl7a1kam1IPLM9FCSBfmmq8Q=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%ezmzK85DZ5mbG2bQcIFEl7a1kam1IPLM9FCSBfmmq8Q=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 03/10/2018\n\n- Unicode is fun! A format that must be utf-8 encoded but handles escape sequences as ascii encodings of utf-16 code units is fun! A format that handles escape sequences for code points larger than `U+FFFF` by doing two four-byte escapes and treating them as a utf-16 surrogate pair is fun! Unicode is Fun! Json is a simple format!\n- implemented the json parser (more precisely, implemented the Deserializer trait): https://github.com/ssbrs/legacy-msg/blob/master/src/json/de.rs\n- implemented Deserialize for the Value and ValueOrdered type: https://github.com/ssbrs/legacy-msg/blob/master/src/json/value.rs\n\nI haven't run a single line of this code, but in theory we can now encode and decode arbitrary json legacy data values.\n\nNext steps:\n\n- get enough sleep\n- run all the lines of code\n- ideally via afl\n- fix all the errors\n- create a setup to verify identical behavior of nodejs and rust implementation\n- implement hash computation and length computation\n- extend the js compatibility verification for hashes and length\n- extract a test data set\n- prettify rust code, create readable documentation\n",
    "mentions": []
  },
  "signature": "Vh8T9akc2gUiS776iZUgI1kLan2Zi+afeGcne3jCgy6GiyVfIpxCFKAi975lB/qcP0wOl5JgjHhlzX9D0dHrDA==.sig.ed25519"
}

{
  "previous": "%AFLMLHLG/ALnOgljKlPN/AlAfTFO9vfOfmxJ52Q4TM4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1148,
  "timestamp": 1538606251186,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%g3hPVPDEO1Aj/uPl0+J2NlhFB2bbFLIHlty+YuqFZ3w=.sha256",
    "branch": "%SPTdvqAxoyrq6NUGAga8ddzPwi4GJZx5N9J6dmWHgo0=.sha256",
    "reply": {
      "%g3hPVPDEO1Aj/uPl0+J2NlhFB2bbFLIHlty+YuqFZ3w=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
      "%SPTdvqAxoyrq6NUGAga8ddzPwi4GJZx5N9J6dmWHgo0=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "I'm not really adding anything here, just trying to make a few things explicit that I felt were implicit in your post, that might be useful for framing this discussion. I think there are a few different levels to look at here.\n\nOn the protocol level, there only three sigils: `@, %, &`. The channel `#` is purely a UI construct used by the current mainstream social media applications built upon ssb.\n\nThere's an unfortunate situation where the reference implementation stores a bunch of different things in the same, stringly typed data structure. But conceptually, cypherlinks (`\"%foo.hash\"`), feed ids (`\"@bar.key\"`) and blob id (`\"&baz.hash\"`) are completely different (and then there are also signatures that use a similar string-based representation). Channels are nothing like the others. These stringly typed representations have leaked into the UI, or maybe it was the other way around.\n\nBesides the protocol layer, there's the UI. For UIs, sigils have some advantages over URIs, e.g. typing a single char lets the application pop up the correct auto-completion menu. And reading them is more pleasant, especially if most of the actual data is redacted.\n\nWhere URIs shine are as a format primarily intended for machines, but still human-handable (i.e. non-binary). Standardizing these will be really useful, but they can coexist for sigils for the UI.\n\n---\n\nSomewhat related: The canonical human-readable format of the [yamf-pubkey](%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256) draft.\n\n---\n\nRandom aside:\n\n> URIs are simple [...]\n\n[Are they?](https://tools.ietf.org/html/rfc3986#page-2)\n",
    "mentions": [
      {
        "link": "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256",
        "name": "yamf-pubkey"
      }
    ]
  },
  "signature": "65cW+o+YaqathJGq7Ej2CFPeto93uYKOSIrqFGxqS5uQsQ4jHlChFzuMoeXzChzgZLktpfsD/qCgQ60iIs7oBw==.sig.ed25519"
}

{
  "previous": "%EgvVBGQATePQ03+mk+GZNpe2M28rtucI948xcSA2q3o=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1149,
  "timestamp": 1538649662369,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb-clients",
    "vote": {
      "link": "%gezYf2XKLcVLq4zHlBH49Hpoz1KH10lKuSsV3AQp9nQ=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "Xm+e63O2CHN3dL6E9dWTuNgiKDk0qKaep4rEH7xGJUQcnTmcveOiq3E5TRnum0RM/YSm7Hr7ke/gKxxQL2zODw==.sig.ed25519"
}

{
  "previous": "%sGd6JD8x5fTViZ2sqxfr1wObB16KHlx3eBkHVcCk+mc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1150,
  "timestamp": 1538649746657,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256",
    "branch": "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256",
    "reply": {
      "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "yamf",
    "recps": null,
    "text": "Linking so I don't forget this when coming back to this: %gezYf2XKLcVLq4zHlBH49Hpoz1KH10lKuSsV3AQp9nQ=.sha256",
    "mentions": [
      {
        "link": "%gezYf2XKLcVLq4zHlBH49Hpoz1KH10lKuSsV3AQp9nQ=.sha256"
      }
    ]
  },
  "signature": "7GuOjaRCd3mG6w5XmxBD7Emoerpic9EMMgCZ2TnVnQvGU5Lvvix7GJXgw287tyuZ3XnRB43+R2CO6KFDuEAPAg==.sig.ed25519"
}

{
  "previous": "%kve6gSAQVk072++2ImbzpB8WnhtQyrjwg0iM+kWaMbk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1151,
  "timestamp": 1538650108742,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%dtq8ag0+ywIa4qGyTMF7rE7xFpMQJxDvg9JvOK/CtS4=.sha256",
    "branch": "%2PNzqbmXzw8yUwlleMac56Spx44QJfw2Tu8ozRUnNVY=.sha256",
    "reply": {
      "%dtq8ag0+ywIa4qGyTMF7rE7xFpMQJxDvg9JvOK/CtS4=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
      "%2PNzqbmXzw8yUwlleMac56Spx44QJfw2Tu8ozRUnNVY=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "sunrise-choir",
    "recps": null,
    "text": "# sunrise choir - 04/10/2018\n\n## attendees\n\n- Aljoscha\n- mikey\n\n## agenda\n\n- [x] regular time slot for calls\n- [x] licensing (agpl vs natifying sbot (MIT))\n- [x] ssb spec format and hosting (stable hyperlinks)\n- [x] feedback: spec wording and code review\n- [x] overview of rust impls, part of spec or separate?\n- [x] binding creation documentation/examples\n\n## why timestamps bother alj\n\nalj: ssb is subjective, new concept!\n\nalj: why does everyone insist on objective timestamps?\n\n## alj and mik agreed on a monthly contract\n\nbest way for alj to legally do work.\n\n5k USD per month.\n\nalj will try to do 20 days per month.\n\n## regular time slots for calls\n\nmik: keen for monday, tuesday, wednesday evening nz time\n\nalj: flexible, want something regular\n\nalj: would like if started at 9am berlin time (8pm nz time)\n\n## licensing\n\nalj: current rust code is AGPL. sbot is MIT.\n\nalj: if we rust-ify sbot, then sbot would need to be AGPL too.\n\nmik: this might really be a question of governance: what is our (legal) strategy with respect to Scuttlebutt code assets?\n\nmik: for now, maybe stick with AGPL, but ensure that those who contribute (copyright) are willing to change in the future if necessary.\n\nACTION: mik will start a conversation about this\n\n## stable hyperlinks\n\nalj: want to refer to section -> subsection -> blah by url\n\nPut more abstractly: Want to refer to specific ssb concepts in a machine-readable way. The web is just an (obvious) implementation detail.\n\nmik: could offer spec.scuttlebutt.nz or spec.scuttlebutt.rs\n\n- what's domain do we use?\n    - scuttlebutt.rs?\n- how do we make html?\n    - GitBook for now\n\n## code review\n\nalj: want to convey good overviews and understanding.\n\nalj: want feedback.\n\n- am i being precise enough?\n- do i cover everything that needs to be convered?\n\nalj: leaning towards being as precise as ~~possible~~ necessary.\n\n## rust impl part of spec\n\nalj: should we link to the rust impl from the spec as a reference implementation?\n\nalj: a story of three parts:\n\n- spec\n- implementation\n- test cases\n\nalj: should we link them all together?\n\nmik: yes!\n\n## should we document for binding creation?\n\nalj: for example: how do i let the parser decode into other native objects?\n\nalj: should we maintain bindings?\n\nmik: yes we should maintain JavaScript bindings, but can happen later when we try to integrate into jsbot\n\nmik: for example: https://github.com/pietgeursen/private-box-native. what's especially interesting is the use of prebuild so people can use our rust native modules without a rust toolchain.\n\n",
    "mentions": []
  },
  "signature": "aY59PawPIA4UnHRCXB7bKJPb6CRx18TFjY5ldorT8CtQU28v94fuZJlDYWkVutnR+dceUUSdVhoyLhxAN9+NBQ==.sig.ed25519"
}

{
  "previous": "%6uhFP/GRaWgce0kTt33OAZvDcEaCrX1NiG5ueHHc6qI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1152,
  "timestamp": 1538672041296,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%g3hPVPDEO1Aj/uPl0+J2NlhFB2bbFLIHlty+YuqFZ3w=.sha256",
    "branch": "%/6g/wI0hrB0OnLh8NtMlhPe0wmkzPC2HX1a08dyyTO4=.sha256",
    "reply": {
      "%g3hPVPDEO1Aj/uPl0+J2NlhFB2bbFLIHlty+YuqFZ3w=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
      "%/6g/wI0hrB0OnLh8NtMlhPe0wmkzPC2HX1a08dyyTO4=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Immediate reactions (sorry for the nitpicking instead of properly engaging =/, I feel like there's a lot of js-client background I'm missing to fully engage with these proposals)\n\n- these URIs are in no way tied to web technologies. A lot of your reasoning seems very focused on the current client landscape. Both the \"nested applications\" and \"href\" considerations feel short-term-ish to me\n- what is \"*the* markdown renderer\"?\n- might make sense to put message types into URIs so that handlers can easily decide whether to engage with the URI at all\n  - something to keep in mind: message types are not necessarily url-safe\n- my first instinct is to register a system-wide, single ssb-URI handler, and then let plugins/clients/applications register themselves with that handler, so that it can forward them. That means that URIs can stay somewhat simple because there are no competing handlers on the os level",
    "mentions": []
  },
  "signature": "tC8KAJKFkM1MmgQEexNshoI98r8EwXWQnvc/fuSxEqrK++PaXpLUHkevyCaQ4p0g+fqoCHRWhgIOKJNSBZ/TAQ==.sig.ed25519"
}

{
  "previous": "%A9lLLOnkFn/xsuROeatAck8Egp/BM592D0i5Q8HHLuQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1153,
  "timestamp": 1538686112594,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%AFLMLHLG/ALnOgljKlPN/AlAfTFO9vfOfmxJ52Q4TM4=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%AFLMLHLG/ALnOgljKlPN/AlAfTFO9vfOfmxJ52Q4TM4=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 04/10/2018\n\nToday was somewhat grindy, chasing a lot of errors.\n\n- talked: %6uhFP/GRaWgce0kTt33OAZvDcEaCrX1NiG5ueHHc6qI=.sha256\n- failed to set up afl for rust: https://github.com/rust-fuzz/afl.rs/issues/141\n- set up [cargo-fuzz](https://fuzz.rs/book/cargo-fuzz.html): https://github.com/ssbrs/legacy-msg/commit/57b8767b861d4762b1374b9737bd98dc3f0de8e3\n\nFuzzers are magical, this is all the test code I wrote to weed out errors in the json parser:\n\n```rust\n#![no_main]\n#[macro_use]\nextern crate libfuzzer_sys;\nextern crate ssb_legacy_msg;\n\nuse ssb_legacy_msg::json::{from_slice, Value, to_vec};\n\nfuzz_target!(|data: &[u8]| {\n    match from_slice::<Value>(data) {\n        Ok(val) => {\n            let sign_json = to_vec(&val, true);\n            let redecoded = from_slice::<Value>(&sign_json[..]).unwrap();\n            assert_eq!(val, redecoded);\n        }\n        Err(_) => {}\n    }\n});\n```\n\n- fixed everything the fuzzer found in a few seconds of running: https://github.com/ssbrs/legacy-msg/commit/f2cb1656d2bcb3283a6775ddd30e2cfac745c5b0\n\n- the fuzzer found that `f64::from_str` erroneously rejects some long numbers such as `11111111111111111111111111111111111111111111111111111111111111111111111111e-323` (which can still be precisely represented as an f64). Guess I'll now have to look into float deserialization...\n  - [strtod](https://crates.io/crates/strtod) to the rescue, there are a few [remaining problems](https://github.com/pvginkel/strtod/issues/3), but those are easily fixed\n  - started fuzzing `strtod`, because why not: https://github.com/ssbrs/strtod/blob/master/fuzz/fuzz_targets/fuzz_target_1.rs\n- implemented the weird utf16/latin1 encoding that skips a bunch of bytes that is used for hash computation\n- created a script for generating test data for legacy json messages: https://github.com/sunrise-choir/legacy-msg-js/blob/master/index.js\n- ran that script over the corpus produced by fuzzing the rust roundtrip encoding/decoding\n- created a rust executable that tests conformance of the rust impl with this test data\n  - not published yet because it  loads some code from the file system for a faster feedback loop\n  - still a few errors to fix, but not today...\n\nNext steps:\n\n- fix the remaining errors so that the rs implementation is compliant with the js one\n- a lot more fuzzing, then minimize the corpus, generate test data, and publish a test suite\n- decide on an order in which to do the remaining legacy message work:\n  - spec and impl json metadata\n  - clean up the code\n  - clean up the specs\n  - define and implement cbor encoding for legacy messages\n  - js bindings?\n",
    "mentions": [
      {
        "link": "%6uhFP/GRaWgce0kTt33OAZvDcEaCrX1NiG5ueHHc6qI=.sha256"
      }
    ]
  },
  "signature": "8vBgpDcrLy98ZtiYqIZle82eBZkFjqUyqX3WFRMu1SsejSYWOh5+vBSCnyJPBeG0jl7WhwR05+f9wEWAbiqvDQ==.sig.ed25519"
}

{
  "previous": "%8C4muzwvOywlOEeK4UFgsikK5OT8+Tk9BdkGrcX+gsk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1154,
  "timestamp": 1538725869678,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%L3sTXRyH0N20R4624x1ebJigtn1zMmsvxXtXrcZN3HI=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%L3sTXRyH0N20R4624x1ebJigtn1zMmsvxXtXrcZN3HI=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Yeah, those two are equal. Parsing it may actually result in a different float, but rounding works for both serialization and deserialization.",
    "mentions": []
  },
  "signature": "twgbrdOFdwIB1TDNL/Pr0t43Pam5iQFuUc5fBtFqVkcFAaScfdnMdrHtk/OHcjJCry0FxAsupgnEnV+cuwZYBQ==.sig.ed25519"
}

{
  "previous": "%qHIsyGax1AV3DNPXF4Cjyd7dvqPgPSl8fENxKc6xDoI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1155,
  "timestamp": 1538739047292,
  "hash": "sha256",
  "content": {
    "type": "post",
    "text": "Did you know that the byte sequence `[34, 228, 166, 164, 110, 237, 166, 164, 44, 34]` (`\"䦤n���,\"`, quotes are part of the string itself) is considered valid utf8 by ECMAScript, but not by the rust std library? By extension, js claims that this is valid json, my rust json parser claims it isn't. One of those two has to be buggy. I really hope it is the rust standard library, or else we will have to put those errors into the ssb spec.\n\nAt least I'm gaining confidence that my testing process is thorough enough...",
    "mentions": []
  },
  "signature": "YVtCWvif9Nzww4Yh0eYqrSYQSee8zYUF+5lvhxUHrsYTqODt+Dpo1Y+arLt4zXS41lKhGi57d68HqCb/OAZHAg==.sig.ed25519"
}

{
  "previous": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1156,
  "timestamp": 1538743647334,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%MlU8AXuf3q77tubFfxD0308VDLBhbTySup0F64MF4vY=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "X0F5Zr3yhrGaCk4/pgxwoDyU0wWCf7vV4siQIcsnjxL2/ioenWmr6tB44fHlbRZtDPoQNVjtohjPEGe0+BK4Bg==.sig.ed25519"
}

{
  "previous": "%FK64PnjsRnWSPSZJyf+uGBo2dGWNe5cSrctGwLPVBaw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1157,
  "timestamp": 1538745600786,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%MlU8AXuf3q77tubFfxD0308VDLBhbTySup0F64MF4vY=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%MlU8AXuf3q77tubFfxD0308VDLBhbTySup0F64MF4vY=.sha256": "@RuNxm8SRujPcJx6GjtTQHp6hprAFv5voEkcvoAkB8Pk=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "So much fun: https://github.com/rust-lang/rust/issues/54845\n\n> Ok, I think I understand it now: It is a valid utf8 encoding of a unicode code point, but the code point happens to not be a valid [unicode scalar value](http://www.unicode.org/glossary/#unicode_scalar_value) (which is what rust `char`s are).\n> \n> Follow-up question (if you don't mind me derailing this):\n> \n> Wikipedia says:\n> \n> > Since RFC 3629 (November 2003), the high and low surrogate halves used by UTF-16 (U+D800 through U+DFFF) and code points not encodable by UTF-16 (those after U+10FFFF) are not legal Unicode values, **and their UTF-8 encoding must be treated as an invalid byte sequence**.\n> \n> Does that mean that nodejs decoding a buffer of those utf8 bytes into a string without complaining is a unicode violation?\n\nI'm not sure I fully understand the interplay of all the involved specs here (unicode, utf8, utf16, ECMAScript JSON.parse, ECMA-404 aka json), but if this is actually a bug in nodejs, we'll need to decide whether we want to\n\n- explicitly allow utf8 encodings of surrogate half codepoints, or\n- stick to valid unicode and change the js implementation\n\nI'd strongly advocate the latter option, but that would break all feeds containing messages that store [invalid unicode code points](https://en.wikipedia.org/wiki/UTF-8#Invalid_code_points) in json strings. Which quite likely is only my own feed, unless anybody else has also pasted some very abstruse strings into their posts...\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519), [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519), [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "vwgRW82+TE0CdZfXt6pY02zo+cGGAaX9TWrSfgEEPMfgWHkI55QnTBs3sPStrBQxUkDi5DAWTag6AWmGNTheCA==.sig.ed25519"
}

{
  "previous": "%GECd9ubBG82NEHQMGWRcj308vbMORNzVsxaDdf7w5Rk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1158,
  "timestamp": 1538746385326,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%GECd9ubBG82NEHQMGWRcj308vbMORNzVsxaDdf7w5Rk=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%GECd9ubBG82NEHQMGWRcj308vbMORNzVsxaDdf7w5Rk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Okay, I'm off to reading the [wtf-8](https://simonsapin.github.io/wtf-8/) spec, which might be what ssb accidentally uses. Quoting the first two paragraphs of the wtf-8 spec, to give you an idea of how great that would be:\n\n> WTF-8 is a hack intended to be used internally in self-contained systems with components that need to support potentially ill-formed UTF-16 for legacy reasons.\n>\n> Any WTF-8 data must be converted to a Unicode encoding at the system’s boundary before being emitted. UTF-8 is recommended. WTF-8 must not be used to represent text in a file format or for transmission over the Internet.\n\nLet us hope I'm somehow terribly wrong about all of this.",
    "mentions": []
  },
  "signature": "IRlpLYGdrTbzqkRf79o0AAEJYAaMFp5apIIhyJQtmE2Gt9Oopb63S0tiZPMi1ovc0HLt9iZuofq6eLiE/UC4AQ==.sig.ed25519"
}

{
  "previous": "%7b7QeCvaJfrof8++oK590199jr+l0gWK9RKCxqAA9pY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1159,
  "timestamp": 1538748393031,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%PwsL6VMEqaFOf21ZOHiHhrJS5RaRHrQmIIA3w95fBMU=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%PwsL6VMEqaFOf21ZOHiHhrJS5RaRHrQmIIA3w95fBMU=.sha256": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Filed a [nodejs issue](https://github.com/nodejs/node/issues/23280), let's see how they react. If this is indeed a bug, maybe you could go ahead and do a bug report on the go side of things.",
    "mentions": []
  },
  "signature": "UZOpOqVafBRYP/XeMZOCC2K92ju4e1CFguLWuK2fiwsJLcfqlY+YqfOc8vBVpgl/uFMw4oQyTWveHFq8ueh1Cw==.sig.ed25519"
}

{
  "previous": "%3b+Xn4mGgmqx1iK5PI8sZpzoBjjZF1B7Yb2ojYkCMzU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1160,
  "timestamp": 1538751012597,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%3b+Xn4mGgmqx1iK5PI8sZpzoBjjZF1B7Yb2ojYkCMzU=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%3b+Xn4mGgmqx1iK5PI8sZpzoBjjZF1B7Yb2ojYkCMzU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Ok, the string I pasted into my message just contains the replacement character `U+FFFD`, not any invalid utf8, so that's a plus, my feed won't be broken.\n\nTurns out `Buf.toString` doesn't check validity at all, it even returns a string for `Buf.from([255], 'utf8').toString('utf8)`. Which is technically allowed, since [js strings](http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.16) are not required to be valid unicode.\n\nThe mismatch happened because I used `Buf.toString` for my test data generation, I'll need too look at what exactly the js ssb implementation does. Maybe this is actually handled correctly and all of this was just a false alarm.",
    "mentions": []
  },
  "signature": "kcHqjK9BkD7DJ6SDc3mz2zlQBhL3lwdAJ11VF2VLu9HwB+t/gLW+b4jcTKSBTVJipIDCs1sNsLwZhLnIM3Y6Aw==.sig.ed25519"
}

{
  "previous": "%tUOwdQ482+SlFsRd77Y45NSb/ytaetUVOaQz5I9HSOo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1161,
  "timestamp": 1538751858253,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%tUOwdQ482+SlFsRd77Y45NSb/ytaetUVOaQz5I9HSOo=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%tUOwdQ482+SlFsRd77Y45NSb/ytaetUVOaQz5I9HSOo=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "The js codebase remains as impenetrable to me as ever. If anybody could point me to where the conversion from byte buffers into strings happens, I'd be very grateful.",
    "mentions": []
  },
  "signature": "1SMA8nbRIZ45eKvCKtTEVO5s3fJc2+1y5NtCWWmpw5jV4D+Bhli+TFlHOHTTenKVvtqM+KZeOAdjgMBW+yh2BQ==.sig.ed25519"
}

{
  "previous": "%T5O1h0ZrWB4dZJq1FFliwUls0JH4HUVx5XgQ21i85nM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1162,
  "timestamp": 1538754386171,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%tUOwdQ482+SlFsRd77Y45NSb/ytaetUVOaQz5I9HSOo=.sha256",
    "reply": {
      "%tUOwdQ482+SlFsRd77Y45NSb/ytaetUVOaQz5I9HSOo=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%T5O1h0ZrWB4dZJq1FFliwUls0JH4HUVx5XgQ21i85nM=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Clarification: `Buffer.toString` does not emit invalid strings, it just replaces invalid byte sequences with the unicode replacement character U+FFFD : https://github.com/nodejs/node/issues/23280#issuecomment-427402427\n\nSo if that is what happens in the js implementation, then things are actually fine I guess. In any case, I'm done for today, I really hope someone knows or can find out what js ssb does.",
    "mentions": []
  },
  "signature": "jZWESIyexEn8YsUGVOfakMzaQUih7MTDKGpuPtKVYhTh6aFPtR/FhuzLe/dgnzRYBXbzNscxueKUL3GbrQT1CQ==.sig.ed25519"
}

{
  "previous": "%bd96n3wGwweq6PnWTyVCMO8zUe17nllRbEItxJRsnGg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1163,
  "timestamp": 1538754529531,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%8C4muzwvOywlOEeK4UFgsikK5OT8+Tk9BdkGrcX+gsk=.sha256",
    "reply": {
      "%8C4muzwvOywlOEeK4UFgsikK5OT8+Tk9BdkGrcX+gsk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%L3sTXRyH0N20R4624x1ebJigtn1zMmsvxXtXrcZN3HI=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 05/10/2018\n\n- found out the float parsing bug in the rust std library was already known for two years, but nobody bothered to document it: https://github.com/rust-lang/rust/issues/54843\n- quickly sketched a spec for the cbor subset suitable for representing legacy messages: https://github.com/sunrise-choir/spec/blob/master/spec.md#cbor-encoding-of-legacy-data\n- fixed the hopefully last mismatches between js and rust legacy message handling, except for the unicode decoding issue:\n  - https://github.com/rust-lang/rust/issues/54845\n  - https://en.wikipedia.org/wiki/UTF-8#Invalid_code_points\n  - %NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256\n  - https://simonsapin.github.io/wtf-8/\n  - https://github.com/nodejs/node/issues/23280\n\nThis was not a fun day of work. The most productive thing might have been the fuzzers running in the background =/\n",
    "mentions": [
      {
        "link": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256"
      }
    ]
  },
  "signature": "LpWdGpQYYyM8jv4Wa7Ps8Za3GdtCYvpN495KHJQDBrk1ZDorDuCu1wkVCMQGTQHxoOC6BJP6S8ULO2QcTCz4CA==.sig.ed25519"
}

{
  "previous": "%TupGHyN+zrXoLesJsmf5fm0pib/kxMH10I3BWjwbL+k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1164,
  "timestamp": 1538776789126,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%bd96n3wGwweq6PnWTyVCMO8zUe17nllRbEItxJRsnGg=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%bd96n3wGwweq6PnWTyVCMO8zUe17nllRbEItxJRsnGg=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "If the js implementation is just replacing invalid utf8 with U+FFFD, then only the transport encoding is affected, and there are two ways forward:\n\n- change the current ssb implementations to treat non-utf8 json as invalid instead of silently patching it, and make that the spec\n  - let's do that one, I'd hate to always say \"its a json subset except that invalid utf8 is ok for stupid reasons\"\n- make the replacement part of the spec, with the weird consequence that strings which actually contain U+FFFD in a string can then be encoded by substituting any non-utf8 byte sequence instead. Implementations would be required to e.g. decode `[34 255 34]` into the string `\"�\"`...\n\nTo fix the js implementation (if it turns out to do the silent character replacement), use code such as `new TextDecoder('utf-8', { fatal: true }).decode(Buffer.from([34, 255, 34]))`, which errors on invalid utf8.",
    "mentions": []
  },
  "signature": "3cGVSg++uGhW+65GaycKHdDCxXaVHquXZcfjjPsx+LgY0yv3+ABJM8fJZ69VqKQKSflpYSEFnL0EEHsz0kgOCg==.sig.ed25519"
}

{
  "previous": "%7cFmte5ThRzZ/0dLYsHL3AZHhYXzL1XiMCTsRp0NqQ8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1165,
  "timestamp": 1538814641443,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebutt",
    "text": "# SSB Message Signing is Fun!\n\nTurns out there is a whole new class of strings for which `JSON.stringify(JSON.parse(str)) === str` does not hold: Node does not preserve object key order in all of these cases. The one I (or rather the fuzzer) found is `JSON.stringify(JSON.parse('{\"!\":2,\"66[[\":2,\"6[[\":2,\"\":3,\"0[al|\":3,\"6[\":2,\"6\":266}'), null, 2)`, which yields (cleaned up escaped quotes for readability)\n\n```json\n{\n  \"6\": 266,\n  \"!\": 2,\n  \"66[[\": 2,\n  \"6[[\": 2,\n  \"\": 3,\n  \"0[al|\": 3,\n  \"6[\": 2\n}\n```\n\ninstead of the expected\n\n```json\nrs: {\n  \"!\": 2,\n  \"66[[\": 2,\n  \"6[[\": 2,\n  \"\": 3,\n  \"0[al|\": 3,\n  \"6[\": 2,\n  \"6\": 266\n}\n```\n\nIf a non-js implementation used the order-preserving signing encoding to compute the signature, and then sent the message over the wire to sbot, then sbot would reject it as invalid. This is not good.\n\nI see three ways out:\n\n- burn everything to the ground\n  - as much as I want to do this, it's not really an option\n- reverse-engineer the js behavior and make it part of the spec by disallowing to send messages over the wire where the object order might change upon the `JSON.parse -> JSON.stringify` roundtrip.\n  - this is horrible for obvious reasons\n- change the behavior of the js implementation to use a custom, order preserving parser when decoding json messages received over the wire\n  - since this only affects the transport encoding, it is not a breaking change to the core protocol\n  - I've heard rumours of a rust implementation that could serve as a drop-in replacement for `JSON.parse` and `JSON.stringify` once js bindings are written\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519) [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519)\n\n[@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519), [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519), [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519): Could you check how your implementations deal with this message?\n\n---\nA bunch of test data for implementors:\n\nInput:\n```\n{\"!\":2,\"66[[\":2,\"6[[\":2,\"\":3,\"0[al|\":3,\"6[\":2,\"6\":266}\n```\n\nInput as hex byte array:\n\n```\n[7b, 22, 21, 22, 3a, 32, 2c, 22, 36, 36, 5b, 5b, 22, 3a, 32, 2c, 22, 36, 5b, 5b, 22, 3a, 32, 2c, 22, 22, 3a, 33, 2c, 22, 30, 5b, 61, 6c, 7c, 22, 3a, 33, 2c, 22, 36, 5b, 22, 3a, 32, 2c, 22, 36, 22, 3a, 32, 36, 36, 7d]\n```\n\nNodejs signing output:\n```\n{\n  \"6\": 266,\n  \"!\": 2,\n  \"66[[\": 2,\n  \"6[[\": 2,\n  \"\": 3,\n  \"0[al|\": 3,\n  \"6[\": 2\n}\n```\n\nNodejs signing output as hex byte array:\n```\n[7b, a, 20, 20, 22, 36, 22, 3a, 20, 32, 36, 36, 2c, a, 20, 20, 22, 21, 22, 3a, 20, 32, 2c, a, 20, 20, 22, 36, 36, 5b, 5b, 22, 3a, 20, 32, 2c, a, 20, 20, 22, 36, 5b, 5b, 22, 3a, 20, 32, 2c, a, 20, 20, 22, 22, 3a, 20, 33, 2c, a, 20, 20, 22, 30, 5b, 61, 6c, 7c, 22, 3a, 20, 33, 2c, a, 20, 20, 22, 36, 5b, 22, 3a, 20, 32, a, 7d]\n```\n\nOrder-preserving output:\n```\nrs: {\n  \"!\": 2,\n  \"66[[\": 2,\n  \"6[[\": 2,\n  \"\": 3,\n  \"0[al|\": 3,\n  \"6[\": 2,\n  \"6\": 266\n}\n```\n\nOrder-preserving output as hex byte array:\n```\n[7b, a, 20, 20, 22, 21, 22, 3a, 20, 32, 2c, a, 20, 20, 22, 36, 36, 5b, 5b, 22, 3a, 20, 32, 2c, a, 20, 20, 22, 36, 5b, 5b, 22, 3a, 20, 32, 2c, a, 20, 20, 22, 22, 3a, 20, 33, 2c, a, 20, 20, 22, 30, 5b, 61, 6c, 7c, 22, 3a, 20, 33, 2c, a, 20, 20, 22, 36, 5b, 22, 3a, 20, 32, 2c, a, 20, 20, 22, 36, 22, 3a, 20, 32, 36, 36, a, 7d]\n```\n",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "CjzYoJDJOfuYdp9jxO/cuciEk0EjfrMl26LJUx08+pf3CQc84tQuR78odQNNoVJSuLBYpMFHvWvEPT0x4IbiDQ==.sig.ed25519"
}

{
  "previous": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1166,
  "timestamp": 1538814973145,
  "hash": "sha256",
  "content": {
    "type": "about",
    "about": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
    "description": "[Does ssb protocol work.](%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256)"
  },
  "signature": "vG6dp269TsaGusWzbgm4QUEz5/79IrSnNbsU5a5uNAPTH58lbTmirImEZ6KXKP1Nw+IXbEmMVvFe5KejbIBUDg==.sig.ed25519"
}

{
  "previous": "%TbnmUv/hAoZAstS9GzgA3/h0lYT+bkhlSjFSHx3HAqM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1167,
  "timestamp": 1538822531976,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": [
      "%TupGHyN+zrXoLesJsmf5fm0pib/kxMH10I3BWjwbL+k=.sha256",
      "%qHIsyGax1AV3DNPXF4Cjyd7dvqPgPSl8fENxKc6xDoI=.sha256"
    ],
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%TupGHyN+zrXoLesJsmf5fm0pib/kxMH10I3BWjwbL+k=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 06/10/2018\n\n(Not a full day of work)\n\n- Fun, so much fun! %ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256\n- Aside from the two blocking issues on the js side of things ([utf8 decoding](%7cFmte5ThRzZ/0dLYsHL3AZHhYXzL1XiMCTsRp0NqQ8=.sha256) and [object entry order](%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256)), the rust implementation of json legacy message content is [now](https://github.com/ssbrs/legacy-msg/commit/8851bb53b5f0ebdab97f58f85ddee53ca09aa206) fully functional and passes the couple of thousand test cases the fuzzer generated.\n\nNext up:\n\n- bother [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) until [utf8 decoding](%7cFmte5ThRzZ/0dLYsHL3AZHhYXzL1XiMCTsRp0NqQ8=.sha256) and [object entry order](%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256) are resolved in js ssb\n  - optional subgoal: create js bindings to the rust json codec for usage by js ssb, if so desired (warning: AGPL code, but I might be willing to relicense it if that helps js ssb to do order-preserving json decoding in rpcs)\n- publish the test data (depends on how utf8 decoding and object entry order get resolved)\n- implement the cbor encoding of legacy message data\n\nI'll do the cleanup, thorough documentation , and actual releases, once both json and cbor legacy message data are fully specified and implemented. I'll tackle legacy metadata afterwards. And when that is done, it's time for #hsdt",
    "mentions": [
      {
        "link": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256"
      },
      {
        "link": "%7cFmte5ThRzZ/0dLYsHL3AZHhYXzL1XiMCTsRp0NqQ8=.sha256",
        "name": "utf8 decoding"
      },
      {
        "link": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256",
        "name": "object entry order"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%7cFmte5ThRzZ/0dLYsHL3AZHhYXzL1XiMCTsRp0NqQ8=.sha256",
        "name": "utf8 decoding"
      },
      {
        "link": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256",
        "name": "object entry order"
      },
      {
        "link": "#hsdt"
      }
    ]
  },
  "signature": "Ed3jvmXGPT8YHDWn9QzpdbgE/mW/XkHjkb7XTsW3E1hN3c+gRxjMIS917CvCqsjx9k7/E6diAwfeBb7G2cBBDg==.sig.ed25519"
}

{
  "previous": "%O8aEFQ3FJQir6ogLs5KA/+BDM+NnceR3eIbzXnlCBEA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1168,
  "timestamp": 1538919558619,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256",
    "branch": "%PTfhJQBitYFEJOZ6SHG6Ltx1KWv7wznoOJssKdHxPe0=.sha256",
    "reply": {
      "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%PTfhJQBitYFEJOZ6SHG6Ltx1KWv7wznoOJssKdHxPe0=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n> natural numbers (positive integers and zero) are first, so \"6\" is first, because it's a valid integer. the rest of those keys are not valid integers:\n>\n> numbers that are not valid natural numbers are encoded as strings and lexicographically sorted.\n\nThe output on my test message is definitely not lexicographically sorted for the non-integer keys. Can you point to a source for the deserialization order you claimed? Is it part of the ECMAScript spec, or just an implementation detail of node? Does node guarantee that behavior, or might it change?\n\n---\n\nAbout the scope of this issue: This is not part of the core message format, instead this is a detail of the rpcs sbots use to send messages to each other. But in practice, this forces signature computation to use the exact same object entry ordering, or all sbots will reject the message, since they will compare the message's claimed signature against the signature they got by using the ordering emitted by `JSON.stringify(JSON.parse(str), null, 2)`. **If we don't change the sbot rpcs but don't understand the entry ordering procedure either, it becomes _impossible_ to write non-js implementations** (and the js one could break on us with any new node version, at which point the **scuttleverse would fork**).\n\nWe really should change the rpcs to use a decoding procedure we actually understand. And since we need to support those legacy messages for which we do not understand the entry order, we should let is simply use the entry-order of the input when computing the signing format.\n\n---\n\nThis is a pretty serious issue, can I please get back an ack that you are fully aware of the consequences [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)? Your previous post reads like you don't see a problem here.\n\nCC [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519), [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519), [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "tbU9s+xI/lEEw8+fuST1XJlGWaeLCKUu0IE2AD9MFbY1SPGh+JdI/HMz3bqtB8kahArO0WTKf3ByuLyRT+FCBw==.sig.ed25519"
}

{
  "previous": "%i8kZo3h3awoj/t/aY33fdLtcz0fDOUfU3f6VeOrmfvo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1169,
  "timestamp": 1538920854158,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256",
    "branch": "%i8kZo3h3awoj/t/aY33fdLtcz0fDOUfU3f6VeOrmfvo=.sha256",
    "reply": {
      "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%i8kZo3h3awoj/t/aY33fdLtcz0fDOUfU3f6VeOrmfvo=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "I think the best way forward might be to deprecate *all* rpcs that use json encoding for message transfer, specify and implement order-preserving cbor-encoding for  legacy messages, and provide new rpcs that use the cbor encoding. A few months after those have been rolled out, all the rpcs that send json-encoded messages can be removed.\n\nIf this issue forces us to deprecate and eventually delete those messages anyways, there's no real benefit in replacing them with order-preserving json, we can directly go to the [cbor subset](https://github.com/sunrise-choir/spec/blob/master/spec.md#cbor-encoding-of-legacy-data).\n\nIf we go for cbor-encoded messages, we can also do a compact encoding of the metadata rather than putting them into a self-describing format. So this involves some more design work than just doing a 1-to-1 conversion between json and cbor. But this is what I [would have been working on soon](%O8aEFQ3FJQir6ogLs5KA/+BDM+NnceR3eIbzXnlCBEA=.sha256) anyways. I'd simply postpone the clean-up work (and completely drop the json-encoded metadata if we remove them anyways), and specify and implement the full cbor message handling instead.",
    "mentions": [
      {
        "link": "%O8aEFQ3FJQir6ogLs5KA/+BDM+NnceR3eIbzXnlCBEA=.sha256",
        "name": "would have been working on soon"
      }
    ]
  },
  "signature": "7N58Uv1TlgyBjgYHTRAsoMDpK/kF1uhkvTev0nxP8tSFE540bzI6zvhFyiWq6yOh9EbWRydlcFmj5KcxLH/yCA==.sig.ed25519"
}

{
  "previous": "%imnlJPrxalmcfCiKOVWHRMdBjxYodSbRkPJynL90+rQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1170,
  "timestamp": 1538932720983,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "yamf",
    "text": "# YAMF-Hash\n\n**Y**et **A**nother **M**ulti **F**ormat - Hash Digest Edition\n\nA future-proof binary encoding for hash digests, for use in structured data.\n\nThis is basically the same as [yamf-pubkey](%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256). The only difference is that the minimum size of a secure hash is 256 bits (rather than the minimum 32 bits of a public key). Thus the length of a hash with an id between 0 and 127 is computed as `2 ^ (8 + (tag >> 3))` (whereas yamf-pubkey does `2 ^ (5 + (tag >> 3))`)\n\nA quick, self-contained definition of the binary encoding:\n\nA binarily encoded yamf-hash begins with a [canonical](https://github.com/multiformats/unsigned-varint/issues/5) [varint](https://github.com/multiformats/unsigned-varint) called the `tag`.\n\n- if `tag >= 128`, the bytes following the tag are a varint encoding of the length of the digest, followed by that many bytes\n- else, the length is `2 ^ (8 + (tag >> 3))` and the tag byte is followed by that many bytes of digest data\n\nThe `tag` indicates what cryptographic algorithm has been used to compute the hash.\n\nThe only currently assigned tag is `0` for [sha256](https://en.wikipedia.org/wiki/SHA-2) digests.\n\nFor human-readable encodings, the tag `0` is given the name `\"sha256\"`.",
    "mentions": [
      {
        "link": "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256",
        "name": "yamf-pubkey"
      }
    ]
  },
  "signature": "LtZUChlxJlFnPXNBOOzrTEAP4xy+U802p52owNpq859kU5eksSzIU3H/XGVHqt92X4BkygW8/KxrwtCaTiOzAA==.sig.ed25519"
}

{
  "previous": "%tLojVSXLYahw/XFXim76QL6dxnOtuYag0Ff/zBrt32Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1171,
  "timestamp": 1538934704389,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebutt",
    "text": "# Compact Encoding of Legacy Metadata\n\nCurrently, ssb encodes message metadata as json. While that works (ok, actually [it doesn't](%i8kZo3h3awoj/t/aY33fdLtcz0fDOUfU3f6VeOrmfvo=.sha256)...), it is rather wasteful. Metadata is structured data, there's no need to use a self-describing data format. A sensible encoding also shouldn't need to base64 encode signatures, hashes etc. So here's a draft for better metadata encoding.\n\nNote that this is only about encoding legacy metadata for backwards-compatibility. This post is not about [changes to the metadata itself](%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256), those are completely orthogonal and will happen at a later point in time. The only hard requirement for the new encoding is that you can always compute the (exactly one) corresponding json encoding. Put formally, there must be an injective function from the newly encoded values to the json-encoded ones. This property is crucial, since otherwise messages can't be verified. I won't specify how to reconstruct the original encoding in this post, but it should be straightforward to see that it is possible.\n\n## Legacy Metadata\n\nThe metadata currently attached to each message is specified [here in the protocol guide](https://ssbc.github.io/scuttlebutt-protocol-guide/#message-format), this post assumes that you read that section. But there are a few things I want to point out as they might not be obvious to everybody:\n\n- Metadata order is fixed up to only one variation, `author` and `sequence` order can be swapped. So the new encoding will need a bit to indicate how to restore the corresponding json.\n- We are not forced to store data in the same order as the json did it.\n- `hash` carries no information at all, there's nothing to encode there\n- a timestamp can be any 64 bit floating point number except `Infinity`, `-Infinity`, `-0` and `NaN`\n- each of those floats has [exactly one](%EyGGCcjAbaShKFCMxXKYiZjQe17SR298D0SLTuKmZpo=.sha256) valid ssb-json encoding, so sending the byte pattern is sufficient to reconstruct the json metadata\n- we can encode cypherlinks, keys, signatures etc. in any way we want, we are not tied to the `<sigil><base64data><suffix>` format\n  - in particular, sigils are unnecessary because we already know the type of data\n    - the `previous` data can also be `null`\n- the cryptographic primitive for the signature is already implied by the `author` key type\n\n## The Encoding\n\nA few more considerations:\n\n- it should be simple to remove the signature\n  - signature be either the first or last piece of data\n- by just storing the data sequentially, you need to parse everything up to the desired piece of data to access it. That's not a problem for metadata, but it means that message content should be at the end of the data.\n  - if the total length of all data is known (which will be the case with both muxrpc and bpmux), then content length can be computed without parsing if it is at the end of the data\n- it should be simple to add feed id and sequence number to a message without them, since replication rpcs don't really want to send those over the network as they can be computed locally\n\nThe last thing to consider is how to encode feed authors (i.e. public keys), signatures (where the cryptographic primitive is already known due to the feed author metadata) and the hash to the previous message (not a full cypherlink since it is already known that it links to a message).\n\nI discussed key encoding [here](%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256), we can use that format. I like the idea @kas raised of using [hex encoding](%gezYf2XKLcVLq4zHlBH49Hpoz1KH10lKuSsV3AQp9nQ=.sha256) for human-readable representations, but that's of no concern for the metadata encoding.\n\nSignatures only need to specify the length of the signature, not the cryptographic primitive (since that's already implied by the feed's public key). It might be possible to come up with a very clever scheme where the feed key already encodes the signature length. I don't think doing so is a good idea. Instead, the signature should simply be a varint length followed by that many bytes of signature data.\n\nPlacing the signature before the feed id is a tiny bit inconvenient since you don't know the crypto primitive of the signature before parsing the author, but the other ordering concerns outweigh this.\n\nWhat remains is the encoding of hashes. This can be done nearly the same way as public key encodings. I wrote this up in a [different](%tLojVSXLYahw/XFXim76QL6dxnOtuYag0Ff/zBrt32Q=.sha256) post to keep things somewhat organized.\n\n## The Encoding (For Real This Time)\n\nThe raw encoding is a simple concatenation of the following bytes `<signature><author><seqnum><timestamp><previous><data_length><data>`, where:\n\n- `<signature>` is a varint `foo` followed by `foo > 1` bytes. The least significant byte of the varint specifies the order of `author` and `sequence` when computing the json signing format.\n- `<author>` is a [yamf-pubkey](%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256)\n- `<seqnum>` is a [canonical](https://github.com/multiformats/unsigned-varint/issues/5) [varint](https://github.com/multiformats/unsigned-varint)\n- `<timestamp>` is an IEEE_754 64 bit float (1 sign bit, 11 exponent bits, 52 mantissa bits, in that order, negative zeros, infinities and NaNs are invalid)\n- `<previous>` is a [yamf-hash](%tLojVSXLYahw/XFXim76QL6dxnOtuYag0Ff/zBrt32Q=.sha256)\n- `<data_length>` is a varint containing\n- `<data>` is whatever data format we come up with (my current proposal is [this](https://github.com/sunrise-choir/spec/blob/master/spec.md#cbor-encoding-of-legacy-data))",
    "mentions": [
      {
        "link": "%i8kZo3h3awoj/t/aY33fdLtcz0fDOUfU3f6VeOrmfvo=.sha256",
        "name": "it doesn&#39;t"
      },
      {
        "link": "%iy6Pekirbl7hHHHuGsYWyfY9j0qqoV4EbFiApL6q3cQ=.sha256",
        "name": "changes to the metadata itself"
      },
      {
        "link": "%EyGGCcjAbaShKFCMxXKYiZjQe17SR298D0SLTuKmZpo=.sha256",
        "name": "exactly one"
      },
      {
        "link": "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256",
        "name": "here"
      },
      {
        "link": "%gezYf2XKLcVLq4zHlBH49Hpoz1KH10lKuSsV3AQp9nQ=.sha256",
        "name": "hex encoding"
      },
      {
        "link": "%tLojVSXLYahw/XFXim76QL6dxnOtuYag0Ff/zBrt32Q=.sha256",
        "name": "different"
      },
      {
        "link": "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256",
        "name": "yamf-pubkey"
      },
      {
        "link": "%tLojVSXLYahw/XFXim76QL6dxnOtuYag0Ff/zBrt32Q=.sha256",
        "name": "yamf-hash"
      }
    ]
  },
  "signature": "bxua9EJ53aj15sf+yCq6D8kZMwNOVsEsVoaC7ZoHtM2y63YrZlu20l9wCftMtKc9r1eonOnMO7pVQMwRVh8rAg==.sig.ed25519"
}

{
  "previous": "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1172,
  "timestamp": 1538934809332,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256",
    "branch": "%imnlJPrxalmcfCiKOVWHRMdBjxYodSbRkPJynL90+rQ=.sha256",
    "reply": {
      "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%imnlJPrxalmcfCiKOVWHRMdBjxYodSbRkPJynL90+rQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Drafted a proposal for compact legacy metadata that can be converted back into json legacy metadata for signing encoding computation: %QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256",
    "mentions": [
      {
        "link": "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256"
      }
    ]
  },
  "signature": "0GwHeL44f6rvOYmpGL6ua+X2Dk5OPaj8N6l+KacE9ZofL0jJgNZfF/IWhY7DCNjXgJV6NXTZItIm37PShI+NCQ==.sig.ed25519"
}

{
  "previous": "%ZEJe7nZSE0f/uQzUTsQNbmzH+/pcNSSTZm58XfZxGJA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1173,
  "timestamp": 1538945227348,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%O8aEFQ3FJQir6ogLs5KA/+BDM+NnceR3eIbzXnlCBEA=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%O8aEFQ3FJQir6ogLs5KA/+BDM+NnceR3eIbzXnlCBEA=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 07/10/2018\n\n- dancing on the brink of madness and/or despair: %i8kZo3h3awoj/t/aY33fdLtcz0fDOUfU3f6VeOrmfvo=.sha256\n  - on the plus side, if we end up deprecating json, we won't have to deal with the unicode replacement character issue\n- lost an hour to [things randomly breaking](https://github.com/ssbc/patchwork/issues/867) and fiddling around with patchbay (thanks [@Christian Bundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519) for helping me getting patchwork to run again)\n- YAMF-hash draft: %tLojVSXLYahw/XFXim76QL6dxnOtuYag0Ff/zBrt32Q=.sha256\n- compact legacy metadata encoding draft: %QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256\n- sketched a yamf-pubkey implementation: https://github.com/ssbrs/yamf-pubkey/blob/master/src/lib.rs\n- started implementing deserialization of the [cbor subset](https://github.com/sunrise-choir/spec/blob/master/spec.md#cbor-encoding-of-legacy-data)\n",
    "mentions": [
      {
        "link": "%i8kZo3h3awoj/t/aY33fdLtcz0fDOUfU3f6VeOrmfvo=.sha256"
      },
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "Christian Bundy"
      },
      {
        "link": "%tLojVSXLYahw/XFXim76QL6dxnOtuYag0Ff/zBrt32Q=.sha256"
      },
      {
        "link": "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256"
      }
    ]
  },
  "signature": "LapJobFbnZNT+OQfdHmVHahfHQSy2fnZoWW309l5ebP0Vlb3+PfRT8C7/8x6dfM0VLS6cgCNKPzAl2jANGiuDA==.sig.ed25519"
}

{
  "previous": "%AlSseDWFG+UcKCVyPFXPVMSl84YV17FF9yQFldH6Nyw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1174,
  "timestamp": 1538945612129,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256",
    "branch": "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256",
    "reply": {
      "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> The least significant byte of the varint specifies the order of author and sequence when computing the json signing format.\n\nShould have been \"The least significant *bit* [...]\". ",
    "mentions": []
  },
  "signature": "YoD0KAwes0Wr8qoLDYW7BMh6oqzh8OCmdMFuhPJNbKMUI4vnk5SZ7hIHDKBx9jKuAn/Xx5YZfVf1vAWpHapUBQ==.sig.ed25519"
}

{
  "previous": "%T9u8UstTZtNuHhoe5zxvgpWnFso72EVHSMiwo9CYRHs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1175,
  "timestamp": 1538985054675,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256",
    "branch": "%T9u8UstTZtNuHhoe5zxvgpWnFso72EVHSMiwo9CYRHs=.sha256",
    "reply": {
      "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%T9u8UstTZtNuHhoe5zxvgpWnFso72EVHSMiwo9CYRHs=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "As per [this exchange](%GDNTWCfnsT8pu2rfVU/CpRwidu4NJIwUopeIB8QfPqw=.sha256), `<author>` also needs an additional varint to indicate the feed type.\n\nThere was also [this idea](%kFNhfPsphpeqoChT7BIuUFURbOzIRuJmcYzuOWpubGo=.sha256) for an additional varint in cypherlinks to messages, but I'm not as convinced anymore. Messages should be as self-describing as possible, including their encoding. I'd rather keep an encoding indicator in the message metadata (talking about the metadata improvements now, not legacy metadata), and distinguish between legacy messages and self-describing new messages via the hash indicator (\"hash tag\"?). So unless anyone complains and I don't change my mind on my own, that's the road I'll explore further.",
    "mentions": [
      {
        "link": "%GDNTWCfnsT8pu2rfVU/CpRwidu4NJIwUopeIB8QfPqw=.sha256",
        "name": "this exchange"
      },
      {
        "link": "%kFNhfPsphpeqoChT7BIuUFURbOzIRuJmcYzuOWpubGo=.sha256",
        "name": "this idea"
      }
    ]
  },
  "signature": "HbOq+JaZwuJK76h9Wgw3fPwiVf2efckIcs0aVW19pqgvZzn6om4nSQyv7Z7Ig4M26RoXR67GBz9dwXhyzt6cDw==.sig.ed25519"
}

{
  "previous": "%xVqT/69yELAEPyDcekvh/+L1cat/j2ejXvE13LIW5Vg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1176,
  "timestamp": 1538993196639,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256",
    "branch": "%xVqT/69yELAEPyDcekvh/+L1cat/j2ejXvE13LIW5Vg=.sha256",
    "reply": {
      "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%xVqT/69yELAEPyDcekvh/+L1cat/j2ejXvE13LIW5Vg=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "The more I'm thinking about the issue of attaching a tag to feed ids, the less I'm convinced it is a good idea.\n\nConceptually, this information belongs to the feed itself. By putting it into the references, a bunch of problems arise:\n\n- this information is duplicated in every single reference rather than having a single source of truth\n  - inefficient\n  - not robust, inconsistencies *will* crop up\n- public keys do not uniquely identify feeds anymore, there can be two feeds with the same pubkey but different tag\n- anyone can claim that a feed has a certain type, without needed the private key to prove it\n- malicious actors can cause you to interpret data in a different way than it was intended, by specifying a non-truthful type\n  - this screams \"attack vector\"\n  - and how could you even know which type is correct?\n    - trying everything and seeing what works is *not* a good strategy, also [polyglots](https://en.wikipedia.org/wiki/Polyglot_(computing)) can exist\n- a single tag is fairly restrictive, what if we needed feed types which were parameterized over e.g. a number, or some keys, or whatever\n  - all the previous issues are vastly amplified in this scenario\n\nThese problems arise because feeds - unlike messages - are not really entities that exist and can be linked to. So to solve this, we'd need a place to store information about a feed. And there's a fairly obvious one (ignoring backwards-compatibility for now): The feed's first message. It wouldn't actually have to be a real message, but the first entry of the feed's sigchain would point to a hash of some data rather than being a \"null pointer\". Or maybe we don't even need any indirection there, the first sigchain entry can simply contain all the feed-type data in place of the backlink.\n\nTo get this backwards-compatible: Legacy messages can't have any feed type rather than the implicit default one, and the non-legacy metadata design can accommodate this.\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "Njh4KOXx8V8Ra8f2MHjRLsqBEj+qLhClNupLBKS3VlhCzD9pJ1mKtP/4Oy85B2PGOjDBjf25GE8Uu7U0I8/3Dg==.sig.ed25519"
}

{
  "previous": "%HFF/8SmwfkQaHuphWxiXALvRBHjZlDiXChgM+9htWbU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1177,
  "timestamp": 1538996962208,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256",
    "branch": "%HFF/8SmwfkQaHuphWxiXALvRBHjZlDiXChgM+9htWbU=.sha256",
    "reply": {
      "%QTFcrr914HI8y8bTfMWRFczNdQ/ncDM7yZ5Ttd/nn0s=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%HFF/8SmwfkQaHuphWxiXALvRBHjZlDiXChgM+9htWbU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Using the first message of the feed doesn't work with ooo. Instead, we can put the feed type into the metadata of every message. That is still more efficient than putting it into links (every message is only published once, but can be linked to much more than once), and the feed type is specified by the owner of the feed's private key. And just like feed id and seqnum, non-ooo replication can omit sending the feed type over the wire with every message.",
    "mentions": []
  },
  "signature": "DDazgbQkr1llrENOea44v2rqh5AI1nIkrvHjlgMMzTy+r3bNg/H2IZrxc2Kqg2T1nyRxrnJELe5DECQEMGpuAw==.sig.ed25519"
}

{
  "previous": "%kW58mRD2Y7xc8DFDB9BtfeKvfYBNMdapCoz0alcXtM0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1178,
  "timestamp": 1539005363093,
  "hash": "sha256",
  "content": "lwqBRl6cJdBNGzB3CujraEec1L7l48qQ2zuVAVFx/somCVu5vy2J+J3gB2wMCbBxRFUVXDxzIxphgbiHO8RJw7fRlQ31YO8Df1EbmWs2BN6NiOo+cv+QswKANb80lmz7VrDEoLUcz+j467v5o8YKwDe3OmCXqwpSTqHLUPfRlGej/hd7MpZA4RwQ25R+RmszvJOnSDuv/2qCSO2NImgDie1dtzMAwc3r4Yx5xFaOiwsmCcd/TzfzotQGBE5mw7f+32oiEhF7u3g1kC4cf1eqY5TVh0TFVOzkeqInw4yoyedCHnBkgGFR3yZ2vFKyTzKa1ScVT6wplAVGXRg7BOgzv78vNAXgAW263aYjm75KmkX+fy7T01c81O27CvLQi6+C+ImZnE4dEgofMmP9p1ceN/lxsIk9f722ZKyWjenz72Wl4VrrpuAxpl1QfJFYGiwWGQzmksIZdW5mBvIIDfNUVt9XGGXGM+Djw9bAfA6nBlKgkZC89OEJY/j5BuqsdF+E7nURsnS07xmSQ/UDSJmwDF5j13/seLf0xueOTcenpPJR0KMoHpb+wHfmqzgWYsaUBQFtPjLUiJhVKgJ3ZEFjOfp96wzhcWNF/CxTlZ1qkVZ03fIUXCrWhToesZlDoE03f14e0Zn0bIW/z5vtVylUlt0FOEPGOX6cYrKRD3O+iFGkdbQ1A52cDwjqIV/orfr6ofDvWp3rp7AclFxn1v18R/bbhvzPiTCE1bKBcbkR7bcyCtojlqFXcDD43eEtYlA8rOhNi3CNz//f7LGp62EEnWjH3drNnE83Iro62AYeUyqQfLUTt2/3ECr5zSLblGNBtm5xsqO+nS1QHKFqnMfAtZSOUYi5zoVqqMq6Z5F/zuxAeD49YzC4zZqrLHfQrt3brJ8MWq/RPWvfXQxtqqgqUE1bVH5yEBTZ8KpzPdEm0f3xJp4r7oGSJFbdEk6j89nByxI4UQuV1nH95cmelFjHBf3BfhqJBuWsA+ifJ1rMbZ+o0FQKqhksQ7G8jGXJYDdLMH+La6qLe68GfLosCzJKnAE8u162sWSUrkC3lSe0ZiDjNaw9jre8LZyYKGYZpduP4oLmz4xIVKzZ5s4ktF0Osz4TpWPuIe0RDJdJW/TKZFnhISMszCmM5GNUPhpff71WAIxZ9pERrpx4hVUh4mRntzQIwZgBldtdYMhOhZfDM5PbBdAFx6uI8cCUfbU0YhKgl5fhiSAWOQB/UuU9MFkebKdl3Tr5rlbasJ9MIP2FAAN3mGEdKW33uQNEqt1vFSSDnizAJabIlq18gJUGL223IT43GDwNB8PRsEhEDAN83PoYoPUCW3ydvVfuo28JF0TJm1zd2gkAjxui2ayoUzoXkHMH52dCAFx4lPcxV7C3Csig1xWGZwVKTEDJfS2ASoh8pV8759QVSHCdqzq7oPHV5zEsWFemFtRfiXW3V0uXzkneYgDw+ECFB7o7emZt63s8WqLAPR/+8Do9e8kVpBAHNdnUGlHx9Y4=.box",
  "signature": "xHAEV0RaHikCXIiVw7X2fj9Lucb3H2HJN7VN8AfRfMGchecpgsPGWNIZtg6PphdaZ26rvgjkZgxToh0in2ljCg==.sig.ed25519"
}

{
  "previous": "%Vz8n3DiVc67OQQ7966pIt/fOQ1tQmAp2coA22+GQA5s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1179,
  "timestamp": 1539014369483,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%AlSseDWFG+UcKCVyPFXPVMSl84YV17FF9yQFldH6Nyw=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%AlSseDWFG+UcKCVyPFXPVMSl84YV17FF9yQFldH6Nyw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 08/10/2018\n\n- thought about indicating feed types: %HFF/8SmwfkQaHuphWxiXALvRBHjZlDiXChgM+9htWbU=.sha256\n- implemented cbor deserialization (untested): https://github.com/ssbrs/legacy-msg/blob/master/src/cbor/de.rs\n- implemented cbor serialization (untested): https://github.com/ssbrs/legacy-msg/blob/master/src/cbor/ser.rs\n  - cbor (de)serialization was such a joy compared to json =)\n- tested and fixed the yamf-pubkey implementation: https://github.com/ssbrs/yamf-pubkey/commit/c4a95748ce3e9b4531f7e694ee0252a9f1ad0e6d\n- implemented yamf-hash (mostly by copypasting the yamf-pubkey implementation): https://github.com/ssbrs/yamf-hash\n- started testing cbor implementation and fixing errors\n\nNext steps depend on how we deal with the [signing problem](%i8kZo3h3awoj/t/aY33fdLtcz0fDOUfU3f6VeOrmfvo=.sha256) and the [cbor feed id encoding](%HFF/8SmwfkQaHuphWxiXALvRBHjZlDiXChgM+9htWbU=.sha256). In any case, I'm close to having implemented the full legacy message code in rust, both for json and cbor. When that's fully done and we settled on how to deal with the open problems, I'll do a bunch of clean up and publishing, as well as js binding.\n",
    "mentions": [
      {
        "link": "%HFF/8SmwfkQaHuphWxiXALvRBHjZlDiXChgM+9htWbU=.sha256"
      },
      {
        "link": "%i8kZo3h3awoj/t/aY33fdLtcz0fDOUfU3f6VeOrmfvo=.sha256",
        "name": "signing problem"
      },
      {
        "link": "%HFF/8SmwfkQaHuphWxiXALvRBHjZlDiXChgM+9htWbU=.sha256",
        "name": "cbor feed id encoding"
      }
    ]
  },
  "signature": "+UeEToIa9+UMaHsTmgQLDRWZJleErn1PSW1/RVQMjCO6L+r3d2/V62vkVoTubVb3vw8I/UMhxBypQ1Ymz34HCQ==.sig.ed25519"
}

{
  "previous": "%KpresJXwd6VojMcDUFDDFC6c0sU/40CUIIabX+peK/k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1180,
  "timestamp": 1539080546653,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256",
    "branch": "%sINR9l55abiivXi7+csVY+oROtRzgwhkK8eivgZBcns=.sha256",
    "reply": {
      "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%sINR9l55abiivXi7+csVY+oROtRzgwhkK8eivgZBcns=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) \n\n> I got some neurons crossed there, when I said \"lexiographic order\" I should have said \"insertion order\"\n\nOk, that actually works. Input order is preserver, except all keys that are either `0` or match `/[1-9][0-9]*/` are moved to the top, sorted lexicographically among themselves. Just implemented this, and the rust impl now passes the full test set.\n\n> @aljoscha also I think you are greatly overstating the risk that the order of JSON fields will change. Firstly, that's not part of node.js, it's a part of V8, who are both more conservative and more competent.\nThey won't change it because it's been this way for ages and they'll break the web.\n\nFair enough, but I'd still prefer if sbot explicitly implemented that behavior rather than relying on unspecified details, even if they realistically won't change. I'll clean up the rust implementation next, and then I can create js bindings as (nearly) drop-in replacements for `JSON.stringify` and `JSON.parse`, with the ordering semantics ssb needs.\n\nMaybe you could already think about how those could be switched in, and whether/how to benchmark the performance impact. I honestly don't know whether they should be faster or slower than v8's JSON handling.\n\nThe js interface of the bindings fill be slightly different from JSON.foo: The parsing function won't support [revivers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter), and the serialization function will come in two, unconfigurable varieties: One for whitespace-less encoding, and one for ssb's signing-format encoding.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "WZv7mZxPSPWQ8l5CrBADrEJtGaJc5c2nLehaFr8cp2SjcbJXhjnqFGJbNkP9Bx+LZTbKwwR4HZRqbA6uu8JfBw==.sig.ed25519"
}

{
  "previous": "%vn1IyTU5EJTvfpmUPIpkbWCGYwgpJjHX85f4VNhNIro=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1181,
  "timestamp": 1539083696305,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256",
    "branch": "%vn1IyTU5EJTvfpmUPIpkbWCGYwgpJjHX85f4VNhNIro=.sha256",
    "reply": {
      "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%vn1IyTU5EJTvfpmUPIpkbWCGYwgpJjHX85f4VNhNIro=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "> Ok, that actually works. Input order is preserver, except all keys that are either 0 or match /[1-9][0-9]*/ are moved to the top, sorted lexicographically among themselves. Just implemented this, and the rust impl now passes the full test set.\n\nI lied, they are sorted by length first, using lexicographic order as a tie-breaker.\n\n`JSON.stringify(JSON.parse('{\"300\": 0, \"20\": 0, \"1\": 0, \"200\": 0, \"250\": 0, \"201\": 0, \"30\": 0}'), null, 2)`\n```js\n\"{\n  \\\"1\\\": 0,\n  \\\"20\\\": 0,\n  \\\"30\\\": 0,\n  \\\"200\\\": 0,\n  \\\"201\\\": 0,\n  \\\"250\\\": 0,\n  \\\"300\\\": 0\n}\"\n```",
    "mentions": []
  },
  "signature": "fFI1/3mXDGjPXbv5Y1ZR/33brdNEPzmttOOyQOXtS7CbpwR3UqHtxxqk3EAVxEmFtZ5WjvWD+nExPqoooMEdAg==.sig.ed25519"
}

{
  "previous": "%lAdPzOAshFmzhhJVzXZpfytv/fBCmd1XkpNdEorCiIg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1182,
  "timestamp": 1539103629161,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%bd96n3wGwweq6PnWTyVCMO8zUe17nllRbEItxJRsnGg=.sha256",
    "reply": {
      "%bd96n3wGwweq6PnWTyVCMO8zUe17nllRbEItxJRsnGg=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%7cFmte5ThRzZ/0dLYsHL3AZHhYXzL1XiMCTsRp0NqQ8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "## Call for Help\n\nThis issue is still blocking me: I need to know what happens when sbot receives a message where a string literal contains invalid utf8. There are three possibilities, and I don't know which one applies:\n\n- it might replace invalid bytes with the unicode replacement character `U+FFFD`\n  - this is what happens by default when converting from buffer to string via `buf.toString()`\n- it might reject the message as invalid\n- it might store invalid utf-16 in the javascript strings\n\nAny of the following would unblock me:\n\n- get a clear statement from [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) which of these three is the desired behavior, and treat any divergent sbot behavior as a bug\n- find the place(s) in the javascript implementation(s) where the conversion from buffer to string happens\n  - no idea where this might happen, but maybe a js contributor could help? CC [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519), [@Matt McKegg](@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519), [@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519), [@Christian Bundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519)\n- manage to send a message with invalid utf8 in a string literal to sbot and detect how it reacts\n  - I don't think the js API is low-level enough to do so, but maybe another implementor could help me out here: [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519) , [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519)\n  - a simple invalid string is `[0x22, 0xff, 0x22]` (double-quote, invalid utf8 byte, double-quote)\n\nI'd be super grateful if anyone could help me here.\n\n---\n\nThe first unblocking option (defining desired behavior instead of looking what sbot does) is important in any case. In my opinion, rejecting invalid utf-8 is the only sensible behavior. Even if sbot performs character replacement instead, I'd very much prefer if we treated that as a bug rather than gospel.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@FbGoHeEcePDG3Evemrc+hm+S77cXKf8BRQgkYinJggg=.ed25519",
        "name": "Matt McKegg"
      },
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      },
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "Christian Bundy"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "YJABEWQgooPkfPS7D80SJBozFWLodRuQTG+9YwR6XDL8t9KcevWQAWDxPdO+GdYXgeF20eSrkLAmW1lWozQNBg==.sig.ed25519"
}

{
  "previous": "%F586gTOCDtmAOIWSc2TlWEdD5HBGNt1WL+Mt/Ne4mg8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1183,
  "timestamp": 1539107179771,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%PglzpRsqN4AeE7WlwdawYysF4V0TBUdAxHdxdPi+hcM=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%PglzpRsqN4AeE7WlwdawYysF4V0TBUdAxHdxdPi+hcM=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Christian Bundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519) \n\nThat would be great. I haven't done this myself, I'm not familiar enough with the js codebase to get this running without  spending *a lot* of time.",
    "mentions": [
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "Christian Bundy"
      }
    ]
  },
  "signature": "eovAm+uYNnbkG08SDfYIrUshAmHX1KlC/NCFMpsJcKhJ9I475wsq4vQDYuF6x+BU3VBvLH5kyDNwtNqstq3+BA==.sig.ed25519"
}

{
  "previous": "%33e3Ws8CJjCFyRjmmg8R1Ic1hsSi/OV34vzU5H3bkXU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1184,
  "timestamp": 1539107217406,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%PglzpRsqN4AeE7WlwdawYysF4V0TBUdAxHdxdPi+hcM=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "t9Te3F1HAG9Gwcc/9FC3iM/j8ISg182vBz8GWa4XT/LK+vlqbUSHFgoVieOYSWaLuA1RmlWDp8ODSJz/MKg6Cg==.sig.ed25519"
}

{
  "previous": "%ov7M0qbuhA+UZmjDsxQdTcxUj5ahwLcb/2lyiu3UTjg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1185,
  "timestamp": 1539112754945,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%KsWKWxP2K55EYacyAe4A1FyhHTp5XR1Es16iJ9bRS5Y=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%KsWKWxP2K55EYacyAe4A1FyhHTp5XR1Es16iJ9bRS5Y=.sha256": "@nti4TWBH/WNZnfwEoSleF3bgagd63Z5yeEnmFIyq0KA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Thank you [@regular](@nti4TWBH/WNZnfwEoSleF3bgagd63Z5yeEnmFIyq0KA=.ed25519).\n\nSbot replaced the invalid utf8 with the replacement character `U+FFFD`. So now we need to decide whether to codify this behavior in the spec, or whether to change sbot.\n\nI see three main reasons for changing sbot to reject invalid utf instead of performing lossy replacement:\n\n- If we allow invalid utf8, then the rpc protocol isn't valid json anymore. This is against the [json spec](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf) js ssb would otherwise follow.\n- Any string that actually contains U+FFFD in a string has multiple valid encodings, namely all those that substitute an invalid utf8 sequence for the U+FFFD character. Conforming implementations have to accept and convert all of them.\n- The legacy message format becomes even more ridiculous.\n\nReasons for keeping the silent replacement behavior:\n\n- No need to fix the sbot code base\n\nMy preferred choice is clear, but I guess it is [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) who gets to decide this?",
    "mentions": [
      {
        "link": "@nti4TWBH/WNZnfwEoSleF3bgagd63Z5yeEnmFIyq0KA=.ed25519",
        "name": "regular"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "Ag6MkHX3N3FCxeAaLvaEq+ahRsVsvkKxJATefHsHthw/5Efec2Ru+o+77N1ovgGYUerkiPUedjCG1Y8u5L+0BQ==.sig.ed25519"
}

{
  "previous": "%zx0GVnlMl179osXbP2r8lC1a9VsDn8tiZli+1BdA6kA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1186,
  "timestamp": 1539112772530,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%u115NoXkWp08Sg5JywsRLRQrwxHUBmK1/PGYS6zQKcI=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "b53LHl3LlPrCTgiPQrS6r/4tV2l50p+y6j7lhERRBpTLwKx8cuGCO3gi/09FozrrgmigqpWyPbMJjkVhvoEIAQ==.sig.ed25519"
}

{
  "previous": "%VjIpL6A5r1gHR3ubECnKb/nLoaRGVC4CIwe0kLDS4xA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1187,
  "timestamp": 1539112773510,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%PnxmQTFxhFieZSEQVTE5ofn1sJZ/bWTxJBNXtVtcqJI=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "bugEnlneRWs9USRmZmfGULY2YzQLFtbg8V2jOKUjEd31Z1VzjXQXHCmj5rH8Yk4mONSBn2Pu7ZmPiePAUQK6BQ==.sig.ed25519"
}

{
  "previous": "%I56id+bmEkGIS0OWck2Y/tiNE6FSPJM7wz4SaboTL1E=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1188,
  "timestamp": 1539113430519,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": [
      "%EIPYNto+/1bQqAcq7CA6QZzhf6BL5rNUFw+ZP1idOQU=.sha256",
      "%zx0GVnlMl179osXbP2r8lC1a9VsDn8tiZli+1BdA6kA=.sha256"
    ],
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%EIPYNto+/1bQqAcq7CA6QZzhf6BL5rNUFw+ZP1idOQU=.sha256": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519) \n> @Aljoscha this is where it converts buffer to str and then json when reading from db: https://github.com/ssbc/secure-scuttlebutt/blob/master/minimal.js#L83\n\nIsn't `encode` only encoding arbitrary js values into js strings, and `decode` decoding js strings into arbitrary js values? Those js strings are an internal, utf-16 encoded representation, but ssb servers exchange utf-8 encoded json. So there's still a conversion missing, and that's the one I'm after (in particular the decoding from utf-8 json into js values (and possibly with a utf-16 string as an intermediate representation)).",
    "mentions": [
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      }
    ]
  },
  "signature": "MWqAyjzjMFhlZ5x407nFFtUJU18diw2n12FGAglNSj4emJOSrDrBkFpeD4TusbiyEcuTHgxTl/3ebnCwQkmyBw==.sig.ed25519"
}

{
  "previous": "%l/q/53suwl+0PwaZ6FAiwP3bYoNnn4wAVuE4oSDtB0o=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1189,
  "timestamp": 1539115518914,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%wYffYkhQBsalTCj03udPQDP2c7kx94h3IbTiW2sQ0eQ=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%wYffYkhQBsalTCj03udPQDP2c7kx94h3IbTiW2sQ0eQ=.sha256": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519) Yeah, that might be right. [This](https://github.com/dominictarr/packet-stream-codec/blob/master/index.js#L28) converts from string to buffer, and [this](https://github.com/dominictarr/packet-stream-codec/blob/master/index.js#L73) from buffer to string.\n\nDoes sbot talk to the db via packet-stream as well? If it doesn't, then there must be at least one other place where these conversions happen. Changing only some of the conversion functions but not all of them would result in some nasty bugs.",
    "mentions": [
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      }
    ]
  },
  "signature": "LZ04Z6sTDTThSL6Jz0O/Y0cFbHWR5eMeZcVS7s1lCcSUtXWzki1ueBhsOxErxDgxwTnUsXUxZU6+CQJunLrCDQ==.sig.ed25519"
}

{
  "previous": "%8fFtpLe5b3nxd6rYPUjHcqRBTvtEMAtPjnTNzTO04Ww=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1190,
  "timestamp": 1539115593145,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%NOSuJbsMldlqiURriZzMCTltYllOUvWxKH/yZdFHshw=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "J9RRfaIu83blnFB2M3kZSkLIO3DZjRaKEXwdrZlWUYMzfZeEHu2UXqflUIl4qWp4ncmmIt6+tljf9R7tqiptBg==.sig.ed25519"
}

{
  "previous": "%/GaDAsviSmo0Px4qyY5lvnyzChzjVtr/PkW5dQDFySo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1191,
  "timestamp": 1539119887795,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%KpresJXwd6VojMcDUFDDFC6c0sU/40CUIIabX+peK/k=.sha256",
    "reply": {
      "%KpresJXwd6VojMcDUFDDFC6c0sU/40CUIIabX+peK/k=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 09/10/2018\n\n- updated spec and rust implementation with the [correct object entry order](%lAdPzOAshFmzhhJVzXZpfytv/fBCmd1XkpNdEorCiIg=.sha256)\n- unicode and utf-8 keep being full of surprises: https://github.com/tormol/encode_unicode/issues/6\n  - implemented overlongness checking, because that is exactly what I signed up for: https://github.com/tormol/encode_unicode/pull/7\n- %zx0GVnlMl179osXbP2r8lC1a9VsDn8tiZli+1BdA6kA=.sha256\n- added text fixtures to the cbor implementation and fixed the implementation\n  - started roundtrip-fuzzing the cbor\n\nToday was another of those grindy days. The above doesn't look like I even did a lot, since most of the time went into reconstructing error cases, fiddling around with the rust standard library, and debugging.\n\nBut on the plus side, this may have been the last grindy work on legacy message stuff. Json encoding is fully implemented, the precise format is [nearly](%zx0GVnlMl179osXbP2r8lC1a9VsDn8tiZli+1BdA6kA=.sha256) nailed down, cbor encoding appears to be working, and I think I've settled on a compact legacy metadata format to go with the cbor content format (I'm pretty convinced that [this](%kW58mRD2Y7xc8DFDB9BtfeKvfYBNMdapCoz0alcXtM0=.sha256) is the right way to go for feed metadata, which was the last open problem with the compact legacy metadata).\n\nWhat remains in this first phase of work is code clean up, documentation, better cbor testing (ideally by checking against other implementations), better cbor spec, specification and implementation of the compact legacy metadata, clean-up of the spec, release of test data, binding creation. All of these are tasks I have full control over, no more bugs in dependencies or protocol weirdness.\n\nI expect to do the first releases of spec, test-suites and rust implementation later this week (leaving cbor stuff for later) :tada:\n ",
    "mentions": [
      {
        "link": "%lAdPzOAshFmzhhJVzXZpfytv/fBCmd1XkpNdEorCiIg=.sha256",
        "name": "correct object entry order"
      },
      {
        "link": "%zx0GVnlMl179osXbP2r8lC1a9VsDn8tiZli+1BdA6kA=.sha256"
      },
      {
        "link": "%zx0GVnlMl179osXbP2r8lC1a9VsDn8tiZli+1BdA6kA=.sha256",
        "name": "nearly"
      },
      {
        "link": "%kW58mRD2Y7xc8DFDB9BtfeKvfYBNMdapCoz0alcXtM0=.sha256",
        "name": "this"
      }
    ]
  },
  "signature": "ErHgl2u+bAnsLDCdsFHQy4R/XDlqMyykGUTBrGgf7JzCR+fmv0NGefKDAPrqcpMX5uN06COBMRZTKgeOBBfbCw==.sig.ed25519"
}

{
  "previous": "%qXZR406vxMxymxd2jC5g0P2Ij+oOKBlA5XnwtSuM17I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1192,
  "timestamp": 1539120096801,
  "hash": "sha256",
  "content": "0uSP2IdD4C6IwGUP/TLaeKMw52DkB/TC75k5XVFJfnc4DK9ASPSu/rRkhvAgFtAWPRgfNHSjvmmdGZmC+I58QOTSrg0IGfelQZuqCK7NojITIbj+MeXK6UryeXNEIwRJXBpcLNbquOlnbjfXEJRhIra19pTm8Z3E9fSzbHAGvHMIq8x+189LoVYfsS1bR20Ry9+0sHxm5l/0vIc2G9V/enDr84Hqj7Q1Q9uoLtzOcsKVzsj+rxpw+OEH7+kF82m/atqgJY69GG8jzC4XdzZsyYpG7F2QmBWWK55W+PGlpvEU8QfRUBTrGiVPIN3wDlVRNSO7GV0NOAG2JFQveKJXBuJjgHqx3sCorK4t9mtiyPaNxvnFaaddyQ/PFZVeJ3n5S/uTI7N0RgKBKBLjySaS+7KzYgVWxAPBa9lUe1PE4arGwJAuHKBj7lIGcj4S0YlHWNONjZdkIgyNN0HvTF6cASatv/WU0l8Mvhnoy3f9WDnhddfel4z+O6hSwGO+HPvjBYS/EMZs0Tnzy7PPSuk1Jl9VL2TYnpCVbM/qp5htqgPvXqYhOxV4/xYhRwf+42rPxBGCG2JgqBUwIkn9pH6lmDPPP4fZKKr2Hpk86om3T46MK+b0gxvfGyy+rkO5s6WO0uur2QBChi4WEv2qYvCIg2eQTaaP+v6TxO6JEb4i4hYud29IOTwvLrTZKKzlroKqPKCc7/mL4Q3SQFVAnzEqckgWi3DjPSb76OBdUyZ5YM/8/4lfcLt0VUlLQ580yzqICZg3ok0rg2qbGcqrpk+J+zTR068A4+shJgqWaQL5bZJIrxwJVvy79o9qtqjHrhaUvDK6EydtpSYiirU1u6UzjOOdSNYLcWruprRujRiP12FVJj7rsFFH3iNZduH67UjtudPATGzmhMKdH2riFol15af0gkfXMByXqYII2xXsno0k6JLL/+2yKPrBtY7GhoWA+HTEdmL00qOqcS53CmBOSyUX64HTuoNNMXWygy2gKKWtJ660q4jWnSClEVGZaobntfRFumTU/S0ULEzkfEt3srfRyPqTFGeEmO1GyWc3FOZY3OYx+pWcCukPs0dwpTBLjauc6JuxXAtq0+jiGs9UnnPekOtgsUWEkwTILpLRVC7TVfIO3UriMNgAj1OGOn0yXtD2rlYE51YRXDGoKv0XZZJYJJgAb/JMhxZXe0O9jENtz2oF+5gM4fu+Y0MLKG2wOTPOpUGO2SrMeWJKlTx1300XJxaUMJ9fW7oKGFkpXGq+cTv4jENeU9n7g1hBFVPrcV4tKHySIY3OC/PGJYT3tMWFgRS7UTwMa9BhlO4XF6WIyH1nb3hF+zSQb0Ns4qg/Wo+w9S/h2xkAMDAD77s=.box",
  "signature": "Ez4Gg7yJBMbmgaCl/wrpt+FdpAGXNqV6qCOxK+TRqBJTZ3NeFqlCtn265pCFnm7yC6BTrGTDTR2zTRgjP7mBAw==.sig.ed25519"
}

{
  "previous": "%qMl15/9oXEbG2QM0XupbjutKRXmxky7BDsMZLQ5HLr8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1193,
  "timestamp": 1539154361220,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": null,
    "vote": {
      "link": "%lV+wrBP1cVJVw3/lhCYmxrlYQDzKjI/cx9eEhdsx6SE=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "COHZFWkqH6faY+CM3N0cQ8o03lVeUHYACvfHsfdm1D1eWslVOIddmJGFi+zOosnE+f1G1SGJekmunLZXIB72DA==.sig.ed25519"
}

{
  "previous": "%EKuWjStPWvgLf8Dl/QryflhII1QKIPtSNzAN9HoMNqo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1194,
  "timestamp": 1539154827095,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZOosXgUtSqt4TtTwACKyLGoHypg6THxbXOBvpQhFunQ=.sha256",
    "branch": "%jKI0Fl9KQKulVnvUMB7IRIaywixWC9AvzGY96AVF4JY=.sha256",
    "reply": {
      "%jKI0Fl9KQKulVnvUMB7IRIaywixWC9AvzGY96AVF4JY=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519) You might like the [spec](https://github.com/sunrise-choir/spec/blob/master/spec.md#legacy-messages) I am drafting, it contains all that info.",
    "mentions": [
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      }
    ]
  },
  "signature": "GqefNiGm+BXZ72WqRx4c4dLvmYMH9TOMCuOVHZ++13smEtgBpZS0NU3EXbhA2HorSpDVtNDXYaXMjzPQTFKVCw==.sig.ed25519"
}

{
  "previous": "%onEYdS5lX014Oj8fLzDYf599JIxuPwwj5P0CAe6y/tA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1195,
  "timestamp": 1539155000801,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%qYb7nfgnAPao6FK4adacmQ7OEV1W/JJ6rdDSsv+vxII=.sha256",
    "branch": "%8OZ8qfJ52G5WAgcMfAfYYDFBHMGJygT6M/BSP7UeBkM=.sha256",
    "reply": {
      "%qYb7nfgnAPao6FK4adacmQ7OEV1W/JJ6rdDSsv+vxII=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%8OZ8qfJ52G5WAgcMfAfYYDFBHMGJygT6M/BSP7UeBkM=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Fyi I've already sketched out a binary format for multiaddresses, but it'll be some time until that comes up, replication will likely be one of the last things I'll tackle as part of the sunrise choir.",
    "mentions": []
  },
  "signature": "fKQEl6rCjuZ9n1ZMwVe/gP+65GfQNa5wStqrVdlKkNCWPpNccJeZ7vadWEguJpi0guIOU/nMQaIuH0klgNX4AQ==.sig.ed25519"
}

{
  "previous": "%nHxPk2b5a4o7cjzXBStRBawBNv+dguPu8oUdKcGw5gw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1196,
  "timestamp": 1539155970084,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": [
      "%OFjy6fymtJRCkDNu4NAb5vJg+ty8ae+MYIxJsnmpFMA=.sha256",
      "%rh5Brc5bzzwqiFokc96wsq1uj3iH7lDx8G+A224K8G8=.sha256"
    ],
    "text": "@Dominic\n> thankfully, something sensible here is happening here @regular and you did not just create a message that makes @aljoscha's spec more complicated ;)\n> [...]\n> So @aljoscha good news, reject such a message!\n\nIt's not this simple: If I sent this message to an sbot during replication, the sbot would *not* reject it. It would perform the character replacement and then accept it if the hash is correct. This is the behavior we have to put into the spec, unless you deem it a bug and change sbot to flat-out reject such messages rather than patching them up and then validating them as if nothing happened.\n\nI'll take your \"good news\" as confirmation that a conforming implementation should fully reject such a message, but you'll need to update the js implementations (apparently [here](%8fFtpLe5b3nxd6rYPUjHcqRBTvtEMAtPjnTNzTO04Ww=.sha256) and [here](%OFjy6fymtJRCkDNu4NAb5vJg+ty8ae+MYIxJsnmpFMA=.sha256), and you might want to double-check whether those are indeed the only places were buffer -> string conversions happen).\n\nCan I get a final ack that unconditional rejection of invalid utf-8 is the behavior to put into the spec?",
    "mentions": [
      {
        "link": "%8fFtpLe5b3nxd6rYPUjHcqRBTvtEMAtPjnTNzTO04Ww=.sha256",
        "name": "here"
      },
      {
        "link": "%OFjy6fymtJRCkDNu4NAb5vJg+ty8ae+MYIxJsnmpFMA=.sha256",
        "name": "here"
      }
    ]
  },
  "signature": "fYJdScXzOTw2wNc84GkTjciWbyL/yL+F3BJ83NG/I5+BovZYp6xBEAas4z1ZQMECScQLZl9q/vIjudVJ2UVcBQ==.sig.ed25519"
}

{
  "previous": "%2Uu3OB1KCLFqkXDqcC4LWH/6Y2GjpVZO+0sTz7JEREA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1197,
  "timestamp": 1539178669130,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%2Uu3OB1KCLFqkXDqcC4LWH/6Y2GjpVZO+0sTz7JEREA=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%2Uu3OB1KCLFqkXDqcC4LWH/6Y2GjpVZO+0sTz7JEREA=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "^^^ [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "Fi6cQSd8Ltx4asb/LYx/3MtKIfTcCrboiAagRK0EmYQ+nx1NEc2XDoTEd+H9trjZEbT6Lf8JJasMa84vQvBJAA==.sig.ed25519"
}

{
  "previous": "%KKzmtqYDiXifHzHkhJl7r9/ouHt95aksTNtpe0qja9I=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1198,
  "timestamp": 1539187198458,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%qXZR406vxMxymxd2jC5g0P2Ij+oOKBlA5XnwtSuM17I=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%qXZR406vxMxymxd2jC5g0P2Ij+oOKBlA5XnwtSuM17I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 10/10/2018\n\n- fiddled around with [gitbook](https://www.gitbook.com/) and [hugo](https://gohugo.io/) for generating the spec website, disappointed by both\n- code clean up: https://github.com/ssbrs/legacy-msg/commit/f45cfbf811b6b701285b010d5a8f8379c8bcd84c\n  - this was surprisingly draining...\n- some more spec writing:\n  - https://github.com/sunrise-choir/spec/commit/587a877875eae40779fdedb9af67922a1c5bddb6\n  - https://github.com/sunrise-choir/spec/commit/bbd8ea62d96501e54657ece38dfc9ed8d90c6913\n  - https://github.com/sunrise-choir/spec/commit/02324859de13f3b2f9bde99150ff673e4e017252\n\nThis felt unproductive... oh well.",
    "mentions": []
  },
  "signature": "7uBoOjYuqGLq74HJ3r6PrHPEd65CpwMpNPRDMzUfvYuU8SyLI+lJX3BSwzzlXIkea6rnV89IbfsPGePUSFtDDQ==.sig.ed25519"
}

{
  "previous": "%dAsf1LY06v2KAOdTf6jAEsQTeivQw1ha8az5Ecnk44c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1199,
  "timestamp": 1539240719902,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%UHX7oKw9T3fAwhkjTnglUp+SNUx55lRZ+TZLbIjBXBc=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "8wUoj2CkW1nx8Q0DPtt6psXP5FM7uB9YOT7junZEGA8sf6y6/nOKYgWePkcciZ8jEl9QrbeYeeU5KiaDXnrDDQ==.sig.ed25519"
}

{
  "previous": "%FzWdzBl56zEDpAznS/pfEOB29a4/jIphMOACRckcWRw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1200,
  "timestamp": 1539240795065,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%W0/US4odp23xgalqbtFyv8dTGCknDeEVeYrJhag2rRk=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "o6+fq3S43eARyQZvr/tgrJV/2BHzBBlcAJjhpEMR3ideyPqE1fY07hv+4+JIpqAMWnXvA0F1MhlLQQKK6Wi8Bg==.sig.ed25519"
}

{
  "previous": "%oSqvt3RpW4yNvUkLdP1omsNI+zlXaEXT4Y8lph1pw4g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1201,
  "timestamp": 1539240822929,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%W0/US4odp23xgalqbtFyv8dTGCknDeEVeYrJhag2rRk=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%W0/US4odp23xgalqbtFyv8dTGCknDeEVeYrJhag2rRk=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "> Yes, lets just \"all json must be valid utf8\"\n\n:green_heart: ",
    "mentions": []
  },
  "signature": "HeoJtXldevKTFn5G/bWACUXb7V5aOLP2hMmvRL7DukQhYHz+d1gyxPEDMu2lowo+cC/VBBQgf8ckG78xffvsDw==.sig.ed25519"
}

{
  "previous": "%CwfKiUCf626/HStCdBNxnHXOICKCMWkR/djHI1HPu0s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1202,
  "timestamp": 1539241094440,
  "hash": "sha256",
  "content": "YtRm4UzCybtBHgorCTwC52aYI5qwSUhNSQJm2rwFuofm9RpXbzHoIK81y15NccC4Yv/kofSE1V/gijT/ahLpgKivzqdawn/BKqyzJR4jv4eMXsqHwMOluxy2qbKv8yYGMeuUvHlyBreNsP1c4HtI09l9wbgo2LQJFgEDRPSzaxtWmDVu0HEetzsL8lRppLPP73tC2FwXb/2jjRCy2w/HdYuywVB9qChsqwpNWm/5STujtPuDV4tD7oXzwrk7AnFyELL7j9tAlg5WIl+jxcTSwukpXbBhV/XoqVCBikltYdNO6LroXkhOowjXGDHNxUwOXABAabdN2Z9e+Q99fMrGYdEfLkWLI0dgY0/zrOp4frYVx0/+eAusN3Ps8fg23i9Lf8cmqKrPPC83tFZMt9q7bOVxREkwJFIqllC3ZKuMQozYYFHwk0gFyXVnDjsvVKKOXLHUyos31wyZolkHm2046huEVU+SPGz3zFi7+Y1z9RxPpVlBMIHzdKSu/xK5kdLYRvXbdA7n9A6kngGO0c3uDP3JfYTxxWJK9Kzc+zgFQrg3kbU8qWEyeTRJL3GE2ThCk12WLL616/hCdkjVxrSVi+h4xPjMRBOeP5E2Cw1JNP1cq9/0JwP5UKgcwS2Alw6SGMpEMALi/n+tM5FdCc2LBapZrzYfrWbpPEpc5vo9o50dPy1DJeeuJxrdJYZWnOyMKiRSzYXtXkBxADUkfUywwP58mJVAmc31TCj5YQ/0o05ZrU2WS5ijU8hcIOTHq1EG+zZFqZlxkkEptWl+JvbuZlcRaLVFTXrXsWxAZ82GaXtLfA1w5vbOaQtXOKN52TcCG/oV8QTiyiRknLmh+IboOYmsisTNRObhxxo11qYzrR9VCXXG1IHWsEYHnNnG5vsDfd65yW4fVEXxmii81UjnhlqOmfhQHThzlqF1OpPEgfZiZEllZTRAALctShg755/a/DJ/O3Tr3VGK4Qo2CdnNlLUHlZ1VDGc8cYGX594ViALpUAiBn4rZNsr35Vs/Zr64H49wBoQq2cFD+vuVOFyhgakqkor6BAPXfOruPPAZmzuluyLCdQLf84NA1BTpp0/rstGq1t+1EIjQizOkwMcOIWuJyL0JXIVRhxjxr/nsNHxc9uTBNqXLgttIV6T60F6Zmvc3KeiraBsrtwKuRM4jBC02kdmjHD/I96wakbNNM1oNyYl2NEyYRm5ZuVRQ5Q2PTFJGKi9BtD+ytLmhWQ0nnUKMOhRR6yARfRfpVdUKW7wHm9bUUnjddSxgDWw1Ga+v1v1Eu1PNoqTl4oFvamQ=.box",
  "signature": "hUsLbBkL4lwvm2rq04CjTt4Ha0zHdxTEvxgczoN/opM81KvqaEAeX7ZGLGmJkuoCoblKRjrgwNwVSlXtY8NiBw==.sig.ed25519"
}

{
  "previous": "%OP8suea04uNyZMZp4fFk87W5TuILN4/mZVBByr47VSA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1203,
  "timestamp": 1539256554983,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256",
    "branch": "%yguQGbduG2F3xglPGs+kB9Xv01aVl9ortkJa8A15q+s=.sha256",
    "reply": {
      "%NeOkZhPNhthqfXXAQ7cIU/NMe3S8SHtDhA8E5hu0H5I=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%yguQGbduG2F3xglPGs+kB9Xv01aVl9ortkJa8A15q+s=.sha256": "@Bk5uzkFxdMJnJR+rKVd+X4LO/u+8VV+lA14e+XLabXQ=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "[@Daan (the other one)](@Bk5uzkFxdMJnJR+rKVd+X4LO/u+8VV+lA14e+XLabXQ=.ed25519):\n> so for a layman: does that mean @Aljoscha's feed will be considered invalid? You made some posts with invalid strings in them, so any (new?) peer would now reject them, right?\n\nNo, fortunately not. The implementation that posted my (and @regular's) data substituted it with something that is safe to replicate.\n\nThe outcome of this discussion means that newer implementations do not need to perform that exact same data substitution, instead they can (and in certain circumstances must) completely reject invalid data, without trying to patch it up.",
    "mentions": [
      {
        "link": "@Bk5uzkFxdMJnJR+rKVd+X4LO/u+8VV+lA14e+XLabXQ=.ed25519",
        "name": "Daan (the other one)"
      }
    ]
  },
  "signature": "cgkXEdfl4CiOf1BP4sZrMkkn6yg/wBsUzLWj/CIQ6DYlJ1jnqF5IxXYZO5fzPaGigIbIM7nPM7hnK6i4Uhz2DA==.sig.ed25519"
}

{
  "previous": "%lFrGAxYhNuVNNfyMrV1m5tBRZrTfbnvgpCJ1sPn8TKI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1204,
  "timestamp": 1539256722923,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%XhrvQZTeIMyc0haaFMYy94+oX3O4Ewzk2HJu1ZBmCbc=.sha256",
    "branch": "%XhrvQZTeIMyc0haaFMYy94+oX3O4Ewzk2HJu1ZBmCbc=.sha256",
    "reply": {
      "%XhrvQZTeIMyc0haaFMYy94+oX3O4Ewzk2HJu1ZBmCbc=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "That is because one of the comments has a timestamp that is (as of now) in the future, and patchwork [trusts those timestamps](%RV4Op3d6LSVyj4wAHTTN0VesbNUSamPFtn7uuYGd1o0=.sha256). In a few weeks, that particular post will stop sticking to the top.",
    "mentions": [
      {
        "link": "%RV4Op3d6LSVyj4wAHTTN0VesbNUSamPFtn7uuYGd1o0=.sha256",
        "name": "trusts those timestamps"
      }
    ]
  },
  "signature": "arSeGcwYLoDTDKBS1ZWEGELbFukYIqYKuM0UvcGLl8ihdNRjP+Q3Yj5Uhrgy/L5/QDt4GCsKYujvrd9Os4W5Ag==.sig.ed25519"
}

{
  "previous": "%4J8G2LWPdSRWbwo7nvhiicRk/gn/+SGEl3eehV54pss=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1205,
  "timestamp": 1539257129657,
  "hash": "sha256",
  "content": {
    "type": "post",
    "text": "# Ramblings On Variable Length Natural Numbers\n\nThe binary ssb protocols will indicate a bunch of types by prefixing a certain tag. Such a tag is nothing but a natural number. We want these tags to take up little space, so we need to choose an appropriate encoding. My drafts so far simply used the ipfs [varuint](https://github.com/multiformats/unsigned-varint), but there are [a](https://github.com/multiformats/unsigned-varint/issues/5) [few](https://github.com/multiformats/unsigned-varint/issues/9) [problems](https://github.com/multiformats/unsigned-varint/issues/12) with that one.\n\nThere is of course no single best encoding, it depends on the expected usage. So I'll summarize some thoughts (many formed by reading through the multiformats varuint issues) and key questions, and propose a format I think would be appropriate for ssb.\n\nI'll start with the most controversial point: Should the encoding allow arbitrarily large integers, or should there be a cutoff point (such as 2^64 - 1)?\n\nThe premise of arbitrary extensibility can only be upheld with arbitrary length integers. Else, there would come a point were we would not be able to e.g. add any more hash functions to ssb. That's why you'd default to an encoding that supports integers of arbitrary size.\n\nBut there are a bunch of problems with that. Computers have inherently limited resources, so truly arbitrary extensibility can not be reached in any case. More practically relevant: Computers are really good at dealing with 64 bit integers, but anything larger incurs performance overhead. A truly variable-length integer type is much less efficient than native fixed-width number types.\n\nThere are also concerns regarding malicious input: If the encoding only supports a finite number of numbers, then there is a maximum length for the encodings. An arbitrary-size format would contain valid encodings of arbitrary lengths, a condition implementations would have to deal with. For that reason, the ipfs varuint format disallows any integers larger then 2^64 - 1. This also allows implementations to use efficient, native 64 bit arithmetic.\n\nBut at that point, why not restrict the domain to natural numbers smaller than 2^64 in the first place? The main argument is that the ipfs format can be extended to larger integers once it becomes necessary. I don't buy into that argument, in my opinion that would be a breaking change. Part of the \"API\"/\"contract\" of the current encoding is that encodings have a maximum length of 9 bytes. Lifting the size limit is a breaking change to that guarantee. Old implementations would reject newly-valid values.\n\nSetting a maximum value can also make the encoding itself more efficient.\n\nSo in my opinion, there are only two valid choices:\n\n- commit to arbitrary length and deal with the consequences\n- pick a maximum value and stick with it\n\nSsb will use varints to tag the variants of union types (e.g. specifying what kind of cryptographic primitive is encoded), and to encode lengths. For both of these, a range between 0 and 2^64 - 1 is more than sufficient. **So unless anyone objects, I will design the binary protocols with a variable-length encoding of unsigned 64 bit integers**.\n\n(pings to people who might want to object: [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519), [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), [@arj](@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519), [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519), [@moid](@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519), [@mix](@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519), this list is not exhaustive)\n\nThe next point is the ability to detect the length of the encoding by looking only at the first (few) bytes. The current ipfs varuint does not allow this, you need to parse the whole thing. If the first byte indicates the length, the remaining bytes can simply consist of the binary representation of the number, so parsing becomes very fast.\n\nFinally, we want canonicity: Each encodable number has exactly one possible encoding, not more.\n\nSome stuff that these encodings *can* do, but ssb probably shouldn't support:\n\n- signed integers\n  - neither lengths nor tags need to be negative\n- endianess indicator\n  - can speed up closed systems that use native endianess throughout, but ssb is inherently open\n  - so we'll use network byte order (aka big endian) all around\n\nWith all of that out of the way, here is a proposal for a variable-length encoding of 64 bit unsigned integers, suitable for use in ssb, heavily inspired by [this one](https://github.com/multiformats/unsigned-varint/issues/8):\n\n*continued in next post...*",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519",
        "name": "arj"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519",
        "name": "moid"
      },
      {
        "link": "@ye+QM09iPcDJD6YvQYjoQc7sLF/IFhmNbEqgdzQo3lQ=.ed25519",
        "name": "mix"
      }
    ]
  },
  "signature": "PI+GQBpMGIPhA4YEsETbtGC0mgwwnjzoKAicFf28zS4sLzGEm0ETjbQpP12WVB7+tbllHun4Z3Y9m0yAZzwaBg==.sig.ed25519"
}

{
  "previous": "%GrYD8mj3wV5s1bqknoYa+rsoeusSuT3sjPBaktTL7ps=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1206,
  "timestamp": 1539257257924,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%GrYD8mj3wV5s1bqknoYa+rsoeusSuT3sjPBaktTL7ps=.sha256",
    "branch": "%GrYD8mj3wV5s1bqknoYa+rsoeusSuT3sjPBaktTL7ps=.sha256",
    "reply": {
      "%GrYD8mj3wV5s1bqknoYa+rsoeusSuT3sjPBaktTL7ps=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "*...continued from previous post*\n\n## VarU64\n\nThe VarU64 encoding for unsigned 64 bit integer works as follows:\n\n| first byte                | value                                                        |\n|---------------------------|--------------------------------------------------------------|\n| 0b0000_0000 - 0b1111_0111 | The numeric value of the byte                                |\n| 0b1111_1000               | The byte is followed by an 8 bit unsigned big-endian integer |\n| 0b1111_1001               | The byte is followed by a 16 bit unsigned big-endian integer |\n| 0b1111_1010               | The byte is followed by a 24 bit unsigned big-endian integer |\n| 0b1111_1011               | The byte is followed by a 32 bit unsigned big-endian integer |\n| 0b1111_1100               | The byte is followed by a 40 bit unsigned big-endian integer |\n| 0b1111_1101               | The byte is followed by a 48 bit unsigned big-endian integer |\n| 0b1111_1110               | The byte is followed by a 56 bit unsigned big-endian integer |\n| 0b1111_1111               | The byte is followed by a 64 bit unsigned big-endian integer |\n\nEach integer may only be encoded using the smallest possible number of bytes. When decoding, violations of that constraints *must* be reported as errors.\n\n---\n\nThis format (compared to the current ipfs varuint):\n\n- restricts the domain to 64 bit unsigned integers\n- indicates the length of the value in the first byte\n- admits exactly one valid encoding per number\n- can be parsed very efficiently\n- optimizes for small values (can store 248 different values in a single byte, compared to 128 for the ipfs varuint)\n- pays for these advantages by leaving quite a few byte strings unused (the encodings that do not use the smallest possible number of bytes)\n  - if it ever becomes absolutely necessary to extend this format to handle integers of larger (or even arbitrary) size, these unused values can enable such an extension\n\nI'll revisit the #yamf formats as necessary once I'll need them in the rust ssb implementation.",
    "mentions": [
      {
        "link": "#yamf"
      }
    ]
  },
  "signature": "tFa8999FwHb25DIti6TTpYzGhTt+xem74ZTpGnNeXCZDh9iL8FnaoQQ2GSaWxm3EwUIYjhAGrmbNRsICaNQNDg==.sig.ed25519"
}

{
  "previous": "%QlFuGsQKY2nSE5IXPk2c/9lRuTpqX6hpBHi0KJ+XI98=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1207,
  "timestamp": 1539262086068,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%EyGGCcjAbaShKFCMxXKYiZjQe17SR298D0SLTuKmZpo=.sha256",
    "branch": "%v0FMgoxOZuEGmCI/u/qiwl9UBMPepHQW/ApXg5QXR2s=.sha256",
    "reply": {
      "%EyGGCcjAbaShKFCMxXKYiZjQe17SR298D0SLTuKmZpo=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%v0FMgoxOZuEGmCI/u/qiwl9UBMPepHQW/ApXg5QXR2s=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "\"Fun\" realization of the day: Sequence numbers are json numbers adhering to the canonicity requirement, so once a feed reaches [length 2^53](http://2ality.com/2012/07/large-integers.html), the legacy encoding can not correctly append new messages. Feeds are currently of bounded length.",
    "mentions": []
  },
  "signature": "+4tsoHlrWBmz4XcjxcS8hLaYd7jjgT2VSJw9nOo9opGinuHB/ZL2O5BzSeqf5odAoW3X174ofxM1OIUHdZgRBQ==.sig.ed25519"
}

{
  "previous": "%fako/wSdcMgpPbiHizlP9Qgs2Vu4reun2c1kBY9zgws=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1208,
  "timestamp": 1539269426437,
  "hash": "sha256",
  "content": {
    "type": "post",
    "text": "# Ready for more unicode fun?\n\nMe neither.\n\nThe following is *not* a problem, the canonicity requirements prevent it. But since I wrote it up before realizing that, I might as well share it.\n\npast Aljoscha:\n> [Json](http://ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf) does unicode escape via four hexadecimal characters that specify the [utf-16 code unit](https://en.wikipedia.org/wiki/UTF-16#U+0000_to_U+D7FF_and_U+E000_to_U+FFFF) to escape. Each of these code units is a valid unicode [code point](http://www.unicode.org/glossary/#code_point). But not all of those code points are valid [unicode scalar values](http://www.unicode.org/glossary/#unicode_scalar_value): [Surrogates code points](https://en.wikipedia.org/wiki/UTF-16#U+010000_to_U+10FFFF) are not scalar values.\nThese surrogate code points are ok when they are matched, a high surrogate followed by a low surrogate. These two code points, taken together, encode a single code point outside the basic multilingual plane. That's how json escape sequences are expected to do it, the world is good. There's a problem though: Nothing stops a user from escaping one of those surrogate code points without properly matching it: `\"\\udc00\"`. Decoding this results in invalid utf-8, the byte sequence (`0xdc, 0x00`) is rejected by conforming utf-8 implementations.\n>\n> But: `JSON.parse('\"\\udc00\"')` happily accepts the input and returns a js string containing invalid unicode (which is allowed, js strings are not guaranteed to contain valid unicode). Run `JSON.stringify(JSON.parse('\"\\udc00\"'))` in a console to see the string literal, helpfully rendering the invalid code point.\n>\n> If we accepted this behavior, it would become impossible to use the language-native unicode string implementations in any language that provides proper validity guarantees for its strings.\n\nAt least that's another obscure detail to add to the spec. There aren't enough obscure details in there yet.",
    "mentions": []
  },
  "signature": "RoF0HQ1H5Jizuui0qhSyDVRqLcScpxeCsVDouSMhR9DsKbPf9C/LPCqxCjmK5sDQQnBs7aoT+zLlsXf5DHMBAg==.sig.ed25519"
}

{
  "previous": "%kXIiDGhzLT837IxoMsay7z1uoNRsHiqSJV6OWAtWb4k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1209,
  "timestamp": 1539272091487,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%kXIiDGhzLT837IxoMsay7z1uoNRsHiqSJV6OWAtWb4k=.sha256",
    "branch": "%kXIiDGhzLT837IxoMsay7z1uoNRsHiqSJV6OWAtWb4k=.sha256",
    "reply": {
      "%kXIiDGhzLT837IxoMsay7z1uoNRsHiqSJV6OWAtWb4k=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Fun fact: Js strings may contain invalid unicode, but they don't provide a method to check whether they are valid or invalid. If you ever need to know:\n\n```js\nlet prev_is_high_surrogate = false;\nfor (let code_point_str of str) {\n  const code_point = code_point_str.codePointAt(0);\n  if (code_point >= 0xD800 && code_point <= 0xDBFF) {\n    if (prev_is_high_surrogate) {\n      throw \"two high surrogates in sequence\";\n    } else {\n      prev_is_high_surrogate = true;\n    }\n  } else if (code_point >= 0xDC00 && code_point <= 0xDFFF) {\n    if (prev_is_high_surrogate) {\n      prev_is_high_surrogate = false;\n    } else {\n      throw \"low surrogate without preceeding high surrogate\"\n    }\n  }\n}\n```",
    "mentions": []
  },
  "signature": "GgUooX9IQ3xtA2z+HOIgqI4cBfqdYGALaxSsjoXDtHroBBqIdOdPV20DVM7XdqW2RQ4SunbqzAS/tiUasVQYBw==.sig.ed25519"
}

{
  "previous": "%iuJDgSyh+4Hjcj3EUcjXZKfsuSZF5zFlsRKGpeBh6W8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1210,
  "timestamp": 1539273009230,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%dAsf1LY06v2KAOdTf6jAEsQTeivQw1ha8az5Ecnk44c=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%dAsf1LY06v2KAOdTf6jAEsQTeivQw1ha8az5Ecnk44c=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 11/10/2018\n\n- got distracted by varint encodings: %GrYD8mj3wV5s1bqknoYa+rsoeusSuT3sjPBaktTL7ps=.sha256        \n- [more](https://github.com/sunrise-choir/spec/commit/4cc858f389182b22c8f49b6f0cc72aa07e3f9ef7) [spec](https://github.com/sunrise-choir/spec/commit/b5be0048e13580415ba46d5b90ae2c9f4c401770) [writing](https://github.com/sunrise-choir/spec/commit/8bc0cc7c3736e815f548c526066d17853126ce32)\n  - at [this point](https://github.com/sunrise-choir/spec/blob/8bc0cc7c3736e815f548c526066d17853126ce32/spec.md), the spec is ~~hardly readable~~ fully describing the current message format.\n- fun with unicode (it just keeps happening, thankfully wasted time on this as it does not affect us): %kXIiDGhzLT837IxoMsay7z1uoNRsHiqSJV6OWAtWb4k=.sha256\n  - had to update the test data validator for this though: https://github.com/sunrise-choir/legacy-msg-js/commit/123c29eb774e29a7e2435d5486ca12ee0a209cf2\n- uploaded a tiny bit of test data for legacy values: https://github.com/ssbrs/legacy-value-testdata\n  - CC [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519), [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519) ",
    "mentions": [
      {
        "link": "%GrYD8mj3wV5s1bqknoYa+rsoeusSuT3sjPBaktTL7ps=.sha256"
      },
      {
        "link": "%kXIiDGhzLT837IxoMsay7z1uoNRsHiqSJV6OWAtWb4k=.sha256"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      }
    ]
  },
  "signature": "lxvjtifD53Oh8r8QweNgXkp7Fx0iJML2sN/wrROxmtceySNGovxUbyH3QwjJDOslyfJpXfsWc9KGfl+K+BznAQ==.sig.ed25519"
}

{
  "previous": "%PW43Ppg8fC29pd0SN4wX35vv1QZOgWRzFkpMjuKY4Lg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1211,
  "timestamp": 1539290864848,
  "hash": "sha256",
  "content": "HnrQOpganMSa2Kv160EpA1NlEbDBnPL6X+VeW5ONv6ZAWZVuB/54Q1C6usCpTaVILdQXKEG0bivggiV+rZaapGErjKV8CrlKrySTicMw+ZMhSYk+URYuu1EEES8w4NNYoDAprXOMGhLHyiYoP50FHgGLtGMadzty7vHrwxjS+HiF0b5h4gL0mxqIqC/Ll8DWDurVVhGjsWHScgLOUvJJwUGxkSfV20lTh4RM9G2cP9byY6ye99grpA+yXsegb/8oBzCgIhMkaJ/4E4VFw5jEreL8Q+tyGnjIeyIZ5TCiSFnRACU0zR6qG1r9Dov8rkAxQNZ9xKrZFOqgimMT4tYtX627oAh5DiNygdvN1zGKxN/Whi/JNXroE8/RSpJOAWfjoIBjYhL4zvqvqA9j4RjhKSko2WtcYq6FkFELHUMwOxo6+9j84ic88kLQ19u/o5QNTdoNjlz7J4aw8dNti8zvjZoUiWsLELbeuVCKHLO62PTdyZd2BvSKnvUfBi6bkMHr4ivS3lwcAwvF7psRpu1DQtlnyooFo3gMrWtnD8fNLAnxjixpnM4ujspgfaQD/U+zfVlZ6U3im+wt7q8sPhMgenPXqmxtiUaGA7mXLiMDbolOuxNVxfCiJSL5s66s2cqTlY0jFN6i5VjM5g1Gam7xvlYr/uSHXZxJep5gOEvcELJWd2G3bz69/TokpyOHTKB8h5iWCoAUScDPwN8zPHyjxIqYDJ9eGwlKzqFs3Gmzpg3FeKM5vwFdFjRVijQpp/qnr+9WC2mbr9fpTiPmem+H/o4QpEaGmdk3u0FRIXS4Nd+k/+95hKgS+5FGSCi4QLz3doF/GP8vLGszKsjv4876IaA/3YRUx7ElHI63CMkqgWM5tFXXGN2bLDTCWo/FFdLsWQ7ucUcAkYXK3iDxkaFq5gcw4zpSQZH+nsI/+QqpIwCi+KrnQDMNXwg8zWP+cdH6/GUWboO/MRk2oKcKoJF2v7sC3U2JkCO7jAJQQbVSSQCISCncgwvBOO+mrpKlafjNaG32m8NBR2PtzeA1/E43UL/fW7WbF6JetPjNqx6qUASd0lUgnaR53Q21JJgjawNsdQ+YFHYiecEPQFBsT1N5vp+4MhZOdqqGZ7nTi25v3E7Y332EHqeQ0MTm9f3y0C4A0p6V.box",
  "signature": "94JU6sb4g4vfh7tUJpsbIXDeKcbXe+3A4h1kDk1L0qbEAXoqaqZvyRYqd9cQ10ukg3usWg1wD2mpWOxUt+pMCw==.sig.ed25519"
}

{
  "previous": "%FhrzU2FC30aHpJWYC5RdbRv374UnYbUoZG0pSUgN1CA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1212,
  "timestamp": 1539339401460,
  "hash": "sha256",
  "content": "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.box",
  "signature": "BAIowjSofEW8+UixU0ruR0mSgraF2eRmEr5Bx9/k/Qa09duGYRcrVwbN96L8ETBCrqOdT4vB9vyiyZtDJ8IwBw==.sig.ed25519"
}

{
  "previous": "%RAezbyeKnyfnZL6uSlCVUuHm4v/YWYfJ2rhdNI6sxuU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1213,
  "timestamp": 1539377581584,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%PW43Ppg8fC29pd0SN4wX35vv1QZOgWRzFkpMjuKY4Lg=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%PW43Ppg8fC29pd0SN4wX35vv1QZOgWRzFkpMjuKY4Lg=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 12/10/2018\n\n- tried to extend the [Deserialize](https://github.com/ssbrs/legacy-msg/blob/master/src/data/de/deserialize.rs) with an associated error value to get statically checked error handling rather than serde's dynamic error handling. Failed, the type system is not expressive enough.\n  - probably should have given up sooner, this felt like I wasted a lot of time\n    - I did learn new things about the rust type system though...\n  - settled on stringly-typed errors like serde: https://github.com/ssbrs/legacy-msg/blob/master/src/lib.rs#L19\n  - that still left some trouble when implementing visitors, so gave them stringly typed errors as well\n- implemented legacy encoding for public keys, wasted a bunch of time error hunting until I realized that the [base64](https://crates.io/crates/base64) crate [does weird things](https://github.com/alicemaz/rust-base64/issues/75): https://github.com/ssbrs/ssb-multiformats\n- set up fuzz tests and test data generation for legacy encoding of public keys, but this is blocked on the base64 bug\n- ~~implemented~~ copy-pasted legacy-encoding for multihashes: https://github.com/ssbrs/ssb-multiformats/blob/master/src/multihash.rs\n\nNext up:\n\n- implementing legacy metadata and its json encoding\n- message validation\n- html version of the spec\n- so, so much code clean up\n- releases\n  - not yet on crates.io btw, I want to keep the flexibility of git dependencies until we know what kind of interfaces make sense\n\nI won't manage to finish it this week, but reasonably soon I'll be done with the legacy stuff. And then I can start thinking about protocol improvements again.\n",
    "mentions": []
  },
  "signature": "HbM/zuw+wtdg37naHweUydO64tRwoEDFZ8jILFm9S+WbfUvrS2kf8sgRT0973U2Vx+iq0rkYvjKywv5kc2QUCQ==.sig.ed25519"
}

{
  "previous": "%GKStctEutueJ14zwLhVO69cMCspyfLfmtlkeuQmjycs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1214,
  "timestamp": 1539545975572,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%mai+JnAw2DJjvlr4FRBzp+kH3w0FsclopQrs5QqaMF4=.sha256",
    "branch": "%JMFh6ouW29HuvA3/89TsTR0K3cX4Hb5NiQEFDUsskwo=.sha256",
    "reply": {
      "%mai+JnAw2DJjvlr4FRBzp+kH3w0FsclopQrs5QqaMF4=.sha256": "@fBS90Djngwl/SlCh/20G7piSC064Qz2hBBxbfnbyM+Y=.ed25519",
      "%JMFh6ouW29HuvA3/89TsTR0K3cX4Hb5NiQEFDUsskwo=.sha256": "@NeB4q4Hy9IiMxs5L08oevEhivxW+/aDu/s/0SkNayi0=.ed25519"
    },
    "channel": "private-groups",
    "recps": null,
    "text": "[@cinnamon](@fBS90Djngwl/SlCh/20G7piSC064Qz2hBBxbfnbyM+Y=.ed25519)\n> You can treat a \"group\" just like a feed (send private messages to and from, follow it, block it, etc)\n\nThis is the hard part, replication and dealing with forks become complex. Unless you choose a trivial (i.e. useless) scheme for reconciling forks, clients need to be aware of forks happening, warranting changes to *all* client APIs.\n\nI wrote up a few thoughts on a very similar subject [here](%DiKg7pb5f8nK+9UXYkh0NFycwI4311vFpl7sJQQVV0E=.sha256), you might find those interesting.\n\n",
    "mentions": [
      {
        "link": "@fBS90Djngwl/SlCh/20G7piSC064Qz2hBBxbfnbyM+Y=.ed25519",
        "name": "cinnamon"
      },
      {
        "link": "%DiKg7pb5f8nK+9UXYkh0NFycwI4311vFpl7sJQQVV0E=.sha256",
        "name": "here"
      }
    ]
  },
  "signature": "GZrul0X2t2NNdUQTIKScF/okVVeHA2B/6dCyazkC13m8x7XY6l4ftil0EDHKRjQ9ZoXz3fyCNwxgNl9KEZZ3AQ==.sig.ed25519"
}

{
  "previous": "%D4e/VEk2ip0kPz8MMrUhiG7yykMCitOxcLudd6guP6s=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1215,
  "timestamp": 1539546483867,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%GKStctEutueJ14zwLhVO69cMCspyfLfmtlkeuQmjycs=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%GKStctEutueJ14zwLhVO69cMCspyfLfmtlkeuQmjycs=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 13/10/2018 and 14/10/2018\n\nSpent a lot of time fighting the compiler and my own traits. I got pretty frustrated, it has taken me ages to write a tiny amount of low-quality code for the [metadata implementation](https://gist.github.com/AljoschaMeyer/c4d3c80dd81a4d57615929bc87781192). But I think I figured out why: I've misunderstood [serde](https://serde.rs/). I wrote a serde-like crate where the supported data model is exactly that of ssb. But the serde data model isn't about json/cbor/whatever, it really is about the rust type system. Data format specific stuff can be done by the Deserializer/Serializer implementations (and most importantly their error type). This was why writing code with my custom traits was so painful - they simply didn't map to the rust types I tried to (de)serialize.\n\nThe moment I realized this, I went from having to force myself to do more rust implementation work to actually looking forward to it. But I'm done for the weekend.\n\nOther things:\n\n- turned spec into html, adding ids to get something linkable from the rust implementation: https://github.com/sunrise-choir/spec/blob/master/index.html\n  - still need a URL\n- signature decoding: https://github.com/ssbrs/ssb-multiformats/commit/3ea18acd8a51fe9d559f2758e961a67c3d9d1ac7\n- unicode stuff: https://github.com/tormol/encode_unicode/pull/7\n\nI can already feel this dev diary [declining](https://xkcd.com/1296/)...",
    "mentions": []
  },
  "signature": "oGlwfyTxgC+gkKtjI2gXeKBbVZXPeBNHQQKg7smSAG65fKLnR9wxeRQ7ZWGfOAzNCRcjLtIwCr5kJc8tst0VAg==.sig.ed25519"
}

{
  "previous": "%Ry/WwEavJIGalPiDh3AWTvX1rP9VmcMlcvl7CrhIyFU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1216,
  "timestamp": 1539547043139,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@2l2DptBNWlUG/gCO4LJBXvqMZ8106WTwmXqlbh1kMuo=.ed25519",
    "following": false
  },
  "signature": "NuadM/Lft5egOvVw8mD4tQTqB6288yalEiJfHNVlimEIYsGRMAciGsX5VRfZughspKDMKcwdbkJpLV+TEj4IAQ==.sig.ed25519"
}

{
  "previous": "%jyKww1pD9C9uaJ8Ipitcu22HTDZU2E/g/zqhpeyuYEs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1217,
  "timestamp": 1539587555049,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%mai+JnAw2DJjvlr4FRBzp+kH3w0FsclopQrs5QqaMF4=.sha256",
    "branch": "%luQDHmZSymh4ejoo9IoRpzxzfNYpnhoeYLW3kmYNqXA=.sha256",
    "reply": {
      "%mai+JnAw2DJjvlr4FRBzp+kH3w0FsclopQrs5QqaMF4=.sha256": "@fBS90Djngwl/SlCh/20G7piSC064Qz2hBBxbfnbyM+Y=.ed25519",
      "%luQDHmZSymh4ejoo9IoRpzxzfNYpnhoeYLW3kmYNqXA=.sha256": "@JoiN9c9+xO0jgu0gg5yflTf+L1peLTBneFHjrKbmcKo=.ed25519"
    },
    "channel": "private-groups",
    "recps": null,
    "text": "[@cinnamon](@fBS90Djngwl/SlCh/20G7piSC064Qz2hBBxbfnbyM+Y=.ed25519)\n> Is that what you call a \"tangle\"?\nhttps://github.com/cn-uofbasel/ssbdrv/blob/master/doc/tangle.md\n\n> I was thinking that device feeds would remain linear as they are now (no forks).\n\nYup, that's what I called a \"physical identity\" in that post. But what happens if two two device feeds update concurrently (which in ssb can mean usage while offline, or usage while only syncing with parts of ones network), how do you order their messages? If the group (what I called an \"logical/aggregated identity\") has to look like one feed to the outside, it needs a total order on all its messages. The tangle.md articulates a data structure that can be used to approach this problem, leaving the order-resolution mechanism to a higher level of abstraction.\n\nAnother useful resource for this is looking at how distributed version control systems perform merge conflict resolution.\n\n---\n\nYou can also lure [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519) into this discussion by using the word [holon](https://en.wikipedia.org/wiki/Holon_(philosophy)) =)\n\n---\n\nAnd a final caveat: I mentally separate this kind of protocol from ssb. I see ssb as an experiment in seeing how far you can take the simple replication of append-only logs. A protocol with fractal identities is just a different thing. And I'm pretty convinced that approaching this on the protocol level would yield better results than simulating fractal identities on top of ssb.",
    "mentions": [
      {
        "link": "@fBS90Djngwl/SlCh/20G7piSC064Qz2hBBxbfnbyM+Y=.ed25519",
        "name": "cinnamon"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "L5jVluBBbZuC7PdovjuWGOxvAm/2PMQgOoJIYOWhhvBUvzY3rm0D1FNSNFSXluGL/YZtG9P5BRFW8YwtUoV3AQ==.sig.ed25519"
}

{
  "previous": "%U7Sfq76YgnLf8r/kCV4eZVI808RTpwa1FWDxDc0CTK8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1218,
  "timestamp": 1539600645988,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%Ry/WwEavJIGalPiDh3AWTvX1rP9VmcMlcvl7CrhIyFU=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%Ry/WwEavJIGalPiDh3AWTvX1rP9VmcMlcvl7CrhIyFU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 15/10/2018\n\nThe problems with serde still persist, there are a few things in the ssb metadata that serde just isn't equipped to deal with. I don't have the energy to push through this right now, I'll take the day off and discuss this in the next sunrise choir call (which luckily happens tomorrow).",
    "mentions": []
  },
  "signature": "7a9hH7t85hUHawIJ/kc5IwrNleCW1VAKWWoEVVPMyDCtqDn4mS5Uos0R1hvAgKhW/LskP8q3Us4JciTPpB1gBA==.sig.ed25519"
}

{
  "previous": "%IvA7g15L0VzwVkDC7qQtoErigUfnl25V7yQ3wLNdUEo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1219,
  "timestamp": 1539612212971,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%3hli4+jOqRZ1EE6EckvVh74DIda+hRzabTfvHecxfqU=.sha256",
    "branch": "%3hli4+jOqRZ1EE6EckvVh74DIda+hRzabTfvHecxfqU=.sha256",
    "reply": {
      "%3hli4+jOqRZ1EE6EckvVh74DIda+hRzabTfvHecxfqU=.sha256": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Also cc [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519)\n\n[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519)\nOut of curiosity, is the crypto overhead noticeable, or is message verification done directly as the data arrives?\n\nI'm against transmitting flumeviews. Currently, the protocol is db-agnostic, and it should probably stay that way.\n\nOther than that, I can't really contribute to this. I'll be getting to a more compact transport encoding for legacy messages next, but that will only help with the network. And the further upcoming protocol changes (most notably offchain-content) will also only reduce the network overhead. ",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "xf7d66Em4OBkDRcLMWnf2UwlexgUJh+CeYqZZ7Sa4wsvhbVPgN/7XI4qf1xatnL8gEMxlnhmI7bhqr92AATfCg==.sig.ed25519"
}

{
  "previous": "%w3J/4CVG63uwTce0GAL2hZgq2xcIaxVUwW+XNXnvSpM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1220,
  "timestamp": 1539614072936,
  "hash": "sha256",
  "content": {
    "type": "post",
    "text": "Base64 is Fun!\n\nhttps://github.com/alicemaz/rust-base64/issues/75#issuecomment-429841903\n\nTLDR: There are non-canonical encodings in base64. I haven't checked yet whether node accepts those. In any case, ssb does not reject them in the verification stage, since signing encoding computation happens without ever decoding the base64 encoded keys/signatures/hashes. [ssb-ref](https://github.com/ssbc/ssb-ref) claims to \"check if a string is a valid ssb-reference\", but only performs a naive regex check.",
    "mentions": []
  },
  "signature": "q1AACOZLWu0BiJmZP2wLcB5kpdFXwewjPW1YUQBgHpHlWR2URj+eV4M4Br1IP448urERxELJ797XeLGspuZiAw==.sig.ed25519"
}

{
  "previous": "%snC1zxvnLUB4au9a2xvEF7JH2pkAj163fT8KuYDexUE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1221,
  "timestamp": 1539672376819,
  "hash": "sha256",
  "content": "3a5dHHpY1I7DW5SJIkuT6cphl4CnUL0YQpdRtFaASoObvrCPi84kjnFrNYmkS1ADrPXAMJrk7DWasxEIvfBFjLNogS9gVsz9gH8ivgXs296WVYrT8zKeOu3D1+f3VRCKhmfUCwt3QYhczfnB5zz668YBFDthZBSKuiBsD99qk8nYnOcCok7v2VQ4uHVLJ1Onxlx4MidcYDau2KnMxL7tWj8hcL18u0T4HmN81rFv4NAzJlqPzS+oViabijpIEfERwgDFn3au7dDW668TK8Ip4zvbs/mWHmbXT4pyaZxg84C6DLIjGiaVre5wADygio9Up14AncrLMTc+MjKmIZdD+CIMbIpKGPaJzIAry1XZKaDKBmMCn3HTpwkmpAMd9iqD6PCDUrmJCyBY/2agflVxjiowsjf2CMdnPCjhcCeosrYtB2I3b/oDgArNGOnjVFvTexz2LXQUQAR4TYDW6GguDYYe8TduI6dJPp3tZepy+ZuvpTjoS5Ag5IitAKIqbcruiMPE0l/4rs2hqC9E51hBPEoGtR5ZEGcpcBPiV61HA3noRfYPADMKEZczoX1CAgPStz3SBebiE9nzc5UvJ7KIm4yKtfuhsmrYKBLIXw0XFwJiG9mB+IS/os3B3k6XCSGWqj/rOlACAXwCpGq54DSzAt5NqHFqM3GX9vS7jATviu8m+lF9/pn4f8ZHtVqoBeFAe4lFiyVa7oCsPgQo7Waya2Bo+eyu1QsPO6sG+H6A8wBCoSUJyQHrwRtVARbFvb0R0SmFWtd915xc9QkmnyAZ/yKcRCASo+Y0pBt30UTnPziSfzf5b1mEFkwuge6UlYzZf9jYg5fFio6MLdpn3gQN/g3CwmDmweO9/UzyY/5Bo84cVlaNbE3NUcCFdjEt4agMnH+eRWtDqvPZIt0pGbiB4BKTy0V+xEpND4bS5cgOkk4BMMwz/coSjsjbIo863Llq+8BEzVkJu0Z8X9tc2X+zfWglGjdcI52uBnAJysdpmZbVhfdMkaCKEyfPsw001AK/PkQSdhczNOdJAIzgS23E642sK1bbHQs5byy7O+xA9f2spA3RLFxDRVyNLcOz.box",
  "signature": "R0F+++HtVCux73EiNgrCmDKtR5kLatKqPNyJ4wYcXuXbxQKrnI8bSB2s5reFx0IEysF5DV3pgYcaVt14x0EPAw==.sig.ed25519"
}

{
  "previous": "%FF9+pWmdfcQbzo/h72eB6fDFOlc8cf1pMGHKdp9YUuk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1222,
  "timestamp": 1539685360545,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%3hli4+jOqRZ1EE6EckvVh74DIda+hRzabTfvHecxfqU=.sha256",
    "branch": [
      "%IwJLgtu8dBENWQ5eKwf8MRTC3ZXgXV1VFmEEBj5jJPg=.sha256",
      "%yXybWRHXosvFfwmBD+Vv9fMSsc75lGgSTIu39g5sK/w=.sha256"
    ],
    "reply": {
      "%3hli4+jOqRZ1EE6EckvVh74DIda+hRzabTfvHecxfqU=.sha256": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
      "%IwJLgtu8dBENWQ5eKwf8MRTC3ZXgXV1VFmEEBj5jJPg=.sha256": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "If it is signature verification rather than decryption that takes so long, then off-chain will also help with this, since much less data gets signed.",
    "mentions": []
  },
  "signature": "SKbm8+330+OHLs00Jvh6/c7pAF1BeDQak7nCuKOcBss+R+AYXzXEU09ATmKZfx7lrXB4Z7mnxKkOl4gp65NGAQ==.sig.ed25519"
}

{
  "previous": "%W5opDNdXr+DTCJLqE0aRJl2YL6anjJm18PzWCkqOiT0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1223,
  "timestamp": 1539685759209,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%dtq8ag0+ywIa4qGyTMF7rE7xFpMQJxDvg9JvOK/CtS4=.sha256",
    "branch": "%6uhFP/GRaWgce0kTt33OAZvDcEaCrX1NiG5ueHHc6qI=.sha256",
    "reply": {
      "%6uhFP/GRaWgce0kTt33OAZvDcEaCrX1NiG5ueHHc6qI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%/xuepFv/QGh7y4J5jHaZNXFzbqjNbd8qAWm4Y1j8xJY=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": "sunrise-choir",
    "recps": null,
    "text": "# sunrise choir - 16/10/2018\n\n## attendees\n\n- piet\n- aljoscha\n- mikey\n\n## agenda\n\n- [x] checkin\n- [x] schedule the meeting for a regular time\n    - Tuesday 8pm NZDT\n    - Tuesday 9am Berlin time\n    - Piet will make gcal invite for ~~Mikey and Piet~~ normal persons\n- [x] schedule the retro\n    - Tuesday 30th of October\n    - Piet will make gcal invite for ~~Mikey and Piet~~ normal persons\n- [x] piet would love to hear about alj's fuzz setup\n- [x] review\n    - everything is horrible (with serde (and ssb))\n    - mik still hasn't started discussion about licenses\n- [x] what is the process for js bindings?\n- [x] what should alj do next?\n\n## review\n\n### Aljoscha\n\n- full spec of legacy message format and metadata\n    - includes edge cases of non-canonical formatting\n    - oppressive amount of edge cases\n- not everything is perfect and generalized\n    - logical is right to generate test cases for fuzzer\n    - once we generate a server executable, can figure out what needs to be improved\n- read in data, validate it, output in compact format or signing format\n    - hash computation: ssb didn't specify encoding, node defaulted to latin-1 encoding, in practice means encoding as utf-16 and taking only least significant bytes\n- metadata\n    - alj underestimated the protocol\n    - defined multiformats\n    - most annoying is how metadata itself is structured, serde is not good at parsing it\n        - content can either be arbitary json object or string\n        - serde cannot elegantly handle this case\n        - solution is to ignore metadata as being json at all\n- should we use custom-serde or serde\n    - normal serde gives us potential for static traits for ssb message types\n    - custom serde more accurately reflects the data model of ssb\n- rust traits are less flexible than desired\n    - ideal is serde parser can directly build up a native js object\n        - https://docs.rs/json/0.11.13/json/enum.JsonValue.html\n        - https://docs.rs/napi-sys/0.1.1/napi_sys/enum.napi_valuetype.html\n- testing & fuzzers\n    - integration to rust toolchain, `cargo fuzz`\n        - https://fuzz.rs/book/cargo-fuzz/setup.html\n    - fuzzer analyzes paths to your code, tries to find the full state space of your implementation, tries all the fuzzy bits\n    - test all the possible (corner) cases!\n    - next step is to try all the possible cases in js\n        - separate what is valid or invalid\n    - creating great testing data sets\n\n### piet\n\n- first day, did setup, thinking about where to go\n- jumped into making private-box-rs have usable js bindings\n- as of yesterday, got js binding working\n    - project is not as tidy as wanted\n        -  faffed around with getting everything working\n    - will have a think about using [`napi-sys`](https://docs.rs/crate/napi-sys/0.1.1) crate\n- spent today looking at how everyone else manages prebuild binaries for things that need binaries\n    - how does `cross` module work?\n        - can we use his docker image? yikes rabbit hole\n    - discovered appveyor \n    - use travis ci for building binaries\n    - `trust` module: rust library for building rust bindings for many os's\n        - japaric is fucking prolific and makes amazingly useful stuff\n- looking at how to do async decryption\n    - oh no, c++ void pointers and madness\n    - will sleep and see how ugly the story is\n- how to tidily manage when things go wrong\n- overall happy with n-api, it's the thing we should be trying to use\n    - only stable in node 10, but legit, is successor to nan\n- tidy tidy tidy\n- goal is to do a good job on this module\n    - so will serve as a good easy-to-use template for other modules\n- alj: is there a check whether a given string is a valid box?\n    - wondering whether need to implement this higher up the stack\n    - maybe good candidate for fuzzing\n\n## what should alj do next?\n\n- fun!\n\n## what is the process for rust-js bindings\n\n- `rust-sys` ?\n    - probably the best way to go\n    - pie will what he can do\n- pie will write up a document on how to make rust-js bindings",
    "mentions": []
  },
  "signature": "/NMMQV2lkzjF6fHnA4Apzi5gA4O0Uwvz4DJ/Nix6VAoSh/+t2eqo0Y1BoY6qTA1IOQ69IExwwDjqXXSak63LCA==.sig.ed25519"
}

{
  "previous": "%7bI0b8/4LHOQFt5tk/EToN1NzwqH43UrppZB+FaX3/8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1224,
  "timestamp": 1539688156153,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "ssb",
    "text": "# Canonical Base64 in SSB data types\n\nWhen decoding base64 data, in some cases the last few bits [don't encode any data](https://github.com/alicemaz/rust-base64/issues/75#issuecomment-429841903). The [rfc mandates](https://tools.ietf.org/html/rfc4648#section-3.5) those to be zero bits. Node helpfully decodes noncanonical data anyways:\n\n```\n> Buffer.from(\"iYW=\", \"base64\") // Not canonical, last bits are `10` rather than `00`\n<Buffer 89 85>\n> Buffer.from(\"iYU=\", \"base64\") // Canonical representation of the data\n<Buffer 89 85>\n```\n\n[Ssb-ref doesn't check for canonicity](https://github.com/ssbc/ssb-ref/blob/master/index.js#L7) either.\n\nAs a result, ssb currently accepts multiple encodings for a single public key/hash/signature/encrypted message content. This means that implementations can't just parse incoming messages and handle the actual data. For correct signature-and-hash-preserving re-serialization, they also need to store details about the possibly noncanonical encoding. It's not that bad (only a single byte of data) per base64 encoded chunk, but it's definitely weird.\n\nSo instead I'd like to specify that all the base64 used in the ssb protocols MUST be canonical and invalid base64 MUST be rejected. [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), is that ok?\n\nCC [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519), [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519)",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      }
    ]
  },
  "signature": "P5wHH9T1SagT7x1ljBa/BR9RLPmbg/tWMTXdxn7WntpH/IngBR8u6g32gn20DnhQn+VkvrQbSqVhT7AMV5YxBw==.sig.ed25519"
}

{
  "previous": "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1225,
  "timestamp": 1539722304151,
  "hash": "sha256",
  "content": "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.box",
  "signature": "DOwoDXSPLjL8QwRibgljRr/pyCW8Te+QdVXPmPl+OUsoz968NDHg+Ps9TO4U/IxVbRpRdrufzGvkzfd9i2yYCg==.sig.ed25519"
}

{
  "previous": "%MXJjnSDZH1i+l5y2vbxmiAiaI/dCUCH9xd0GmgkU39U=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1226,
  "timestamp": 1539725761242,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%IvA7g15L0VzwVkDC7qQtoErigUfnl25V7yQ3wLNdUEo=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%IvA7g15L0VzwVkDC7qQtoErigUfnl25V7yQ3wLNdUEo=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 15/10/2018\n\n- talked: %7bI0b8/4LHOQFt5tk/EToN1NzwqH43UrppZB+FaX3/8=.sha256\n- learned enough about base64 canonicity to recommend enforcing it: %5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256\n- implemented the [VarU64 format](%QlFuGsQKY2nSE5IXPk2c/9lRuTpqX6hpBHi0KJ+XI98=.sha256) (good thing I already had that crate name on cargo.rs) and wrote a spec: https://github.com/AljoschaMeyer/varu64-rs\n- fixed a problem with bpmux: https://github.com/AljoschaMeyer/bpmux/commit/fd2eb85f2bff162609363b4037d5f6098cbee82e\n  - bpmux-rel isn't updated yet, that'll wait until I get to implementing it\n- generalized and slightly modified the [yamf-pubkey](%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256) and [yamf-hash](%tLojVSXLYahw/XFXim76QL6dxnOtuYag0Ff/zBrt32Q=.sha256) formats into a single type-length-value encoding format without semantic assumptions, and implemented most of it: https://github.com/AljoschaMeyer/ctlv\n",
    "mentions": [
      {
        "link": "%7bI0b8/4LHOQFt5tk/EToN1NzwqH43UrppZB+FaX3/8=.sha256"
      },
      {
        "link": "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256"
      },
      {
        "link": "%QlFuGsQKY2nSE5IXPk2c/9lRuTpqX6hpBHi0KJ+XI98=.sha256",
        "name": "VarU64 format"
      },
      {
        "link": "%cLnq+v5N6771kniz97k/j52qh1F6mUssWCGrYPwKLkA=.sha256",
        "name": "yamf-pubkey"
      },
      {
        "link": "%tLojVSXLYahw/XFXim76QL6dxnOtuYag0Ff/zBrt32Q=.sha256",
        "name": "yamf-hash"
      }
    ]
  },
  "signature": "6nXMLljZD7/+2DMq+U77l4lMSCZn4i2i/a3TIGgaJastOL7oVfEZGPcBIfGfAPaCUn8imPy83iOlqNISS4JXAg==.sig.ed25519"
}

{
  "previous": "%a/sPmkGYYAkpw2pFWo3i7PBsXQ7Q4xM5CrBzTl0U9EI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1227,
  "timestamp": 1539726687385,
  "hash": "sha256",
  "content": "vJoNkfBuDDbiEqetjv7u/QUqnFOTsSzrU2JElyYYbfb0trF1VChQIg3Gp+fWqOgmEcxocldj3FMW0W2TKk1fVthjP84OR5xSPyKlQftPPrjgGaWgvIlpEHx9hH9ssWbYUy7lMqLa+YdyAajx5ChDDoOdqukMnYbvM+2sQTo4wlpU+5udYiMx1CEljphdGomWSFmRiLiLqRSi9kXYRzng3y2ypKuMZbPsZZbXYzPychAo0ViRyMv1oKydHqpd9gLoBia0xW1kkPCP6JJfkWVwTqrEZ6kYZHQ3kuArSj7/W5OsbOy/a1hkSemvwAgZotrlNg8jzG1vKPjVz4pJUBS3n/TKybIrzp6Hly35Rel5zUTDXczX9LxyXWcSxIULfyAHasfK8LdRHhzIWyFep/nIBaLHkaFnIdeP6jj/twEy8B1ulLh03aUtpk2JHKdk9HMaNvF2gouXSseJi/4zwtGylFF27D1S7T50PgVlUykbV3SBd6h6AzImvCz6u7N5kWHmqtFNmN9ZpU+zc9GWHVY9/5rGeOlAJFPbDk4DjUahZElEZmuykfLe/2xMpBlLXPE5AEES2G0NL/jXMhRfJlTSzPhqfwYZ/GyPFo3NZ4lKMy4A3hwlX53rcgS9aqk7hWoTQDLqzJy7T8oA1gRvRUnfckv1g8rgoeJmlmD2weUCXRXKW0zQNNJMysg2zkFb5sJFhxUxdtkccSEiRSU9AkhbPuiJgfabhxKZnzqpwgte37y92DXiRW3VBF1kOSsuZBurI3ASw+fiEnDiqkgZ0kuBpkRfTzRsuwingL1mD5ZyeM2s2041OXEEPDsbZpDsqrDez8LLfigrAbbupYgqrqvxbxva2mk8TyAw9AqPumxdU/6yUiau1Il739VeF8hAYj+ys2bwPz9+2syOHIH/+qSYkZzT9PuNCRAWZFnpW3uFHMCstXkKS5t9VCW+391LVy0cTQ0JYD6oxuubuahs143U5kUAfRiXnCHQJwNW+nTUR/tlzPc1gHmNM8W+uTwJI4qY+30WxP7vlk/veheo/wvvwuzbORMU7ECHzQ0zOg3xjT2IpLiH5bYhIpJ/UIhZyo23V1WGzCHVmZ82/aNuAI7MplQEtuY/9MiOJA51tn5Anv8rD+na4jTpToCML4kFT85yvZ0j6zY2XteiWydRP1zeQEDXQj/B+0/Yt86aCfMoYH3TFEvYw3btGajGuNAXfWu2joYdM/s6i6/MDfK5b9lEqKMAIlF+GlllRtLGZjoM2Rioh2InwuXtSxgciM33xW7xCeNV9tpNS6yGI4GO0uMP762XK5z22u0QtfqL5cJ0LWagtLC0DowZDCCRN/9dsWUbmc7d0RdpF0VPnBvBPEv2ZWqVXM5GEiJd7k/otiTZWwRXmpr8CtspPqpyUkRaAeXQgXwpOvI13ew5akWH14ka7xKXY83ChWfq1GTDBJg7RXxZDhlkrbvCGYJGbP0XMoDHLzg1tHjBYnmRIkr88jXvjkig002hiHPsaSHQV4S7htTcNBy7ytvK2tKhesaM/+FkAYkdAwpAAQ951qKWTDShwg5wzpuAtWmyHYPdQHpGmz9vat/isoL0jRUu7462q4mUwe2NMf+AUttIIPvFITWI3nHVdi6CGXPukSfrSMEGsuSx+cx77Z4VjcPj784byubBa4AVWgEISPCvQU4PtQkf7cpMT46Gyj9oKKQHhdr/3hdXgJvstLWAIaZe5hop8imyi/uTscXepWTEoltCDbx94Ycb3Sp0788rJ6/bZ2k47DeJ5m8cYOH1G+0m+7eE5JbNL5lEXYz4ouOoJ80V5gvCaEhcSIH/swzWnuWHY7E5tI9nE0hdxQqAO1tnXX0LsDUnEbCv.box",
  "signature": "z24IQ6iMwH2kiUwgf/FC37km3aJ0wqadCtlLmqUkh/T2/XOvbWgswA9ZdTmWWXI8Nu0Dy4DILEeZnIsEGThrAQ==.sig.ed25519"
}

{
  "previous": "%2JA4zYH7+KdOD64Qcaz3shJ8WXX3D61ajyp+ycK/IAQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1228,
  "timestamp": 1539773133025,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256",
    "branch": "%WH06R1BZtYDsj4ZBsIQm6/wyz2FhvB5sq+Fc+GxBHqg=.sha256",
    "reply": {
      "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%WH06R1BZtYDsj4ZBsIQm6/wyz2FhvB5sq+Fc+GxBHqg=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "ssb",
    "recps": null,
    "text": "How do you iterate over all messages your local sbot knows about? If someone who has experience with this sort of thing would like to do the check, here's a function to call for each message in your database:\n\n```js\nfunction check_msg(msg) {\n  if (msg.previous != null && !is_canonic(msg.previous.slice(1, 45))) {\n    throw \"non-canonic previous\";\n  }\n\n  if (!is_canonic(msg.author.slice(1, 45))) {\n    throw \"non-canonic author\";\n  }\n\n  if (!is_canonic(msg.signature.slice(0, 88))) {\n    throw \"non-canonic signature\";\n  }\n\n  if (typeof msg.content === \"string\" && !is_canonic(msg.content.slice(0, msg.content.indexOf(\".box\")))) {\n    throw \"non-canonic private message\";\n  }\n}\n\nfunction is_canonic(str) {\n  return Buffer.from(str, \"base64\").toString(\"base64\") === str;\n}\n\n```\n\nIf it never throws, then your sbot does not know about any messages with invalid base64 encoding.\n\nIdeally this should be done by somebody who has the feeds of [@Vendan](@wLinNWXMCITML7/3DyVrcQvhVuit7rQehPJdXlsyuVU=.ed25519), [@Vendan-Phone](@EgnRlBtE37ZBnMQPwW1Z6BsakPUq0oVjn3bpdAqIeic=.ed25519) and [@cft](@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519) (those contain data not published by sbot).\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519) and [@Christian Bundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519), [@regular](@nti4TWBH/WNZnfwEoSleF3bgagd63Z5yeEnmFIyq0KA=.ed25519) (that's what you get for helping me once - I'll ping you again. Please let me know if that's not ok)",
    "mentions": [
      {
        "link": "@wLinNWXMCITML7/3DyVrcQvhVuit7rQehPJdXlsyuVU=.ed25519",
        "name": "Vendan"
      },
      {
        "link": "@EgnRlBtE37ZBnMQPwW1Z6BsakPUq0oVjn3bpdAqIeic=.ed25519",
        "name": "Vendan-Phone"
      },
      {
        "link": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
        "name": "cft"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "Christian Bundy"
      },
      {
        "link": "@nti4TWBH/WNZnfwEoSleF3bgagd63Z5yeEnmFIyq0KA=.ed25519",
        "name": "regular"
      }
    ]
  },
  "signature": "Ad9LVtqFp8BAJalnyAFiw/ZPpld6r6wUw2cenkbqzv5qFxr52sD3xCP2qlgNI0CwYWG7gm4qidzvNK4PLjKPDA==.sig.ed25519"
}

{
  "previous": "%NyoXRbMzJ9tdsdoDSiMg7GsHRjQeUcU49iJQus20gmg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1229,
  "timestamp": 1539782289313,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "sunrise-choir",
    "text": "[forking from](%KVof+6X69wI2XfROrFtZj5omrGf6fsO6/eLFiki0rwU=.sha256) (CC [@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519), [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519))\n\nFor parsing directly into js values, we need to invoke napi from rust. But the [raw bindings](https://github.com/napi-rs/napi-sys/blob/master/src/bindings.rs) are sufficient for that. There'll be some wrapping into better interfaces, but if none of the high-level APIs are usable, I can code that up myself.\n\nThings will get more hairy once we want to interact with libuv, but for fully synchronous code (such message encoding, decoding, verification), this should be fairly doable.\n\nI'm not worrying that much about not providing C libraries. Just like you can bridge directly between js and rust, you can do so for other languages as well. It makes more sense to teach a language to interact with rust once rather than writing custom bridge code for everytime you want to call into rust from that language.\n\n> using napi-sys is even more verbose in rust because every call to napi is unsafe. And it's just a line for line copy of what you have to do in C\n\nNothing stops use from putting everything inside a large `unsafe` block =P\n\nI think the biggest concern might be the build process. But if it is possible to get prebuilds etc. running smoothly with a napy-sys approach, I'd strongly favor that.",
    "mentions": [
      {
        "link": "%KVof+6X69wI2XfROrFtZj5omrGf6fsO6/eLFiki0rwU=.sha256",
        "name": "forking from"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "HUJAIb51ptgFrfgNZFUf+NAvqIBaNpHKO5NunTTRbLH4JQIFPGVAehlY5MKC2zkQXreKeSGY3/WDc2Z1y7y4AQ==.sig.ed25519"
}

{
  "previous": "%hIY5H9m8z+cv2Mm92JXQiJs0GyQVOwFp6cJlyMgN2X4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1230,
  "timestamp": 1539782382651,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb",
    "vote": {
      "link": "%uEEmuKzSuw7MLGrciBbzYjpHsZHqOxe6gHARDDYRI/0=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "glftFz42nKv2kMsx366Rrb+lexT8ki/cWlUFsVG/nGm27mCqiMWw1kt4SsBo9DbSpSytrgu5D7TMRso4DlD3Bg==.sig.ed25519"
}

{
  "previous": "%6O+pVKMgCo5dIIgYv3usULWxsDZkksmG1SRxaIvDvw4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1231,
  "timestamp": 1539782384367,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "ssb",
    "vote": {
      "link": "%+Q15YiZ6sYVPe/pDl7DWyg7Wne0z/vLpFS/y7iY+vCs=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "glK4zV9amlpPzr2R7NDL8lDK5tFVehpm7RNYpxBMFOHj/mK17mAiLgxXjmdMzz2g9h/1ugfa7Jq/IWKz1IpsDw==.sig.ed25519"
}

{
  "previous": "%hstNlNH2oe+yidm9z2CkzKiGyQmCfuB8BFH6TPVyVEA=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1232,
  "timestamp": 1539782615026,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256",
    "branch": "%uEEmuKzSuw7MLGrciBbzYjpHsZHqOxe6gHARDDYRI/0=.sha256",
    "reply": {
      "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%uEEmuKzSuw7MLGrciBbzYjpHsZHqOxe6gHARDDYRI/0=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "ssb",
    "recps": null,
    "text": "Thanks both of you. I'll go ahead and add the canonicity requirement to the spec.\n\nUpdating [ssb-ref](https://github.com/ssbc/ssb-ref/blob/master/index.js) to use stricter checks will make sbot reject noncanonical base64 I think.\n\nCC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      }
    ]
  },
  "signature": "nWfTF3BIwumLZ1Pa1My693ajVb6SpE7I2d28MgRMp4TGaZVL1XoI0g6tVpWj6AxYdsi53dIYMbXPk3AZkA3ZAw==.sig.ed25519"
}

{
  "previous": "%S/g1v46Qo42QjPf6/mrS4prJnghUmBGHxvJ785+t0sg=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1233,
  "timestamp": 1539783411481,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256",
    "branch": "%S/g1v46Qo42QjPf6/mrS4prJnghUmBGHxvJ785+t0sg=.sha256",
    "reply": {
      "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%S/g1v46Qo42QjPf6/mrS4prJnghUmBGHxvJ785+t0sg=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb",
    "recps": null,
    "text": "Ssb-ref alone is not sufficient, sbot also needs to explicitly check signatures an encrypted messages.",
    "mentions": []
  },
  "signature": "JVoLofC0MyHFenu9LJmRbE8zzUPcj4cVrwsqBG+T4N+DOe0xBgSQDOEKGVe57TvhQiV0pxgOZd3XI7fZT+CDDw==.sig.ed25519"
}

{
  "previous": "%PxhkKV8GEoyJX+wqhwaZ5trYeQlpAAZpo/gkGlU3PA8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1234,
  "timestamp": 1539801065348,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%xKxpayrjd/ZIq/J/z2+x+K5MVrUhW8gJjGoQs3aEbbQ=.sha256",
    "branch": "%xKxpayrjd/ZIq/J/z2+x+K5MVrUhW8gJjGoQs3aEbbQ=.sha256",
    "reply": {
      "%xKxpayrjd/ZIq/J/z2+x+K5MVrUhW8gJjGoQs3aEbbQ=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "I'm lacking a lot of context, so I'll just have to ask: The `\"meta\"` entry is neither signed nor sent over the wire, right? Or formulated another way: Is this just about js implementation details?\n\nRelated question: Is this related to plugins, in a way that might be relevant for a future sandboxing, ipc-based plugin system?",
    "mentions": []
  },
  "signature": "U4LdQT+vk/1G1dsyBJbQ53aaEDiKoSwlt7xypBA3ilU4UXcqA5rWWF3SlydmRQ/AgmSHI3mSfDq4gFgqUmXdDw==.sig.ed25519"
}

{
  "previous": "%8TU06ASwrYtDZsEQtjb5ZyJW+IFh1q9/G6h0wlIZ4Bs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1235,
  "timestamp": 1539803409763,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%7G6D3tFNJHh1eoKH8zx6b0enLyXns/8prL04D0Jmzbo=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "CAaGX8txjbn3B59A8vF4VTiznQMuLZVpTczIdqFPprDJDgdHKoS3+N84U8VmJ2F76GhVyJUiIjoY23ehk80nBw==.sig.ed25519"
}

{
  "previous": "%t+/szJ5LzNdX/hWohKt6AZYPmSwDp+rPHepqEkm350g=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1236,
  "timestamp": 1539809818824,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%a/sPmkGYYAkpw2pFWo3i7PBsXQ7Q4xM5CrBzTl0U9EI=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%a/sPmkGYYAkpw2pFWo3i7PBsXQ7Q4xM5CrBzTl0U9EI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 17/10/2018\n\n- base64 stuff: %NyoXRbMzJ9tdsdoDSiMg7GsHRjQeUcU49iJQus20gmg=.sha256\n  - this is now mostly resolved:\n    - ssb will enforce canonicity\n    - the [base64 rust crate](https://github.com/alicemaz/rust-base64/issues/76) will reject non-canonical input soon\n- created a [mdBook](https://rust-lang-nursery.github.io/mdBook/index.html) for the spec: https://github.com/sunrise-choir/spec\n  - [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519), can you do some magic so that this gets compiled and published at spec.scuttlebutt.nz upon a push to master?\n    - or if asking for magic is too much, is there a more mundane way to get the spec onto the www?\n- finished the ctlv implementation: https://github.com/AljoschaMeyer/ctlv/commit/2d28a1654a99709dfdb26afb4f1ba9ac070699b7\n- walked up and down the room, throwing a ball, thinking about replication strategies and overlapping distributed spanning trees\n  - I think that falls in the intersection between \"fun\" and \"useful for ssb\"\n- started a canonical json serializer for regular serde\n",
    "mentions": [
      {
        "link": "%NyoXRbMzJ9tdsdoDSiMg7GsHRjQeUcU49iJQus20gmg=.sha256"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      }
    ]
  },
  "signature": "69913g4mTOsar/jpfOWRe6/vv0Vu9iv0iwCjm6gldPmqGxzTdzR3HJCVVSnigAjfmIM6Y1RBVkXfWum2aYPlDw==.sig.ed25519"
}

{
  "previous": "%a23cZ8SH7UDMoU65Et0gV8bPGLsb4IvUg0z8CgvlbR0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1237,
  "timestamp": 1539810071464,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "sunrise-choir",
    "vote": {
      "link": "%OFRTMspIJXTDnooiu8i39Rx5TWtbn2yiKxJi1gcUXck=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "+/wvUFes/TETrHrsB2dhwVmEJgst0DqK3S5wDPkXXonmqT3yZ1wVL1dkvjRzp7A2I6NAZbFL5b3C2lDpDZonAA==.sig.ed25519"
}

{
  "previous": "%I+2XvFFWknXyEBwDSXBK4p3WmiFYhyuRR/tMZhKFZrc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1238,
  "timestamp": 1539811001160,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256",
    "branch": "%PxhkKV8GEoyJX+wqhwaZ5trYeQlpAAZpo/gkGlU3PA8=.sha256",
    "reply": {
      "%5kJUD3o5ukQQHWUh4mSMhMh07pQf3slmWq3BzznpJyw=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%PxhkKV8GEoyJX+wqhwaZ5trYeQlpAAZpo/gkGlU3PA8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb",
    "recps": null,
    "text": "Note for the js devs: The most efficient way of checking for canonicity is probably to count the number of padding `=`s and check against a list of allowed last characters. Less efficient but simpler to implement: If there is one padding `=`, decode and reencode the last two nonpadding characters and check for equality, if there are two padding `==`s, decode and reencode the last three nonpadding characters. That is at least more efficient than reencoding the full string.\n\nThe rust implementation will perform the check as part of the decoding process, but js doesn't get that luxury.",
    "mentions": []
  },
  "signature": "aIKLIsDrdvvMaQchEnUTxV1YLtW1AMVeQ866TcDKSs0V1xIz3aJMqxUqhSp1/T0tUm1TvSwzFY+W58HkrhmwAQ==.sig.ed25519"
}

{
  "previous": "%ue+DhZqXw6lJALDERqSjQ+Yl74iAs/n+r8mGs7Dehrs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1239,
  "timestamp": 1539855519861,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "dev-diaries",
    "vote": {
      "link": "%ymulqy/SgRxO/Cr3YsGomb6FWC9I10FYj2qSKZXtqL4=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "J1jYwN0JKqPFFQjtMWv+xcjbWJZ4SdO5acqJNMVR5A2s8Hi/AbsMy7VS4NKXGhmMDXlPYCXVgzZKcuqwmYlZBg==.sig.ed25519"
}

{
  "previous": "%W1vm4o6XWrSy8i2VFXm9rGJguswnCKXmK+K0tPDHZd4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1240,
  "timestamp": 1539874490724,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%a23cZ8SH7UDMoU65Et0gV8bPGLsb4IvUg0z8CgvlbR0=.sha256",
    "reply": {
      "%a23cZ8SH7UDMoU65Et0gV8bPGLsb4IvUg0z8CgvlbR0=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%ymulqy/SgRxO/Cr3YsGomb6FWC9I10FYj2qSKZXtqL4=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 18/10/2018\n\n- serde rewrite of the data formats\n- metadata parsing and serialization\n\nNothing to report, just a bunch of code that needs to be written. Doing both in parallel, neither is done yet. Code is in such a terrible state that I won't bother uploading it.\nI'll continue working, but I can already post this, nothing new is going to happen over the next few hours of work...\n",
    "mentions": []
  },
  "signature": "78RSftSiqUgGytD4KK8BWHcF8sEePJasjdiS+/5jt+XlaFPdSxB0N2THDwnLrbpRnnkmvyueb3j7Frw+Ym3HDQ==.sig.ed25519"
}

{
  "previous": "%uFwD/xs0rH0mzP7CbQC+lMFa1HVjUh1FLNA/JJwFe6Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1241,
  "timestamp": 1539898483603,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%DiKg7pb5f8nK+9UXYkh0NFycwI4311vFpl7sJQQVV0E=.sha256",
    "branch": "%anNcE3HvtXBPHwtBnIwcuh+mR1Chy+F1fXlNk+LMGBQ=.sha256",
    "reply": {
      "%DiKg7pb5f8nK+9UXYkh0NFycwI4311vFpl7sJQQVV0E=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%anNcE3HvtXBPHwtBnIwcuh+mR1Chy+F1fXlNk+LMGBQ=.sha256": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519"
    },
    "channel": "ssb-tangles",
    "recps": null,
    "text": "Note to future-me:  [Lasp](https://pages.lip6.fr/syncfree/attachments/article/46/d4_2-d4_2_1.pdf#page=86) provides composition of CRDTs. It should be possible to build a system with subjectively aggregated identities where each particular view of who is part of the identity results in a coherent system state, as long as all data types are CRDTs. Lasp could provide a framework for solving the \"everything must be a CRDT\" constraint. Add in a replication scheme optimized for fractal identities, and you have a really fascinating research project.",
    "mentions": []
  },
  "signature": "XXcBvjG6i3cDkc2QPLFUbuUfOXMgNq/Q++Z7YzgZ2cluAVDKqCpVQLjBV6LnVdoAAxy54h+Y2EO6oc5C3a2SCw==.sig.ed25519"
}

{
  "previous": "%DQ+bXoF3UjxZ26E8WtTmmuYk1/NuRBw6CAW13DaUH0k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1242,
  "timestamp": 1539903957402,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%DiKg7pb5f8nK+9UXYkh0NFycwI4311vFpl7sJQQVV0E=.sha256",
    "branch": "%DQ+bXoF3UjxZ26E8WtTmmuYk1/NuRBw6CAW13DaUH0k=.sha256",
    "reply": {
      "%DiKg7pb5f8nK+9UXYkh0NFycwI4311vFpl7sJQQVV0E=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%DQ+bXoF3UjxZ26E8WtTmmuYk1/NuRBw6CAW13DaUH0k=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "ssb-tangles",
    "recps": null,
    "text": "And from the same document: [notes](https://pages.lip6.fr/syncfree/attachments/article/46/d4_2-d4_2_1.pdf#page=116) on crdts that aggregate results of incremental computations (e.g. reducing a bunch of messages into a state). Not directly applicable to ssb, but interesting when thinking about generalizations of ssb.",
    "mentions": []
  },
  "signature": "SOG+q52A66vLUuBfS24bW8zvH3719aLXFDKV0hJt2MslJAP3ZI+TOL76C2jZbOa+GXF+tiXKMLI1bv8sKw9hCg==.sig.ed25519"
}

{
  "previous": "%FinG+K3gbqrXRTeqsDuGThMFt7y7X0++F1rZ8OiCnBc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1243,
  "timestamp": 1539904447025,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%DiKg7pb5f8nK+9UXYkh0NFycwI4311vFpl7sJQQVV0E=.sha256",
    "branch": "%XR+8ScJ1NknY0m2jXErIdEWLAncbrwnYvYZ283s+CB0=.sha256",
    "reply": {
      "%XR+8ScJ1NknY0m2jXErIdEWLAncbrwnYvYZ283s+CB0=.sha256": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519"
    },
    "channel": "ssb-tangles",
    "recps": null,
    "text": "[@bobhaugen](@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519) Tangles are not a standard data structure (as far as I'm aware of), but [@cft](@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519) used the term in [this document](https://github.com/cn-uofbasel/ssbdrv/blob/master/doc/tangle.md) (apparently related to the central concept of the IOTA cryptocurrency described [here](https://assets.ctfassets.net/r1dr6vzfxhev/2t4uxvsIqk0EUau6g2sw0g/45eae33637ca92f85dd9f4a3a218e1ec/iota1_4_3.pdf)).",
    "mentions": [
      {
        "link": "@iL6NzQoOLFP18pCpprkbY80DMtiG4JFFtVSVUaoGsOQ=.ed25519",
        "name": "bobhaugen"
      },
      {
        "link": "@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519",
        "name": "cft"
      }
    ]
  },
  "signature": "PRy2UxSfdj41YhVj9K+4R0Xu7JbFkEUCVluwDnSjyEqzBethO1I7XvPSiMt1B69Q21sgHYqw6CvEVAnF57z3BQ==.sig.ed25519"
}

{
  "previous": "%Gnv1ZbnIN5DDZZCZkeeD/O1KTkNkRmVw6Ov3DiCmY6k=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1244,
  "timestamp": 1539944351579,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%WU/0tLVKovppP90bTeQ+PV/FtlszcaAwi2RzJTBv7io=.sha256",
    "branch": "%T5Tmmu3sFDKiBGHl29TB76lgyNt3/1LuLWOCMHfJBsI=.sha256",
    "reply": {
      "%WU/0tLVKovppP90bTeQ+PV/FtlszcaAwi2RzJTBv7io=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%T5Tmmu3sFDKiBGHl29TB76lgyNt3/1LuLWOCMHfJBsI=.sha256": "@RtsOc2h1gqh0fRrjrUTHAkRBu9YyDgsD+EWsfLpykrc=.ed25519"
    },
    "channel": "manyverse",
    "recps": null,
    "text": "[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) Could you ping me once you know whether this is validation or indexing overhead? If it is validation, then the protocol design could perhaps help. I'm currently drafting a writeup on a merkle-tree based feed structure which would allow partial feed verification in sublinear time. I'm not yet convinced whether that would be a good route to take for ssb, but it could help with initial sync.",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "4cykWCvCZ+iwYjC1NEdXAvozSHfW0TwlBr8vWfW3odySzPCIzsM/6y2SkYnrfoT3jkC2MKoF9S8GF9y+bfdzDQ==.sig.ed25519"
}

{
  "previous": "%UmroGyBbXHovAGCEWjjZoOFMXnnVlG22kENrZPSkqpw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1245,
  "timestamp": 1539987059762,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": [
      "%uFwD/xs0rH0mzP7CbQC+lMFa1HVjUh1FLNA/JJwFe6Q=.sha256",
      "%ymulqy/SgRxO/Cr3YsGomb6FWC9I10FYj2qSKZXtqL4=.sha256"
    ],
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%uFwD/xs0rH0mzP7CbQC+lMFa1HVjUh1FLNA/JJwFe6Q=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 19/10/2018\n\n- started drafting a post on merkle-trees for ssb logs, but got stuck on the actual implementation details, so I postponed it because I also want to get some programming done today: https://gist.github.com/AljoschaMeyer/a824a410032fcf8ad310cf80c24a185e\n  - and prior to drafting, this involved a bunch of reading and thinking\n    - I think we can do better than this structure: https://github.com/blockstack/blockstack-core/issues/146\n      - this adds quasilinear space overhead to the feed (I think?), a tree-based solution should manage to get it down to linear\n    - this is just plain amazing: http://soc1024.ece.illinois.edu/gpads/gpads-full.pdf\n      - seriously, I did not expect that searching the web for `merkle skip list` would lead into such an amazing rabbit hole\n        - which I'll have to explore in my free time I guess - back to programming for now\n        - but just imagine combinding λ• with [Lasp](https://pages.lip6.fr/syncfree/attachments/article/46/d4_2-d4_2_1.pdf#page=66)... there's just so much CS still has to explore =)\n- finished the serde json serializer\n  - does not yet have a mode for automatically serializing map entries in the correct order though\n- nearly finished a serde json deserializer\n- more merkle trees - no point in fighting my own brain\n  - I'm starting to accept the need for a [merkle skiplist](https://github.com/blockstack/blockstack-core/issues/146) rather than a pure tree, but I'm still unhappy with the space requirement in the feed itself...",
    "mentions": []
  },
  "signature": "hX5//LMbWJYL41EL1VlcM5jsApioAmtEBD5IzhbSdFgBkPmUnmzfDtKnbe7rV5X7RaQceifC1NDjcBGADl+NDg==.sig.ed25519"
}

{
  "previous": "%oJ9A++vrbxXlCgGLqttaVh5eFmQBA/rqpkBiq5QXHkY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1246,
  "timestamp": 1539987701228,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%JoQV6OLL9BgXc3Cy6PPZxcY+1/0AELKaFcLGMS/oYag=.sha256",
    "branch": [
      "%hTE8Z6rixI7VKNq/0MiaiPqY2ioHGp415B2pJTPxyVQ=.sha256",
      "%xt6UnesHl0tm4Yb+Er1DIk1SQ0ZqFxJP82epjYjE/Rc=.sha256"
    ],
    "reply": {
      "%JoQV6OLL9BgXc3Cy6PPZxcY+1/0AELKaFcLGMS/oYag=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
      "%hTE8Z6rixI7VKNq/0MiaiPqY2ioHGp415B2pJTPxyVQ=.sha256": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519"
    },
    "channel": "rust",
    "recps": null,
    "text": "Most of the code in the ssbrs repos is more of a draft/sketch than a good model for solid/ideomatic rust. So I'd recommend you look elsewhere. If you just want to study some hight-quality code, check out the repos in [rust-lang](https://github.com/rust-lang) and [rust-lang-nursery](https://github.com/rust-lang-nursery), or perhaps [servo](https://github.com/servo) for some highly optimized stuff.",
    "mentions": []
  },
  "signature": "dgumzK1l3BrXu3SkM+4/dRKTr6iB9wqolWs76Q8vgWt9YLBNVX4GX4OivubEYlsOTPP0MZ6xnegjuRy+m3AcBA==.sig.ed25519"
}

{
  "previous": "%EOgBBxs6Mwxy84hmGy8uathgv7H2KzChgN2Mp0hFWpU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1247,
  "timestamp": 1540049970802,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "scuttlebutt",
    "text": "# Merkle Trees for SSB Feeds\n\nOr: Enabling partially subscribable feeds, but with a lot of words before I get to that point.\n\nLike offchain content, this is another idea that has been floating through the scuttleverse at various points in time. A compact summary that is only useful if you already know what this is about: By changing the metadata of ssb messages, we could create merkle trees rather than linked lists. This allows verifying the `k`-th message of a feed by traversing only `log(k)` many messages, rather than the full `k` messages of the linked list in the current model.\n\nThis is an issue that\n\n- touches the very core of the protocol\n- seems to be both rather abstract and hammering on pointless detail at first\n- but turns out to have far-reaching consequences\n\nThis post will at times be very technical and somewhat computer-sciency, but I'll try to explain enough that anybody interested can follow the gist of it. It's also a pretty long read, but I hope a few of you can still take the time to read it. Some of it my look complicated at first, but once you gain some intuition, it all becomes manageable. It's definitely not too complicated for real-world use - dat uses a data structure like this internally.\n\nOutline:\n\n- background on ssb security guarantees\n- why would we need merkle trees\n- how merkle trees work\n- implementing it via ssb metadata\n- complexity analysis\n- further optimizations\n- conclusion\n\nCC protocol humans: [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519), [@dinosaur](@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519),\n[@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519), [@cel](@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519), [@Christian Bundy](@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519),   [@cryptix](@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519),  [@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519)\n\n## Background: SSB's Security Guarantees\n\nIn order to meet its security guarantees, ssb verifies certain properties for all messages. The most basic one is to check that it indeed belongs to its claimed feed. This is done by checking the [signature](https://en.wikipedia.org/wiki/Digital_signature) attached to every message. If that were all the guarantees ssb provided (and such a protocol is interesting [in its own right](%wvfvXjRiXe5ALdYHQi8cMwIEuC+TqJVTWrc4ezyavJU=.sha256)), then there would be no need for the backlinks in each message's metadata. The backlink is simply a [secure hash](https://en.wikipedia.org/wiki/Cryptographic_hash_function) of the previous message. The first property gained through backlinks that might come to mind is immutability. Even the feed owner can not retroactively change the feed, since that would break the linked list of hashes. Once somebody knows the first `k` messages, the feed owner can not convince that person that any message up to `k` was different than that person first thought.\n\nAt a first glance, sequence numbers seem to give immutability already. If there were no backlinks, but you had a set of `k` messages, each with a different sequence number between `0` and `k - 1`, then you could still restore the correct order and you could detect any retroactive changes by just checking whether two different messages claim the same sequence number, at which point you'd declare the feed broken (just like a forked feed in ssb's actual model is considered broken). So why go through the trouble of a linked list?\n\nIf ssb only used sequence numbers, then a malicious feed could hand out different copies of itself to different peers, and they could not tell that something weird was going on until they compared feeds. But they's never have an incentive to compare feeds, why would they request a message they already have?\n\nWhy do backlinks solve this, whereas sequence numbers fail? The list of hashes guarantees that the messages have actually been created in the order of their claimed sequence numbers.\n\nSuppose you just asked me for the fifth message in my feed, and there were no backlinks. I could just make up some message content, give it seqnum `5`, sign it, and hand it over to you. I would not need to commit to the content of any previous messages. If some time later you asked for the third message in my feed, I could again freely invent something. You have no way of knowing that the third message has actually been authored at a later point in time.\n\nBacklinks prevent this and forces everyone to adhere to the linear temporal order of messages. If I made up the fifth message, I'd also need to give it a backlink. But if I freely invented that backlink, and later you asked me for message four, I couldn't come up with a message that has that invented hash (if I could, the hash function would be broken and I could do much more profitable things than lying about ssb messages). So instead, to invent message five, I'd also need to invent the content of message four first. But since that one again has a backlink, I need to commit to the content of mesage three before that, and so on. As a result, ssb gives the guarantee that the order of messages in a feed corresponds to temporal order in real life. That's pretty amazing once you think about it.\n\nThis temporal order guarantee also translates into truly immutable feeds, where it is impossible to hand out more than one version of the feed to different parties.",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
        "name": "dinosaur"
      },
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519",
        "name": "cel"
      },
      {
        "link": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
        "name": "Christian Bundy"
      },
      {
        "link": "@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519",
        "name": "cryptix"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "%wvfvXjRiXe5ALdYHQi8cMwIEuC+TqJVTWrc4ezyavJU=.sha256",
        "name": "in its own right"
      }
    ]
  },
  "signature": "BJkU9WssLJZtFvhuiT4735ABncCELhWeeJq1uBd+wzpc9nPKoJi8FqgJeMBwJxpb5TpX53NlVyw7RHgY5VGgBg==.sig.ed25519"
}

{
  "previous": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1248,
  "timestamp": 1540050095622,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "## The Problem\n\nSsb has that property, so why should there be a problem? The problem is one of complexity. If I gave you the `k`-th and `l`-th message from the same feed, and `k` has a lower sequence number than `l`, how could you verify that message `l` has indeed been created after message `k`? You'd have to traverse the full hash chain from `l` back to `k`. In the worst case, `k` would be zero. Then, you'd need to traverse the full feed. So to verify message `l`, you need to perform `l` many checks - and to do so, you need to know the data of `l` other messages. Put into more mathematical terms: the length of a validity certificate is linear in the sequence number of the message.\n\nWhat if you only cared about a subset of the messages of a feed, but still wanted the full security guarantees? With current ssb, your only chance is to download the full feed, even though you don't care about much of it. This is the problem that merkle trees can solve. But first a few words on a related concept: Out-of-order (ooo) messages.\n\nSsb provides ooo messages, where a server can ask its peers to deliver it a message of a certain hash. That way, you can retrieve messages without downloading their full feed. That's fine, but it forfeits the guarantee about creation order. Instead, you trust that whoever gave you that hash has already verified the validity of that message. While that's fine for relatively inconsequential, one-off retrievals such as fetching a post in a thread you are interested in, it is not a solid foundation for regularly fetching a subset of a feed. And in general, it is somewhat dangerous that there are essentially two types of messages floating around: ones where you know for sure that creation order guarantees hold, and ones where you only trust somebody that they hold. Application developers need to cleanly separate those if things are to stay secure.\n\nMore generally, this split between verifiable and unverifiable messages makes the whole system more complex to reason about. This may sound vague and abstract, but this additional complexity has surfaced [multiple](%yCfMJcM19PEN2vLdMxo5cDGFOwhqZlhLiybwBV7wdPU=.sha256) [times](%kW58mRD2Y7xc8DFDB9BtfeKvfYBNMdapCoz0alcXtM0=.sha256) already, imposing metadata overhead on all messages.\n\nI don't want to argue that ooo messages are a bad feature per se. But if there was an alternative that managed to preserve security guarantees, it should surely be considered. And merkle trees provide this alternative.\n\n## Merkle Trees\n\n(This section is rather technical and assumes some familiarity with basic computer science themes regarding data structures and complexity.)\n\nMerkle trees (see the [wikipedia article](https://en.wikipedia.org/wiki/Merkle_tree)) are collections that can give a certificate (basically a proof) that they contain a certain item. Crucially, the size of such a certificate is only logarithmic in the number of items, as is the verification time. Proof of membership is not exactly what ssb needs, but it is close enough to be adapted to our needs. There are few other points that need some tweaking. For one, merkle trees assume a bounded size and a well-known root hash, but ssb feeds have neither. Furthermore, we want to avoid adding additional nodes to our message graph, so we'd rather store non-leaf nodes implicitly.\n\nLet's start with a basic scenario to get a feel for the setting: The following graphic shows an ssb feed of eight messages and a corresponding merkle tree.\n\n![001.svg](&IfkFJywkPTytjUcu1GdkZ33hLkTY+iYVsWcjIaqvhYM=.sha256)\n\n`m0` to `m7` are the messages, `h0` to `h7` are hashes of those messages, the dotted edges between the first two layers are ssb's regular backlinks. `h<x><y>` is the hash of the concatenation of `h<x>` and `h<y>`. You can imagine a time-axis going from left to right. Instead of the regular symmetric tree layout, I've moved the hash nodes to the first point in time at which they can possibly be computed. An non-dotted edge from node `v` to node `u` means that `u` can not have been computed if `v` didn't already exist (else, the hash function would be broken).\n\nIn the regular merkle tree setting, certificates work as follows: Assuming I already knew the hash of the item I'm interested in (say `h6`) and the root hash (`h01234567`), how can someone prove to me that `h6` is in the tree? They only need to give me `h7`, `h45`, and `h0123`, and then I can check whether `hash(h0123 | hash(h45 | hash(h6 | h7))) == h01234567`. If it is, then `h6` did indeed contribute to the creation of my well-known root value `h01234567`. What we care about here is that this also implies that `h6` (and thus `m6`) was created before `h7`. And if I later asked for a certificate for `h3`, the correct certificate also implies that `m3` was indeed created before `m6` (by checking that the `h0123` value is the same in both certificates (which happens implicitly since otherwise the final root hash would differ)).\n\nTransfering this to ssb, the first problem is that we don't have a well-known root hash. But that is fine, we just send the root as part of the certificate instead. `m6` is signed, so we already know that it is either a member of the correct feed, or the feed owner has been forking the feed. We can't detect forks with only a single message, since for a fork you always need at least two, contradictory ones. Rather then collection membership, we only care about being able to verify that any message of `seqnum < 6` that we receive at a later point in time must have already existed when we received `m6`. And that's what the merkle tree gives us. Well, except for a few problems we still need to deal with.\n\nAssume we received `m6` and the associated certificate `c6` described above (`h7`, `h45`, `h0123`, and `h01234567`), and now we ask for `m1`. The certificate `c1` we get consists of `h0` and `h01`. The server we are requesting from might not even know about any messages that were published after `m1`. But now we can't check whether `c1` contradicts `c6`. `c6` contains `h0123`, but does not tell us how `h01` must relate to it. Fortunately, there's an easy fix: Each certificate must contain all the diamon-shaped nodes (`h0`, `h01`, `h0123`, and so on) that existed up to that point in time. Each diamond node is the root of the complete binary merkle trees over the first `2^i` messages for some `i`. Each certificate is created by \"working downwards\" until one of these roots is reached, so by including them, we ensure that all certificates can be checked against each other.",
    "mentions": [
      {
        "link": "%yCfMJcM19PEN2vLdMxo5cDGFOwhqZlhLiybwBV7wdPU=.sha256",
        "name": "multiple"
      },
      {
        "link": "%kW58mRD2Y7xc8DFDB9BtfeKvfYBNMdapCoz0alcXtM0=.sha256",
        "name": "times"
      },
      {
        "link": "&IfkFJywkPTytjUcu1GdkZ33hLkTY+iYVsWcjIaqvhYM=.sha256",
        "name": "001.svg",
        "type": "image/svg+xml",
        "size": 17784
      }
    ]
  },
  "signature": "8Ju0vWIqROKcVA8JzcBLwcfWmBXllMPTbYVo/4watq5gPteshqhNhCrXJjctudeNsB1jMYl/DgZcDYOttUqCCA==.sig.ed25519"
}

{
  "previous": "%/DmqNODlO97dAlm7a7jrEQlnF5XhH7dQv1+xjwCyJ0c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1249,
  "timestamp": 1540050191813,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%/DmqNODlO97dAlm7a7jrEQlnF5XhH7dQv1+xjwCyJ0c=.sha256",
    "reply": {
      "%/DmqNODlO97dAlm7a7jrEQlnF5XhH7dQv1+xjwCyJ0c=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "So are we done now? Nope. Our `c6` certificate assumed that `m7` was available, but what if it didn't exist yet (or the certificate creator didn't know about it yet)? This is depicted in the following graphic:\n\n![002.svg](&QQIIuxz+OMxNIGsOartpSlssKKbRacAGNzPyQXK6mzE=.sha256)\n\nHere we don't have a single merkle tree, but a merkle forest with three roots: `h0123`, `h45` and `h6`. This feed as a length that is one less than a power of two, these feeds are the worst-case scenario as they result in the largest number of disjoint trees. The naive certificate attempt consisting of only these roots doesn't work, since the three hashes are completely independent. I could first create `m6`, and once someone requested it, I could then invent messages `m0` to `m5`, compute `h0123` and `h45`, and then use these hashes in the certificate. To prevent this, we add `Hh45h6` (the hash of the concatenation of `h45` and `h6`), and analogously `Hh0123h45`. `Hh45h6` must be published (and signed) together with `m6`, `Hh0123h45` must be published (and signed) together with `m5`. This gives us a valid certificate `h0123, h45, Hh0123h45, h6, Hh45h6, h01, h0` for `m6`. (credit for this goes to the [dat whitepaper's merkle tree and replication sections](https://datproject.org/paper#page=6))\n\nThe following graphic depicts the graph where all of these additional hashes are present, marked in blue.\n\n![003.svg](&SPY4r5leQ4YeGiw9o1fCETAomEGcVv4MnMafO6l64So=.sha256)\n\nAs a consequence, there are two possible certificates for all non-power-of-two'th messages: The one described above that bridges across different merkle trees, and a more compact one that can only be computed once the feed length has advanced to the next power of two. A simple solution is to always use the one that can immediately be computed. But these two don't conflict, so the actual implementation can use the more efficient one whenever possible. Servers just need to be aware that even if they know that the efficient one can be computed, their peer's view of the feed might be outdated, forcing the peer to send the inefficient certificate instead.\n\nBefore I move on to the actual implementations, a quick note on correctness. I won't do a full prove here, that would need a bunch of definitions first. But a basic proof sketch is based around three properties of certificates:\n\n1. A certificate must somehow depend on all previously published messages. In the graph, that means that there must be a directed path from each message to one of the nodes in the certificate\n2. A certificate must be self-consistent (unlike the naive attempt in the length-7 feed above). In the graph, that means that there must be a directed path from the certified message to each node in the certificate.\n3. It must be possible to check that any two certificates do not contradict each other. In the graph, that means that after taking the union of the two certificates, each vertex from the certificate for the earlier message must be reachable from a vertex from the other certificate.\n\nYou can then go on and show that the scheme I presented fulfills these criteria. My intuition tells me that there's also a proof of optimality somewhere in there. But the more difficult part is actually showing that these criteria are exactly what we need to give ssb's security guarantees. Formal proofs in that domain are outside my current knowledge level though.\n\n## Implementation in SSB\n\nThis is a very direct translation of the above tree construction scheme into ssb. It omits some obvious optimizations, these are discussed later.\n\nTo the regular metadata of the message `msg_s` with sequence number `s`, append the following (in order, before signing)\n\n- `hash(msg_s)` as field `\"hash0\"`\n- `hash(msg_(s - 1).hash0 | msg_s.hash0)` (called `\"hash1\"`) iff `s == (l * 2^1) - 1` for some `l`\n- `hash(msg_(s - 2).hash1 | msg_s.hash1)` (called `\"hash2\"`) iff `s == (l * 2^2) - 1` for some `l`\n- ...\n- `hash(msg_(s - 2^(k - 1)).hash<k - 1> | msg_s.hash<k - 1>)`  (called `\"hash<k>\"`) iff `s == (l * 2^k) - 1` for some `l`\n- If `s` is one less then a power of two, we are done. Else we need to add the additional hash that allows bridging between disparate merkle trees:\n  - add `hash(msg_(s - 2^(k - 1)).hash<k> | msg_s.hash<k - 1>)` (called `\"bridge\"`)\n\nThis may look intimidating, but it does nothing more than constructing the trees described above. Also a note on addressing: I used these names \"hash42\" to indicate the level of the tree, which is nice for humans. But for machines, there are relatively simple numbering schemes that provide bijections between natural numbers and those inner tree nodes (stealing from the [dat whitepaper](https://datproject.org/paper#page=5) again). So addressing those is actually very efficient, both in terms of in-memory access time, and address size when sending stuff over the network.",
    "mentions": [
      {
        "link": "&QQIIuxz+OMxNIGsOartpSlssKKbRacAGNzPyQXK6mzE=.sha256",
        "name": "002.svg",
        "type": "image/svg+xml",
        "size": 13234
      },
      {
        "link": "&SPY4r5leQ4YeGiw9o1fCETAomEGcVv4MnMafO6l64So=.sha256",
        "name": "003.svg",
        "type": "image/svg+xml",
        "size": 17033
      }
    ]
  },
  "signature": "+twbrOD/LKlYW88/dGAKASSjEsmh/F10Jfj2Pp0CDl9sBtAge0ONWgWPJWN9tYc3nFVUrD28Y/xOiW3U5wsOAw==.sig.ed25519"
}

{
  "previous": "%LeKA6U4euO23h7VxdRm8ajldUFEMIXLGqXWtoPYMiu4=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1250,
  "timestamp": 1540050219641,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%LeKA6U4euO23h7VxdRm8ajldUFEMIXLGqXWtoPYMiu4=.sha256",
    "reply": {
      "%LeKA6U4euO23h7VxdRm8ajldUFEMIXLGqXWtoPYMiu4=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "## Complexity\n\nThe scheme encodes a binary tree in the feed, the number of inner nodes in a binary tree is linear in the number of leafs, so we end up with only linear space overhead (compare with e.g. [this approach](https://github.com/blockstack/blockstack-core/issues/146) that has quasilinear overhead) in the feed. The metadata is not evenly distributed accross nodes, but it is bounded at `log_2(seqnum)`.\n\nMore concretely: On average, this adds two hashes to each metadata entry (one for the bridge (except for powers of two), one for the regular merkle tree (on average)).\n\nCertificates are paths to the root of the tree and then back to the first message, so they have length at most `2 * log_2(seqnum)`. Verification time complexity has the same bound.\n\n## Optimizations\n\nA few rather trivial ones:\n\n- no need to store `hash(msg_k)` in the feed, you can compute that directly from `msg_k`\n- no need to store `hash(hash(msg_<k-1>) | hash(msg_k))` in the feed, you can compute that directly from the `msg_k` as well (`msg_k` already contains `hash(msg_<k-1>)` - it's the backlink)\n- we can interpolate between feed size overhead and certificate size by dropping the highest non-leaf layers of the tree, sending a bounded number of leaf nodes instead as part of the certificate. The actual certificate can then be computed from those leaf nodes. This is not really an optimization, it just allows us to keep feeds more compact at the cost of making certificates less performant. Note that this only adjusts constants, it never improves the linear feed size overhead or breaks the logarithmic certificate size/performance.\n\nAnother nifty optimization can be done when sending certificates around. Two certificates for messages from the same feed will always share some nodes (if they didn't they couldn't prove the guarantees we are interested in). So it is not always necessary to send full certificates. Certificates share more data the closer the two keys are. When requesting a message of seqnum `k`, the server can also attach the next smaller and the next larger seqnum from the same feed for which it already has certificates. The peer can then easily compute the minimum amount of data it needs to send. <unproven intuition> I think when requesting a full feed in random order that way, the total amount of certificate overhead is only linear in the feed size (rather than quasilinear without that optimization)</unproven intuition>.\n\n## Conclusions\n\nWe can efficiently allow random-access verification of messages. The current approach for random-access messages (ooo) simply gives up and forfeits some of ssb's security guarantees. Merkle-ooo can fix that.\n\nAnother application would be initial sync (CC [@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519)): You could first request the newest `n` messages of a feed, and hand them to the client. Afterwards, you can request the remainder of the feed, doing traditional verification via backlinks.\n\nMore generally though, this could provide the basis for partial feed subscriptions. Plugins could expose their own replication rpcs that efficiently determine what kind of messages to send, and the merkle-tree validation would do the rest. The core does not need to care about the criteria by which the subset of the feed is selected. Due to the optimization where it is not necessary to send full certificates, this would allow linear-time verification of the partially subscribed feeds, just like regular ones. And that's the really, really, *really* powerful feature enabled by merkle trees.\n\nThe inability to do partial subcriptions is one of the two weakest points of ssb in my opinion (the other one being the non-hierarchical nature of identities). Merkle trees can fix that.",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "RdXxidML+KoUg3NYWAT1vIK47NpoJkMQoLYjNUwWL4BqgBa/q6uONKbxBHO1oIvNVm4o09orS40/fm3woD5gDw==.sig.ed25519"
}

{
  "previous": "%5BBfWSMjmhhXu2ejMXkFTTxXNSH33UdneDRe57kCNxY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1251,
  "timestamp": 1540056343550,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": [
      "%5BBfWSMjmhhXu2ejMXkFTTxXNSH33UdneDRe57kCNxY=.sha256",
      "%gwj95/yhCcx1YemmnwQ9+ZFprM9n9cmHiuh7+3zjV2o=.sha256"
    ],
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%gwj95/yhCcx1YemmnwQ9+ZFprM9n9cmHiuh7+3zjV2o=.sha256": "@+UMKhpbzXAII+2/7ZlsgkJwIsxdfeFi36Z5Rk1gCfY0=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@andrestaltz_phone](@+UMKhpbzXAII+2/7ZlsgkJwIsxdfeFi36Z5Rk1gCfY0=.ed25519)\n> Quick question: would it be easy to fetch 'about' messages (which are typically early in the feed)?\n\nThat's a separate concern. The whole feed infrastructure is unopinionated about replication rpcs. The obvious ones are still full feed replication and random-acces via hash (aka ooo but with security guarantees). But of course it is possible to build others as plugins.\n\nA really sweet spot between efficiency and expressiveness/granularity could be prefixes of message types. So you'd say \"I have feed @foo at sequence number 42, but only those messages whose type starts either with `about` or `chess::`.\" The peer could then check whether it has any messages newer than seqnum 42 whose type matches one of the prefixes and send them.\n\nThis could be implemented pretty efficiently by sending around radix trees of the type prefixes. And the empty radix tree could be special-cased to mean \"I replicate the full feed\".\n\nA different, much more expressive (and thus inefficient and complex) plugin could allow sending code in a query language, or even some sort of non-turingcomplete programming language (à la [dhall](https://github.com/dhall-lang/dhall-lang)) for computing at the peer's machine what kind of messages to retrieve.\n\nAnd on the other end of the complexity spectrum, you could just build a plugin that exposes an rpc that does nothing but exchanging about messages.\n\n---\n\nI haven't made up my mind whether I would want to have something like the prefix-based pubsub in the core rpc set, but I think if we want something in-between full-feed replication and ooo as a core rpc, then it is a very good candidate.",
    "mentions": [
      {
        "link": "@+UMKhpbzXAII+2/7ZlsgkJwIsxdfeFi36Z5Rk1gCfY0=.ed25519",
        "name": "andrestaltz_phone"
      }
    ]
  },
  "signature": "gBiJzUNhekgKy5920TVoFXlRRdo9YXonKqgWt9wqAvxggeR2z5uyBDjof4VtOdiyg77bbqOlLny4J/SxByJ4Aw==.sig.ed25519"
}

{
  "previous": "%0eJLwmZ8uePGPtoTx4PAq8ZwhVOmcMxWwBSQHpobzCM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1252,
  "timestamp": 1540064844740,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%PjcPuxx4P3ZFJn80Btdk7OuTVS59p0OvB+wgNmL8o5E=.sha256",
    "reply": {
      "%PjcPuxx4P3ZFJn80Btdk7OuTVS59p0OvB+wgNmL8o5E=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
      "%F8aA84eyNlG+CUIvHndHVR/lB6aRLSh4jPKL/8cxt80=.sha256": "@+D0ku/LReK6kqd3PSrcVCfbLYbDtTmS4Bd21rqhpYNA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519)\n> If you have two out-of-order messages by the same author, o1 and o2, you can't prove that o2 really signs o1 - but what is that even useful for? you only know or care that these messages exist because of your friend, so I suggest that we've already captured the important thing.\n\nDoesn't that argumentation apply to ssb as a whole? Why do we even bother with backlinks, we can just use sequence numbers then.\n\n---\n\nSpeaking of ooo: I can't see the message %eDQzaPnoV65hLhgj5dna/s71+gikcpM+tu2jPVEvMtg=.sha256 that Dominic has replied to, and patchwork doesn't have ooo yet. Could somebody paste that message and/or link to the author?\n ",
    "mentions": [
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%eDQzaPnoV65hLhgj5dna/s71+gikcpM+tu2jPVEvMtg=.sha256"
      }
    ]
  },
  "signature": "1zvPv9CSVys5LHGdf0A2WdjEtIhl97pmhYCr0oMwA7htFDvf/rS3dHVaGRKFXcz2mJU3kqbb8zMk6ZIhTb9oBw==.sig.ed25519"
}

{
  "previous": "%qdqVSMJQDmd67pkD8qznOsEFyDMQNM2f29VSwQ6zbp8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1253,
  "timestamp": 1540068648301,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%eDQzaPnoV65hLhgj5dna/s71+gikcpM+tu2jPVEvMtg=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "LHF6UZo+otuuM1VdLO2FhiRcsZ1k+cvg3swKnZZdaWhf8ChsaCQWxN944HwtyRgWo1mXq9RHGNFPCkVXTwzcBw==.sig.ed25519"
}

{
  "previous": "%s85YSG3TPY0JiPj4lulJUPmlIkLycprLzekj8Y9jBEU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1254,
  "timestamp": 1540069446317,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%YV3STx50yElDRXEYkg1z6QOIh3S8/C43Hvk1oC9LW5E=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%YV3STx50yElDRXEYkg1z6QOIh3S8/C43Hvk1oC9LW5E=.sha256": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Dash](@omCUUgtKFe2eQgrSmxq4Yw4AWcwAWjIG9BAeFceH+3w=.ed25519) Huh, looks like I did nothing but reinvent hypercore. Oh well...\n\nI guess that means it is time to reimplement ssb on top of [hypercore feeds](https://github.com/datproject/docs/blob/master/docs/hyperdrive_spec.md#hypercore-feeds), but keeping our own replication protocol? Only semi-joking here.",
    "mentions": [
      {
        "link": "@omCUUgtKFe2eQgrSmxq4Yw4AWcwAWjIG9BAeFceH+3w=.ed25519",
        "name": "Dash"
      }
    ]
  },
  "signature": "kLqsv6O4GLv4cMGF9q2mjn3uBJ5A2+p+Zy9GUhhE3chTUyIt6B/9y5D88NAPOKEyZDyc9z77gukzpfC7mYt5BA==.sig.ed25519"
}

{
  "previous": "%8EVkMv/JpHiBOhcUO+qkw01UrVXKl7BJgC/R1uQr/90=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1255,
  "timestamp": 1540072360544,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%oJ9A++vrbxXlCgGLqttaVh5eFmQBA/rqpkBiq5QXHkY=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%oJ9A++vrbxXlCgGLqttaVh5eFmQBA/rqpkBiq5QXHkY=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 20/10/2018\n\n- wrote words: %L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256\n- finished the serde message data deserializer\n- adapted the remaining code to work with it\n- passing the full test data set again\n\nEverything is ready to get back to metadata handling. Once that's done and [base64#76](https://github.com/alicemaz/rust-base64/issues/76) is resolved, I can generate test data sets, and then the legacy stuff is over.\n",
    "mentions": [
      {
        "link": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256"
      }
    ]
  },
  "signature": "fJmC2i07MJDPbvkb6Z8Xigazl+1imVqnwXBbRIbWLgSUEAjPNqO8sfu+BLNlc4ppjx/qqmlKy5q46/toV3N/Bg==.sig.ed25519"
}

{
  "previous": "%irDHnh42eR+I94+MLq9JMCwQMjOOmlXJZ8OhIPD5uM0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1256,
  "timestamp": 1540161444835,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%irDHnh42eR+I94+MLq9JMCwQMjOOmlXJZ8OhIPD5uM0=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%irDHnh42eR+I94+MLq9JMCwQMjOOmlXJZ8OhIPD5uM0=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 21/10/2018\n\n- fiddled around with the spec, creating headings for concepts I want to link to\n- cleaned up the legacy-data code\n  - up to the point where I'm starting to be happy with the codebase\n- sorted the legacy value test data by error category\n- published a repo that lets you test the [rust legacy test data implementation](https://github.com/ssbrs/legacy-msg-data) against the [test data set](https://github.com/sunrise-choir/legacy-value-testdata): https://github.com/ssbrs/test-legacy-message-data\n",
    "mentions": []
  },
  "signature": "tVFHC5tiO0ODcGdX0DrdWzq3CeLiQ50M1/VNhWl40bOydYOpRV7Eoe3+/gBs0jQbfIabTgyw8LZPJWd1NkIXAA==.sig.ed25519"
}

{
  "previous": "%Uqc0CJeEjJ86nbRjS2MAoSoHTWkFB0Cik06T8HGugQs=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1257,
  "timestamp": 1540208047778,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%UEs7cMlbAuO8HQk5El6p8yVpHDfVuVAPsTyGetNbT8k=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%UEs7cMlbAuO8HQk5El6p8yVpHDfVuVAPsTyGetNbT8k=.sha256": "@1APMt97diJmNPAmbKrfQChgFkuLWrJ6CKLPhGS2u7cY=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Through this thread I have @mentioned everyone whose replies I can see. If I didn't mention you, then your ssb messages don't reach me.\n\n---\n\n[@nanomonkey](@+D0ku/LReK6kqd3PSrcVCfbLYbDtTmS4Bd21rqhpYNA=.ed25519)\n\n> What if each message type had their own log-chain and sequence number. So that I can say, I don't care about your chess and gathering messages, but I'd love to have and replicate your about and post messages. This seems ideal to me. You could start a client out replicating about messages, and then add on other feeds as interest requires.\n\nAck, that's something to consider. It is fairly orthogonal to the merkle-tree discussion though, so I won't go into this approach right now if that's ok for you. I'll definitely pick this up when the time for the metadata redesign comes. If you (or perhaps [अभिनाश](@1APMt97diJmNPAmbKrfQChgFkuLWrJ6CKLPhGS2u7cY=.ed25519)) want to flesh this out further, I'd appreciate if you could fork the thread to keep things somewhat structured.\n\n---\n\n[@keks](@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519)\n\n> One note though: please try to make your posts shorter. Specs can be walls of text (to avoid ambiguity), but starting a discussion like that doesn't scale.\n\nDuly noted. I will try to clearly separate these background-knowledge-transfer-posts from protocol-discussion-posts. But the background-knowledge-transfer-posts definitely won't go away, I want to keep this reasonably accessible to the wider, technially-interested scuttleverse (so no worries [@jeswin](%O/IFz+/GlR8fsamMBzC8z8URw5UDXhDG93I4Xsrasac=.sha256)).\n\n> First question: In the graphs, what's the difference between the diamond, hexagon and rectangle nodes, and why does the path to m0 consist of diamonds and the others are rectangles? I suppose hex nodes are basically incomplete subtrees?\n\n- diamond: Root of a complete binary merkle tree that contains the first `2^k` messages of the feed for some `k`. The second half of a path to `m0` always runs along these (with the first half going downwards from some `m_i` until a diamond node is reached).\n- hexagon: roots of complete binary merkle trees that do not span messages from the beginning of the feed and are not inner nodes of one of the diamond trees\n  - once the feed grows enough, a new diamond node gets created and the hexagons covered by it become regular rectangles in this visualization\n    - this is only visual, the actual data structure does not need to tag node types at all\n- non-blue rectangle: a node that is not a root of one o the relevant (i.e. diamond- or hexagon-rooted) complete binary merkle tree\n\n> Second question: I assume some of these hashes are signed by the feed author. I guess it's all but the blue ones? Otherwise I don't see a benefit over the current system, because if I ask you for an individual message, you could just make up some hashes.\n\nAll of them need to be signed, even the blue ones. Else a malicious peer could substitute a different blue hash, resulting in conflicting certificates for an otherwise valid feed. Only the feed owner is allowed/able to publish data that results in conflicting certificates (just as currently only he feed owner is allowed/able to fork the feed).\n\nI *think* each hash needs a separate signature (I got this wrong in the \"implementation\" section), because otherwise certificate size would blow up to `log(n) * log(n)` (maybe?) \\*waves hands and hopes nobody cares about a precise complexity analysis\\*.\n\n> Bonus question: How does all of this relate to Merkle Mountain Ranges?\n\nAnother name for the same thing. This whole process would have been easier had I alredy known what to search for. But at least I had to think through everything myself. For example neither dat nor the mountain-range stuff I found mention the problem that certificates need the full path back to `m0` so that all conflicts can be detected immediately. Maybe someone more knowledgeable about #dat could check whether hypercore does indeed not give that guarantee, and whether that conflicts with what dat *wants* to guarantee.\n",
    "mentions": [
      {
        "link": "@+D0ku/LReK6kqd3PSrcVCfbLYbDtTmS4Bd21rqhpYNA=.ed25519",
        "name": "nanomonkey"
      },
      {
        "link": "@1APMt97diJmNPAmbKrfQChgFkuLWrJ6CKLPhGS2u7cY=.ed25519",
        "name": "अभिनाश"
      },
      {
        "link": "@YXkE3TikkY4GFMX3lzXUllRkNTbj5E+604AkaO1xbz8=.ed25519",
        "name": "keks"
      },
      {
        "link": "%O/IFz+/GlR8fsamMBzC8z8URw5UDXhDG93I4Xsrasac=.sha256",
        "name": "jeswin"
      },
      {
        "link": "#dat"
      }
    ]
  },
  "signature": "9hB8HsVMeMKuLW4gh4l/HdHvFRKGtHBlKOVCpX9bDyhf1rQZHeiwr0AHKHFOuOwHUQ2CsS0OCnhqUuQLHV+OBA==.sig.ed25519"
}

{
  "previous": "%fJTyyLK8+9t9/Uhp6nmIr/2o46xnFdnAkYqeIQP8xSU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1258,
  "timestamp": 1540208062873,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%fJTyyLK8+9t9/Uhp6nmIr/2o46xnFdnAkYqeIQP8xSU=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%fJTyyLK8+9t9/Uhp6nmIr/2o46xnFdnAkYqeIQP8xSU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Piet](@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519)\n\n> The merkel tree seems like a really beautiful idea.\n\nYeah, binary trees are magical.\n\n>I particularly agree with @Dominic's point:\n>\n> > the context and meaning of later messages is some times related to earlier messages ... what sort of impact does that have on the application? what kind of applications works with this, or is broken by this?\n\nThat's definitely something application designers need to consider, yes. But we'd be giving them *more options*, not constraining them. An application would choose whether it wants self-contained messages (working with arbitrarily chopped-up feeds), or whether it wants to perform reductions over multiple messages into a single piece of application state (à la event-sourcing). The latter case would break.\n\nBut it is possible for applications to get the best of both worlds: Any message that relies on previous messages can link to them, and the application can then instruct the server to (transitively if necessary) fetch those via merkle-ooo. But in any case, all of that is part of the application layer, not the protocol layer. (CC [@Dominic](@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519))\n\nNow that I think about it, making these event-sourcing-backlinks part of the protocol would save a bunch of roundtrips. Hmm... (I don't think that's goinging to be a good idea, but it's one to consider nonetheless)\n\nAs for older applications: I'm not aware of any current client that uses event-sourcing accross multiple message types, so a partial feed subscription mechanism like the [type-prefix based one](%0eJLwmZ8uePGPtoTx4PAq8ZwhVOmcMxWwBSQHpobzCM=.sha256) should be sufficient to prevent any breakage. And the type-prefix solution also allows events-sourcing accross different message types authored by the same application if they share a common namespace (e.g. the fictional \"chess.move\" and \"chess.annotate\") messages. That's a simple middleground where you can assume that the clients have the full log and can thus do event sourcing without any explicit backlinks, yet disinterested clients don't need to download the full feed.\n\n> I'm trying to find the killer real world pain in ssb we can solve that justifies the implementation and increase in complexity throughout the stack.\n\nTo me, \"ooo introduces messages with second-class security guarantees\" is more of a \"killer real world pain\" than any kind of application you could come up with. But then again, I may have a non-standard view of what constitutes \"real world\" concerns.\n\nThe ooo security guarantees are what led me down this rabbit-hole, partially subscribable feeds were just a byproduct. But I guess it easier to lobby for those. The all-or-nothing approach of current ssb may be the last part of the protocol that doesn't scale well. But again, I feel like that might not be \"real worldy\" enough for everybody. So I guess someone else should do the marketing =D",
    "mentions": [
      {
        "link": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519",
        "name": "Piet"
      },
      {
        "link": "@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519",
        "name": "Dominic"
      },
      {
        "link": "%0eJLwmZ8uePGPtoTx4PAq8ZwhVOmcMxWwBSQHpobzCM=.sha256",
        "name": "type-prefix based one"
      }
    ]
  },
  "signature": "oNqsAoBasvLvBZCGf2lI9heEV0g2UvKARC1TGIsjfmLC06iqGdCP5PPeFcuRboVIo0UEU9kHRtXLtRIhicYqCQ==.sig.ed25519"
}

{
  "previous": "%q8cLlR5qDQNQ8IRYWgNbk83sezBTrEJ4/eWTcv/OyxU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1259,
  "timestamp": 1540211407899,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%q8cLlR5qDQNQ8IRYWgNbk83sezBTrEJ4/eWTcv/OyxU=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%q8cLlR5qDQNQ8IRYWgNbk83sezBTrEJ4/eWTcv/OyxU=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Here is a strawman proposal for what it could look like if we go (moderately) crazy on partial feed replication rpcs:\n\nIn current ssb, a replication request consists of a feed id and the newest sequence number on that feed known to the requesting server. If both peers have that feed, but their newest known seqnum differs, the peer who knows about more messages sends the new ones to the other.\n\nA partial replication request would additionally contain the following values:\n\n- *range*: exactly one of\n  - *all*: don't filter by seqnum\n  - *start(amount)*: only exchange messages with sequence number below `amount`\n  - *end(amount)*: only exchange message among the newest `amount` many\n    - note that this results in different ranges for the two peers, but that's by design\n- *types_exact*: A set of utf-8 strings. Only exchange messages whose type is in the set, unless the set is empty.\n  - the set can be stored as a radix tree (or really any compression scheme)\n- *types_prefixes*: A set of utf-8 strings. Only exchange messages whose type begins with a string in the set, unless the set is empty\n  - the set can be stored as a radix tree (or really any compression scheme)\n\nThese values act as filters, only messages that pass all filters are replicated.\n\nThis scheme allows encoding a reasonable subset of all possible feed partitions. For fully general feed partions, you can still expose replication rpcs via plugins that use merkle-ooo to do the actual message exchange.\n\n[@andrestaltz](@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519) This scheme would be sufficiently expressive for all your manyverse needs, right?\n\n---\n\nAnd a strawman proposal for allowing applications to use message schemes where state is reduced over multiple messages of the same feed:\n\nEach message metadata contains up to eight integers, each smaller then the sequence number of the message. When replicating a message (e.g. via partial replication, merkle-ooo, or transitively), the messages from the same feed whose sequence number is one of those integers are also replicated.\n\nHuh, that turned out surprisingly simple.",
    "mentions": [
      {
        "link": "@QlCTpvY7p9ty2yOFrv1WU1AE88aoQc4Y7wYal7PFc+w=.ed25519",
        "name": "andrestaltz"
      }
    ]
  },
  "signature": "k7+b+2cVBO2SMnTioG1cEzp/KHVfC2qOg9bzUNrWowwiYJGjHCaZPATKajNv+kvwhz2oEUSPaG/nEoCKkIR0DQ==.sig.ed25519"
}

{
  "previous": "%nZDDuGa5bu10f72vW8ZwjRsv6+azROP9vB+HFU4dDVw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1260,
  "timestamp": 1540224074590,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "go-ssb",
    "vote": {
      "link": "%3z2ffD/bR0jToFXFB85n4tOKSL/BhVC4YnSBNaXuCkk=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "bcopd5j+qIJr8tASfjyJysijya++909lb2nGWZ05gywZsgDuHp145XTtLtfLCPWZDq34rK18Df+SDxbXMLeeBw==.sig.ed25519"
}

{
  "previous": "%gEdqh20Rwx8AFr5uDcwCs+jMR8O4XunVK1zkfelbXbw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1261,
  "timestamp": 1540224420816,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%+IYhIgJmA+9OrLfy5nf1nMK45ZxzJW0JUXIsGG9mGOM=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%+IYhIgJmA+9OrLfy5nf1nMK45ZxzJW0JUXIsGG9mGOM=.sha256": "@ZdKcwA/aQ96HRzvD7hyAMmsSzXx5kGzWRBbZJnNkXKI=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Jan van Brügge](@ZdKcwA/aQ96HRzvD7hyAMmsSzXx5kGzWRBbZJnNkXKI=.ed25519) Jup, pretty much. The mechanism is fully general though, it is not tied to any decision about actually want to provide replication-by-type in the core or not. That's a decision for (slightly) higher up in the protocol stack.\n\nThe merkle-ooo approach is indeed strictly more powerful, but also strictly more complex. The different sigchains are much less expressive, but they wouldn't require any additional metadata overhead.",
    "mentions": [
      {
        "link": "@ZdKcwA/aQ96HRzvD7hyAMmsSzXx5kGzWRBbZJnNkXKI=.ed25519",
        "name": "Jan van Brügge"
      }
    ]
  },
  "signature": "J9fwI8iyWIdcL6QZErKXsGnxefNgH36exPLVo2aCckHY9F/ndogsVpIQFQLoebTJT5IlXaZZWNouVDTT6OLDAw==.sig.ed25519"
}

{
  "previous": "%rzKG1M/B9+KicacpfoVjESG9fcpy2BUnmOZXwMqJRwc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1262,
  "timestamp": 1540241448952,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%zdq51a9LP24kknkIiWcDYuKYlNm0xp9cfpg/+qvvGy8=.sha256",
    "reply": {
      "%zdq51a9LP24kknkIiWcDYuKYlNm0xp9cfpg/+qvvGy8=.sha256": "@5fYRrgyJON0r0R9SPrK0oxR1XKhqNXqiN0FBX+MgfH4=.ed25519",
      "%dH5f21NpmyhL+0sT8IaOSaSX4CWdo+KaUH6KekO2V7A=.sha256": "@U5GvOKP/YUza9k53DSXxT0mk3PIrnyAmessvNfZl5E0=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@rabble](@5fYRrgyJON0r0R9SPrK0oxR1XKhqNXqiN0FBX+MgfH4=.ed25519)\n\n> This might be naive, but would using merkel trees for the feeds allow a user to force a rebase of their feed? If for example, somebody needed to delete something. They could post a 'this feed has been rebased at x hash' on their feed, then post something a link to what the new hash for that content would be after each content which references the orphaned hash for the content?\n\nI'm having trouble parsing that paragraph. Are you suggesting a way of deliberately forking and then later merging the feed? If so, I think the fundamental problem with that is that the feed needs to stay valid even if only a subset of its messages are known. So no subset of the feed may look like it was forked in the usual, forbidden way. Also, I don't quite see how this is related to merkle-trees rather then simple linked lists. So I guess I'm missing something?\n\nAs usual with deletion, the following caveats apply:\n\n- you can't reliably delete any data that ever left your machine\n- a whole bunch of things rely on ssb feeds staying immutable\n- application-level \"please ignore this message\"-messages are already possible today\n- the freedom to locally delete content while retaining the ability to verify a feed is something we could get trough #offchain-content, no need for merkle-shenanigans there\n\nAnd finally: As a German, I find the idea of a [merkel tree](https://steemitimages.com/DQmRuke9UpFEpKcp8s17Br2fhpY4hdYSoVskZMXqAA3RNCK/Merkel%20Tree.jpg) is somewhat disturbing :stuck_out_tongue_closed_eyes: ",
    "mentions": [
      {
        "link": "@5fYRrgyJON0r0R9SPrK0oxR1XKhqNXqiN0FBX+MgfH4=.ed25519",
        "name": "rabble"
      },
      {
        "link": "#offchain-content"
      }
    ]
  },
  "signature": "+TmbrJXr68Olwg+tFzHtzm240tM0BwzyFmymRtMAj6GSxwGFCFsrrVwNT7cbeKM6sC+IFkCw3LwOa75tNzYwDw==.sig.ed25519"
}

{
  "previous": "%tZulTFxntwnWD88WbePrceczgbjukGbSZ+LOXSTK9VI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1263,
  "timestamp": 1540241452656,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%dH5f21NpmyhL+0sT8IaOSaSX4CWdo+KaUH6KekO2V7A=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "ho1gl4F1kmhoNlv3Ci6uGG58oyRfvdyVLUrT+0X+/HQxdwDGmfgkvIwhshWdFdHIVeSkZ6La34D9xr3SXSEKDg==.sig.ed25519"
}

{
  "previous": "%ruUAZOh/e6wUbrby7kc53kKse+Gb2RpGou2I9ta/EbM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1264,
  "timestamp": 1540245730737,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%Uqc0CJeEjJ86nbRjS2MAoSoHTWkFB0Cik06T8HGugQs=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%Uqc0CJeEjJ86nbRjS2MAoSoHTWkFB0Cik06T8HGugQs=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 22/10/2018\n\n- put some more time into the merkle-tree thread\n- tidied up the multiformats implementation, added support for serializing directly into a `Write`r.\n- added encrypted content to the multiformats section of the spec\n- started non-horrible version of the metadata implementation\n",
    "mentions": []
  },
  "signature": "0hUUQDD3ARq0iNN+TLBZ66tdLhLI3PbKWPF6GAy/Vi1Em8mAB6xdg/Gx54slp0EEewWDfR3uiDVTsC7E5OlJDQ==.sig.ed25519"
}

{
  "previous": "%x5jH4DElARkUWnaalO9q6q7L8NVmPc4z201QcRarWc8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1265,
  "timestamp": 1540245936715,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "scuttlebutt",
    "vote": {
      "link": "%ZBeZLMz/D+Mzi5H6kzbg5BMjAMl1kNKW56yyq+MTqOU=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "MRcgHQ2b4K7dL2Jqo/9fvwEJk0pC90zvmKLIFOaD2wB1i/xeHhtYnrZI5cqo7jn0Z2Gp5HPdJkW/W8QPpKHdBw==.sig.ed25519"
}

{
  "previous": "%K3/R6dhxueOkY6paEbdOxTuT8KE+WTg3pHog36e7Apw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1266,
  "timestamp": 1540277840506,
  "hash": "sha256",
  "content": "hH5hSrTqemTKCFzB7AwPSA+ogDYswm6hwcVmjWKFnJ/YP+2vcvaeUFgUIF3r9qSkspzuJZ8ms35+ixcNxZ6+MaxSXRh6LH2+HxsScljyp36gntQZWbS1Lmxden/Eh4Ada+w9gImObrfrXfEos5MHe/VF/LVYNL57+VZ/ImZBUsVD1/FLDTxgdZ1OEGSUBTxauzj6qgxhcKdOCi1jO2UUKVzu5dU0uWQAPjZ+kWtHSdd1Gtsea1dGlXFa8+0NwUrML+w6McmXWL2NIpF4LV+BPqpsY5kv2GXwGPZGotFRTCayJ+Pg6FlpnUmcOEVG+FnVWv17G48SBR3BBQzJ8YgJ7+689IF5a4WEu0copARLt56wLjmPoUvrdCa9NFpjFW1bVbG5bWgBErjaoOuw3wrPg746PWqwvFA58N3THV9fQ859xpaiXJ8ndT+hZ1odqaHvBShRZ2JYftSV3Wg6uAA4XsuAWFkpylPvgUrdmzfBnyNbxRESZ3f+okDh1kRmD9FBvqUVSvF4uJpAc6fVRQAJio8Bypd1G1cSSw6A8svnXtcCWoUR2BSdfgEIrymqeIIQGAtZF0unZJwVoUkREuS3coagL//PP8A7B6rottOVFbrYw5DoGXSzaroHvDuQIA//vAFRh+BKs0bAa9MactHMqXg0F6TZU5xucG4MrHFiBqXEaldJfxMb9IGu+k7aczWqHoYd4S/9RbtN3gU9RensyX/lcG4zvFDELsu7lqx+o2QMrHcTDG7VZUqjPcK0n7EV8F29xTL+v5xErDslwACXOUpN8DduZ9eYVH2B1jEhYNofoX18pEn6ZIiJFTMgNrsaURxAIt6SMARCqso8vcOat9oE5+FxStQi4S3K0Pt6P7UWhP1XMbMLCoCdVJrBxGhVY7/x1nJkySBxM4/E5ZeLP6aGDd3y2P+yTMB5styRxUOLCVMn5NfsomCYQI420ZznoxNIeR51UjkI3YEziuSWhiG0RJoTvKYQW6yeDPEaJV2wTzHkHLETz8+lWqtPdx4PvPUVM18Wj2qjOY/4UCGdKrY/AfnoUnXaYxyfN8KS3v4SN2wzLPZGBPLfLGpASqHDMEuaXkNXZPvUyP0JmnQxhOMIwykfstCULS45mmaF7acL2uJuThGkVh3ij8pV6nsGqsoIjw==.box",
  "signature": "EbkCrbHAxxZPUSzy3R20HqAgdUgU4ytJVeFfeZzS72yt9v6pYMJbiqP+Eh5KRYTfrsgAbYsku/THUp3gtiFaBQ==.sig.ed25519"
}

{
  "previous": "%tJXmdwazjuwZ8e46DYnJGmIR8t2wGdrWraUwsAW/YtI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1267,
  "timestamp": 1540284480159,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%dtq8ag0+ywIa4qGyTMF7rE7xFpMQJxDvg9JvOK/CtS4=.sha256",
    "branch": [
      "%/xuepFv/QGh7y4J5jHaZNXFzbqjNbd8qAWm4Y1j8xJY=.sha256",
      "%7bI0b8/4LHOQFt5tk/EToN1NzwqH43UrppZB+FaX3/8=.sha256"
    ],
    "reply": {
      "%dtq8ag0+ywIa4qGyTMF7rE7xFpMQJxDvg9JvOK/CtS4=.sha256": "@6ilZq3kN0F+dXFHAPjAwMm87JEb/VdB+LC9eIMW3sa0=.ed25519",
      "%/xuepFv/QGh7y4J5jHaZNXFzbqjNbd8qAWm4Y1j8xJY=.sha256": "@Sur8RwcDh6kBjub8pLZpHNWDfuuRpYVyCHrVo+TdA/4=.ed25519"
    },
    "channel": "sunrise-choir",
    "recps": null,
    "text": "# sunrise choir -  23/10/2018\n\n## Attendees\n\n- Aljoscha\n- mikey\n- pie\n\n## Agenda\n\n- [x] checkin\n- [x] rfc: formal change proposals?\n- [x] state of bindings?\n- [x] private-box spec\n- [x] licensing stuff?\n- [x] merkle stuff?\n- [x] checkout\n\n## rfc\n\n- alj: who decides?\n    - is it whoever happens to implement it in sbot?\n    - mik: governance!\n- alj: don't care about format, as long as consistent\n- mik brought it up in private thread: \n- alj is close to making new things, so could use an rfc format soon\n- mik: will be the case we need to hand-wave as we go\n- mik: we have the social capital, as long as we are intentional with how we spend our social capital\n- pie: hard to say no to working code and documented systems\n\n## state of bindings\n\nLooking good.\n\n## private-box spec\n\n- alj: pie you said you want to practice writing specs ;)\n- pie: mik is this a good idea?\n- pie: where do specs live, how should they be written?\n- mik: alj made an mdbook, a rusty gitbook\n    - https://github.com/sunrise-choir/spec\n- mik: i made travis auto-publish to\n    - https://spec.scuttlebutt.nz\n    - https://spec.ssb.nz\n\n## spec in general\n\n- licensed as CC share-alike\n- alj: want to link to stable identifiers for concepts\n- mik: structure is going to change anyways\n- mik: glossary of all stuff you want to link to\n\n## licensing stuff?\n\n- mik still needs to start the conversation\n- new learning is Manyverse needs copyright assignment or something similar because it can't publish to Apple Store as (A)GPL\n    - in publishing to Apple Store, they require you to accept a new license, which is incompatible with (A)GPL\n    - solution is if you own copyright (or have it assigned to you), then you dual-license it to publish it under the store\n- mik: i'm of the opinion that we should have a legal entity that owns all the Scuttlebutt copyright\n- mik: barring acceptance by the rest of the community, i'm keen to have all Sunrise Choir copyright owned by some entity\n    - keen for us to strongly defend the value we create\n- mik: basically\n    - keen to license under AGPL-3.0\n    - also keen to have flexibility for future open source licenses and one-off proprietary licenses\n\n\n## merk(le|el) stuff\n\n- alj: my plan was to let old feeds rot (but still supported)\n- mik: keen to migrate old feeds, don't want to give up the cypherlinked library of knowlege we've accumulated\n- alj + mik: we still haven't figured out how to migrate data without breaking cypherlinks\n    - stupidly hard\n- mik: i've been talking with dom about this since the beginning\n    - latest convo: if we were to upgrade hash function, we'd publish a new message (say a message of type \"upgrade:hash\") that re-hashes the old message, then in the future when you reference the old message you use both hash ids\n- alj: this seems like a protocol thing, not an application-level thing\n  - messages are inherently application-level\n- alj: see what ipfs is doing\n- alj: with regards to using new feeds with old feeds, it can work if each server supports both, might be possible to use initial characters of old feeds to mark version, etc\n- mik: can we retroactively add the merkle-structure to old feeds\n    - can we maintain old hashes, signatures, etc for linking\n- alj: hyper-core is a fun idea, but afraid it's not seriously an option\n    - we have more meta-data than they do\n    - and use different hash and signature multiformats\n    - if we were tied to hyper-core, we wouldn't be able to add new protocol features that aren't already there\n        - hash upgrades, signature upgrades, message dependencies, etc\n- alj: current view is to have replication meta-data (what you need for security guarantees) to carry around a payload\n    - then have a ssb specific payload inside (what you need for applications)\n- alj: *post-call-edit*: Nope, my current view is that there are of three levels of data:\n  - metadata relevant to verification\n  - Type and Option\\<Timestamp\\> as the interface shared by all message content\n  - actual content\n",
    "mentions": []
  },
  "signature": "yMu4TfA4Xtewjto/Zw+9jZ+er0hqklrCFVSdymevU9BkpiKZaKmyBr4Ure4Piz6GB+EvI9EnUaRAw+0ss+b2Dw==.sig.ed25519"
}

{
  "previous": "%EdG4zcG7RWrcNju58cSfFmSGBPNfPPLic1VfUS1XxJM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1268,
  "timestamp": 1540295179631,
  "hash": "sha256",
  "content": "Q6QqIUeRZQFpWNExw0u+IW6N5sIix5U7YvaFMhBrXyEdl58AaumTyoP1YO85Nz3vdBRZSRSptB/z6pniPlZWW9bFxoMWlsKsXThmosBVCq/S9PHG/JyCG/tPdgfMFX5PqoA1MUcFQDsyNcCq8BZmuGlfwyGLhDkXtGCmzwNqEnKTyCxzGlgrA2h13ToLzAsc5Nq6TPgRvwgcjVuWQvfBhkpyVW/Dquaidykg2y8y4ACKTBG8MRdBQa1myOuSxBiTArz/IkcXOdntwPRG2qpklkVsTvbojfBaTzxq1LXcPOFgsyGV9+tYOrdEnq6nf8dGAF9HITd47fHoEnVgXJDoR34HdZ5F0UlbTUXedifKPARDMfRnzqz6et4KRcYT4QDqFghZfUbpHegTmuqE/OQXlXnenwWFqF8zE5AcydAC5crb9eiwNW41S/QB0SwAZAatASmYf+R73ciNH1QTYFYcFfhr3JWnPlIheAinxz0VtFWCpuNeacwFrRywne+X4zR/2ZEBvIk12MjVRE7OHlSAzeW5yIQ7CtuSTh4BGHGwlgXXN1xVQOWOPC/+Y1bzL/OFoWAsa3DFbrjB+We2A1DpX2nXSTgcfCO624eNNiZx4gsGhHy3MS+0CowzJB+PtPAuMnPojCP2HJFBlbZ6NUDd/OnCLQicF5CFV9sTk6AD6wTck9C9E/reVW7zECOHgaUvLTTfJNnvTojVYeLYJZZxOueyyteOC6NkiQCgPTzNhCyMq3o2Zy8SUo8MTtoUkdy6r2fg+FHlT/SDhc7RUIm12lX7aX83H69QP2tUqnRv9Z7X0+Z+JsH96l5fxZ9QtVDMQVYhORQJga6KUgCfQrE27vxl8A/7owSFUGrupJWNe33QhvPTFG36XF9XQghjVkF1AM+wnBRqx6IJ8Djs4jiMjg+lr3SHIjVZzI5AOBJpMGkyrnQ18j/gM9vgrXYedO3+JBPUMeWMnHpBjp91xTTCqGn7lGec1TR1BXdsqbrX06+TlXEw9CikpJT+a5KrrBkhtUgFdKuYEj0qMt0PIbeoWh+4tD7lQSefJU/s9SUIY6qW1/xHt15gNgp+4OUDpH53cvqvm3y0gsccm43WjUI3T80xsEDvOvWVxnihQm31qugQtFF7E4LbdxnRD0SbYzARSsKvvsM3Rb4bFKXKAjR1XJplJ/EkhElEsD64wAKA4hCGzQasLVhif28OfueYS0cDzfLm2JcFAeOKFnB9LqoSNcsMRR2rDFS8ZF6Qbi0OOS8eD9eEttz2UkzlKN14e4B0jG/r4AQWHwBSdc1Xm8tpIJn7tLLts55SVzvgz/9p268AFFMXMqKbu+v2kzQp/g5sYPd8k6zbqX/ID2B9LkegCyOruHI0ULIVvVbL5BUQoie0JKcP9yqjnr6pi86OhfbaxeGL3S8A6wK4tdDmg1oojdlqlCwT5vNdo2q0BdSQmPholdpdXwQiw9+sKlYooCNBKLqyfb/hFw/Exr5/cE40cmat0lICjtPN1XrOYU87OU8UmZuen8wSrT+YGBd5SSdAlL+JjmD4aaNWzRQa81WT.box",
  "signature": "1ZSACJBrQPDdxWDGFx79Z6yDOww8bFLTQXVkoMdttyAQziEA14jXQe4LnVXtsEKNER/XhbhM2CwJVCzZHeBzCg==.sig.ed25519"
}

{
  "previous": "%JZbNvXD1NMt61u8IDq+IHoquUlKBaEijxxQ9POy6hjc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1269,
  "timestamp": 1540326682676,
  "hash": "sha256",
  "content": "x8o+qYGclpWZcrPkKZh+kLv1jq2ltWHSKmg0Cj8nm10+t7ZoCLkZ4OCHs4dXBsFb8md29laDilK+Be0VoLeJYUIFV04QalKf4hFrLWJ62TdyciNma2KQ86QVpdyml4RzjJNz2zN/wBPXsvxoDhJIn7dbMcid+O8PYBIAhkFVz4F2LKs400JlRxkJOrVr2lDHMDYq4tw1hV6uzTy5vUV9pn6wJLOXNEX8medF0luRrRhKz9iUpJo8cj+xR1pJQgC6/pUpI5tWKpL4GY36dRGEZjhOW4IX5wV+VS9kiB+nkfQRkD7dIRlrdtK4gV8umtXqP6yay/waI4GCzg8jMRGwxsKzfrzR3doJse90SrwwzGKs0mo7/tTgkSPxP4IGSv3cO5XrHbp2SfCznHfZzyxYWZiMYK0P1R7RBVZnE3/ZvTW8Kd2VW8gmt3H5yHIgS0WJRmRWaCRjuhVv29Jgza7TFWZL5jI7t3588EbPRvMERnJRL208KbMPMdkh58FPtQHj7xTjeZgRIGEx8AA5FSBS1c55CV8q+lFgLuAt4DBdkUNOxLEvNK2dKoE7fFhxA+Rhpu7ZrJsnYUjwi/yXNIi/w+ZDJS7ptCb/D5S/fcEJxABOMx866bGY6I8ALeWVU/9nS0ibC+Bt6VKTeRxhwk8dKEJd1/GsDSIrRUgij7rxSLlImx3ErtqK+88PLj0NdzblVJLOhZYqmdej1XoKAcX5Cjcl3wBW10Y8rRBzwT+90p4PX1lgHpj+NGGB5s+xF1tdYoWeaaIVRzilO/ZyokxE3fboAXqmTTUb6fCng1Qseq45gl39CKEk3JCQtEwB0k60OAe/akOuSJXHMx/XuvkoQndFjbNMt6X8XovuHSaRaDNWQO7/DdHalMMKBElR+LD+K149pFKrcdaLyL3Urv87zBE+HmkQhYxULhW4Fi+8RBTkGRkUwo4nZhNSv7KVnyoZFZie7ltngzzesawePum3YuLx9eFvTrCbM4pVykg82ehP0a0nvWji5/x9LposgrF2X8r4aaDdKasRU+gAX31TBFiQK/BfqKV28RzxFGAm//1JPH/3cZmqbDY1yCjRq3z47i8B557NDO9XRKMOEVtmLogQ0DOowRMkvrl+4FpZmH6IkTiBByrHVzMUiak31OeqjplZ74dMZ1tzvDemzEICen89Yf80ltZKKPmthjxXXaBmbmcTSLu/ONElvmtsiwoUeXJmAQucXosVjE/zA/4AkBKS/sSgf8qxAoQcPunGt+GF4GGNkxi/McH7+8qUJPKYXplnIhm/dzeiotrX95CnMpCnj0Z9PiKJxx94ICgAO12u0E+uLninmQDjh5hItDHHzGUax7QForNtMWFWTiR6Hn/oyvi9su4X7p9QmiZEZVCZtg==.box",
  "signature": "7BGakL6poHPb+rKvNHLXSbk8qrdCNpZ4CUUwU4OUs3rrcItedNudXSj4xWtIjuCMzdIf7V7SsLzaYbP3fZkfAw==.sig.ed25519"
}

{
  "previous": "%RdNojEzZ9eOSH9WSSFMmtFV1K2bx7S8s5/mGIGswtXo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1270,
  "timestamp": 1540380511259,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%UaG6P/N+wF93giRtjQiotaEheaoodjheWb1xTJRTPWc=.sha256",
    "branch": "%0YvQqM/ZbNrSLMie9pX4LTuQGG6tSJUAx3craNWyF2A=.sha256",
    "reply": {
      "%UaG6P/N+wF93giRtjQiotaEheaoodjheWb1xTJRTPWc=.sha256": "@p146LsUczQ1K7kki2kUyxCLX3EF+O5rf1sOUOjf+Lqo=.ed25519",
      "%0YvQqM/ZbNrSLMie9pX4LTuQGG6tSJUAx3craNWyF2A=.sha256": "@p146LsUczQ1K7kki2kUyxCLX3EF+O5rf1sOUOjf+Lqo=.ed25519"
    },
    "channel": "haskell",
    "recps": null,
    "text": "[@Fabián Heredia Montiel](@k53z9zrXEsxytIE+38qaApl44ZJS68XvkepQ0fyJLdg=.ed25519)\n\nWe have properly defined the [signing format](https://spec.scuttlebutt.nz/datamodel.html#signing-encoding), including the [order of object entries](https://spec.scuttlebutt.nz/datamodel.html#signing-encoding-objects). The TLDR: objects first serialize those entries whose keys look like natural numbers, sorted numerically. Afterwards, the other entries are serialized in an arbitrary order. When validating a signature, use the same order in which those entries were present in the input that gave you the message in the first place.\n\nThe rust implementation of legacy messages is close to done, I can ping you in the announcement post. It might be a solid choise to use it via the ffi. Reimplementing things in haskell wouldn't be too difficult though, if you've got a good floating point reader and pretty printer (roughly a third of the signing format spec deals with floats, and it is only declarative, it doesn't tell you how to actually implement that).",
    "mentions": [
      {
        "link": "@k53z9zrXEsxytIE+38qaApl44ZJS68XvkepQ0fyJLdg=.ed25519",
        "name": "Fabián Heredia Montiel"
      }
    ]
  },
  "signature": "qDsRH0FaCEDYJry+uAL12OJrrpH7Nhxp0Qr67Gvq621MDXfDxRYbKsmUi3cxVLpRRJX/3zHJAeagmRLLc1qRBg==.sig.ed25519"
}

{
  "previous": "%0l4RaytnBFn3gndZo4wqpeWmFSUG8kAZyVOsx0TKIdI=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1271,
  "timestamp": 1540380704823,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@C0sPjDDjCJDygLq6/IVTQXameoWW/SH1amlSoKrD5MQ=.ed25519",
    "following": true
  },
  "signature": "1KLTP5ghHh3XfYnP4h9V8MXhBf/5TZHyAEv3W0C9L406ummwgoKIZAf3zOnEZ8KWDb2fSKVnct16Ajnlm2oUAA==.sig.ed25519"
}

{
  "previous": "%vj/qTdW3nOaW8SqIWx6joVkqggTtzomneoJX91jIiCM=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1272,
  "timestamp": 1540382053436,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%KyIiZPgQBUMG33r6kFY9coHUqoG4V5y7aaE+ICIaqXQ=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%KyIiZPgQBUMG33r6kFY9coHUqoG4V5y7aaE+ICIaqXQ=.sha256": "@xk+dS550w0rfZSB93jPlPASPvhUdjj0nnIYTUbQlcEs=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Tim Makarios (on Manyverse)](@C0sPjDDjCJDygLq6/IVTQXameoWW/SH1amlSoKrD5MQ=.ed25519)\n\nI followed your feed, so I can see your posts now. I might unsubscribe at a later point though. No hard feelings, I'm just trying to keep the ssb fire hose manageable. But thank you for reaching out, I value all comments on these posts.\n\n> Surely the certificate (h7, h45, h0123, h01234567) proves only that the messages supposedly prior to m6 were created before the certificate, not necessarily before the message. Otherwise it would also prove that h7 was known before m6, which is backwards.\n\nThe `(h7, h45, h0123, h01234567)` certificate for `m6` fully validates m6, but it can only be created once `m7` exists. It does not declare that `h7` existed before `m6`, it just uses a path through the merkle tree that happens to include `m7`. This certificate (one you also add `h0`, `h01`) encodes the creation order of the first eight messages. It doesn't say that `m7` existed before `m6`, it says that `m6` existed before `m7`.\n\nIf `m7` isn't known yet, you need to create a different certificate - that's what the third post is all about.\n\n> To prove that a message was created after certain other messages, I think the certificate has to be part of the message itself, contributing to its hash, doesn't it?\n\nNot exactly. A certificate is just a collection of hashes. These hashes refer to the original message, and are indeed signed. There's a large number of possible certificates (at the very least one per message). So if all of these were put into the feed, we'd get a blow-up in feed size. The beauty in this mechanism is that these hashes verify each other, so you can just pick the subset you actually need.",
    "mentions": [
      {
        "link": "@C0sPjDDjCJDygLq6/IVTQXameoWW/SH1amlSoKrD5MQ=.ed25519",
        "name": "Tim Makarios (on Manyverse)"
      }
    ]
  },
  "signature": "U1PvHx1YEo5yC/XwKuU5LJf+ZX73dbcCtDpFVnl0UPBqqtUtKWwhgommh7oLfnavIzFj6njvnnnaMbWFVD8nCQ==.sig.ed25519"
}

{
  "previous": "%5wxUCloLlFkmzsLqODoQusYMx06tKDSEf7KyegGLaec=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1273,
  "timestamp": 1540390557232,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "buttcouncil",
    "vote": {
      "link": "%2jBwzGD3DteqtWWn98f+0drw5qwyUgbM9+EUNnObh1c=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "6606b6FOsuhUqfnA4KNuIoF1qWXTIfJtiRrvbINohlQbKKX12zFXSGnFj/yPQI58ABvbA/vxo8sn49UxoaHrCw==.sig.ed25519"
}

{
  "previous": "%5IdNZxNdihY6zRSM734CFzKieWs5gMjfaLsoHtveyUc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1274,
  "timestamp": 1540394308269,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@GqsSW1pLJq5qUbJuDAtm7MwwOhpf+Ur6BfDH0kZKCJc=.ed25519",
    "following": true
  },
  "signature": "0LP/nDoNvgNK6T9PaFJs5cI4ASoIM4KBjlUAcM3n8/QF4rilbUDOno2v7OTYlgwF6NhPLl8ocm5TmHf6QfmTAQ==.sig.ed25519"
}

{
  "previous": "%IF5iRvPuvcUJrE223QQCpiL5vDqKaNuQzMMwSZJ8EQQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1275,
  "timestamp": 1540394339582,
  "hash": "sha256",
  "content": {
    "type": "contact",
    "contact": "@xuq5ATR6hDNt6/0q1RB+L1f0dyeVk1kG1JAXu4jo/GU=.ed25519",
    "following": true
  },
  "signature": "/4e4ixHHtKQTbzfL8uMZ1e5butFhUsreeCJqHHXVDiSMQK6OH13adgBhdXVN2cjCG3no5m+9EX5t4CbOZyO8DQ==.sig.ed25519"
}

{
  "previous": "%G8mLEktMGL2UdbTRiCryBO9fqBdkkUCkyGm4fKxOQZU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1276,
  "timestamp": 1540396526357,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%x5jH4DElARkUWnaalO9q6q7L8NVmPc4z201QcRarWc8=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%x5jH4DElARkUWnaalO9q6q7L8NVmPc4z201QcRarWc8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 23/10/2018 and 24/10/2018\n\n- started fuzzing the multiformats implementation, needed to fiddle around until I got the (temporary) canonicity check right\n- metadata/message implementation: https://github.com/ssbrs/ssb-legacy-msg\n  - yay!\n",
    "mentions": []
  },
  "signature": "uf5iIv0sOx01qk84tHGAgmhrfhgogjrsdXeOYm1EouHkIjE/+yXiWuH778dPpURw7gjCy8sR3WLbC9YXvYZlAQ==.sig.ed25519"
}

{
  "previous": "%aaedvtZsTkRF8mFzdjNwG4u3Aoi5a5pOczeganXq4Qo=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1277,
  "timestamp": 1540465878938,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": [
      "%5wxUCloLlFkmzsLqODoQusYMx06tKDSEf7KyegGLaec=.sha256",
      "%97NeKBm0aFLK0KMs94rxArxehG/nrMtNPce54if73rM=.sha256"
    ],
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%97NeKBm0aFLK0KMs94rxArxehG/nrMtNPce54if73rM=.sha256": "@C0sPjDDjCJDygLq6/IVTQXameoWW/SH1amlSoKrD5MQ=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Tim Makarios (on Manyverse)](@C0sPjDDjCJDygLq6/IVTQXameoWW/SH1amlSoKrD5MQ=.ed25519) \n\nYou are right, that scenario actually breaks things. So the remaining question is: \"Can you still break it if we always use the certificates that can be created when the message itself is created\"? If the answer to that is \"yes\", then we can probably scrap the whole thing. And if the answer is \"no\", then I'll need an actual proof for that. Proving that such a scheme works is something I'd do in any case before rolling it out.\n\nI'm also thinking right now about using additional backlinks further back into the list rather then using the additional hashes  (the blue nodes) for bridging disparate trees. It seems kinda weird that there are different mechanisms (combined hashes vs single-message backlinks) for establishing creation order.\n\n> What's more, if the bogus hash of m5 doesn't contribute to h6, why can't I rebundle m6 with a new certificate, this time based on the real hash of m5? Then even careful verifiers that verify everything won't detect a problem.\n\n`m6` creates a backlink to m5, or in your scenario, a bogus backlink. A \"careful verifier\" can just traverse all backlinks, so there's no way of fooling those.",
    "mentions": [
      {
        "link": "@C0sPjDDjCJDygLq6/IVTQXameoWW/SH1amlSoKrD5MQ=.ed25519",
        "name": "Tim Makarios (on Manyverse)"
      }
    ]
  },
  "signature": "p4y2A3s7nJPt0TeBuyC1yWKIjpumq105mC8qSepICn+t1lr7TyBHEUMLZZEOWbt0tWUGV6//ZamlceXWxYWjBg==.sig.ed25519"
}

{
  "previous": "%16F5YV1yju98iy5q3o6x0ljnZ09aQEAHaC20nmYDlN8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1278,
  "timestamp": 1540475054485,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%16F5YV1yju98iy5q3o6x0ljnZ09aQEAHaC20nmYDlN8=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%16F5YV1yju98iy5q3o6x0ljnZ09aQEAHaC20nmYDlN8=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Ok, I think I found the way to make the blue nodes less ugly: Instead of publishing and signing these extra hashes, each message (except for those one less than a power of two) includes the previous \"mountaintop\" (diamond node, the \"left\" input to the blue node of that message) in its (signed) metadata. But then, the certificates would need to validate the right spine of each subtree, which would be more data than the scheme with the extra hashes. Still logarithmic though. And who knows, maybe the other one can be somehow circumvented... I really need to sit down and do a correctness proof (or disproof...).\n\n---\n\nA few general things that are nice to know:\n\n- the whole scheme (placement of additioal hashes etc.) works by describing each number as a sum of different powers of two - i.e. its binary representation\n- message `k` needs to store `t` certificate hashes, where `t` is the number of trailing ones in the binary representation of `k`\n- to compute the sequence number of the mountaintop previous to message `k` (where `k` is not itself a mountaintop), set all non-leading ones in the decimal representation of `k` to zero and subtract one\n- the \"height\" of that mountaintop is the number of of places in the decimal representation of `k` minus the number of leading ones",
    "mentions": []
  },
  "signature": "Y7qz9QWdrqN4sfS1wAIJ/0nksj6HUSIh5m31DxIZPV2h/oSMDAjvj2Fhd+cgbiTKAX7AqJlv5gKzMHLdWRauDg==.sig.ed25519"
}

{
  "previous": "%8S3Sh3PI3bNSk9/bzVr5nIeewfPg5UDiFm7Y/PslkJc=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1279,
  "timestamp": 1540557403714,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%WT+1y5oSKkpV3pkXX2Q6AMaQWABaYma0lOpCq2W2Z0o=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "7mbXeLibR/HyjlSWg5gqB5M+61m4Z0dMveu/rXgMA3doPNu+wdo+P4DuAhVA13b78kVarHS2QWS37c+8jc7BCw==.sig.ed25519"
}

{
  "previous": "%ec99VI6GqgpBhZEiKP4P3wKk72X6ZMYUzud3ZP5CIHk=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1280,
  "timestamp": 1540561747512,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": [
      "%8S3Sh3PI3bNSk9/bzVr5nIeewfPg5UDiFm7Y/PslkJc=.sha256",
      "%WT+1y5oSKkpV3pkXX2Q6AMaQWABaYma0lOpCq2W2Z0o=.sha256"
    ],
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%WT+1y5oSKkpV3pkXX2Q6AMaQWABaYma0lOpCq2W2Z0o=.sha256": "@C0sPjDDjCJDygLq6/IVTQXameoWW/SH1amlSoKrD5MQ=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "[@Tim Makarios (on Manyverse)](@C0sPjDDjCJDygLq6/IVTQXameoWW/SH1amlSoKrD5MQ=.ed25519)\n\n> For example, if B is the finite set of powers of 2 whose sum is n (that is, basically, the binary expansion of n), then for each element b of B, include in message n a backlink to the message whose sequence number is 1 less than the sum of all members of B that are greater than or equal to b.\n\nWow, this is beautiful. \nLooks like it is indeed amortized O(1) overhead in signed data, and O(log(n)) in certificate space and validation time.\n\nI've pondered constructing a deterministic skip list over the feed, but I didn't make the jump to use backlinks only. Your approach is skip-list-ish, but not exactly a skip-list. So my take on this theme:\n\nFor all k such that `2^k` <= n: if `n+1` is divisible by `2^k`, include the hash of `n - 2^k` in the message.\n",
    "mentions": [
      {
        "link": "@C0sPjDDjCJDygLq6/IVTQXameoWW/SH1amlSoKrD5MQ=.ed25519",
        "name": "Tim Makarios (on Manyverse)"
      }
    ]
  },
  "signature": "86VRQLO+OkK/IVB0v/iwDeDd/gPNTwX/PeC9nGGMg38mMVJlGqJz/IZdYTAn8fRXrxipxPQ8wvL8ipvV7a9DCg==.sig.ed25519"
}

{
  "previous": "%KPseOV91dFC8Tk3od3UTb2Z1ufSIgzF37l1N5UBqWlE=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1281,
  "timestamp": 1540564193096,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%KPseOV91dFC8Tk3od3UTb2Z1ufSIgzF37l1N5UBqWlE=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%KPseOV91dFC8Tk3od3UTb2Z1ufSIgzF37l1N5UBqWlE=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "There's a drawback to the purely backlink-based approaches though (at least to my naive skip list, but it also applies to your suggestion I think): While there is a certificate of logarithmic length for any two messages x, y that proves that x was published before y, that certificate is specific to that pair of messages. With the merkle-approaches, one of the goal was that there is a certificate per sequence number, and any two of those certificates allow verifying the existed-before relation of those two messages.\n\nWhen requesting a message by hash, you don't know its sequence number yet. So you can't know beforehand what certificate to request.\n\nEven worse, the peer might only partially replicate that feed itself, and it might not have the messages that make up the particular certificate. I *think* that's a showstopper and forces us to come up with a correct merkle-tree-based approach?",
    "mentions": []
  },
  "signature": "gCIQYUtA/xIMBA+q18xAL0al0ImuJXwQWdOw00YQlj5G5lMk+XYIiJ2PY/M/D4kZjQoWE6KLTsM6jPK0fxgdDQ==.sig.ed25519"
}

{
  "previous": "%lvWUTql6F4zhglK6QhRsHUhR8f+c17I4Y8cy3T60XJQ=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1282,
  "timestamp": 1540569906280,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256",
    "branch": "%lvWUTql6F4zhglK6QhRsHUhR8f+c17I4Y8cy3T60XJQ=.sha256",
    "reply": {
      "%L9m5nHRqpXM4Zkha1ENTk5wNOXQMduve8Hc9+F0RLZI=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%lvWUTql6F4zhglK6QhRsHUhR8f+c17I4Y8cy3T60XJQ=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "scuttlebutt",
    "recps": null,
    "text": "Aaand I think none of this actually works.\n\nPast Aljoscha wrote:\n> Assume we received m6 and the associated certificate c6 described above (h7, h45, h0123, and h01234567), and now we ask for m1. The certificate c1 we get consists of h0 and h01. The server we are requesting from might not even know about any messages that were published after m1. But now we can't check whether c1 contradicts c6. c6 contains h0123, but does not tell us how h01 must relate to it. Fortunately, there's an easy fix: Each certificate must contain all the diamon-shaped nodes (h0, h01, h0123, and so on) that existed up to that point in time.\n\nThe same problem also applies to verifying message 8 and 15. And 16 and 23, and 24 and 31. And so on. So we'd need to include the spines of all merkle-subtrees with height four. But it's worse than that: For a feed of length at least 32, the same problem arises for verifying the creation order of messages 16 and 31. So we also need to include the spines of all merkle-subtrees with height five. And so on. As a result, we'd need to include all layers of the tree except the three lowest ones. And that is in O(n).\n\n---\n\nSo either we\n\n- find the error in my reasoning\n- figure out how to actually get message-specific certificates with size in O(log(n))\n- figure out how to work with an approach that produces logarithmic certificates specific to each pair of messages\n- give up\n\n---\n\n=(",
    "mentions": []
  },
  "signature": "50xspHNr0r+o6fYzTP0I0l9WzYudc1dQ03SBuDpCsvwkcWYGEWKy3jPU6CqUaa6EpBg3lVh3bqk9Ir4aQfDfCQ==.sig.ed25519"
}

{
  "previous": "%qZ5dtIH+w8LVCcpG5NjguNdz9axNtpxV3YnMk0AFSBw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1283,
  "timestamp": 1540586220865,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256",
    "branch": "%aaedvtZsTkRF8mFzdjNwG4u3Aoi5a5pOczeganXq4Qo=.sha256",
    "reply": {
      "%ZBzVJhKOYub7bFtZpYCeXPa3O7Me4gftEl80b+ts6Kk=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%aaedvtZsTkRF8mFzdjNwG4u3Aoi5a5pOczeganXq4Qo=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519"
    },
    "channel": "dev-diaries",
    "recps": null,
    "text": "Dev Diary 25/10/2018 and 26/10/2018\n\n- put more time into merkle trees, only to realize today that the approach doesn't work: %qZ5dtIH+w8LVCcpG5NjguNdz9axNtpxV3YnMk0AFSBw=.sha256\n- programming involved a bunch of small additions towards message verification, but the good stuff is blocked on [this](https://github.com/sodiumoxide/sodiumoxide/issues/267)\n\nThe progress feels extremely slow, I have reached the 20 days of work per month (with a lot of those spent *completely* on sleep, food and ssb), and there's some rl stuff occupying my mind. So I'm going to take it slowly for a couple of days and work mostly when I feel like it, rather than my previous, pretty rigorous schedule.\n",
    "mentions": [
      {
        "link": "%qZ5dtIH+w8LVCcpG5NjguNdz9axNtpxV3YnMk0AFSBw=.sha256"
      }
    ]
  },
  "signature": "/pgNlvUgMHPVZJypB/Hn6cZLtZozloxPjA7x7m1k0yXpNeA8BGprdRemNF3qtOXseejlJ9b0oVvnxMPlVgfGDQ==.sig.ed25519"
}

{
  "previous": "%S9Nt+Hz0BsfI3EkicwbLjppRma+sLMfx31Qp+ruGO/0=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1284,
  "timestamp": 1540587168654,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%9qR4HHGhvEmK7sVUM4E89KedyEaq8LZE7ztC6OdUUYY=.sha256",
    "branch": [
      "%/R1nKD6p3Hwpcj/lDklldf7SXXjk5CljnDRax1BTiJA=.sha256",
      "%CuUQlEwWPDpL0HqtsKuhZfD97Emn1VMDb58dKkUQbmQ=.sha256",
      "%ImQliBMjc/K086s0k3zkhzZbXERZEk7CxUvEqdlQ66A=.sha256",
      "%ZBqUXXxNgR3k033pP4wzAB9aynM66HDOwcXed257qm0=.sha256",
      "%r1Fqh6tcfLiTMhk4HVgoWxaeRN1lkSH8XDpjZAwz/ac=.sha256",
      "%s5C+6YrDEHkqtdUP9yeDM7tx+NfImfL0DWynthNDCuU=.sha256"
    ],
    "reply": {
      "%9qR4HHGhvEmK7sVUM4E89KedyEaq8LZE7ztC6OdUUYY=.sha256": "@3ZeNUiYQZisGC6PLf3R+u2s5avtxLsXC66xuK41e6Zk=.ed25519",
      "%ImQliBMjc/K086s0k3zkhzZbXERZEk7CxUvEqdlQ66A=.sha256": "@RJ09Kfs3neEZPrbpbWVDxkN92x9moe3aPusOMOc4S2I=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "Can I get into the voucher queue? How do I get into the voucher queue? Am I in the voucher queue? I would be excited to be in the voucher queue.",
    "mentions": []
  },
  "signature": "q9ryw2UTBJ0f/tvxs+/9v4fZtLaQmnmD7NsDImVqcMK2w6yP0Zqx4Tj1i8OPMU46YCkgaSYIOZ4EVf7fmPGdAg==.sig.ed25519"
}

{
  "previous": "%HngErBNjHVfgD4ZKhHxG5C09aVJ8y5Bub4AdDaVly+8=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1285,
  "timestamp": 1540630276795,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "vote": {
      "link": "%UWIyvlI3HEWgigfad0l/pvd5lQbVHfLf2VHCBXnxNdw=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "ZN2F/lRXSUUqGIh3RSav9HNNjhBp7V2y/AXPeVdu4jHrNVkFs8knSMlZDwpSsYhZ8oTVF94dCO6m9SNZnBOGDw==.sig.ed25519"
}

{
  "previous": "%m32SBQLPyaah0IO1KXWaIMMbO9z/f6EVLwKf9M6C7vY=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1286,
  "timestamp": 1540648194739,
  "hash": "sha256",
  "content": "+qfHoq03OmjTFyhWf0y1f7cZRES+Gl+1dah3kUl9f06RIgclv7+EANv4c28Yau++N95rH4etsk1vTy45jhm701xuF1rGbi/q3UMuwwKnukOitq2lhiVbwAjcNMC6ACqKEtN8AxvjlMm/k0KiIMywyufzywrsKUyLf2ycWVpoUEQ1IPiQxE61q8K//Sr9vg/NIPNjJX0TmgRG+/eie6T61TG/89HnDfeVoo2vXMkaZ17pRsJde/jXAfrPSNeihbOpjZEBYGf6foDy3rNi9dQeerSU4lQLOa1DsVm0JOgRReUEW3D0cE0bsssdCdRVoIqYJlwKIIc38yxgr9b23Py92ER86xR5Z/kjiX0ZV//bfbvZM4P+q5k3K1imN/4xQHsrD23Yz1xHdvoPx8dgcduYNON/vDpY567Yih7flBq5D4nmqKrVss8CybnWSZsfggaYPSZb7tcWicVbhepn6V+m8up4r1l3q1N17+qKc5Q6SuC1wJofOgZlUKlNPpFuIX3G8UUb2Nt4bKNtv+k8QeQCrysKl8EP23hjT69V5KoTXszxpY8Oy+tRwXwwkTeWXPoXcV1Wz+4GjQauPYXhfeGEL3ALqmCPXrmKU1q2atSeUySxTMnH0VFMlwTojUsaW2C19Hqn7x+uYicL6T7jMh5kq4cojazY6s5MRq+KOTxrIkSUeYrgOTnUuyFojCvscXLOCu94tw0YYGDt+AQOuDLeFQ3DxLlXZIiKNiXK48xRh7u0fwpt4/cdmNZ1xFO6oZBCKZMkct5+gcHp8TK2T1zXiZ/5L3SDnuABrpGIgzNg1G677G0hrcmVtdts5WaGoo4noZ2GKY5hUqx8zg==.box",
  "signature": "m7W62LBMolD/OtEu8DOVHHLxE8KS/6WvplMaJKwCDgpO1UB8YROzzFxIQQDgIqxF8uBOYlJSX4/HFzSI+ycTDQ==.sig.ed25519"
}

{
  "previous": "%0K89gBiQcXm0H7Rt7z3poyiNLZFglYN0mHuoiutU3ew=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1287,
  "timestamp": 1540658359487,
  "hash": "sha256",
  "content": "Fbm4IBW7GHGzCGEYJMzV6TleZpVzAGBP/I7B2VGr5f0+ujjPct/ei8UKBtUwx0MDftFZpb9hwE97dY2Ps3dx1dydZ4okJ+vnRJZHujvWf1IH2JhFoDwmtimEp0K7hVCDc9t5L1dTpNSzCpJ27OZ1nXang0DthWjpa95emNbCKOhWQ/EIimSocBxTC7W2g/bwJcfLnStENjmTq1KlEKQ2wtwIMV0DocalxGU6zire6ralyMyZZ+2FUbjpDIB0wKaRyycWjt9pJaqtc3HOHhuZTn5ffeQu7HJ8LD5SAqGyEiIcA8WFcMyNbA7ig64x1LM9u5YatVqxQf1GODdLJ0iTSlMmRPZ2XuDW7Jj4aoTpD2AgEhXF4AwB/FJht1rqXkeQTKoCH4NWYSlA4uUB8wY0afSd8SLrQFUy/iJVdBOL4KQy6BcukMVkWO5j9lZ5sEu3iXoPd5WbXCoJJMh8+GBvy089Oul8vhtvaD8aXJFTDTmsuhlr9y/zOeU53jnLMPJ147dInJAB72j2icMtumHd4nTLy0oKIgtepIuG3vi8PkPo3XX1e0EPesMeXIlPTwypK0oI3ib7+Prk1Sg0CkE+r/TkYlXtyuh/dli91FJo2MMvA++JFmxxEaoOtkoBd5UF0ocwL9zq+GKEW9T9EAorUs7O61nyZw+mIclnWap2ToOz74zPbRzgNDmB1pQoJaRD4F9FIcmp29l1q5X8YRPHGF4NOtkDyaYnfA0WfaDcYVU0kr+OPKOf4QpR+uoD84uI0M1jQKDgUqTUaW0hMM5CkhqtR4cGSOvEBAnpaBQJnDXigOWxMTdjePs9MaRLnGlWc718im6r1D7C+Qeth6Okl67qyG8OvG1giKJgEkHrwBm3LB44liW5s/CvvF+PV/nYGNMaKGgDk7cfBoGq/Tx6uBANFP0/3xmRrLS6OeXFzVdsnjUY4FhnKmTJAwbb34bg45n27saGEuyqesW/WI06c0RoZcPOAkpdibDV+CnJL6+8fvTtEbVJSLV9RII6jNQdw0oCuwMUmDAkpvyrrnPzBSKu4VRpA/M8WpKBG/boSjSbrg5ugNis2ed+ldAn3Bj6O8+pFKCB6HBd6Mk2cS7WHKXaJPQogvTVrOkZGGWF8HNQ/2pjVowdOziEb/T/ciPXHo/LDrubKaVUxj/7rZYEQYTq64plMayJu+POxs+ZjEtJijVSHOH9GAlp+QtG2FOrWtwseB8ukvrPXdLGtTgThs1lx4SxkfquE6mv5dajZQdZlkjL3VjCGRQOaLB6AinLuftshh3AgIpSya0j2SYe5vlRi7wtIw3Nhz/8OlwleuyWOA8jvn2WpsgwAGrj+FJpLjWpl+7iiP4P3R8m6SUL+ERJ/pIBHt1jAKP7o1hLgT4FzTgdq9ad3mJu3mFKhxvLHYq3+qW0Q1viNlXrsBZcOJ2fu+6i9s8YEpU0SCKnb3n0shLGL06gKO8j0E/31D2v.box",
  "signature": "57MeKekYy+hiPcvv10HeUqodAcFx6gGh/3tu0NWSc1xiOA9IZgEa2jqWKardn5aLJwXHaL03533ehAPRNHxPDw==.sig.ed25519"
}

{
  "previous": "%b3vDdU1BUsAPYNbk3YxmSQ2aNZ+28NPJjoJyedhDU4Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1288,
  "timestamp": 1540739511592,
  "hash": "sha256",
  "content": {
    "type": "post",
    "channel": "sbot",
    "text": "I want the sbot cli to output my feed without those `{key: foo, value: bar, timestamp: baz}` wrappers. The [docs](http://scuttlebot.io/apis/scuttlebot/ssb.html#createfeedstream-source) tell me to set the `--keys` boolean option to false (it defauls to true).\n\nThe documentation does not tell me *how* to set that boolean to false. Does anybody know? ",
    "mentions": []
  },
  "signature": "NHwJYx/C7lY93opIIwbbRoXQzRr9r32/st031G/5FX+QFdpndRocyx72a12q1zRaSVJAs4rcNbfYLgwec7qVDw==.sig.ed25519"
}

{
  "previous": "%pL0ERAYFGwgDsIS8y9pGluxaUNq0IqWCP23glOnJN7c=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1289,
  "timestamp": 1540751617305,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%fAotKZL1Kmx3Efuh19Ko+WC2xgMwJJ2eBIL2TICgidc=.sha256",
    "branch": "%fAotKZL1Kmx3Efuh19Ko+WC2xgMwJJ2eBIL2TICgidc=.sha256",
    "reply": {
      "%fAotKZL1Kmx3Efuh19Ko+WC2xgMwJJ2eBIL2TICgidc=.sha256": "@IgYpd+tCtXnlE2tYX/8rR2AGt+P8svC98WH3MdYAa8Y=.ed25519"
    },
    "channel": null,
    "recps": null,
    "text": "As part of a university course, three fellow students and me will do a formal analysis of ebt as used in ssb, which might lead to a paper. I guess it'll be more of a generic distributed systems paper (\"Here is an algorithm that has only been validated experimentally, we *prove* that it works (well).\") rather than ssb specific, but it's a start. And I might be able to sneak some interesting, ssb-related stuff in there, like the effects of [restricted gossip](%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256), or how to [implement it in the first place](%dh6USEfPso9uZpB1iJrPX7kQHTYzcJyCU5lpSfRkhWY=.sha256).",
    "mentions": [
      {
        "link": "%z28ZLyE7OSAjirrBG5RQyZzpVCilnoCb3MTY2lugwO0=.sha256",
        "name": "restricted gossip"
      },
      {
        "link": "%dh6USEfPso9uZpB1iJrPX7kQHTYzcJyCU5lpSfRkhWY=.sha256",
        "name": "implement it in the first place"
      }
    ]
  },
  "signature": "N4fmnluXsCpnAKRzoNU4udEVir38vuG+XlnRBN/qv2YQ4utCFTUMQ2oRV6Uu9JEjSNrJjNIMU8KK1pZhJvFOBg==.sig.ed25519"
}

{
  "previous": "%+ofnt2M/IalFBkUDStlWfa+MtDCgEmpbEgLSVqojk4Q=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1290,
  "timestamp": 1540754187234,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "sbot",
    "vote": {
      "link": "%x0xebUPTulyIRpQ7T+B5CPvQjOOx8vot+SuT/ov1Q6U=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "Xg4luKGJovTzc1MP2kS/VLYNJfOuGSI/D/SfAvehnXc7NWMrRJN24oSq7MtTIRBy5XsH+8WdjhwBEi1zXX36CA==.sig.ed25519"
}

{
  "previous": "%hVxuq+3r3eyUoP6PuIidw2Z0Gsj3Rv34yDyAi0gP+Dw=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1291,
  "timestamp": 1540754190434,
  "hash": "sha256",
  "content": {
    "type": "vote",
    "channel": "sbot",
    "vote": {
      "link": "%NDUHv7INf3HsihorqdvXUUDHivVhGJq8kHhphX7NGHY=.sha256",
      "value": 1,
      "expression": "Like"
    }
  },
  "signature": "lMNf/xKQAAXxiDZoRQL+oAHWb9VB9A7Y80gYdVchwktizfvKznGuMQvo+2HGo/sahfj+gccZeNq5RL4U+cMbBQ==.sig.ed25519"
}

{
  "previous": "%1IzA7NOAlUxlVCTP98VpqZkQ71eHSZOgcjwMhpQn1UU=.sha256",
  "author": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
  "sequence": 1292,
  "timestamp": 1540754250293,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%pL0ERAYFGwgDsIS8y9pGluxaUNq0IqWCP23glOnJN7c=.sha256",
    "branch": "%x0xebUPTulyIRpQ7T+B5CPvQjOOx8vot+SuT/ov1Q6U=.sha256",
    "reply": {
      "%pL0ERAYFGwgDsIS8y9pGluxaUNq0IqWCP23glOnJN7c=.sha256": "@zurF8X68ArfRM71dF3mKh36W0xDM8QmOnAS5bYOq8hA=.ed25519",
      "%x0xebUPTulyIRpQ7T+B5CPvQjOOx8vot+SuT/ov1Q6U=.sha256": "@ppdSxn1pSozJIqtDE4pYgwaQGmswCT9y15VJJcXRntI=.ed25519"
    },
    "channel": "sbot",
    "recps": null,
    "text": "[@ansuz](@ppdSxn1pSozJIqtDE4pYgwaQGmswCT9y15VJJcXRntI=.ed25519) That works, thanks a bunch! ",
    "mentions": [
      {
        "link": "@ppdSxn1pSozJIqtDE4pYgwaQGmswCT9y15VJJcXRntI=.ed25519",
        "name": "ansuz"
      }
    ]
  },
  "signature": "4hmWB4P3QagLDbLU4nJvXr7QDNIFkWbvOvW9apy6GozfpVJ51GaCKoYAg+BuiJ0xlAA4X46767YUFBjud/juBw==.sig.ed25519"
}
